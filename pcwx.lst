CCS PCH C Compiler, Version 4.135, 4375               23-Nov-15 10:39

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 10926 bytes (17%)
                         Largest free fragment is 54606
               RAM used: 2005 (51%) at main() level
                         2280 (59%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   2878
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03E0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   06EA
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   066E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0412
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
026B8:  MOVLB  8
026BA:  MOVF   xDF,F
026BC:  BNZ   26C2
026BE:  MOVF   xE0,F
026C0:  BZ    2746
....................       if (*s1 != *s2) 
026C2:  MOVFF  8DB,FE9
026C6:  MOVFF  8DC,FEA
026CA:  MOVFF  FEF,8E1
026CE:  MOVFF  8DE,03
026D2:  MOVFF  8DD,FE9
026D6:  MOVFF  8DE,FEA
026DA:  MOVF   FEF,W
026DC:  SUBWF  xE1,W
026DE:  BZ    270E
....................          return((*s1 <*s2) ? -1: 1); 
026E0:  MOVFF  8DC,03
026E4:  MOVFF  8DB,FE9
026E8:  MOVFF  8DC,FEA
026EC:  MOVFF  FEF,8E1
026F0:  MOVFF  8DE,03
026F4:  MOVFF  8DD,FE9
026F8:  MOVFF  8DE,FEA
026FC:  MOVF   FEF,W
026FE:  SUBWF  xE1,W
02700:  BC    2706
02702:  MOVLW  FF
02704:  BRA    2708
02706:  MOVLW  01
02708:  MOVWF  01
0270A:  BRA    274A
....................       else if (*s1 == '\0') 
0270C:  BRA    2724
0270E:  MOVFF  8DC,03
02712:  MOVFF  8DB,FE9
02716:  MOVFF  8DC,FEA
0271A:  MOVF   FEF,F
0271C:  BNZ   2724
....................          return(0); 
0271E:  MOVLW  00
02720:  MOVWF  01
02722:  BRA    274A
02724:  MOVFF  8DC,03
02728:  MOVF   xDB,W
0272A:  INCF   xDB,F
0272C:  BTFSC  FD8.2
0272E:  INCF   xDC,F
02730:  MOVFF  8DE,03
02734:  MOVF   xDD,W
02736:  INCF   xDD,F
02738:  BTFSC  FD8.2
0273A:  INCF   xDE,F
0273C:  MOVF   xDF,W
0273E:  BTFSC  FD8.2
02740:  DECF   xE0,F
02742:  DECF   xDF,F
02744:  BRA    26BA
....................    return(0); 
02746:  MOVLW  00
02748:  MOVWF  01
.................... } 
0274A:  MOVLB  0
0274C:  GOTO   2820 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
010F0:  MOVLW  05
010F2:  MOVLB  7
010F4:  SUBWF  xDC,F
010F6:  BNC   110C
010F8:  MOVLW  07
010FA:  MOVWF  FEA
010FC:  MOVLW  DC
010FE:  MOVWF  FE9
01100:  MOVF   FEF,W
01102:  BZ    110C
01104:  BRA    1108
01106:  CLRWDT
01108:  DECFSZ FEF,F
0110A:  BRA    1106
0110C:  MOVLB  0
0110E:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
006A8:  BTFSS  F9E.5
006AA:  BRA    06A8
006AC:  MOVFF  FAB,35
006B0:  MOVFF  FAE,01
006B4:  BTFSS  35.1
006B6:  BRA    06BC
006B8:  BCF    FAB.4
006BA:  BSF    FAB.4
006BC:  RETURN 0
*
01206:  BTFSS  F9E.4
01208:  BRA    1206
0120A:  MOVWF  FAD
0120C:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00656:  BTFSS  FA4.5
00658:  BRA    0656
0065A:  MOVFF  F71,35
0065E:  MOVFF  F74,01
00662:  BTFSS  35.1
00664:  BRA    066A
00666:  BCF    F71.4
00668:  BSF    F71.4
0066A:  GOTO   0670 (RETURN)
*
01110:  BTFSS  FA4.4
01112:  BRA    1110
01114:  MOVWF  F73
01116:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00DBC:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00D1C:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00D1E:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00D20:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00D22:  MOVLB  7
00D24:  MOVF   xD8,F
00D26:  BNZ   0D2E
.................... 		c=0b00011; 
00D28:  MOVLW  03
00D2A:  MOVWF  xDC
.................... 	else if ( 1 == ch )  
00D2C:  BRA    0D78
00D2E:  DECFSZ xD8,W
00D30:  BRA    0D38
.................... 		c=0b10011; 
00D32:  MOVLW  13
00D34:  MOVWF  xDC
.................... 	else if ( 2 == ch )  
00D36:  BRA    0D78
00D38:  MOVF   xD8,W
00D3A:  SUBLW  02
00D3C:  BNZ   0D44
.................... 		c=0b01011; 
00D3E:  MOVLW  0B
00D40:  MOVWF  xDC
.................... 	else if ( 3 == ch )  
00D42:  BRA    0D78
00D44:  MOVF   xD8,W
00D46:  SUBLW  03
00D48:  BNZ   0D50
.................... 		c=0b11011; 
00D4A:  MOVLW  1B
00D4C:  MOVWF  xDC
.................... 	else if ( 4 == ch ) 
00D4E:  BRA    0D78
00D50:  MOVF   xD8,W
00D52:  SUBLW  04
00D54:  BNZ   0D5C
.................... 		c=0b00111; 
00D56:  MOVLW  07
00D58:  MOVWF  xDC
.................... 	else if ( 5 == ch )  
00D5A:  BRA    0D78
00D5C:  MOVF   xD8,W
00D5E:  SUBLW  05
00D60:  BNZ   0D68
.................... 		c=0b10111; 
00D62:  MOVLW  17
00D64:  MOVWF  xDC
.................... 	else if ( 6 == ch ) 
00D66:  BRA    0D78
00D68:  MOVF   xD8,W
00D6A:  SUBLW  06
00D6C:  BNZ   0D74
.................... 		c=0b01111; 
00D6E:  MOVLW  0F
00D70:  MOVWF  xDC
.................... 	else 
00D72:  BRA    0D78
.................... 		c=0b11111; 
00D74:  MOVLW  1F
00D76:  MOVWF  xDC
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00D78:  CLRF   xDB
00D7A:  MOVF   xDB,W
00D7C:  SUBLW  04
00D7E:  BNC   0D96
.................... 		output_low(MCP3208_CLK); 
00D80:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00D82:  BTFSC  xDC.0
00D84:  BRA    0D8A
00D86:  BCF    F8B.5
00D88:  BRA    0D8C
00D8A:  BSF    F8B.5
.................... 		c=c>>1; 
00D8C:  BCF    FD8.0
00D8E:  RRCF   xDC,F
.................... 		output_high(MCP3208_CLK); 
00D90:  BSF    F8B.3
.................... 	} 
00D92:  INCF   xDB,F
00D94:  BRA    0D7A
....................  
....................  
.................... 	value=0; 
00D96:  CLRF   xDA
00D98:  CLRF   xD9
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00D9A:  CLRF   xDB
00D9C:  MOVF   xDB,W
00D9E:  SUBLW  0D
00DA0:  BNC   0DB8
.................... 		output_low(MCP3208_CLK); 
00DA2:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00DA4:  BTFSC  F82.4
00DA6:  BRA    0DAC
00DA8:  BCF    FD8.0
00DAA:  BRA    0DAE
00DAC:  BSF    FD8.0
00DAE:  RLCF   xD9,F
00DB0:  RLCF   xDA,F
.................... 		output_high(MCP3208_CLK); 
00DB2:  BSF    F8B.3
.................... 	} 
00DB4:  INCF   xDB,F
00DB6:  BRA    0D9C
....................  
.................... 	bit_clear(value,13); 
00DB8:  BCF    xDA.5
.................... 	bit_clear(value,12); 
00DBA:  BCF    xDA.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00DBE:  MOVFF  7D9,01
00DC2:  MOVFF  7DA,02
.................... } 
00DC6:  MOVLB  0
00DC8:  GOTO   0E3A (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00EC4:  MOVLB  8
00EC6:  CLRF   xDA
00EC8:  MOVFF  7ED,8D9
00ECC:  CLRF   xDC
00ECE:  MOVLW  20
00ED0:  MOVWF  xDB
00ED2:  MOVLB  0
00ED4:  RCALL  081A
00ED6:  MOVFF  02,03
00EDA:  MOVF   01,W
00EDC:  ADDLW  CA
00EDE:  MOVWF  01
00EE0:  MOVLW  00
00EE2:  ADDWFC 03,F
00EE4:  MOVFF  01,7F1
00EE8:  MOVLB  7
00EEA:  MOVFF  03,7F2
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00EEE:  CLRF   xEF
00EF0:  CLRF   xEE
.................... 	for( i = 0; i < 16 ; i++ ) { 
00EF2:  CLRF   xF0
00EF4:  MOVF   xF0,W
00EF6:  SUBLW  0F
00EF8:  BNC   0F1C
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00EFA:  BCF    FD8.0
00EFC:  RLCF   xF0,W
00EFE:  CLRF   03
00F00:  ADDWF  xF1,W
00F02:  MOVWF  FE9
00F04:  MOVF   xF2,W
00F06:  ADDWFC 03,W
00F08:  MOVWF  FEA
00F0A:  MOVFF  FEC,03
00F0E:  MOVF   FED,F
00F10:  MOVF   FEF,W
00F12:  ADDWF  xEE,F
00F14:  MOVF   03,W
00F16:  ADDWFC xEF,F
.................... 	} 
00F18:  INCF   xF0,F
00F1A:  BRA    0EF4
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00F1C:  MOVLW  08
00F1E:  ADDWF  xEE,W
00F20:  MOVWF  xF3
00F22:  MOVLW  00
00F24:  ADDWFC xEF,W
00F26:  MOVWF  xF4
00F28:  RRCF   xF4,W
00F2A:  MOVWF  03
00F2C:  RRCF   xF3,W
00F2E:  MOVWF  02
00F30:  RRCF   03,F
00F32:  RRCF   02,F
00F34:  RRCF   03,F
00F36:  RRCF   02,F
00F38:  RRCF   03,F
00F3A:  RRCF   02,F
00F3C:  MOVLW  0F
00F3E:  ANDWF  03,F
00F40:  MOVFF  02,01
00F44:  MOVFF  03,02
.................... } 
00F48:  MOVLB  0
00F4A:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00DCC:  MOVLB  1
00DCE:  INCF   xCA,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00DD0:  MOVF   xCA,W
00DD2:  SUBLW  0F
00DD4:  BC    0DD8
.................... 		current.adc_buffer_index=0; 
00DD6:  CLRF   xCA
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00DD8:  MOVLB  7
00DDA:  CLRF   xD5
00DDC:  MOVF   xD5,W
00DDE:  SUBLW  07
00DE0:  BNC   0E70
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00DE2:  MOVLB  8
00DE4:  CLRF   xDA
00DE6:  MOVFF  7D5,8D9
00DEA:  CLRF   xDC
00DEC:  MOVLW  20
00DEE:  MOVWF  xDB
00DF0:  MOVLB  0
00DF2:  RCALL  081A
00DF4:  MOVFF  02,03
00DF8:  MOVF   01,W
00DFA:  ADDLW  34
00DFC:  MOVLB  7
00DFE:  MOVWF  xD6
00E00:  MOVLW  00
00E02:  ADDWFC 02,W
00E04:  MOVWF  xD7
00E06:  CLRF   03
00E08:  MOVLB  1
00E0A:  MOVFF  1CA,02
00E0E:  BCF    FD8.0
00E10:  RLCF   02,F
00E12:  RLCF   03,F
00E14:  MOVF   02,W
00E16:  MOVLB  7
00E18:  ADDWF  xD6,W
00E1A:  MOVWF  01
00E1C:  MOVF   xD7,W
00E1E:  ADDWFC 03,F
00E20:  MOVF   01,W
00E22:  ADDLW  96
00E24:  MOVWF  01
00E26:  MOVLW  00
00E28:  ADDWFC 03,F
00E2A:  MOVFF  01,7D6
00E2E:  MOVFF  03,7D7
00E32:  MOVFF  7D5,7D8
00E36:  MOVLB  0
00E38:  BRA    0D1C
00E3A:  MOVFF  7D7,FEA
00E3E:  MOVFF  7D6,FE9
00E42:  MOVFF  02,FEC
00E46:  MOVF   FED,F
00E48:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00E4C:  CLRF   03
00E4E:  MOVLB  7
00E50:  MOVFF  7D5,02
00E54:  BCF    FD8.0
00E56:  RLCF   02,F
00E58:  RLCF   03,F
00E5A:  MOVF   02,W
00E5C:  ADDLW  BA
00E5E:  MOVWF  FE9
00E60:  MOVLW  00
00E62:  ADDWFC 03,W
00E64:  MOVWF  FEA
00E66:  CLRF   FEC
00E68:  MOVF   FED,F
00E6A:  CLRF   FEF
....................  
.................... 	} 
00E6C:  INCF   xD5,F
00E6E:  BRA    0DDC
.................... } 
00E70:  MOVLB  0
00E72:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00B22:  MOVF   xF2,W
00B24:  XORWF  xF3,W
00B26:  MOVWF  01
*
00B74:  MOVF   xF2,W
00B76:  XORWF  xF3,W
00B78:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00AAC:  MOVLB  7
00AAE:  CLRF   xDE
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00AB0:  MOVFF  7DD,03
00AB4:  MOVF   xDC,W
00AB6:  BTFSC  FD8.2
00AB8:  DECF   xDD,F
00ABA:  DECF   xDC,F
00ABC:  MOVWF  xDF
00ABE:  MOVFF  03,7E0
00AC2:  MOVF   xDF,F
00AC4:  BNZ   0ACA
00AC6:  MOVF   xE0,F
00AC8:  BZ    0B34
.................... 		*data = read_eeprom( address++ ); 
00ACA:  MOVFF  7DB,03
00ACE:  MOVF   xDA,W
00AD0:  MOVWF  FE9
00AD2:  MOVFF  03,FEA
00AD6:  MOVF   xD9,W
00AD8:  MOVWF  03
00ADA:  MOVF   xD8,W
00ADC:  INCF   xD8,F
00ADE:  BTFSC  FD8.2
00AE0:  INCF   xD9,F
00AE2:  MOVWF  xE1
00AE4:  MOVFF  03,7E2
00AE8:  MOVFF  FF2,7E3
00AEC:  BCF    FF2.6
00AEE:  BCF    FF2.7
00AF0:  MOVFF  7E2,FAA
00AF4:  MOVFF  7E1,FA9
00AF8:  BCF    FA6.6
00AFA:  BCF    FA6.7
00AFC:  BSF    FA6.0
00AFE:  MOVF   FA8,W
00B00:  BTFSC  xE3.6
00B02:  BSF    FF2.6
00B04:  BTFSC  xE3.7
00B06:  BSF    FF2.7
00B08:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00B0A:  MOVFF  7DB,03
00B0E:  MOVF   xDA,W
00B10:  MOVWF  FE9
00B12:  MOVFF  03,FEA
00B16:  MOVFF  FEF,7DF
00B1A:  MOVFF  7DE,7F2
00B1E:  MOVFF  7DF,7F3
*
00B28:  MOVFF  01,7DE
.................... 		data++; 
00B2C:  INCF   xDA,F
00B2E:  BTFSC  FD8.2
00B30:  INCF   xDB,F
.................... 	} 
00B32:  BRA    0AB0
.................... 	return crc; 
00B34:  MOVFF  7DE,01
.................... } 
00B38:  MOVLB  0
00B3A:  GOTO   0CD0 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00B3E:  MOVLB  7
00B40:  CLRF   xF0
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B42:  MOVFF  7EF,03
00B46:  MOVF   xEE,W
00B48:  BTFSC  FD8.2
00B4A:  DECF   xEF,F
00B4C:  DECF   xEE,F
00B4E:  MOVWF  xF1
00B50:  MOVFF  03,7F2
00B54:  MOVF   xF1,F
00B56:  BNZ   0B5C
00B58:  MOVF   xF2,F
00B5A:  BZ    0BDA
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00B5C:  MOVFF  7ED,03
00B60:  MOVF   xEC,W
00B62:  MOVWF  FE9
00B64:  MOVFF  03,FEA
00B68:  MOVFF  FEF,7F1
00B6C:  MOVFF  7F0,7F2
00B70:  MOVFF  7F1,7F3
*
00B7A:  MOVFF  01,7F0
.................... 		write_eeprom( address++, *data++ ); 
00B7E:  MOVF   xEB,W
00B80:  MOVWF  03
00B82:  MOVF   xEA,W
00B84:  INCF   xEA,F
00B86:  BTFSC  FD8.2
00B88:  INCF   xEB,F
00B8A:  MOVWF  xF1
00B8C:  MOVFF  03,7F2
00B90:  MOVF   xED,W
00B92:  MOVWF  03
00B94:  MOVF   xEC,W
00B96:  INCF   xEC,F
00B98:  BTFSC  FD8.2
00B9A:  INCF   xED,F
00B9C:  MOVWF  FE9
00B9E:  MOVFF  03,FEA
00BA2:  MOVFF  FEF,7F3
00BA6:  MOVFF  7F2,FAA
00BAA:  MOVFF  7F1,FA9
00BAE:  MOVFF  7F3,FA8
00BB2:  BCF    FA6.6
00BB4:  BCF    FA6.7
00BB6:  BSF    FA6.2
00BB8:  MOVF   FF2,W
00BBA:  MOVWF  00
00BBC:  BCF    FF2.6
00BBE:  BCF    FF2.7
00BC0:  MOVLB  F
00BC2:  MOVLW  55
00BC4:  MOVWF  FA7
00BC6:  MOVLW  AA
00BC8:  MOVWF  FA7
00BCA:  BSF    FA6.1
00BCC:  BTFSC  FA6.1
00BCE:  BRA    0BCC
00BD0:  BCF    FA6.2
00BD2:  MOVF   00,W
00BD4:  IORWF  FF2,F
.................... 	} 
00BD6:  MOVLB  7
00BD8:  BRA    0B42
....................  
.................... 	return crc; 
00BDA:  MOVFF  7F0,01
.................... } 
00BDE:  MOVLB  0
00BE0:  GOTO   0C04 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00BE4:  MOVLB  7
00BE6:  CLRF   xE9
00BE8:  MOVLW  36
00BEA:  MOVWF  xE8
00BEC:  CLRF   xEB
00BEE:  MOVLW  02
00BF0:  MOVWF  xEA
00BF2:  MOVFF  7E9,7ED
00BF6:  MOVFF  7E8,7EC
00BFA:  CLRF   xEF
00BFC:  MOVLW  60
00BFE:  MOVWF  xEE
00C00:  MOVLB  0
00C02:  BRA    0B3E
00C04:  MOVFF  01,7E7
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00C08:  CLRF   FAA
00C0A:  CLRF   FA9
00C0C:  MOVFF  7E7,FA8
00C10:  BCF    FA6.6
00C12:  BCF    FA6.7
00C14:  BSF    FA6.2
00C16:  MOVF   FF2,W
00C18:  MOVWF  00
00C1A:  BCF    FF2.6
00C1C:  BCF    FF2.7
00C1E:  MOVLB  F
00C20:  MOVLW  55
00C22:  MOVWF  FA7
00C24:  MOVLW  AA
00C26:  MOVWF  FA7
00C28:  BSF    FA6.1
00C2A:  BTFSC  FA6.1
00C2C:  BRA    0C2A
00C2E:  BCF    FA6.2
00C30:  MOVF   00,W
00C32:  IORWF  FF2,F
.................... } 
00C34:  MOVLB  0
00C36:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00C38:  MOVLW  96
00C3A:  MOVLB  1
00C3C:  MOVWF  xF6
....................  
.................... 	config.modbus_address=38; 
00C3E:  MOVLW  26
00C40:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00C42:  MOVLW  02
00C44:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00C46:  MOVLW  50
00C48:  MOVWF  39
.................... 	config.serial_number=9876; 
00C4A:  MOVLW  26
00C4C:  MOVWF  3B
00C4E:  MOVLW  94
00C50:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00C52:  CLRF   3D
00C54:  MOVLW  14
00C56:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00C58:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00C5A:  MOVLW  02
00C5C:  MOVWF  40
00C5E:  MOVLW  76
00C60:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00C62:  CLRF   42
00C64:  MOVLW  02
00C66:  MOVWF  41
.................... 	config.power_startup=0; 
00C68:  CLRF   43
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00C6A:  CLRF   FEA
00C6C:  MOVLW  4E
00C6E:  MOVWF  FE9
00C70:  CLRF   00
00C72:  CLRF   02
00C74:  MOVLW  48
00C76:  MOVWF  01
00C78:  MOVLB  0
00C7A:  RCALL  083C
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00C7C:  CLRF   FEA
00C7E:  MOVLW  4E
00C80:  MOVWF  FE9
00C82:  MOVLW  00
00C84:  CALL   017C
00C88:  TBLRD*-
00C8A:  TBLRD*+
00C8C:  MOVF   FF5,W
00C8E:  MOVWF  FEE
00C90:  IORLW  00
00C92:  BNZ   0C8A
.................... 	strcpy(config.nmea0183_sentence[1],"$WIMDA"); 
00C94:  CLRF   FEA
00C96:  MOVLW  54
00C98:  MOVWF  FE9
00C9A:  MOVLW  00
00C9C:  CALL   0194
00CA0:  TBLRD*-
00CA2:  TBLRD*+
00CA4:  MOVF   FF5,W
00CA6:  MOVWF  FEE
00CA8:  IORLW  00
00CAA:  BNZ   0CA2
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00CAC:  RCALL  0BE4
....................  
.................... } 
00CAE:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00CB0:  MOVLB  7
00CB2:  CLRF   xD7
00CB4:  MOVLW  36
00CB6:  MOVWF  xD6
00CB8:  CLRF   xD9
00CBA:  MOVLW  02
00CBC:  MOVWF  xD8
00CBE:  MOVFF  7D7,7DB
00CC2:  MOVFF  7D6,7DA
00CC6:  CLRF   xDD
00CC8:  MOVLW  60
00CCA:  MOVWF  xDC
00CCC:  MOVLB  0
00CCE:  BRA    0AAC
00CD0:  MOVFF  01,7D5
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00CD4:  MOVFF  FF2,7D6
00CD8:  BCF    FF2.6
00CDA:  BCF    FF2.7
00CDC:  CLRF   FAA
00CDE:  CLRF   FA9
00CE0:  BCF    FA6.6
00CE2:  BCF    FA6.7
00CE4:  BSF    FA6.0
00CE6:  MOVF   FA8,W
00CE8:  MOVLB  7
00CEA:  BTFSC  xD6.6
00CEC:  BSF    FF2.6
00CEE:  BTFSC  xD6.7
00CF0:  BSF    FF2.7
00CF2:  SUBWF  xD5,W
00CF4:  BZ    0CFC
.................... 		write_default_param_file(); 
00CF6:  MOVLB  0
00CF8:  RCALL  0C38
00CFA:  MOVLB  7
.................... 	} 
.................... } 
00CFC:  MOVLB  0
00CFE:  GOTO   2A1C (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
01268:  BTFSS  FAC.1
0126A:  BRA    1268
.................... } 
0126C:  GOTO   1286 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00D02:  BTFSS  F9E.5
00D04:  BRA    0D0A
.................... 		fgetc(STREAM_PI); 
00D06:  RCALL  06A8
.................... 	} 
00D08:  BRA    0D02
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00D0A:  BSF    F9D.5
.................... } 
00D0C:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00D0E:  RCALL  0D02
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00D10:  MOVLW  C6
00D12:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00D14:  MOVLW  C0
00D16:  IORWF  FF2,F
.................... } 
00D18:  GOTO   2A2E (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003CC:  BCF    FF2.5
.................... 	if (enable) { 
003CE:  MOVLB  8
003D0:  MOVF   xE5,F
003D2:  BZ    03DC
.................... 		set_timer0(0); 
003D4:  CLRF   FD7
003D6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003D8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003DA:  BSF    FF2.5
.................... 	} 
.................... } 
003DC:  MOVLB  0
003DE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003E0:  MOVLB  6
003E2:  MOVF   xC0,W
003E4:  SUBLW  02
003E6:  BNZ   03FC
003E8:  MOVF   xC1,F
003EA:  BNZ   03FC
003EC:  MOVF   xC2,F
003EE:  BNZ   03FC
003F0:  BTFSC  xBF.0
003F2:  BRA    03FC
....................    { 
....................       modbus_rx.len-=2; 
003F4:  MOVLW  02
003F6:  SUBWF  xC4,F
....................       modbus_serial_new=TRUE; 
003F8:  BSF    xBF.0
....................    } 
....................    else 
003FA:  BRA    03FE
....................       modbus_serial_new=FALSE; 
003FC:  BCF    xBF.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003FE:  SETF   xC2
00400:  SETF   xC1
....................    modbus_serial_state=MODBUS_GETADDY; 
00402:  CLRF   xC0
....................    modbus_enable_timeout(FALSE); 
00404:  MOVLB  8
00406:  CLRF   xE5
00408:  MOVLB  0
0040A:  RCALL  03CC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0040C:  BCF    FF2.2
0040E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
006BE:  MOVLB  6
006C0:  MOVF   xC2,W
006C2:  MOVLB  8
006C4:  XORWF  xE5,W
006C6:  MOVWF  xE6
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
006C8:  CLRF   03
006CA:  MOVF   xE6,W
006CC:  MOVLB  0
006CE:  RCALL  01AC
006D0:  MOVWF  01
006D2:  MOVLB  6
006D4:  MOVF   xC1,W
006D6:  XORWF  01,W
006D8:  MOVWF  xC2
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006DA:  CLRF   03
006DC:  MOVLB  8
006DE:  MOVF   xE6,W
006E0:  MOVLB  0
006E2:  RCALL  02BC
006E4:  MOVFF  FE8,6C1
.................... } 
006E8:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
0120E:  MOVLB  7
01210:  MOVF   xE7,W
01212:  MOVLB  0
01214:  RCALL  1206
01216:  CLRF   19
01218:  BTFSC  FF2.6
0121A:  BSF    19.6
0121C:  BCF    FF2.6
0121E:  BTFSC  FF2.7
01220:  BSF    19.7
01222:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
01224:  MOVFF  7E7,8E5
01228:  CALL   06BE
0122C:  BTFSC  19.6
0122E:  BSF    FF2.6
01230:  BTFSC  19.7
01232:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
01234:  CLRWDT
01236:  MOVLW  08
01238:  MOVWF  00
0123A:  DECFSZ 00,F
0123C:  BRA    123A
0123E:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
01240:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
01242:  MOVLB  6
01244:  SETF   xC2
01246:  SETF   xC1
....................    modbus_serial_new=FALSE; 
01248:  BCF    xBF.0
....................  
....................    RCV_OFF(); 
0124A:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
0124C:  CLRWDT
0124E:  MOVLW  3C
01250:  MOVWF  00
01252:  DECFSZ 00,F
01254:  BRA    1252
01256:  NOP   
....................  
....................    modbus_serial_putc(to); 
01258:  MOVFF  7E5,7E7
0125C:  MOVLB  0
0125E:  RCALL  120E
....................    modbus_serial_putc(func); 
01260:  MOVFF  7E6,7E7
01264:  RCALL  120E
.................... } 
01266:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
01270:  MOVFF  6C2,7E6
....................    crc_low=modbus_serial_crc.b[0]; 
01274:  MOVFF  6C1,7E5
....................  
....................    modbus_serial_putc(crc_high); 
01278:  MOVFF  7E6,7E7
0127C:  RCALL  120E
....................    modbus_serial_putc(crc_low); 
0127E:  MOVFF  7E5,7E7
01282:  RCALL  120E
....................  
....................    WAIT_FOR_HW_BUFFER(); 
01284:  BRA    1268
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
01286:  CLRWDT
01288:  MOVLW  3C
0128A:  MOVWF  00
0128C:  DECFSZ 00,F
0128E:  BRA    128C
01290:  NOP   
....................  
....................  
....................    RCV_ON(); 
01292:  RCALL  0D02
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
01294:  MOVLB  6
01296:  SETF   xC2
01298:  SETF   xC1
.................... } 
0129A:  MOVLB  0
0129C:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
010CA:  MOVLB  6
010CC:  BTFSC  xBF.0
010CE:  BRA    10D8
....................       return FALSE; 
010D0:  MOVLW  00
010D2:  MOVWF  01
010D4:  BRA    10EA
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
010D6:  BRA    10E4
010D8:  BTFSS  xC5.7
010DA:  BRA    10E4
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
010DC:  MOVFF  6C7,6C6
....................       modbus_rx.len = 1; 
010E0:  MOVLW  01
010E2:  MOVWF  xC4
....................    } 
....................    modbus_serial_new=FALSE; 
010E4:  BCF    xBF.0
....................    return TRUE; 
010E6:  MOVLW  01
010E8:  MOVWF  01
.................... } 
010EA:  MOVLB  0
010EC:  GOTO   2324 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02290:  MOVFF  7DD,7E5
02294:  MOVLW  06
02296:  MOVLB  7
02298:  MOVWF  xE6
0229A:  MOVLB  0
0229C:  CALL   1242
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
022A0:  MOVFF  7DF,7E2
022A4:  MOVFF  7DF,7E7
022A8:  CALL   120E
....................    modbus_serial_putc(make8(reg_address,0)); 
022AC:  MOVFF  7DE,7E2
022B0:  MOVFF  7DE,7E7
022B4:  CALL   120E
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
022B8:  MOVFF  7E1,7E2
022BC:  MOVFF  7E1,7E7
022C0:  CALL   120E
....................    modbus_serial_putc(make8(reg_value,0)); 
022C4:  MOVFF  7E0,7E2
022C8:  MOVFF  7E0,7E7
022CC:  CALL   120E
....................  
....................    modbus_serial_send_stop(); 
022D0:  CALL   1270
.................... } 
022D4:  GOTO   2508 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
022D8:  MOVFF  7DB,7E5
022DC:  MOVLW  10
022DE:  MOVLB  7
022E0:  MOVWF  xE6
022E2:  MOVLB  0
022E4:  CALL   1242
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
022E8:  MOVFF  7DD,7E0
022EC:  MOVFF  7DD,7E7
022F0:  CALL   120E
....................    modbus_serial_putc(make8(start_address,0)); 
022F4:  MOVFF  7DC,7E0
022F8:  MOVFF  7DC,7E7
022FC:  CALL   120E
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02300:  MOVFF  7DF,7E0
02304:  MOVFF  7DF,7E7
02308:  CALL   120E
....................    modbus_serial_putc(make8(quantity,0)); 
0230C:  MOVFF  7DE,7E0
02310:  MOVFF  7DE,7E7
02314:  CALL   120E
....................  
....................    modbus_serial_send_stop(); 
02318:  CALL   1270
.................... } 
0231C:  GOTO   25CA (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0129E:  MOVLB  7
012A0:  MOVF   xDC,W
012A2:  IORLW  80
012A4:  MOVWF  xDF
012A6:  MOVFF  7DD,7E0
012AA:  MOVFF  7DB,7E5
012AE:  MOVWF  xE6
012B0:  MOVLB  0
012B2:  RCALL  1242
....................    modbus_serial_putc(error); 
012B4:  MOVFF  7DE,7E7
012B8:  RCALL  120E
....................    modbus_serial_send_stop(); 
012BA:  RCALL  1270
.................... } 
012BC:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          53 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1012 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
01384:  MOVLB  1
01386:  CLRF   xCC
01388:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
0138A:  CLRF   xCE
0138C:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
0138E:  CLRF   xD0
01390:  CLRF   xCF
.................... } 
01392:  MOVLB  0
01394:  GOTO   1E12 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
01320:  BCF    FF2.6
01322:  BCF    FF2.7
01324:  BTFSC  FF2.7
01326:  BRA    1322
....................  
.................... 	current.pulse_count[0]=0; 
01328:  CLRF   xA9
0132A:  CLRF   xA8
.................... 	current.pulse_count[1]=0; 
0132C:  CLRF   xAB
0132E:  CLRF   xAA
.................... 	current.pulse_count[2]=0; 
01330:  CLRF   xAD
01332:  CLRF   xAC
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
01334:  SETF   x9D
01336:  SETF   x9C
.................... 	current.pulse_min_period[1]=65535; 
01338:  SETF   x9F
0133A:  SETF   x9E
.................... 	current.pulse_min_period[2]=65535; 
0133C:  SETF   xA1
0133E:  SETF   xA0
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
01340:  CLRF   xA3
01342:  CLRF   xA2
.................... 	current.pulse_max_period[1]=0; 
01344:  CLRF   xA5
01346:  CLRF   xA4
.................... 	current.pulse_max_period[2]=0; 
01348:  CLRF   xA7
0134A:  CLRF   xA6
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
0134C:  MOVLB  1
0134E:  CLRF   xD6
01350:  CLRF   xD5
....................  
.................... 	enable_interrupts(GLOBAL); 
01352:  MOVLW  C0
01354:  IORWF  FF2,F
.................... } 
01356:  MOVLB  0
01358:  GOTO   1DC2 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
0135C:  BCF    FF2.6
0135E:  BCF    FF2.7
01360:  BTFSC  FF2.7
01362:  BRA    135E
.................... 	current.pulse_sum[0]=0; 
01364:  CLRF   xB1
01366:  CLRF   xB0
01368:  CLRF   xAF
0136A:  CLRF   xAE
.................... 	current.pulse_sum[1]=0; 
0136C:  CLRF   xB5
0136E:  CLRF   xB4
01370:  CLRF   xB3
01372:  CLRF   xB2
.................... 	current.pulse_sum[2]=0; 
01374:  CLRF   xB9
01376:  CLRF   xB8
01378:  CLRF   xB7
0137A:  CLRF   xB6
.................... 	enable_interrupts(GLOBAL); 
0137C:  MOVLW  C0
0137E:  IORWF  FF2,F
.................... } 
01380:  GOTO   1DD2 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
012BE:  BCF    FF2.6
012C0:  BCF    FF2.7
012C2:  BTFSC  FF2.7
012C4:  BRA    12C0
.................... 	l=current.pulse_sum[ch]; 
012C6:  MOVLB  8
012C8:  CLRF   xDA
012CA:  MOVFF  7ED,8D9
012CE:  CLRF   xDC
012D0:  MOVLW  04
012D2:  MOVWF  xDB
012D4:  MOVLB  0
012D6:  CALL   081A
012DA:  MOVFF  02,03
012DE:  MOVF   01,W
012E0:  ADDLW  AE
012E2:  MOVWF  FE9
012E4:  MOVLW  00
012E6:  ADDWFC 02,W
012E8:  MOVWF  FEA
012EA:  MOVFF  FEF,00
012EE:  MOVFF  FEC,01
012F2:  MOVFF  FEC,02
012F6:  MOVFF  FEC,03
012FA:  MOVFF  03,7F1
012FE:  MOVFF  02,7F0
01302:  MOVFF  01,7EF
01306:  MOVFF  00,7EE
.................... 	enable_interrupts(GLOBAL); 
0130A:  MOVLW  C0
0130C:  IORWF  FF2,F
....................  
.................... 	return l; 
0130E:  MOVFF  7EE,00
01312:  MOVFF  7EF,01
01316:  MOVFF  7F0,02
0131A:  MOVFF  7F1,03
.................... } 
0131E:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01398:  MOVLB  7
0139A:  MOVF   xE8,W
0139C:  SUBLW  06
0139E:  BC    13F4
013A0:  XORLW  FF
013A2:  BNZ   13AA
013A4:  MOVF   xE7,W
013A6:  SUBLW  CF
013A8:  BC    13F4
013AA:  MOVF   xE8,W
013AC:  SUBLW  09
013AE:  BNC   13F4
013B0:  BNZ   13B8
013B2:  MOVF   xE7,W
013B4:  SUBLW  CF
013B6:  BNC   13F4
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
013B8:  MOVLW  D0
013BA:  SUBWF  xE7,W
013BC:  MOVWF  xED
013BE:  MOVLW  07
013C0:  SUBWFB xE8,W
013C2:  MOVWF  xEE
013C4:  MOVLW  02
013C6:  ADDWF  xEE,F
013C8:  MOVFF  FF2,7EF
013CC:  BCF    FF2.6
013CE:  BCF    FF2.7
013D0:  MOVFF  7EE,FAA
013D4:  MOVFF  7ED,FA9
013D8:  BCF    FA6.6
013DA:  BCF    FA6.7
013DC:  BSF    FA6.0
013DE:  MOVF   FA8,W
013E0:  BTFSC  xEF.6
013E2:  BSF    FF2.6
013E4:  BTFSC  xEF.7
013E6:  BSF    FF2.7
013E8:  CLRF   03
013EA:  MOVWF  01
013EC:  MOVF   03,W
013EE:  MOVWF  02
013F0:  GOTO   1F04
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
013F4:  MOVF   xE8,W
013F6:  SUBLW  03
013F8:  BC    1478
013FA:  XORLW  FF
013FC:  BNZ   1404
013FE:  MOVF   xE7,W
01400:  SUBLW  4B
01402:  BC    1478
01404:  MOVF   xE8,W
01406:  SUBLW  04
01408:  BNC   1478
0140A:  BNZ   1412
0140C:  MOVF   xE7,W
0140E:  SUBLW  93
01410:  BNC   1478
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
01412:  MOVLW  4C
01414:  SUBWF  xE7,W
01416:  MOVWF  xE9
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01418:  MOVFF  7E9,7ED
0141C:  MOVLW  06
0141E:  MOVWF  xEE
01420:  MOVLB  0
01422:  CALL   0A00
01426:  MOVFF  00,7EA
.................... 		n = n / 6; /* number of sentence */ 
0142A:  MOVFF  7E9,7ED
0142E:  MOVLW  06
01430:  MOVLB  7
01432:  MOVWF  xEE
01434:  MOVLB  0
01436:  CALL   0A00
0143A:  MOVFF  01,7E9
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
0143E:  MOVLB  7
01440:  MOVF   xE9,W
01442:  MULLW  06
01444:  MOVF   FF3,W
01446:  CLRF   03
01448:  ADDLW  18
0144A:  MOVWF  xED
0144C:  MOVLW  00
0144E:  ADDWFC 03,W
01450:  MOVWF  xEE
01452:  CLRF   03
01454:  MOVF   xEA,W
01456:  ADDWF  xED,W
01458:  MOVWF  01
0145A:  MOVF   xEE,W
0145C:  ADDWFC 03,F
0145E:  MOVF   01,W
01460:  ADDLW  36
01462:  MOVWF  FE9
01464:  MOVLW  00
01466:  ADDWFC 03,W
01468:  MOVWF  FEA
0146A:  MOVF   FEF,W
0146C:  CLRF   03
0146E:  MOVWF  01
01470:  MOVFF  03,02
01474:  GOTO   1F04
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
01478:  MOVF   xE8,W
0147A:  SUBLW  12
0147C:  BC    14BE
0147E:  XORLW  FF
01480:  BNZ   1488
01482:  MOVF   xE7,W
01484:  SUBLW  87
01486:  BC    14BE
01488:  MOVF   xE8,W
0148A:  SUBLW  17
0148C:  BNC   14BE
0148E:  BNZ   1496
01490:  MOVF   xE7,W
01492:  SUBLW  47
01494:  BNC   14BE
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
01496:  MOVLW  88
01498:  SUBWF  xE7,F
0149A:  MOVLW  13
0149C:  SUBWFB xE8,F
....................  
....................  		p  = nmea.sentence[0]; 
0149E:  MOVLW  02
014A0:  MOVWF  xEC
014A2:  SETF   xEB
.................... 		return (int16) p[addr]; 
014A4:  MOVF   xEB,W
014A6:  ADDWF  xE7,W
014A8:  MOVWF  FE9
014AA:  MOVF   xEC,W
014AC:  ADDWFC xE8,W
014AE:  MOVWF  FEA
014B0:  MOVF   FEF,W
014B2:  CLRF   03
014B4:  MOVWF  01
014B6:  MOVFF  03,02
014BA:  GOTO   1F04
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
014BE:  MOVF   xE8,W
014C0:  SUBLW  16
014C2:  BC    152C
014C4:  XORLW  FF
014C6:  BNZ   14CE
014C8:  MOVF   xE7,W
014CA:  SUBLW  6F
014CC:  BC    152C
014CE:  MOVF   xE8,W
014D0:  SUBLW  19
014D2:  BNC   152C
014D4:  BNZ   14DC
014D6:  MOVF   xE7,W
014D8:  SUBLW  4F
014DA:  BNC   152C
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
014DC:  MOVLW  70
014DE:  SUBWF  xE7,F
014E0:  MOVLW  17
014E2:  SUBWFB xE8,F
.................... 		addr = addr * 2; 
014E4:  BCF    FD8.0
014E6:  RLCF   xE7,F
014E8:  RLCF   xE8,F
....................  
....................  		p  = nmea.sentence[0]; 
014EA:  MOVLW  02
014EC:  MOVWF  xEC
014EE:  SETF   xEB
.................... 		return (int16) make16(p[addr],p[addr+1]); 
014F0:  MOVF   xEB,W
014F2:  ADDWF  xE7,W
014F4:  MOVWF  FE9
014F6:  MOVF   xEC,W
014F8:  ADDWFC xE8,W
014FA:  MOVWF  FEA
014FC:  MOVFF  FEF,7ED
01500:  MOVLW  01
01502:  ADDWF  xE7,W
01504:  MOVWF  xEE
01506:  MOVLW  00
01508:  ADDWFC xE8,W
0150A:  MOVWF  xEF
0150C:  MOVF   xEB,W
0150E:  ADDWF  xEE,W
01510:  MOVWF  FE9
01512:  MOVF   xEC,W
01514:  ADDWFC xEF,W
01516:  MOVWF  FEA
01518:  MOVFF  FEF,7F0
0151C:  MOVFF  7ED,03
01520:  MOVFF  7F0,01
01524:  MOVFF  7ED,02
01528:  GOTO   1F04
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
0152C:  MOVF   xE7,W
0152E:  MOVWF  00
01530:  MOVF   xE8,W
01532:  MOVWF  03
01534:  MOVF   03,W
01536:  BNZ   1542
01538:  MOVF   00,F
0153A:  MOVLB  0
0153C:  BTFSC  FD8.2
0153E:  BRA    197E
01540:  MOVLB  7
01542:  MOVF   03,W
01544:  BNZ   1552
01546:  MOVLW  01
01548:  SUBWF  00,W
0154A:  MOVLB  0
0154C:  BTFSC  FD8.2
0154E:  BRA    198C
01550:  MOVLB  7
01552:  MOVF   03,W
01554:  BNZ   1562
01556:  MOVLW  02
01558:  SUBWF  00,W
0155A:  MOVLB  0
0155C:  BTFSC  FD8.2
0155E:  BRA    199A
01560:  MOVLB  7
01562:  MOVF   03,W
01564:  BNZ   1572
01566:  MOVLW  03
01568:  SUBWF  00,W
0156A:  MOVLB  0
0156C:  BTFSC  FD8.2
0156E:  BRA    19A8
01570:  MOVLB  7
01572:  MOVF   03,W
01574:  BNZ   1582
01576:  MOVLW  04
01578:  SUBWF  00,W
0157A:  MOVLB  0
0157C:  BTFSC  FD8.2
0157E:  BRA    19B6
01580:  MOVLB  7
01582:  MOVF   03,W
01584:  BNZ   1592
01586:  MOVLW  05
01588:  SUBWF  00,W
0158A:  MOVLB  0
0158C:  BTFSC  FD8.2
0158E:  BRA    19DC
01590:  MOVLB  7
01592:  MOVF   03,W
01594:  BNZ   15A2
01596:  MOVLW  06
01598:  SUBWF  00,W
0159A:  MOVLB  0
0159C:  BTFSC  FD8.2
0159E:  BRA    19EA
015A0:  MOVLB  7
015A2:  MOVF   03,W
015A4:  BNZ   15B2
015A6:  MOVLW  07
015A8:  SUBWF  00,W
015AA:  MOVLB  0
015AC:  BTFSC  FD8.2
015AE:  BRA    19F8
015B0:  MOVLB  7
015B2:  MOVF   03,W
015B4:  BNZ   15C2
015B6:  MOVLW  08
015B8:  SUBWF  00,W
015BA:  MOVLB  0
015BC:  BTFSC  FD8.2
015BE:  BRA    1A06
015C0:  MOVLB  7
015C2:  MOVF   03,W
015C4:  BNZ   15D2
015C6:  MOVLW  09
015C8:  SUBWF  00,W
015CA:  MOVLB  0
015CC:  BTFSC  FD8.2
015CE:  BRA    1A14
015D0:  MOVLB  7
015D2:  MOVF   03,W
015D4:  BNZ   15E2
015D6:  MOVLW  0A
015D8:  SUBWF  00,W
015DA:  MOVLB  0
015DC:  BTFSC  FD8.2
015DE:  BRA    1A22
015E0:  MOVLB  7
015E2:  MOVF   03,W
015E4:  BNZ   15F2
015E6:  MOVLW  0B
015E8:  SUBWF  00,W
015EA:  MOVLB  0
015EC:  BTFSC  FD8.2
015EE:  BRA    1A4A
015F0:  MOVLB  7
015F2:  MOVF   03,W
015F4:  BNZ   1602
015F6:  MOVLW  0C
015F8:  SUBWF  00,W
015FA:  MOVLB  0
015FC:  BTFSC  FD8.2
015FE:  BRA    1A58
01600:  MOVLB  7
01602:  MOVF   03,W
01604:  BNZ   1612
01606:  MOVLW  0D
01608:  SUBWF  00,W
0160A:  MOVLB  0
0160C:  BTFSC  FD8.2
0160E:  BRA    1A66
01610:  MOVLB  7
01612:  MOVF   03,W
01614:  BNZ   1622
01616:  MOVLW  0E
01618:  SUBWF  00,W
0161A:  MOVLB  0
0161C:  BTFSC  FD8.2
0161E:  BRA    1A74
01620:  MOVLB  7
01622:  MOVF   03,W
01624:  BNZ   1632
01626:  MOVLW  0F
01628:  SUBWF  00,W
0162A:  MOVLB  0
0162C:  BTFSC  FD8.2
0162E:  BRA    1A82
01630:  MOVLB  7
01632:  MOVF   03,W
01634:  BNZ   1642
01636:  MOVLW  10
01638:  SUBWF  00,W
0163A:  MOVLB  0
0163C:  BTFSC  FD8.2
0163E:  BRA    1A90
01640:  MOVLB  7
01642:  MOVF   03,W
01644:  BNZ   1652
01646:  MOVLW  11
01648:  SUBWF  00,W
0164A:  MOVLB  0
0164C:  BTFSC  FD8.2
0164E:  BRA    1AB8
01650:  MOVLB  7
01652:  MOVF   03,W
01654:  BNZ   1662
01656:  MOVLW  12
01658:  SUBWF  00,W
0165A:  MOVLB  0
0165C:  BTFSC  FD8.2
0165E:  BRA    1AC6
01660:  MOVLB  7
01662:  MOVF   03,W
01664:  BNZ   1672
01666:  MOVLW  13
01668:  SUBWF  00,W
0166A:  MOVLB  0
0166C:  BTFSC  FD8.2
0166E:  BRA    1AF4
01670:  MOVLB  7
01672:  MOVF   03,W
01674:  BNZ   1682
01676:  MOVLW  14
01678:  SUBWF  00,W
0167A:  MOVLB  0
0167C:  BTFSC  FD8.2
0167E:  BRA    1B0C
01680:  MOVLB  7
01682:  MOVF   03,W
01684:  BNZ   1692
01686:  MOVLW  15
01688:  SUBWF  00,W
0168A:  MOVLB  0
0168C:  BTFSC  FD8.2
0168E:  BRA    1B1A
01690:  MOVLB  7
01692:  MOVF   03,W
01694:  BNZ   16A2
01696:  MOVLW  16
01698:  SUBWF  00,W
0169A:  MOVLB  0
0169C:  BTFSC  FD8.2
0169E:  BRA    1B48
016A0:  MOVLB  7
016A2:  MOVF   03,W
016A4:  BNZ   16B2
016A6:  MOVLW  17
016A8:  SUBWF  00,W
016AA:  MOVLB  0
016AC:  BTFSC  FD8.2
016AE:  BRA    1B62
016B0:  MOVLB  7
016B2:  MOVF   03,W
016B4:  BNZ   16C2
016B6:  MOVLW  18
016B8:  SUBWF  00,W
016BA:  MOVLB  0
016BC:  BTFSC  FD8.2
016BE:  BRA    1B70
016C0:  MOVLB  7
016C2:  MOVF   03,W
016C4:  BNZ   16D2
016C6:  MOVLW  19
016C8:  SUBWF  00,W
016CA:  MOVLB  0
016CC:  BTFSC  FD8.2
016CE:  BRA    1B9E
016D0:  MOVLB  7
016D2:  MOVF   03,W
016D4:  BNZ   16E2
016D6:  MOVLW  1A
016D8:  SUBWF  00,W
016DA:  MOVLB  0
016DC:  BTFSC  FD8.2
016DE:  BRA    1BB8
016E0:  MOVLB  7
016E2:  MOVF   03,W
016E4:  BNZ   16F2
016E6:  MOVLW  1B
016E8:  SUBWF  00,W
016EA:  MOVLB  0
016EC:  BTFSC  FD8.2
016EE:  BRA    1BC6
016F0:  MOVLB  7
016F2:  MOVF   03,W
016F4:  BNZ   1702
016F6:  MOVLW  1C
016F8:  SUBWF  00,W
016FA:  MOVLB  0
016FC:  BTFSC  FD8.2
016FE:  BRA    1BF4
01700:  MOVLB  7
01702:  MOVF   03,W
01704:  BNZ   1712
01706:  MOVLW  1D
01708:  SUBWF  00,W
0170A:  MOVLB  0
0170C:  BTFSC  FD8.2
0170E:  BRA    1C0E
01710:  MOVLB  7
01712:  MOVF   03,W
01714:  BNZ   1722
01716:  MOVLW  1E
01718:  SUBWF  00,W
0171A:  MOVLB  0
0171C:  BTFSC  FD8.2
0171E:  BRA    1C1C
01720:  MOVLB  7
01722:  MOVF   03,W
01724:  BNZ   1732
01726:  MOVLW  1F
01728:  SUBWF  00,W
0172A:  MOVLB  0
0172C:  BTFSC  FD8.2
0172E:  BRA    1C4A
01730:  MOVLB  7
01732:  MOVF   03,W
01734:  BNZ   1742
01736:  MOVLW  20
01738:  SUBWF  00,W
0173A:  MOVLB  0
0173C:  BTFSC  FD8.2
0173E:  BRA    1C64
01740:  MOVLB  7
01742:  MOVF   03,W
01744:  BNZ   1752
01746:  MOVLW  21
01748:  SUBWF  00,W
0174A:  MOVLB  0
0174C:  BTFSC  FD8.2
0174E:  BRA    1C72
01750:  MOVLB  7
01752:  MOVF   03,W
01754:  BNZ   1762
01756:  MOVLW  22
01758:  SUBWF  00,W
0175A:  MOVLB  0
0175C:  BTFSC  FD8.2
0175E:  BRA    1CA0
01760:  MOVLB  7
01762:  MOVF   03,W
01764:  BNZ   1772
01766:  MOVLW  23
01768:  SUBWF  00,W
0176A:  MOVLB  0
0176C:  BTFSC  FD8.2
0176E:  BRA    1CBA
01770:  MOVLB  7
01772:  MOVF   03,W
01774:  BNZ   1782
01776:  MOVLW  24
01778:  SUBWF  00,W
0177A:  MOVLB  0
0177C:  BTFSC  FD8.2
0177E:  BRA    1CC8
01780:  MOVLB  7
01782:  MOVF   03,W
01784:  BNZ   1792
01786:  MOVLW  25
01788:  SUBWF  00,W
0178A:  MOVLB  0
0178C:  BTFSC  FD8.2
0178E:  BRA    1CF6
01790:  MOVLB  7
01792:  MOVF   03,W
01794:  BNZ   17A2
01796:  MOVLW  26
01798:  SUBWF  00,W
0179A:  MOVLB  0
0179C:  BTFSC  FD8.2
0179E:  BRA    1D10
017A0:  MOVLB  7
017A2:  MOVF   03,W
017A4:  BNZ   17B2
017A6:  MOVLW  27
017A8:  SUBWF  00,W
017AA:  MOVLB  0
017AC:  BTFSC  FD8.2
017AE:  BRA    1D1E
017B0:  MOVLB  7
017B2:  MOVF   03,W
017B4:  BNZ   17C2
017B6:  MOVLW  28
017B8:  SUBWF  00,W
017BA:  MOVLB  0
017BC:  BTFSC  FD8.2
017BE:  BRA    1D4C
017C0:  MOVLB  7
017C2:  MOVF   03,W
017C4:  BNZ   17D2
017C6:  MOVLW  29
017C8:  SUBWF  00,W
017CA:  MOVLB  0
017CC:  BTFSC  FD8.2
017CE:  BRA    1D66
017D0:  MOVLB  7
017D2:  MOVF   03,W
017D4:  BNZ   17E2
017D6:  MOVLW  2A
017D8:  SUBWF  00,W
017DA:  MOVLB  0
017DC:  BTFSC  FD8.2
017DE:  BRA    1D74
017E0:  MOVLB  7
017E2:  MOVF   03,W
017E4:  BNZ   17F2
017E6:  MOVLW  2B
017E8:  SUBWF  00,W
017EA:  MOVLB  0
017EC:  BTFSC  FD8.2
017EE:  BRA    1D8E
017F0:  MOVLB  7
017F2:  MOVF   03,W
017F4:  BNZ   1802
017F6:  MOVLW  2C
017F8:  SUBWF  00,W
017FA:  MOVLB  0
017FC:  BTFSC  FD8.2
017FE:  BRA    1D9E
01800:  MOVLB  7
01802:  MOVF   03,W
01804:  BNZ   1812
01806:  MOVLW  2D
01808:  SUBWF  00,W
0180A:  MOVLB  0
0180C:  BTFSC  FD8.2
0180E:  BRA    1DAE
01810:  MOVLB  7
01812:  MOVF   03,W
01814:  BNZ   1822
01816:  MOVLW  2E
01818:  SUBWF  00,W
0181A:  MOVLB  0
0181C:  BTFSC  FD8.2
0181E:  BRA    1DBE
01820:  MOVLB  7
01822:  MOVF   03,W
01824:  BNZ   1832
01826:  MOVLW  2F
01828:  SUBWF  00,W
0182A:  MOVLB  0
0182C:  BTFSC  FD8.2
0182E:  BRA    1DCE
01830:  MOVLB  7
01832:  MOVF   03,W
01834:  BNZ   1842
01836:  MOVLW  30
01838:  SUBWF  00,W
0183A:  MOVLB  0
0183C:  BTFSC  FD8.2
0183E:  BRA    1DDE
01840:  MOVLB  7
01842:  MOVF   03,W
01844:  BNZ   1852
01846:  MOVLW  31
01848:  SUBWF  00,W
0184A:  MOVLB  0
0184C:  BTFSC  FD8.2
0184E:  BRA    1DEE
01850:  MOVLB  7
01852:  MOVF   03,W
01854:  BNZ   1862
01856:  MOVLW  32
01858:  SUBWF  00,W
0185A:  MOVLB  0
0185C:  BTFSC  FD8.2
0185E:  BRA    1DFE
01860:  MOVLB  7
01862:  MOVF   03,W
01864:  BNZ   1872
01866:  MOVLW  33
01868:  SUBWF  00,W
0186A:  MOVLB  0
0186C:  BTFSC  FD8.2
0186E:  BRA    1E0E
01870:  MOVLB  7
01872:  MOVF   03,W
01874:  BNZ   1882
01876:  MOVLW  34
01878:  SUBWF  00,W
0187A:  MOVLB  0
0187C:  BTFSC  FD8.2
0187E:  BRA    1E1E
01880:  MOVLB  7
01882:  MOVF   03,W
01884:  BNZ   1892
01886:  MOVLW  35
01888:  SUBWF  00,W
0188A:  MOVLB  0
0188C:  BTFSC  FD8.2
0188E:  BRA    1E2E
01890:  MOVLB  7
01892:  MOVLW  03
01894:  SUBWF  03,W
01896:  BNZ   18A4
01898:  MOVLW  E8
0189A:  SUBWF  00,W
0189C:  MOVLB  0
0189E:  BTFSC  FD8.2
018A0:  BRA    1E3E
018A2:  MOVLB  7
018A4:  MOVLW  03
018A6:  SUBWF  03,W
018A8:  BNZ   18B6
018AA:  MOVLW  E9
018AC:  SUBWF  00,W
018AE:  MOVLB  0
018B0:  BTFSC  FD8.2
018B2:  BRA    1E4E
018B4:  MOVLB  7
018B6:  MOVLW  03
018B8:  SUBWF  03,W
018BA:  BNZ   18C8
018BC:  MOVLW  EA
018BE:  SUBWF  00,W
018C0:  MOVLB  0
018C2:  BTFSC  FD8.2
018C4:  BRA    1E5C
018C6:  MOVLB  7
018C8:  MOVLW  03
018CA:  SUBWF  03,W
018CC:  BNZ   18DA
018CE:  MOVLW  EB
018D0:  SUBWF  00,W
018D2:  MOVLB  0
018D4:  BTFSC  FD8.2
018D6:  BRA    1E6A
018D8:  MOVLB  7
018DA:  MOVLW  03
018DC:  SUBWF  03,W
018DE:  BNZ   18EC
018E0:  MOVLW  EC
018E2:  SUBWF  00,W
018E4:  MOVLB  0
018E6:  BTFSC  FD8.2
018E8:  BRA    1E78
018EA:  MOVLB  7
018EC:  MOVLW  03
018EE:  SUBWF  03,W
018F0:  BNZ   18FE
018F2:  MOVLW  ED
018F4:  SUBWF  00,W
018F6:  MOVLB  0
018F8:  BTFSC  FD8.2
018FA:  BRA    1E86
018FC:  MOVLB  7
018FE:  MOVLW  03
01900:  SUBWF  03,W
01902:  BNZ   1910
01904:  MOVLW  EE
01906:  SUBWF  00,W
01908:  MOVLB  0
0190A:  BTFSC  FD8.2
0190C:  BRA    1E94
0190E:  MOVLB  7
01910:  MOVLW  03
01912:  SUBWF  03,W
01914:  BNZ   1922
01916:  MOVLW  EF
01918:  SUBWF  00,W
0191A:  MOVLB  0
0191C:  BTFSC  FD8.2
0191E:  BRA    1EA4
01920:  MOVLB  7
01922:  MOVLW  03
01924:  SUBWF  03,W
01926:  BNZ   1934
01928:  MOVLW  F0
0192A:  SUBWF  00,W
0192C:  MOVLB  0
0192E:  BTFSC  FD8.2
01930:  BRA    1EB2
01932:  MOVLB  7
01934:  MOVLW  03
01936:  SUBWF  03,W
01938:  BNZ   1946
0193A:  MOVLW  F1
0193C:  SUBWF  00,W
0193E:  MOVLB  0
01940:  BTFSC  FD8.2
01942:  BRA    1EC2
01944:  MOVLB  7
01946:  MOVLW  03
01948:  SUBWF  03,W
0194A:  BNZ   1958
0194C:  MOVLW  F2
0194E:  SUBWF  00,W
01950:  MOVLB  0
01952:  BTFSC  FD8.2
01954:  BRA    1ED0
01956:  MOVLB  7
01958:  MOVLW  03
0195A:  SUBWF  03,W
0195C:  BNZ   196A
0195E:  MOVLW  F3
01960:  SUBWF  00,W
01962:  MOVLB  0
01964:  BTFSC  FD8.2
01966:  BRA    1EDE
01968:  MOVLB  7
0196A:  MOVLW  03
0196C:  SUBWF  03,W
0196E:  BNZ   197C
01970:  MOVLW  F4
01972:  SUBWF  00,W
01974:  MOVLB  0
01976:  BTFSC  FD8.2
01978:  BRA    1EEE
0197A:  MOVLB  7
0197C:  BRA    1EFC
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
0197E:  MOVFF  A8,01
01982:  MOVFF  A9,02
01986:  MOVLB  7
01988:  BRA    1F04
0198A:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
0198C:  MOVF   x96,W
0198E:  MOVWF  01
01990:  MOVF   x97,W
01992:  MOVWF  02
01994:  MOVLB  7
01996:  BRA    1F04
01998:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
0199A:  MOVF   x9C,W
0199C:  MOVWF  01
0199E:  MOVF   x9D,W
019A0:  MOVWF  02
019A2:  MOVLB  7
019A4:  BRA    1F04
019A6:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
019A8:  MOVF   xA2,W
019AA:  MOVWF  01
019AC:  MOVF   xA3,W
019AE:  MOVWF  02
019B0:  MOVLB  7
019B2:  BRA    1F04
019B4:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
019B6:  MOVLB  7
019B8:  CLRF   xED
019BA:  MOVLB  0
019BC:  RCALL  12BE
019BE:  MOVFF  03,7C9
019C2:  MOVFF  02,7C8
019C6:  MOVFF  01,7C7
019CA:  MOVFF  00,7C6
019CE:  MOVLB  7
019D0:  MOVF   xC6,W
019D2:  MOVWF  01
019D4:  MOVF   xC7,W
019D6:  MOVWF  02
019D8:  BRA    1F04
019DA:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
019DC:  MOVLB  7
019DE:  MOVF   xC8,W
019E0:  MOVWF  01
019E2:  MOVF   xC9,W
019E4:  MOVWF  02
019E6:  BRA    1F04
019E8:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
019EA:  MOVF   xAA,W
019EC:  MOVWF  01
019EE:  MOVF   xAB,W
019F0:  MOVWF  02
019F2:  MOVLB  7
019F4:  BRA    1F04
019F6:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
019F8:  MOVF   x98,W
019FA:  MOVWF  01
019FC:  MOVF   x99,W
019FE:  MOVWF  02
01A00:  MOVLB  7
01A02:  BRA    1F04
01A04:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01A06:  MOVF   x9E,W
01A08:  MOVWF  01
01A0A:  MOVF   x9F,W
01A0C:  MOVWF  02
01A0E:  MOVLB  7
01A10:  BRA    1F04
01A12:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01A14:  MOVF   xA4,W
01A16:  MOVWF  01
01A18:  MOVF   xA5,W
01A1A:  MOVWF  02
01A1C:  MOVLB  7
01A1E:  BRA    1F04
01A20:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01A22:  MOVLW  01
01A24:  MOVLB  7
01A26:  MOVWF  xED
01A28:  MOVLB  0
01A2A:  RCALL  12BE
01A2C:  MOVFF  03,7C9
01A30:  MOVFF  02,7C8
01A34:  MOVFF  01,7C7
01A38:  MOVFF  00,7C6
01A3C:  MOVLB  7
01A3E:  MOVF   xC6,W
01A40:  MOVWF  01
01A42:  MOVF   xC7,W
01A44:  MOVWF  02
01A46:  BRA    1F04
01A48:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01A4A:  MOVLB  7
01A4C:  MOVF   xC8,W
01A4E:  MOVWF  01
01A50:  MOVF   xC9,W
01A52:  MOVWF  02
01A54:  BRA    1F04
01A56:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01A58:  MOVF   xAC,W
01A5A:  MOVWF  01
01A5C:  MOVF   xAD,W
01A5E:  MOVWF  02
01A60:  MOVLB  7
01A62:  BRA    1F04
01A64:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01A66:  MOVF   x9A,W
01A68:  MOVWF  01
01A6A:  MOVF   x9B,W
01A6C:  MOVWF  02
01A6E:  MOVLB  7
01A70:  BRA    1F04
01A72:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01A74:  MOVF   xA0,W
01A76:  MOVWF  01
01A78:  MOVF   xA1,W
01A7A:  MOVWF  02
01A7C:  MOVLB  7
01A7E:  BRA    1F04
01A80:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01A82:  MOVF   xA6,W
01A84:  MOVWF  01
01A86:  MOVF   xA7,W
01A88:  MOVWF  02
01A8A:  MOVLB  7
01A8C:  BRA    1F04
01A8E:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01A90:  MOVLW  02
01A92:  MOVLB  7
01A94:  MOVWF  xED
01A96:  MOVLB  0
01A98:  RCALL  12BE
01A9A:  MOVFF  03,7C9
01A9E:  MOVFF  02,7C8
01AA2:  MOVFF  01,7C7
01AA6:  MOVFF  00,7C6
01AAA:  MOVLB  7
01AAC:  MOVF   xC6,W
01AAE:  MOVWF  01
01AB0:  MOVF   xC7,W
01AB2:  MOVWF  02
01AB4:  BRA    1F04
01AB6:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01AB8:  MOVLB  7
01ABA:  MOVF   xC8,W
01ABC:  MOVWF  01
01ABE:  MOVF   xC9,W
01AC0:  MOVWF  02
01AC2:  BRA    1F04
01AC4:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01AC6:  CLRF   03
01AC8:  MOVLB  1
01ACA:  MOVF   xCA,W
01ACC:  MOVWF  02
01ACE:  BCF    FD8.0
01AD0:  RLCF   02,F
01AD2:  RLCF   03,F
01AD4:  MOVF   02,W
01AD6:  ADDLW  CA
01AD8:  MOVWF  FE9
01ADA:  MOVLW  00
01ADC:  ADDWFC 03,W
01ADE:  MOVWF  FEA
01AE0:  MOVFF  FEC,03
01AE4:  MOVF   FED,F
01AE6:  MOVF   FEF,W
01AE8:  MOVWF  01
01AEA:  MOVF   03,W
01AEC:  MOVWF  02
01AEE:  MOVLB  7
01AF0:  BRA    1F04
01AF2:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01AF4:  MOVLB  7
01AF6:  CLRF   xED
01AF8:  MOVLB  0
01AFA:  CALL   0EC4
01AFE:  MOVF   01,W
01B00:  MOVWF  01
01B02:  MOVF   02,W
01B04:  MOVWF  02
01B06:  MOVLB  7
01B08:  BRA    1F04
01B0A:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01B0C:  MOVF   xBA,W
01B0E:  MOVWF  01
01B10:  MOVF   xBB,W
01B12:  MOVWF  02
01B14:  MOVLB  7
01B16:  BRA    1F04
01B18:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01B1A:  CLRF   03
01B1C:  MOVLB  1
01B1E:  MOVF   xCA,W
01B20:  MOVWF  02
01B22:  BCF    FD8.0
01B24:  RLCF   02,F
01B26:  RLCF   03,F
01B28:  MOVF   02,W
01B2A:  ADDLW  EA
01B2C:  MOVWF  FE9
01B2E:  MOVLW  00
01B30:  ADDWFC 03,W
01B32:  MOVWF  FEA
01B34:  MOVFF  FEC,03
01B38:  MOVF   FED,F
01B3A:  MOVF   FEF,W
01B3C:  MOVWF  01
01B3E:  MOVF   03,W
01B40:  MOVWF  02
01B42:  MOVLB  7
01B44:  BRA    1F04
01B46:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01B48:  MOVLW  01
01B4A:  MOVLB  7
01B4C:  MOVWF  xED
01B4E:  MOVLB  0
01B50:  CALL   0EC4
01B54:  MOVF   01,W
01B56:  MOVWF  01
01B58:  MOVF   02,W
01B5A:  MOVWF  02
01B5C:  MOVLB  7
01B5E:  BRA    1F04
01B60:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01B62:  MOVF   xBC,W
01B64:  MOVWF  01
01B66:  MOVF   xBD,W
01B68:  MOVWF  02
01B6A:  MOVLB  7
01B6C:  BRA    1F04
01B6E:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01B70:  CLRF   03
01B72:  MOVLB  1
01B74:  MOVF   xCA,W
01B76:  MOVWF  02
01B78:  BCF    FD8.0
01B7A:  RLCF   02,F
01B7C:  RLCF   03,F
01B7E:  MOVF   02,W
01B80:  ADDLW  0A
01B82:  MOVWF  FE9
01B84:  MOVLW  01
01B86:  ADDWFC 03,W
01B88:  MOVWF  FEA
01B8A:  MOVFF  FEC,03
01B8E:  MOVF   FED,F
01B90:  MOVF   FEF,W
01B92:  MOVWF  01
01B94:  MOVF   03,W
01B96:  MOVWF  02
01B98:  MOVLB  7
01B9A:  BRA    1F04
01B9C:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01B9E:  MOVLW  02
01BA0:  MOVLB  7
01BA2:  MOVWF  xED
01BA4:  MOVLB  0
01BA6:  CALL   0EC4
01BAA:  MOVF   01,W
01BAC:  MOVWF  01
01BAE:  MOVF   02,W
01BB0:  MOVWF  02
01BB2:  MOVLB  7
01BB4:  BRA    1F04
01BB6:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01BB8:  MOVF   xBE,W
01BBA:  MOVWF  01
01BBC:  MOVF   xBF,W
01BBE:  MOVWF  02
01BC0:  MOVLB  7
01BC2:  BRA    1F04
01BC4:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01BC6:  CLRF   03
01BC8:  MOVLB  1
01BCA:  MOVF   xCA,W
01BCC:  MOVWF  02
01BCE:  BCF    FD8.0
01BD0:  RLCF   02,F
01BD2:  RLCF   03,F
01BD4:  MOVF   02,W
01BD6:  ADDLW  2A
01BD8:  MOVWF  FE9
01BDA:  MOVLW  01
01BDC:  ADDWFC 03,W
01BDE:  MOVWF  FEA
01BE0:  MOVFF  FEC,03
01BE4:  MOVF   FED,F
01BE6:  MOVF   FEF,W
01BE8:  MOVWF  01
01BEA:  MOVF   03,W
01BEC:  MOVWF  02
01BEE:  MOVLB  7
01BF0:  BRA    1F04
01BF2:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01BF4:  MOVLW  03
01BF6:  MOVLB  7
01BF8:  MOVWF  xED
01BFA:  MOVLB  0
01BFC:  CALL   0EC4
01C00:  MOVF   01,W
01C02:  MOVWF  01
01C04:  MOVF   02,W
01C06:  MOVWF  02
01C08:  MOVLB  7
01C0A:  BRA    1F04
01C0C:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01C0E:  MOVF   xC0,W
01C10:  MOVWF  01
01C12:  MOVF   xC1,W
01C14:  MOVWF  02
01C16:  MOVLB  7
01C18:  BRA    1F04
01C1A:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01C1C:  CLRF   03
01C1E:  MOVLB  1
01C20:  MOVF   xCA,W
01C22:  MOVWF  02
01C24:  BCF    FD8.0
01C26:  RLCF   02,F
01C28:  RLCF   03,F
01C2A:  MOVF   02,W
01C2C:  ADDLW  4A
01C2E:  MOVWF  FE9
01C30:  MOVLW  01
01C32:  ADDWFC 03,W
01C34:  MOVWF  FEA
01C36:  MOVFF  FEC,03
01C3A:  MOVF   FED,F
01C3C:  MOVF   FEF,W
01C3E:  MOVWF  01
01C40:  MOVF   03,W
01C42:  MOVWF  02
01C44:  MOVLB  7
01C46:  BRA    1F04
01C48:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01C4A:  MOVLW  04
01C4C:  MOVLB  7
01C4E:  MOVWF  xED
01C50:  MOVLB  0
01C52:  CALL   0EC4
01C56:  MOVF   01,W
01C58:  MOVWF  01
01C5A:  MOVF   02,W
01C5C:  MOVWF  02
01C5E:  MOVLB  7
01C60:  BRA    1F04
01C62:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01C64:  MOVF   xC2,W
01C66:  MOVWF  01
01C68:  MOVF   xC3,W
01C6A:  MOVWF  02
01C6C:  MOVLB  7
01C6E:  BRA    1F04
01C70:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01C72:  CLRF   03
01C74:  MOVLB  1
01C76:  MOVF   xCA,W
01C78:  MOVWF  02
01C7A:  BCF    FD8.0
01C7C:  RLCF   02,F
01C7E:  RLCF   03,F
01C80:  MOVF   02,W
01C82:  ADDLW  6A
01C84:  MOVWF  FE9
01C86:  MOVLW  01
01C88:  ADDWFC 03,W
01C8A:  MOVWF  FEA
01C8C:  MOVFF  FEC,03
01C90:  MOVF   FED,F
01C92:  MOVF   FEF,W
01C94:  MOVWF  01
01C96:  MOVF   03,W
01C98:  MOVWF  02
01C9A:  MOVLB  7
01C9C:  BRA    1F04
01C9E:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01CA0:  MOVLW  05
01CA2:  MOVLB  7
01CA4:  MOVWF  xED
01CA6:  MOVLB  0
01CA8:  CALL   0EC4
01CAC:  MOVF   01,W
01CAE:  MOVWF  01
01CB0:  MOVF   02,W
01CB2:  MOVWF  02
01CB4:  MOVLB  7
01CB6:  BRA    1F04
01CB8:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01CBA:  MOVF   xC4,W
01CBC:  MOVWF  01
01CBE:  MOVF   xC5,W
01CC0:  MOVWF  02
01CC2:  MOVLB  7
01CC4:  BRA    1F04
01CC6:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01CC8:  CLRF   03
01CCA:  MOVLB  1
01CCC:  MOVF   xCA,W
01CCE:  MOVWF  02
01CD0:  BCF    FD8.0
01CD2:  RLCF   02,F
01CD4:  RLCF   03,F
01CD6:  MOVF   02,W
01CD8:  ADDLW  8A
01CDA:  MOVWF  FE9
01CDC:  MOVLW  01
01CDE:  ADDWFC 03,W
01CE0:  MOVWF  FEA
01CE2:  MOVFF  FEC,03
01CE6:  MOVF   FED,F
01CE8:  MOVF   FEF,W
01CEA:  MOVWF  01
01CEC:  MOVF   03,W
01CEE:  MOVWF  02
01CF0:  MOVLB  7
01CF2:  BRA    1F04
01CF4:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01CF6:  MOVLW  06
01CF8:  MOVLB  7
01CFA:  MOVWF  xED
01CFC:  MOVLB  0
01CFE:  CALL   0EC4
01D02:  MOVF   01,W
01D04:  MOVWF  01
01D06:  MOVF   02,W
01D08:  MOVWF  02
01D0A:  MOVLB  7
01D0C:  BRA    1F04
01D0E:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01D10:  MOVF   xC6,W
01D12:  MOVWF  01
01D14:  MOVF   xC7,W
01D16:  MOVWF  02
01D18:  MOVLB  7
01D1A:  BRA    1F04
01D1C:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01D1E:  CLRF   03
01D20:  MOVLB  1
01D22:  MOVF   xCA,W
01D24:  MOVWF  02
01D26:  BCF    FD8.0
01D28:  RLCF   02,F
01D2A:  RLCF   03,F
01D2C:  MOVF   02,W
01D2E:  ADDLW  AA
01D30:  MOVWF  FE9
01D32:  MOVLW  01
01D34:  ADDWFC 03,W
01D36:  MOVWF  FEA
01D38:  MOVFF  FEC,03
01D3C:  MOVF   FED,F
01D3E:  MOVF   FEF,W
01D40:  MOVWF  01
01D42:  MOVF   03,W
01D44:  MOVWF  02
01D46:  MOVLB  7
01D48:  BRA    1F04
01D4A:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01D4C:  MOVLW  07
01D4E:  MOVLB  7
01D50:  MOVWF  xED
01D52:  MOVLB  0
01D54:  CALL   0EC4
01D58:  MOVF   01,W
01D5A:  MOVWF  01
01D5C:  MOVF   02,W
01D5E:  MOVWF  02
01D60:  MOVLB  7
01D62:  BRA    1F04
01D64:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01D66:  MOVF   xC8,W
01D68:  MOVWF  01
01D6A:  MOVF   xC9,W
01D6C:  MOVWF  02
01D6E:  MOVLB  7
01D70:  BRA    1F04
01D72:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01D74:  MOVLB  1
01D76:  MOVF   xD2,W
01D78:  MOVWF  03
01D7A:  MOVF   xD1,W
01D7C:  INCF   xD1,F
01D7E:  BTFSC  FD8.2
01D80:  INCF   xD2,F
01D82:  MOVWF  01
01D84:  MOVF   03,W
01D86:  MOVWF  02
01D88:  MOVLB  7
01D8A:  BRA    1F04
01D8C:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01D8E:  MOVLB  1
01D90:  MOVF   xD5,W
01D92:  MOVWF  01
01D94:  MOVF   xD6,W
01D96:  MOVWF  02
01D98:  MOVLB  7
01D9A:  BRA    1F04
01D9C:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01D9E:  MOVLB  1
01DA0:  MOVF   xD3,W
01DA2:  MOVWF  01
01DA4:  MOVF   xD4,W
01DA6:  MOVWF  02
01DA8:  MOVLB  7
01DAA:  BRA    1F04
01DAC:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01DAE:  MOVLB  1
01DB0:  MOVF   xD8,W
01DB2:  MOVWF  01
01DB4:  MOVF   xD9,W
01DB6:  MOVWF  02
01DB8:  MOVLB  7
01DBA:  BRA    1F04
01DBC:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01DBE:  GOTO   1320
01DC2:  MOVLW  00
01DC4:  MOVWF  01
01DC6:  MOVWF  02
01DC8:  MOVLB  7
01DCA:  BRA    1F04
01DCC:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01DCE:  GOTO   135C
01DD2:  MOVLW  00
01DD4:  MOVWF  01
01DD6:  MOVWF  02
01DD8:  MOVLB  7
01DDA:  BRA    1F04
01DDC:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01DDE:  MOVLB  1
01DE0:  MOVF   xCB,W
01DE2:  MOVWF  01
01DE4:  MOVF   xCC,W
01DE6:  MOVWF  02
01DE8:  MOVLB  7
01DEA:  BRA    1F04
01DEC:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01DEE:  MOVLB  1
01DF0:  MOVF   xCD,W
01DF2:  MOVWF  01
01DF4:  MOVF   xCE,W
01DF6:  MOVWF  02
01DF8:  MOVLB  7
01DFA:  BRA    1F04
01DFC:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01DFE:  MOVLB  1
01E00:  MOVF   xCF,W
01E02:  MOVWF  01
01E04:  MOVF   xD0,W
01E06:  MOVWF  02
01E08:  MOVLB  7
01E0A:  BRA    1F04
01E0C:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01E0E:  GOTO   1384
01E12:  MOVLW  00
01E14:  MOVWF  01
01E16:  MOVWF  02
01E18:  MOVLB  7
01E1A:  BRA    1F04
01E1C:  MOVLB  0
.................... 		case 52: return (int16) current.rda_bytes_received; 
01E1E:  MOVLB  1
01E20:  MOVF   xE1,W
01E22:  MOVWF  01
01E24:  MOVF   xE2,W
01E26:  MOVWF  02
01E28:  MOVLB  7
01E2A:  BRA    1F04
01E2C:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
01E2E:  MOVLB  1
01E30:  MOVF   xE3,W
01E32:  MOVWF  01
01E34:  MOVF   xE4,W
01E36:  MOVWF  02
01E38:  MOVLB  7
01E3A:  BRA    1F04
01E3C:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01E3E:  CLRF   03
01E40:  MOVF   39,W
01E42:  MOVWF  01
01E44:  MOVF   03,W
01E46:  MOVWF  02
01E48:  MOVLB  7
01E4A:  BRA    1F04
01E4C:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01E4E:  MOVF   3A,W
01E50:  MOVWF  01
01E52:  MOVF   3B,W
01E54:  MOVWF  02
01E56:  MOVLB  7
01E58:  BRA    1F04
01E5A:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01E5C:  MOVLW  50
01E5E:  MOVWF  01
01E60:  MOVLW  00
01E62:  MOVWF  02
01E64:  MOVLB  7
01E66:  BRA    1F04
01E68:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01E6A:  MOVLW  57
01E6C:  MOVWF  01
01E6E:  MOVLW  00
01E70:  MOVWF  02
01E72:  MOVLB  7
01E74:  BRA    1F04
01E76:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01E78:  MOVLW  58
01E7A:  MOVWF  01
01E7C:  MOVLW  00
01E7E:  MOVWF  02
01E80:  MOVLB  7
01E82:  BRA    1F04
01E84:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01E86:  MOVLW  01
01E88:  MOVWF  01
01E8A:  MOVLW  00
01E8C:  MOVWF  02
01E8E:  MOVLB  7
01E90:  BRA    1F04
01E92:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01E94:  CLRF   03
01E96:  MOVF   36,W
01E98:  MOVWF  01
01E9A:  MOVF   03,W
01E9C:  MOVWF  02
01E9E:  MOVLB  7
01EA0:  BRA    1F04
01EA2:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01EA4:  MOVF   3C,W
01EA6:  MOVWF  01
01EA8:  MOVF   3D,W
01EAA:  MOVWF  02
01EAC:  MOVLB  7
01EAE:  BRA    1F04
01EB0:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01EB2:  CLRF   03
01EB4:  MOVF   3E,W
01EB6:  MOVWF  01
01EB8:  MOVF   03,W
01EBA:  MOVWF  02
01EBC:  MOVLB  7
01EBE:  BRA    1F04
01EC0:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01EC2:  MOVF   3F,W
01EC4:  MOVWF  01
01EC6:  MOVF   40,W
01EC8:  MOVWF  02
01ECA:  MOVLB  7
01ECC:  BRA    1F04
01ECE:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01ED0:  MOVF   41,W
01ED2:  MOVWF  01
01ED4:  MOVF   42,W
01ED6:  MOVWF  02
01ED8:  MOVLB  7
01EDA:  BRA    1F04
01EDC:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01EDE:  CLRF   03
01EE0:  MOVF   43,W
01EE2:  MOVWF  01
01EE4:  MOVF   03,W
01EE6:  MOVWF  02
01EE8:  MOVLB  7
01EEA:  BRA    1F04
01EEC:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01EEE:  CLRF   03
01EF0:  MOVF   38,W
01EF2:  MOVWF  01
01EF4:  MOVF   03,W
01EF6:  MOVWF  02
01EF8:  MOVLB  7
01EFA:  BRA    1F04
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01EFC:  MOVLW  FF
01EFE:  MOVWF  01
01F00:  MOVWF  02
01F02:  BRA    1F04
.................... 	} 
....................  
.................... } 
01F04:  MOVLB  0
01F06:  GOTO   1F58 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01118:  MOVLB  7
0111A:  MOVF   xDD,W
0111C:  SUBLW  1F
0111E:  BNZ   1138
01120:  MOVF   xDE,W
01122:  SUBLW  4E
01124:  BNZ   1138
01126:  MOVF   xDF,W
01128:  SUBLW  20
0112A:  BNZ   1138
0112C:  MOVF   xE0,W
0112E:  SUBLW  4E
01130:  BNZ   1138
.................... 		return 1; 
01132:  MOVLW  01
01134:  MOVWF  01
01136:  BRA    1200
....................  
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
01138:  MOVF   xDE,W
0113A:  SUBLW  16
0113C:  BC    115C
0113E:  XORLW  FF
01140:  BNZ   1148
01142:  MOVF   xDD,W
01144:  SUBLW  6F
01146:  BC    115C
01148:  MOVF   xE0,W
0114A:  SUBLW  19
0114C:  BNC   115C
0114E:  BNZ   1156
01150:  MOVF   xDF,W
01152:  SUBLW  50
01154:  BNC   115C
.................... 		return 1; 
01156:  MOVLW  01
01158:  MOVWF  01
0115A:  BRA    1200
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
0115C:  MOVF   xDE,W
0115E:  SUBLW  12
01160:  BC    1180
01162:  XORLW  FF
01164:  BNZ   116C
01166:  MOVF   xDD,W
01168:  SUBLW  87
0116A:  BC    1180
0116C:  MOVF   xE0,W
0116E:  SUBLW  17
01170:  BNC   1180
01172:  BNZ   117A
01174:  MOVF   xDF,W
01176:  SUBLW  48
01178:  BNC   1180
.................... 		return 1; 
0117A:  MOVLW  01
0117C:  MOVWF  01
0117E:  BRA    1200
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01180:  MOVF   xDE,W
01182:  SUBLW  03
01184:  BC    11A4
01186:  XORLW  FF
01188:  BNZ   1190
0118A:  MOVF   xDD,W
0118C:  SUBLW  4B
0118E:  BC    11A4
01190:  MOVF   xE0,W
01192:  SUBLW  04
01194:  BNC   11A4
01196:  BNZ   119E
01198:  MOVF   xDF,W
0119A:  SUBLW  94
0119C:  BNC   11A4
.................... 		return 1; 
0119E:  MOVLW  01
011A0:  MOVWF  01
011A2:  BRA    1200
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
011A4:  MOVF   xDE,W
011A6:  SUBLW  02
011A8:  BC    11C8
011AA:  XORLW  FF
011AC:  BNZ   11B4
011AE:  MOVF   xDD,W
011B0:  SUBLW  E7
011B2:  BC    11C8
011B4:  MOVF   xE0,W
011B6:  SUBLW  03
011B8:  BNC   11C8
011BA:  BNZ   11C2
011BC:  MOVF   xDF,W
011BE:  SUBLW  F5
011C0:  BNC   11C8
.................... 		return 1; 
011C2:  MOVLW  01
011C4:  MOVWF  01
011C6:  BRA    1200
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
011C8:  MOVF   xDE,W
011CA:  SUBLW  06
011CC:  BC    11EC
011CE:  XORLW  FF
011D0:  BNZ   11D8
011D2:  MOVF   xDD,W
011D4:  SUBLW  CF
011D6:  BC    11EC
011D8:  MOVF   xE0,W
011DA:  SUBLW  09
011DC:  BNC   11EC
011DE:  BNZ   11E6
011E0:  MOVF   xDF,W
011E2:  SUBLW  D1
011E4:  BNC   11EC
.................... 		return 1; 
011E6:  MOVLW  01
011E8:  MOVWF  01
011EA:  BRA    1200
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
011EC:  MOVF   xE0,F
011EE:  BNZ   11FC
011F0:  MOVF   xDF,W
011F2:  SUBLW  36
011F4:  BNC   11FC
.................... 		return 1; 
011F6:  MOVLW  01
011F8:  MOVWF  01
011FA:  BRA    1200
....................  
.................... 	return 0; 
011FC:  MOVLW  00
011FE:  MOVWF  01
.................... } 
01200:  MOVLB  0
01202:  GOTO   2454 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01F0A:  MOVFF  7DC,7E5
01F0E:  MOVFF  7DB,7E6
01F12:  CALL   1242
.................... 	modbus_serial_putc(register_count*2); 
01F16:  BCF    FD8.0
01F18:  MOVLB  7
01F1A:  RLCF   xDF,W
01F1C:  MOVWF  xE5
01F1E:  RLCF   xE0,W
01F20:  MOVWF  xE6
01F22:  MOVFF  7E5,7E7
01F26:  MOVLB  0
01F28:  CALL   120E
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01F2C:  MOVLB  7
01F2E:  CLRF   xE2
01F30:  CLRF   xE1
01F32:  MOVF   xE2,W
01F34:  SUBWF  xE0,W
01F36:  BNC   1F82
01F38:  BNZ   1F40
01F3A:  MOVF   xDF,W
01F3C:  SUBWF  xE1,W
01F3E:  BC    1F82
.................... 		l=map_modbus(start_address+i); 
01F40:  MOVF   xE1,W
01F42:  ADDWF  xDD,W
01F44:  MOVWF  xE5
01F46:  MOVF   xE2,W
01F48:  ADDWFC xDE,W
01F4A:  MOVWF  xE6
01F4C:  MOVWF  xE8
01F4E:  MOVFF  7E5,7E7
01F52:  MOVLB  0
01F54:  GOTO   1398
01F58:  MOVFF  02,7E4
01F5C:  MOVFF  01,7E3
.................... 		modbus_serial_putc(make8(l,1)); 
01F60:  MOVFF  7E4,7E5
01F64:  MOVFF  7E4,7E7
01F68:  CALL   120E
....................   		modbus_serial_putc(make8(l,0)); 
01F6C:  MOVFF  7E3,7E5
01F70:  MOVFF  7E3,7E7
01F74:  CALL   120E
.................... 	} 
01F78:  MOVLB  7
01F7A:  INCF   xE1,F
01F7C:  BTFSC  FD8.2
01F7E:  INCF   xE2,F
01F80:  BRA    1F32
....................  
.................... 	modbus_serial_send_stop(); 
01F82:  MOVLB  0
01F84:  CALL   1270
.................... } 
01F88:  GOTO   2496 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01F8C:  MOVLB  7
01F8E:  MOVF   xE2,W
01F90:  SUBLW  06
01F92:  BC    200A
01F94:  XORLW  FF
01F96:  BNZ   1F9E
01F98:  MOVF   xE1,W
01F9A:  SUBLW  CF
01F9C:  BC    200A
01F9E:  MOVF   xE2,W
01FA0:  SUBLW  09
01FA2:  BNC   200A
01FA4:  BNZ   1FAC
01FA6:  MOVF   xE1,W
01FA8:  SUBLW  CF
01FAA:  BNC   200A
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01FAC:  MOVF   xE4,W
01FAE:  SUBLW  00
01FB0:  BC    1FC2
01FB2:  XORLW  FF
01FB4:  BNZ   1FBC
01FB6:  MOVF   xE3,W
01FB8:  SUBLW  00
01FBA:  BC    1FC2
01FBC:  MOVLW  03
01FBE:  MOVWF  01
01FC0:  BRA    228C
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01FC2:  MOVLW  D0
01FC4:  SUBWF  xE1,W
01FC6:  MOVWF  xE7
01FC8:  MOVLW  07
01FCA:  SUBWFB xE2,W
01FCC:  MOVWF  xE8
01FCE:  MOVLW  02
01FD0:  ADDWF  xE8,F
01FD2:  MOVFF  7E8,FAA
01FD6:  MOVFF  7E7,FA9
01FDA:  MOVFF  7E3,FA8
01FDE:  BCF    FA6.6
01FE0:  BCF    FA6.7
01FE2:  BSF    FA6.2
01FE4:  MOVF   FF2,W
01FE6:  MOVWF  00
01FE8:  BCF    FF2.6
01FEA:  BCF    FF2.7
01FEC:  MOVLB  F
01FEE:  MOVLW  55
01FF0:  MOVWF  FA7
01FF2:  MOVLW  AA
01FF4:  MOVWF  FA7
01FF6:  BSF    FA6.1
01FF8:  BTFSC  FA6.1
01FFA:  BRA    1FF8
01FFC:  BCF    FA6.2
01FFE:  MOVF   00,W
02000:  IORWF  FF2,F
.................... 		return 0; 
02002:  MOVLW  00
02004:  MOVWF  01
02006:  MOVLB  7
02008:  BRA    228C
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
0200A:  MOVF   xE2,W
0200C:  SUBLW  03
0200E:  BC    20A0
02010:  XORLW  FF
02012:  BNZ   201A
02014:  MOVF   xE1,W
02016:  SUBLW  4B
02018:  BC    20A0
0201A:  MOVF   xE2,W
0201C:  SUBLW  04
0201E:  BNC   20A0
02020:  BNZ   2028
02022:  MOVF   xE1,W
02024:  SUBLW  93
02026:  BNC   20A0
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02028:  MOVF   xE4,W
0202A:  SUBLW  00
0202C:  BC    203E
0202E:  XORLW  FF
02030:  BNZ   2038
02032:  MOVF   xE3,W
02034:  SUBLW  00
02036:  BC    203E
02038:  MOVLW  03
0203A:  MOVWF  01
0203C:  BRA    228C
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
0203E:  MOVLW  4C
02040:  SUBWF  xE1,W
02042:  MOVWF  xE5
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
02044:  MOVFF  7E5,7ED
02048:  MOVLW  06
0204A:  MOVWF  xEE
0204C:  MOVLB  0
0204E:  CALL   0A00
02052:  MOVFF  00,7E6
.................... 		n = n / 6; /* number of sentence */ 
02056:  MOVFF  7E5,7ED
0205A:  MOVLW  06
0205C:  MOVLB  7
0205E:  MOVWF  xEE
02060:  MOVLB  0
02062:  CALL   0A00
02066:  MOVFF  01,7E5
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
0206A:  MOVLB  7
0206C:  MOVF   xE5,W
0206E:  MULLW  06
02070:  MOVF   FF3,W
02072:  CLRF   03
02074:  ADDLW  18
02076:  MOVWF  xE7
02078:  MOVLW  00
0207A:  ADDWFC 03,W
0207C:  MOVWF  xE8
0207E:  CLRF   03
02080:  MOVF   xE6,W
02082:  ADDWF  xE7,W
02084:  MOVWF  01
02086:  MOVF   xE8,W
02088:  ADDWFC 03,F
0208A:  MOVF   01,W
0208C:  ADDLW  36
0208E:  MOVWF  FE9
02090:  MOVLW  00
02092:  ADDWFC 03,W
02094:  MOVWF  FEA
02096:  MOVFF  7E3,FEF
.................... 		 
.................... 		return 0; 
0209A:  MOVLW  00
0209C:  MOVWF  01
0209E:  BRA    228C
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
020A0:  MOVLB  1
020A2:  MOVF   xD7,F
020A4:  BZ    20DC
.................... 		if ( 1000 == address ) { 
020A6:  MOVLB  7
020A8:  MOVF   xE1,W
020AA:  SUBLW  E8
020AC:  BNZ   20C0
020AE:  MOVF   xE2,W
020B0:  SUBLW  03
020B2:  BNZ   20C0
.................... 			config.serial_prefix=value; 
020B4:  MOVFF  7E3,39
.................... 			return 0; 
020B8:  MOVLW  00
020BA:  MOVWF  01
020BC:  BRA    228C
.................... 		} else if ( 1001 == address ) { 
020BE:  BRA    20DA
020C0:  MOVF   xE1,W
020C2:  SUBLW  E9
020C4:  BNZ   20DA
020C6:  MOVF   xE2,W
020C8:  SUBLW  03
020CA:  BNZ   20DA
.................... 			config.serial_number=value; 
020CC:  MOVFF  7E4,3B
020D0:  MOVFF  7E3,3A
.................... 			return 0; 
020D4:  MOVLW  00
020D6:  MOVWF  01
020D8:  BRA    228C
020DA:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
020DC:  MOVLB  7
020DE:  MOVF   xE1,W
020E0:  MOVWF  00
020E2:  MOVF   xE2,W
020E4:  MOVWF  03
020E6:  MOVLW  03
020E8:  SUBWF  03,W
020EA:  BNZ   20F6
020EC:  MOVLW  EE
020EE:  SUBWF  00,W
020F0:  MOVLB  0
020F2:  BZ    2190
020F4:  MOVLB  7
020F6:  MOVLW  03
020F8:  SUBWF  03,W
020FA:  BNZ   2106
020FC:  MOVLW  EF
020FE:  SUBWF  00,W
02100:  MOVLB  0
02102:  BZ    21A8
02104:  MOVLB  7
02106:  MOVLW  03
02108:  SUBWF  03,W
0210A:  BNZ   2116
0210C:  MOVLW  F0
0210E:  SUBWF  00,W
02110:  MOVLB  0
02112:  BZ    21B8
02114:  MOVLB  7
02116:  MOVLW  03
02118:  SUBWF  03,W
0211A:  BNZ   2126
0211C:  MOVLW  F1
0211E:  SUBWF  00,W
02120:  MOVLB  0
02122:  BZ    21D0
02124:  MOVLB  7
02126:  MOVLW  03
02128:  SUBWF  03,W
0212A:  BNZ   2136
0212C:  MOVLW  F2
0212E:  SUBWF  00,W
02130:  MOVLB  0
02132:  BZ    21DC
02134:  MOVLB  7
02136:  MOVLW  03
02138:  SUBWF  03,W
0213A:  BNZ   2146
0213C:  MOVLW  F3
0213E:  SUBWF  00,W
02140:  MOVLB  0
02142:  BZ    21F6
02144:  MOVLB  7
02146:  MOVLW  03
02148:  SUBWF  03,W
0214A:  BNZ   2158
0214C:  MOVLW  F4
0214E:  SUBWF  00,W
02150:  MOVLB  0
02152:  BTFSC  FD8.2
02154:  BRA    220E
02156:  MOVLB  7
02158:  MOVLW  07
0215A:  SUBWF  03,W
0215C:  BNZ   216A
0215E:  MOVLW  CE
02160:  SUBWF  00,W
02162:  MOVLB  0
02164:  BTFSC  FD8.2
02166:  BRA    2226
02168:  MOVLB  7
0216A:  MOVLW  07
0216C:  SUBWF  03,W
0216E:  BNZ   217C
02170:  MOVLW  CF
02172:  SUBWF  00,W
02174:  MOVLB  0
02176:  BTFSC  FD8.2
02178:  BRA    2240
0217A:  MOVLB  7
0217C:  MOVLW  4E
0217E:  SUBWF  03,W
02180:  BNZ   218E
02182:  MOVLW  1F
02184:  SUBWF  00,W
02186:  MOVLB  0
02188:  BTFSC  FD8.2
0218A:  BRA    225A
0218C:  MOVLB  7
0218E:  BRA    2282
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
02190:  MOVLB  7
02192:  MOVF   xE4,F
02194:  BNZ   219C
02196:  MOVF   xE3,W
02198:  SUBLW  80
0219A:  BC    21A2
0219C:  MOVLW  03
0219E:  MOVWF  01
021A0:  BRA    228C
.................... 			config.modbus_address=value; 
021A2:  MOVFF  7E3,36
.................... 			break; 
021A6:  BRA    2288
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
021A8:  MOVLB  1
021AA:  BSF    xF9.1
.................... 			config.adc_sample_ticks=value; 
021AC:  MOVFF  7E4,3D
021B0:  MOVFF  7E3,3C
.................... 			break; 
021B4:  MOVLB  7
021B6:  BRA    2288
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
021B8:  MOVLB  7
021BA:  MOVF   xE4,F
021BC:  BNZ   21C4
021BE:  MOVF   xE3,W
021C0:  SUBLW  01
021C2:  BC    21CA
021C4:  MOVLW  03
021C6:  MOVWF  01
021C8:  BRA    228C
.................... 			config.allow_bootload_request=value; 
021CA:  MOVFF  7E3,3E
.................... 			break; 
021CE:  BRA    2288
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
021D0:  MOVFF  7E4,40
021D4:  MOVFF  7E3,3F
.................... 			break; 
021D8:  MOVLB  7
021DA:  BRA    2288
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
021DC:  MOVLB  7
021DE:  MOVF   xE3,F
021E0:  BNZ   21EC
021E2:  MOVF   xE4,F
021E4:  BNZ   21EC
021E6:  MOVLW  03
021E8:  MOVWF  01
021EA:  BRA    228C
.................... 			config.pi_offtime_seconds=value; 
021EC:  MOVFF  7E4,42
021F0:  MOVFF  7E3,41
.................... 			break; 
021F4:  BRA    2288
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
021F6:  MOVLB  7
021F8:  MOVF   xE4,F
021FA:  BNZ   2202
021FC:  MOVF   xE3,W
021FE:  SUBLW  01
02200:  BC    2208
02202:  MOVLW  03
02204:  MOVWF  01
02206:  BRA    228C
.................... 			config.power_startup=value; 
02208:  MOVFF  7E3,43
.................... 			break; 
0220C:  BRA    2288
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
0220E:  MOVLB  7
02210:  MOVF   xE4,F
02212:  BNZ   221A
02214:  MOVF   xE3,W
02216:  SUBLW  02
02218:  BC    2220
0221A:  MOVLW  03
0221C:  MOVWF  01
0221E:  BRA    228C
.................... 			config.rs485_port_mode=value; 
02220:  MOVFF  7E3,38
.................... 			break; 
02224:  BRA    2288
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02226:  MOVLB  7
02228:  DECFSZ xE3,W
0222A:  BRA    2230
0222C:  MOVF   xE4,F
0222E:  BZ    2236
02230:  MOVLW  03
02232:  MOVWF  01
02234:  BRA    228C
.................... 			write_default_param_file(); 
02236:  MOVLB  0
02238:  CALL   0C38
.................... 			break; 
0223C:  MOVLB  7
0223E:  BRA    2288
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02240:  MOVLB  7
02242:  DECFSZ xE3,W
02244:  BRA    224A
02246:  MOVF   xE4,F
02248:  BZ    2250
0224A:  MOVLW  03
0224C:  MOVWF  01
0224E:  BRA    228C
.................... 			write_param_file(); 
02250:  MOVLB  0
02252:  CALL   0BE4
.................... 			break; 
02256:  MOVLB  7
02258:  BRA    2288
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
0225A:  MOVLB  7
0225C:  MOVF   xE3,W
0225E:  SUBLW  0A
02260:  BNZ   2268
02262:  MOVF   xE4,W
02264:  SUBLW  07
02266:  BZ    2274
.................... 				current.factory_unlocked=0; 
02268:  MOVLB  1
0226A:  CLRF   xD7
.................... 				return ILLEGAL_DATA_VALUE; 
0226C:  MOVLW  03
0226E:  MOVWF  01
02270:  MOVLB  7
02272:  BRA    228C
.................... 			} 
.................... 			current.factory_unlocked=1; 
02274:  MOVLW  01
02276:  MOVLB  1
02278:  MOVWF  xD7
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
0227A:  MOVLW  C8
0227C:  MOVWF  xF6
.................... 			break; 
0227E:  MOVLB  7
02280:  BRA    2288
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02282:  MOVLW  02
02284:  MOVWF  01
02286:  BRA    228C
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02288:  MOVLW  00
0228A:  MOVWF  01
.................... } 
0228C:  MOVLB  0
0228E:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02320:  GOTO   10CA
02324:  MOVF   01,F
02326:  BTFSC  FD8.2
02328:  BRA    260C
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
0232A:  DECFSZ 38,W
0232C:  BRA    23E0
0232E:  MOVF   36,W
02330:  MOVLB  6
02332:  SUBWF  xC3,W
02334:  BTFSS  FD8.2
02336:  BRA    233C
02338:  MOVLB  0
0233A:  BRA    23E0
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
0233C:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
0233E:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02340:  CLRWDT
02342:  MOVLW  02
02344:  MOVLB  7
02346:  MOVWF  xDB
02348:  MOVLW  B5
0234A:  MOVWF  xDC
0234C:  MOVLB  0
0234E:  CALL   10F0
02352:  MOVLB  7
02354:  DECFSZ xDB,F
02356:  BRA    2348
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02358:  MOVLB  6
0235A:  MOVF   xC3,W
0235C:  MOVLB  0
0235E:  CALL   1110
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02362:  CLRWDT
02364:  MOVLW  67
02366:  MOVWF  00
02368:  DECFSZ 00,F
0236A:  BRA    2368
0236C:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
0236E:  MOVLB  6
02370:  MOVF   xC5,W
02372:  MOVLB  0
02374:  CALL   1110
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02378:  CLRWDT
0237A:  MOVLW  67
0237C:  MOVWF  00
0237E:  DECFSZ 00,F
02380:  BRA    237E
02382:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02384:  MOVLB  7
02386:  CLRF   xDA
02388:  MOVLW  02
0238A:  MOVLB  6
0238C:  ADDWF  xC4,W
0238E:  MOVLB  7
02390:  SUBWF  xDA,W
02392:  BC    23C0
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02394:  MOVLW  C7
02396:  ADDWF  xDA,W
02398:  MOVWF  FE9
0239A:  MOVLW  06
0239C:  MOVWF  FEA
0239E:  BTFSC  FD8.0
023A0:  INCF   FEA,F
023A2:  MOVFF  FEF,7DB
023A6:  MOVF   xDB,W
023A8:  MOVLB  0
023AA:  CALL   1110
.................... 				delay_us(104); //one stop bit @ 9600 baud 
023AE:  CLRWDT
023B0:  MOVLW  67
023B2:  MOVWF  00
023B4:  DECFSZ 00,F
023B6:  BRA    23B4
023B8:  NOP   
.................... 			} 
023BA:  MOVLB  7
023BC:  INCF   xDA,F
023BE:  BRA    2388
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
023C0:  BTFSS  F72.1
023C2:  BRA    23C0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
023C4:  CLRWDT
023C6:  MOVLW  02
023C8:  MOVWF  xDB
023CA:  MOVLW  B5
023CC:  MOVWF  xDC
023CE:  MOVLB  0
023D0:  CALL   10F0
023D4:  MOVLB  7
023D6:  DECFSZ xDB,F
023D8:  BRA    23CA
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
023DA:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
023DC:  BCF    F8C.0
023DE:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
023E0:  MOVF   36,W
023E2:  SUBLW  80
023E4:  BZ    23F2
023E6:  MOVF   36,W
023E8:  MOVLB  6
023EA:  SUBWF  xC3,W
023EC:  BTFSS  FD8.2
023EE:  BRA    25F6
023F0:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
023F2:  MOVLB  1
023F4:  INCFSZ xCB,W
023F6:  BRA    23FE
023F8:  INCFSZ xCC,W
023FA:  BRA    23FE
023FC:  BRA    2404
.................... 				current.modbus_our_packets++; 
023FE:  INCF   xCB,F
02400:  BTFSC  FD8.2
02402:  INCF   xCC,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02404:  MOVLW  14
02406:  MOVWF  xF6
....................  
.................... 			switch(modbus_rx.func) { 
02408:  MOVLB  6
0240A:  MOVF   xC5,W
0240C:  XORLW  03
0240E:  MOVLB  0
02410:  BZ    2422
02412:  XORLW  07
02414:  BZ    2422
02416:  XORLW  02
02418:  BZ    249A
0241A:  XORLW  16
0241C:  BTFSC  FD8.2
0241E:  BRA    250C
02420:  BRA    25CE
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02422:  MOVFF  6C7,7D6
02426:  MOVFF  6C8,7D5
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
0242A:  MOVFF  6C9,7D8
0242E:  MOVFF  6CA,7D7
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02432:  MOVLB  7
02434:  MOVF   xD7,W
02436:  ADDWF  xD5,W
02438:  MOVWF  xDB
0243A:  MOVF   xD8,W
0243C:  ADDWFC xD6,W
0243E:  MOVWF  xDC
02440:  MOVFF  7D6,7DE
02444:  MOVFF  7D5,7DD
02448:  MOVWF  xE0
0244A:  MOVFF  7DB,7DF
0244E:  MOVLB  0
02450:  GOTO   1118
02454:  MOVF   01,F
02456:  BNZ   247C
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02458:  MOVFF  6C3,7DB
0245C:  MOVLB  7
0245E:  CLRF   xDD
02460:  MOVFF  6C5,7DC
02464:  MOVLW  02
02466:  MOVWF  xDE
02468:  MOVLB  0
0246A:  CALL   129E
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
0246E:  MOVLB  1
02470:  CLRF   xD0
02472:  MOVLW  02
02474:  MOVWF  xCF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02476:  CLRF   xF6
.................... 					} else { 
02478:  BRA    2498
0247A:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
0247C:  MOVFF  6C5,7DB
02480:  MOVFF  6C3,7DC
02484:  MOVFF  7D6,7DE
02488:  MOVFF  7D5,7DD
0248C:  MOVFF  7D8,7E0
02490:  MOVFF  7D7,7DF
02494:  BRA    1F0A
02496:  MOVLB  1
.................... 					} 
.................... 					break; 
02498:  BRA    25EE
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0249A:  MOVFF  6C7,7D6
0249E:  MOVFF  6C8,7D5
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
024A2:  MOVFF  6C9,7DC
024A6:  MOVFF  6CA,7DB
024AA:  MOVFF  7D6,7E2
024AE:  MOVFF  7D5,7E1
024B2:  MOVFF  6C9,7E4
024B6:  MOVFF  6CA,7E3
024BA:  RCALL  1F8C
024BC:  MOVFF  01,7D9
....................  
.................... 					if ( result ) { 
024C0:  MOVLB  7
024C2:  MOVF   xD9,F
024C4:  BZ    24E8
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
024C6:  MOVFF  6C3,7DB
024CA:  CLRF   xDD
024CC:  MOVFF  6C5,7DC
024D0:  MOVFF  7D9,7DE
024D4:  MOVLB  0
024D6:  CALL   129E
.................... 						current.modbus_last_error=result; 
024DA:  MOVLB  1
024DC:  CLRF   xD0
024DE:  MOVFF  7D9,1CF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
024E2:  CLRF   xF6
.................... 					}  else { 
024E4:  BRA    250A
024E6:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
024E8:  MOVFF  6C9,7DC
024EC:  MOVFF  6CA,7DB
024F0:  MOVFF  6C3,7DD
024F4:  MOVFF  7D6,7DF
024F8:  MOVFF  7D5,7DE
024FC:  MOVFF  6C9,7E1
02500:  MOVFF  6CA,7E0
02504:  MOVLB  0
02506:  BRA    2290
02508:  MOVLB  1
.................... 					} 
.................... 					break; 
0250A:  BRA    25EE
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0250C:  MOVFF  6C7,7D6
02510:  MOVFF  6C8,7D5
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02514:  MOVFF  6C9,7D8
02518:  MOVFF  6CA,7D7
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
0251C:  MOVLB  7
0251E:  CLRF   xDA
02520:  MOVF   xD8,F
02522:  BNZ   252A
02524:  MOVF   xD7,W
02526:  SUBWF  xDA,W
02528:  BC    25AE
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
0252A:  MOVF   xDA,W
0252C:  ADDWF  xD5,W
0252E:  MOVWF  xDB
02530:  MOVLW  00
02532:  ADDWFC xD6,W
02534:  MOVWF  xDC
02536:  BCF    FD8.0
02538:  RLCF   xDA,W
0253A:  ADDLW  05
0253C:  ADDLW  C7
0253E:  MOVWF  FE9
02540:  MOVLW  06
02542:  MOVWF  FEA
02544:  BTFSC  FD8.0
02546:  INCF   FEA,F
02548:  MOVFF  FEF,7DD
0254C:  BCF    FD8.0
0254E:  RLCF   xDA,W
02550:  ADDLW  06
02552:  ADDLW  C7
02554:  MOVWF  FE9
02556:  MOVLW  06
02558:  MOVWF  FEA
0255A:  BTFSC  FD8.0
0255C:  INCF   FEA,F
0255E:  MOVFF  FEF,7DE
02562:  MOVFF  7DD,7E0
02566:  MOVFF  7DE,7DF
0256A:  MOVFF  7DC,7E2
0256E:  MOVFF  7DB,7E1
02572:  MOVFF  7DD,7E4
02576:  MOVFF  7DE,7E3
0257A:  MOVLB  0
0257C:  RCALL  1F8C
0257E:  MOVFF  01,7D9
....................  
.................... 						if ( result ) { 
02582:  MOVLB  7
02584:  MOVF   xD9,F
02586:  BZ    25AA
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02588:  MOVFF  6C3,7DB
0258C:  CLRF   xDD
0258E:  MOVFF  6C5,7DC
02592:  MOVFF  7D9,7DE
02596:  MOVLB  0
02598:  CALL   129E
.................... 							current.modbus_last_error=result; 
0259C:  MOVLB  1
0259E:  CLRF   xD0
025A0:  MOVFF  7D9,1CF
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
025A4:  CLRF   xF6
.................... 			 
.................... 							break; 
025A6:  MOVLB  7
025A8:  BRA    25AE
.................... 						} 
.................... 					} 
025AA:  INCF   xDA,F
025AC:  BRA    2520
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
025AE:  MOVF   xD9,F
025B0:  BNZ   25CA
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
025B2:  MOVFF  6C3,7DB
025B6:  MOVFF  7D6,7DD
025BA:  MOVFF  7D5,7DC
025BE:  MOVFF  7D8,7DF
025C2:  MOVFF  7D7,7DE
025C6:  MOVLB  0
025C8:  BRA    22D8
.................... 					} 
....................  
.................... 					break;   
025CA:  MOVLB  1
025CC:  BRA    25EE
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
025CE:  MOVFF  6C3,7DB
025D2:  MOVLB  7
025D4:  CLRF   xDD
025D6:  MOVFF  6C5,7DC
025DA:  MOVLW  01
025DC:  MOVWF  xDE
025DE:  MOVLB  0
025E0:  CALL   129E
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
025E4:  MOVLB  1
025E6:  CLRF   xD0
025E8:  MOVLW  01
025EA:  MOVWF  xCF
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
025EC:  CLRF   xF6
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
025EE:  CLRF   xD9
025F0:  CLRF   xD8
....................  
.................... 		} else { 
025F2:  BRA    260C
025F4:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
025F6:  MOVLB  1
025F8:  INCFSZ xCD,W
025FA:  BRA    2602
025FC:  INCFSZ xCE,W
025FE:  BRA    2602
02600:  BRA    2608
.................... 				current.modbus_other_packets++; 
02602:  INCF   xCD,F
02604:  BTFSC  FD8.2
02606:  INCF   xCE,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02608:  MOVLW  0A
0260A:  MOVWF  xF6
0260C:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
0260E:  GOTO   2A9E (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00412:  MOVLB  8
00414:  BTFSS  xE7.0
00416:  BRA    0430
00418:  MOVLB  1
0041A:  INCFSZ xE5,W
0041C:  BRA    0428
0041E:  INCFSZ xE6,W
00420:  BRA    0428
00422:  MOVLB  8
00424:  BRA    0430
00426:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00428:  INCF   xE5,F
0042A:  BTFSC  FD8.2
0042C:  INCF   xE6,F
0042E:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00430:  BTFSS  xE7.2
00432:  BRA    044C
00434:  MOVLB  1
00436:  INCFSZ xE7,W
00438:  BRA    0444
0043A:  INCFSZ xE8,W
0043C:  BRA    0444
0043E:  MOVLB  8
00440:  BRA    044C
00442:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00444:  INCF   xE7,F
00446:  BTFSC  FD8.2
00448:  INCF   xE8,F
0044A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0044C:  BTFSS  xE7.4
0044E:  BRA    0468
00450:  MOVLB  1
00452:  INCFSZ xE9,W
00454:  BRA    0460
00456:  INCFSZ xEA,W
00458:  BRA    0460
0045A:  MOVLB  8
0045C:  BRA    0468
0045E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00460:  INCF   xE9,F
00462:  BTFSC  FD8.2
00464:  INCF   xEA,F
00466:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00468:  BCF    xE7.1
0046A:  BTFSC  F81.0
0046C:  BSF    xE7.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0046E:  BTFSC  xE7.1
00470:  BRA    04F4
00472:  MOVLB  6
00474:  BTFSC  xBF.1
00476:  BRA    047C
00478:  MOVLB  8
0047A:  BRA    04F4
.................... 		current.pulse_count[0]++; 
0047C:  MOVLB  0
0047E:  INCF   xA8,F
00480:  BTFSC  FD8.2
00482:  INCF   xA9,F
.................... 		current.pulse_sum[0]++; 
00484:  MOVLW  01
00486:  ADDWF  xAE,F
00488:  BTFSC  FD8.0
0048A:  INCF   xAF,F
0048C:  BTFSC  FD8.2
0048E:  INCF   xB0,F
00490:  BTFSC  FD8.2
00492:  INCF   xB1,F
.................... 		if ( 1 == ext0_state ) { 
00494:  MOVLB  6
00496:  BTFSS  xBF.2
00498:  BRA    04E2
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0049A:  MOVLB  8
0049C:  BCF    xE7.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0049E:  MOVFF  1E6,97
004A2:  MOVFF  1E5,96
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004A6:  MOVLB  0
004A8:  MOVF   x97,W
004AA:  SUBWF  x9D,W
004AC:  BNC   04BE
004AE:  BNZ   04B6
004B0:  MOVF   x9C,W
004B2:  SUBWF  x96,W
004B4:  BC    04BE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004B6:  MOVFF  97,9D
004BA:  MOVFF  96,9C
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004BE:  MOVF   xA3,W
004C0:  SUBWF  x97,W
004C2:  BNC   04DE
004C4:  BNZ   04CC
004C6:  MOVF   x96,W
004C8:  SUBWF  xA2,W
004CA:  BC    04DE
004CC:  INCFSZ x96,W
004CE:  BRA    04D6
004D0:  INCFSZ x97,W
004D2:  BRA    04D6
004D4:  BRA    04DE
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004D6:  MOVFF  97,A3
004DA:  MOVFF  96,A2
.................... 			} 
.................... 			ext0_state=0; 
004DE:  MOVLB  6
004E0:  BCF    xBF.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004E2:  BTFSC  xBF.2
004E4:  BRA    04F4
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004E6:  MOVLB  1
004E8:  CLRF   xE6
004EA:  CLRF   xE5
.................... 			ext0_count=1; 
004EC:  MOVLB  8
004EE:  BSF    xE7.0
.................... 			ext0_state=1; 
004F0:  MOVLB  6
004F2:  BSF    xBF.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004F4:  MOVLB  6
004F6:  BCF    xBF.1
004F8:  MOVLB  8
004FA:  BTFSS  xE7.1
004FC:  BRA    0504
004FE:  MOVLB  6
00500:  BSF    xBF.1
00502:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00504:  BCF    xE7.3
00506:  BTFSC  F81.1
00508:  BSF    xE7.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0050A:  BTFSC  xE7.3
0050C:  BRA    0590
0050E:  MOVLB  6
00510:  BTFSC  xBF.3
00512:  BRA    0518
00514:  MOVLB  8
00516:  BRA    0590
.................... 		current.pulse_count[1]++; 
00518:  MOVLB  0
0051A:  INCF   xAA,F
0051C:  BTFSC  FD8.2
0051E:  INCF   xAB,F
.................... 		current.pulse_sum[1]++; 
00520:  MOVLW  01
00522:  ADDWF  xB2,F
00524:  BTFSC  FD8.0
00526:  INCF   xB3,F
00528:  BTFSC  FD8.2
0052A:  INCF   xB4,F
0052C:  BTFSC  FD8.2
0052E:  INCF   xB5,F
.................... 		if ( 1 == ext1_state ) { 
00530:  MOVLB  6
00532:  BTFSS  xBF.4
00534:  BRA    057E
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00536:  MOVLB  8
00538:  BCF    xE7.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0053A:  MOVFF  1E8,99
0053E:  MOVFF  1E7,98
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00542:  MOVLB  0
00544:  MOVF   x99,W
00546:  SUBWF  x9F,W
00548:  BNC   055A
0054A:  BNZ   0552
0054C:  MOVF   x9E,W
0054E:  SUBWF  x98,W
00550:  BC    055A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00552:  MOVFF  99,9F
00556:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0055A:  MOVF   xA5,W
0055C:  SUBWF  x99,W
0055E:  BNC   057A
00560:  BNZ   0568
00562:  MOVF   x98,W
00564:  SUBWF  xA4,W
00566:  BC    057A
00568:  INCFSZ x98,W
0056A:  BRA    0572
0056C:  INCFSZ x99,W
0056E:  BRA    0572
00570:  BRA    057A
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
00572:  MOVFF  99,A5
00576:  MOVFF  98,A4
.................... 			} 
.................... 			ext1_state=0; 
0057A:  MOVLB  6
0057C:  BCF    xBF.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0057E:  BTFSC  xBF.4
00580:  BRA    0590
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
00582:  MOVLB  1
00584:  CLRF   xE8
00586:  CLRF   xE7
.................... 			ext1_count=1; 
00588:  MOVLB  8
0058A:  BSF    xE7.2
.................... 			ext1_state=1; 
0058C:  MOVLB  6
0058E:  BSF    xBF.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
00590:  MOVLB  6
00592:  BCF    xBF.3
00594:  MOVLB  8
00596:  BTFSS  xE7.3
00598:  BRA    05A0
0059A:  MOVLB  6
0059C:  BSF    xBF.3
0059E:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005A0:  BCF    xE7.5
005A2:  BTFSC  F81.2
005A4:  BSF    xE7.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005A6:  BTFSC  xE7.5
005A8:  BRA    062C
005AA:  MOVLB  6
005AC:  BTFSC  xBF.5
005AE:  BRA    05B4
005B0:  MOVLB  8
005B2:  BRA    062C
.................... 		current.pulse_count[2]++; 
005B4:  MOVLB  0
005B6:  INCF   xAC,F
005B8:  BTFSC  FD8.2
005BA:  INCF   xAD,F
.................... 		current.pulse_sum[2]++; 
005BC:  MOVLW  01
005BE:  ADDWF  xB6,F
005C0:  BTFSC  FD8.0
005C2:  INCF   xB7,F
005C4:  BTFSC  FD8.2
005C6:  INCF   xB8,F
005C8:  BTFSC  FD8.2
005CA:  INCF   xB9,F
.................... 		if ( 1 == ext2_state ) { 
005CC:  MOVLB  6
005CE:  BTFSS  xBF.6
005D0:  BRA    061A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
005D2:  MOVLB  8
005D4:  BCF    xE7.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005D6:  MOVFF  1EA,9B
005DA:  MOVFF  1E9,9A
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005DE:  MOVLB  0
005E0:  MOVF   x9B,W
005E2:  SUBWF  xA1,W
005E4:  BNC   05F6
005E6:  BNZ   05EE
005E8:  MOVF   xA0,W
005EA:  SUBWF  x9A,W
005EC:  BC    05F6
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005EE:  MOVFF  9B,A1
005F2:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005F6:  MOVF   xA7,W
005F8:  SUBWF  x9B,W
005FA:  BNC   0616
005FC:  BNZ   0604
005FE:  MOVF   x9A,W
00600:  SUBWF  xA6,W
00602:  BC    0616
00604:  INCFSZ x9A,W
00606:  BRA    060E
00608:  INCFSZ x9B,W
0060A:  BRA    060E
0060C:  BRA    0616
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0060E:  MOVFF  9B,A7
00612:  MOVFF  9A,A6
.................... 			} 
.................... 			ext2_state=0; 
00616:  MOVLB  6
00618:  BCF    xBF.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0061A:  BTFSC  xBF.6
0061C:  BRA    062C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0061E:  MOVLB  1
00620:  CLRF   xEA
00622:  CLRF   xE9
.................... 			ext2_count=1; 
00624:  MOVLB  8
00626:  BSF    xE7.4
.................... 			ext2_state=1; 
00628:  MOVLB  6
0062A:  BSF    xBF.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0062C:  MOVLB  6
0062E:  BCF    xBF.5
00630:  MOVLB  8
00632:  BTFSS  xE7.5
00634:  BRA    063C
00636:  MOVLB  6
00638:  BSF    xBF.5
0063A:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0063C:  MOVLB  7
0063E:  INCF   xCA,F
.................... 	if ( 10 == tick ) { 
00640:  MOVF   xCA,W
00642:  SUBLW  0A
00644:  BNZ   064E
.................... 		tick=0; 
00646:  CLRF   xCA
.................... 		timers.now_millisecond=1; 
00648:  MOVLB  1
0064A:  BSF    xF9.2
0064C:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0064E:  BCF    F9E.1
00650:  MOVLB  0
00652:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0066E:  BRA    0656
00670:  MOVFF  01,8E4
.................... 	current.rda2_bytes_received++; 
00674:  MOVLB  1
00676:  INCF   xE3,F
00678:  BTFSC  FD8.2
0067A:  INCF   xE4,F
....................  
.................... 	if ( RS485_MODE_OFF != config.rs485_port_mode ) { 
0067C:  MOVF   38,F
0067E:  BZ    06A0
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
00680:  MOVLB  2
00682:  CLRF   xFE
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
00684:  INCFSZ xFD,W
00686:  BRA    068A
00688:  BRA    069E
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
0068A:  MOVLW  FD
0068C:  ADDWF  xFD,W
0068E:  MOVWF  FE9
00690:  MOVLW  01
00692:  MOVWF  FEA
00694:  BTFSC  FD8.0
00696:  INCF   FEA,F
00698:  MOVFF  8E4,FEF
.................... 			timers.rda2_buff_pos++; 
0069C:  INCF   xFD,F
0069E:  MOVLB  1
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
006A0:  BCF    FA4.5
006A2:  MOVLB  0
006A4:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
006EA:  RCALL  06A8
006EC:  MOVFF  01,8E4
....................  
.................... 	current.rda_bytes_received++; 
006F0:  MOVLB  1
006F2:  INCF   xE1,F
006F4:  BTFSC  FD8.2
006F6:  INCF   xE2,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006F8:  MOVLB  6
006FA:  BTFSC  xBF.0
006FC:  BRA    0754
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
006FE:  MOVF   xC0,F
00700:  BNZ   0712
.................... 			modbus_serial_crc.d = 0xFFFF; 
00702:  SETF   xC2
00704:  SETF   xC1
.................... 			modbus_rx.address = c; 
00706:  MOVFF  8E4,6C3
.................... 			modbus_serial_state++; 
0070A:  INCF   xC0,F
.................... 			modbus_rx.len = 0; 
0070C:  CLRF   xC4
.................... 			modbus_rx.error=0; 
0070E:  CLRF   xC6
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00710:  BRA    0740
00712:  DECFSZ xC0,W
00714:  BRA    071E
.................... 			modbus_rx.func = c; 
00716:  MOVFF  8E4,6C5
.................... 			modbus_serial_state++; 
0071A:  INCF   xC0,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
0071C:  BRA    0740
0071E:  MOVF   xC0,W
00720:  SUBLW  02
00722:  BNZ   0740
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
00724:  INCFSZ xC4,W
00726:  BRA    072C
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00728:  MOVLW  FE
0072A:  MOVWF  xC4
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
0072C:  MOVLW  C7
0072E:  ADDWF  xC4,W
00730:  MOVWF  FE9
00732:  MOVLW  06
00734:  MOVWF  FEA
00736:  BTFSC  FD8.0
00738:  INCF   FEA,F
0073A:  MOVFF  8E4,FEF
.................... 			modbus_rx.len++; 
0073E:  INCF   xC4,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00740:  MOVFF  8E4,8E5
00744:  MOVLB  0
00746:  RCALL  06BE
.................... 		modbus_enable_timeout(TRUE); 
00748:  MOVLW  01
0074A:  MOVLB  8
0074C:  MOVWF  xE5
0074E:  MOVLB  0
00750:  RCALL  03CC
00752:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
....................  
00754:  BCF    F9E.5
00756:  MOVLB  0
00758:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00856:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00858:  MOVLW  08
0085A:  MOVWF  F61
0085C:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
0085E:  MOVLW  00
00860:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
00862:  MOVLW  FF
00864:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00866:  MOVLW  92
00868:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
0086A:  MOVLW  80
0086C:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
0086E:  BCF    F96.0
00870:  BCF    F96.1
00872:  BCF    F96.2
00874:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00876:  MOVLB  1
00878:  CLRF   xF6
.................... 	timers.load_off_seconds=2; 
0087A:  CLRF   xF8
0087C:  MOVLW  02
0087E:  MOVWF  xF7
.................... 	timers.now_adc_sample=0; 
00880:  BCF    xF9.0
.................... 	timers.now_adc_reset_count=0; 
00882:  BCF    xF9.1
.................... 	timers.now_millisecond=0; 
00884:  BCF    xF9.2
.................... 	timers.port_b=0b11111111; 
00886:  SETF   xFA
.................... 	timers.port_c=0b11111111; 
00888:  SETF   xFB
....................  
.................... 	timers.rda2_buff_pos=0; 
0088A:  MOVLB  2
0088C:  CLRF   xFD
.................... 	timers.rda2_buff_gap=255; 
0088E:  SETF   xFE
.................... 	timers.now_parse_rda2=0; 
00890:  MOVLB  1
00892:  BCF    xFC.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
00894:  MOVLB  7
00896:  CLRF   xD5
00898:  MOVF   xD5,W
0089A:  SUBLW  02
0089C:  BNC   094C
.................... 		current.pulse_period[i]=0; 
0089E:  CLRF   03
008A0:  MOVFF  7D5,02
008A4:  BCF    FD8.0
008A6:  RLCF   02,F
008A8:  RLCF   03,F
008AA:  MOVF   02,W
008AC:  ADDLW  96
008AE:  MOVWF  FE9
008B0:  MOVLW  00
008B2:  ADDWFC 03,W
008B4:  MOVWF  FEA
008B6:  CLRF   FEC
008B8:  MOVF   FED,F
008BA:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
008BC:  CLRF   03
008BE:  MOVFF  7D5,02
008C2:  BCF    FD8.0
008C4:  RLCF   02,F
008C6:  RLCF   03,F
008C8:  MOVF   02,W
008CA:  ADDLW  9C
008CC:  MOVWF  FE9
008CE:  MOVLW  00
008D0:  ADDWFC 03,W
008D2:  MOVWF  FEA
008D4:  SETF   FEC
008D6:  MOVF   FED,F
008D8:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
008DA:  CLRF   03
008DC:  MOVFF  7D5,02
008E0:  BCF    FD8.0
008E2:  RLCF   02,F
008E4:  RLCF   03,F
008E6:  MOVF   02,W
008E8:  ADDLW  A2
008EA:  MOVWF  FE9
008EC:  MOVLW  00
008EE:  ADDWFC 03,W
008F0:  MOVWF  FEA
008F2:  CLRF   FEC
008F4:  MOVF   FED,F
008F6:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
008F8:  CLRF   03
008FA:  MOVFF  7D5,02
008FE:  BCF    FD8.0
00900:  RLCF   02,F
00902:  RLCF   03,F
00904:  MOVF   02,W
00906:  ADDLW  A8
00908:  MOVWF  FE9
0090A:  MOVLW  00
0090C:  ADDWFC 03,W
0090E:  MOVWF  FEA
00910:  CLRF   FEC
00912:  MOVF   FED,F
00914:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00916:  MOVLB  8
00918:  CLRF   xDA
0091A:  MOVFF  7D5,8D9
0091E:  CLRF   xDC
00920:  MOVLW  04
00922:  MOVWF  xDB
00924:  MOVLB  0
00926:  RCALL  081A
00928:  MOVF   01,W
0092A:  ADDLW  AE
0092C:  MOVWF  FE9
0092E:  MOVLW  00
00930:  ADDWFC 02,W
00932:  MOVWF  FEA
00934:  MOVF   FEE,F
00936:  MOVF   FEE,F
00938:  CLRF   FEC
0093A:  MOVF   FED,F
0093C:  CLRF   FEF
0093E:  MOVF   FED,F
00940:  CLRF   FEF
00942:  MOVF   FED,F
00944:  CLRF   FEF
.................... 	} 
00946:  MOVLB  7
00948:  INCF   xD5,F
0094A:  BRA    0898
....................  
.................... 	current.modbus_our_packets=0; 
0094C:  MOVLB  1
0094E:  CLRF   xCC
00950:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
00952:  CLRF   xCE
00954:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
00956:  CLRF   xD0
00958:  CLRF   xCF
.................... 	current.sequence_number=0; 
0095A:  CLRF   xD2
0095C:  CLRF   xD1
.................... 	current.uptime_minutes=0; 
0095E:  CLRF   xD4
00960:  CLRF   xD3
.................... 	current.interval_milliseconds=0; 
00962:  CLRF   xD6
00964:  CLRF   xD5
.................... 	current.adc_buffer_index=0; 
00966:  CLRF   xCA
.................... 	current.factory_unlocked=0; 
00968:  CLRF   xD7
.................... 	current.watchdog_seconds=0; 
0096A:  CLRF   xD9
0096C:  CLRF   xD8
.................... 	current.rda_bytes_received=0; 
0096E:  CLRF   xE2
00970:  CLRF   xE1
.................... 	current.rda2_bytes_received=0; 
00972:  CLRF   xE4
00974:  CLRF   xE3
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
00976:  MOVLW  02
00978:  MOVWF  FEA
0097A:  SETF   FE9
0097C:  CLRF   00
0097E:  MOVLW  03
00980:  MOVWF  02
00982:  MOVLW  C0
00984:  MOVWF  01
00986:  MOVLB  0
00988:  RCALL  083C
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
0098A:  MOVFF  4B,1DC
0098E:  MOVFF  4A,1DB
.................... 	current.power_off_delay=config.power_off_below_delay; 
00992:  MOVFF  47,1DE
00996:  MOVFF  46,1DD
.................... 	current.power_override_timeout=0; 
0099A:  MOVLB  1
0099C:  CLRF   xE0
0099E:  CLRF   xDF
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
009A0:  MOVLW  00
009A2:  IORLW  05
009A4:  MOVWF  FBA
009A6:  MOVLW  4A
009A8:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
009AA:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
009AC:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
009AE:  MOVLB  0
009B0:  GOTO   291A (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00F4C:  MOVLB  1
00F4E:  BCF    xF9.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00F50:  BCF    FD8.0
00F52:  MOVLB  7
00F54:  RLCF   xD0,W
00F56:  MOVWF  xD5
00F58:  RLCF   xD1,W
00F5A:  MOVWF  xD6
00F5C:  MOVLW  00
00F5E:  MOVLB  1
00F60:  BTFSS  xFB.5
00F62:  MOVLW  01
00F64:  MOVLB  7
00F66:  IORWF  xD5,F
00F68:  MOVFF  7D5,7D0
00F6C:  MOVF   xD6,W
00F6E:  IORLW  E0
00F70:  MOVWF  xD1
.................... 	if ( b2_state==0xf000) { 
00F72:  MOVF   xD0,F
00F74:  BNZ   0F7C
00F76:  MOVF   xD1,W
00F78:  SUBLW  F0
00F7A:  BNZ   0F7C
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00F7C:  MOVLB  1
00F7E:  INCFSZ xE5,W
00F80:  BRA    0F8E
00F82:  INCFSZ xE6,W
00F84:  BRA    0F8E
.................... 				current.pulse_period[0]=0; 
00F86:  MOVLB  0
00F88:  CLRF   x97
00F8A:  CLRF   x96
00F8C:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00F8E:  INCFSZ xE7,W
00F90:  BRA    0F9E
00F92:  INCFSZ xE8,W
00F94:  BRA    0F9E
.................... 				current.pulse_period[1]=0; 
00F96:  MOVLB  0
00F98:  CLRF   x99
00F9A:  CLRF   x98
00F9C:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00F9E:  INCFSZ xE9,W
00FA0:  BRA    0FAE
00FA2:  INCFSZ xEA,W
00FA4:  BRA    0FAE
.................... 				current.pulse_period[2]=0; 
00FA6:  MOVLB  0
00FA8:  CLRF   x9B
00FAA:  CLRF   x9A
00FAC:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00FAE:  MOVFF  F81,1FA
.................... 	timers.port_c=port_c; 
00FB2:  MOVFF  F82,1FB
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
00FB6:  MOVF   xF6,F
00FB8:  BNZ   0FBE
.................... 		output_low(LED_GREEN); 
00FBA:  BCF    F89.3
.................... 	} else { 
00FBC:  BRA    0FC2
.................... 		output_high(LED_GREEN); 
00FBE:  BSF    F89.3
.................... 		timers.led_on_green--; 
00FC0:  DECF   xF6,F
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00FC2:  INCFSZ xD5,W
00FC4:  BRA    0FCC
00FC6:  INCFSZ xD6,W
00FC8:  BRA    0FCC
00FCA:  BRA    0FD2
.................... 		current.interval_milliseconds++; 
00FCC:  INCF   xD5,F
00FCE:  BTFSC  FD8.2
00FD0:  INCF   xD6,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00FD2:  MOVLB  7
00FD4:  INCF   xCE,F
00FD6:  BTFSC  FD8.2
00FD8:  INCF   xCF,F
.................... 	if ( 1000 == ticks ) { 
00FDA:  MOVF   xCE,W
00FDC:  SUBLW  E8
00FDE:  BNZ   1064
00FE0:  MOVF   xCF,W
00FE2:  SUBLW  03
00FE4:  BNZ   1064
.................... 		ticks=0; 
00FE6:  CLRF   xCF
00FE8:  CLRF   xCE
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00FEA:  MOVLB  1
00FEC:  INCFSZ xD8,W
00FEE:  BRA    0FF6
00FF0:  INCFSZ xD9,W
00FF2:  BRA    0FF6
00FF4:  BRA    0FFC
.................... 			current.watchdog_seconds++; 
00FF6:  INCF   xD8,F
00FF8:  BTFSC  FD8.2
00FFA:  INCF   xD9,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00FFC:  MOVF   3F,F
00FFE:  BNZ   1004
01000:  MOVF   40,F
01002:  BZ    1022
01004:  MOVF   40,W
01006:  SUBWF  xD9,W
01008:  BNC   1022
0100A:  BNZ   1012
0100C:  MOVF   xD8,W
0100E:  SUBWF  3F,W
01010:  BC    1022
01012:  MOVF   xF7,F
01014:  BNZ   1022
01016:  MOVF   xF8,F
01018:  BNZ   1022
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
0101A:  MOVFF  42,1F8
0101E:  MOVFF  41,1F7
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
01022:  MOVF   xF7,F
01024:  BNZ   102E
01026:  MOVF   xF8,F
01028:  BNZ   102E
.................... 			output_high(PI_POWER_EN); 
0102A:  BSF    F8B.0
.................... 		} else { 
0102C:  BRA    1044
.................... 			output_low(PI_POWER_EN); 
0102E:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01030:  MOVF   xF7,W
01032:  BTFSC  FD8.2
01034:  DECF   xF8,F
01036:  DECF   xF7,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
01038:  MOVF   xF7,F
0103A:  BNZ   1044
0103C:  MOVF   xF8,F
0103E:  BNZ   1044
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01040:  CLRF   xD9
01042:  CLRF   xD8
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
01044:  MOVLB  7
01046:  INCF   xCB,F
.................... 		if ( 60 == uptimeTicks ) { 
01048:  MOVF   xCB,W
0104A:  SUBLW  3C
0104C:  BNZ   1064
.................... 			uptimeTicks=0; 
0104E:  CLRF   xCB
.................... 			if ( current.uptime_minutes < 65535 )  
01050:  MOVLB  1
01052:  INCFSZ xD3,W
01054:  BRA    105C
01056:  INCFSZ xD4,W
01058:  BRA    105C
0105A:  BRA    1062
.................... 				current.uptime_minutes++; 
0105C:  INCF   xD3,F
0105E:  BTFSC  FD8.2
01060:  INCF   xD4,F
01062:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
01064:  INCFSZ xD2,W
01066:  BRA    107A
01068:  INCFSZ xD3,W
0106A:  BRA    107A
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
0106C:  CLRF   xED
0106E:  MOVLB  0
01070:  RCALL  0EC4
01072:  MOVFF  02,7D3
01076:  MOVFF  01,7D2
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
0107A:  MOVLB  1
0107C:  BTFSS  xF9.1
0107E:  BRA    1088
.................... 		timers.now_adc_reset_count=0; 
01080:  BCF    xF9.1
.................... 		adcTicks=0; 
01082:  MOVLB  7
01084:  CLRF   xCD
01086:  CLRF   xCC
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01088:  MOVLB  7
0108A:  INCF   xCC,F
0108C:  BTFSC  FD8.2
0108E:  INCF   xCD,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
01090:  MOVF   3C,W
01092:  SUBWF  xCC,W
01094:  BNZ   10AA
01096:  MOVF   3D,W
01098:  SUBWF  xCD,W
0109A:  BNZ   10AA
.................... 		adcTicks=0; 
0109C:  CLRF   xCD
0109E:  CLRF   xCC
.................... 		timers.now_adc_sample=1; 
010A0:  MOVLB  1
010A2:  BSF    xF9.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
010A4:  MOVLB  7
010A6:  SETF   xD3
010A8:  SETF   xD2
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
010AA:  MOVLB  2
010AC:  INCFSZ xFE,W
010AE:  BRA    10B2
010B0:  BRA    10B4
.................... 		timers.rda2_buff_gap++; 
010B2:  INCF   xFE,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
010B4:  MOVF   xFE,W
010B6:  SUBLW  09
010B8:  BC    10C4
010BA:  MOVF   xFD,F
010BC:  BZ    10C4
.................... 		timers.now_parse_rda2=1;	 
010BE:  MOVLB  1
010C0:  BSF    xFC.0
010C2:  MOVLB  2
.................... 	} 
.................... } 
010C4:  MOVLB  0
010C6:  GOTO   2A8C (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 n) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < n && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
02612:  MOVLB  8
02614:  CLRF   xE0
02616:  MOVF   xDF,W
02618:  SUBWF  xE0,W
0261A:  BC    2688
0261C:  CLRF   03
0261E:  MOVF   xE0,W
02620:  ADDWF  xDD,W
02622:  MOVWF  FE9
02624:  MOVF   xDE,W
02626:  ADDWFC 03,W
02628:  MOVWF  FEA
0262A:  MOVF   FEF,F
0262C:  BZ    2688
0262E:  CLRF   03
02630:  MOVF   xE0,W
02632:  ADDWF  xDD,W
02634:  MOVWF  FE9
02636:  MOVF   xDE,W
02638:  ADDWFC 03,W
0263A:  MOVWF  FEA
0263C:  MOVF   FEF,W
0263E:  SUBLW  0A
02640:  BZ    2688
02642:  CLRF   03
02644:  MOVF   xE0,W
02646:  ADDWF  xDD,W
02648:  MOVWF  FE9
0264A:  MOVF   xDE,W
0264C:  ADDWFC 03,W
0264E:  MOVWF  FEA
02650:  MOVF   FEF,W
02652:  SUBLW  0D
02654:  BZ    2688
.................... 		dest[i] = src[i]; 
02656:  CLRF   03
02658:  MOVF   xE0,W
0265A:  ADDWF  xDB,W
0265C:  MOVWF  01
0265E:  MOVF   xDC,W
02660:  ADDWFC 03,F
02662:  MOVFF  03,8E2
02666:  CLRF   03
02668:  MOVF   xE0,W
0266A:  ADDWF  xDD,W
0266C:  MOVWF  FE9
0266E:  MOVF   xDE,W
02670:  ADDWFC 03,W
02672:  MOVWF  FEA
02674:  MOVFF  FEF,8E3
02678:  MOVFF  8E2,FEA
0267C:  MOVFF  01,FE9
02680:  MOVFF  8E3,FEF
.................... 	} 
02684:  INCF   xE0,F
02686:  BRA    2616
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < n ; i++) { 
02688:  MOVF   xDF,W
0268A:  SUBWF  xE0,W
0268C:  BC    26A2
.................... 		dest[i] = '\0'; 
0268E:  CLRF   03
02690:  MOVF   xE0,W
02692:  ADDWF  xDB,W
02694:  MOVWF  FE9
02696:  MOVF   xDC,W
02698:  ADDWFC 03,W
0269A:  MOVWF  FEA
0269C:  CLRF   FEF
.................... 	} 
0269E:  INCF   xE0,F
026A0:  BRA    2688
....................  
.................... 	/* always null terminate */ 
.................... 	dest[n-1]='\0'; 
026A2:  MOVLW  01
026A4:  SUBWF  xDF,W
026A6:  CLRF   03
026A8:  ADDWF  xDB,W
026AA:  MOVWF  FE9
026AC:  MOVF   xDC,W
026AE:  ADDWFC 03,W
026B0:  MOVWF  FEA
026B2:  CLRF   FEF
.................... } 
026B4:  MOVLB  0
026B6:  RETURN 0
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02750:  MOVFF  2FD,8D5
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02754:  MOVLB  2
02756:  SETF   xFD
.................... 	memcpy(buff,timers.rda2_buff,length); 
02758:  MOVLW  07
0275A:  MOVWF  FEA
0275C:  MOVLW  D5
0275E:  MOVWF  FE9
02760:  MOVLW  01
02762:  MOVWF  FE2
02764:  MOVLW  FD
02766:  MOVWF  FE1
02768:  MOVLB  8
0276A:  MOVF   xD5,W
0276C:  MOVWF  01
0276E:  BZ    2778
02770:  MOVFF  FE6,FEE
02774:  DECFSZ 01,F
02776:  BRA    2770
.................... 	timers.rda2_buff_gap=0; 
02778:  MOVLB  2
0277A:  CLRF   xFE
.................... 	timers.rda2_buff_pos=0; 
0277C:  CLRF   xFD
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
0277E:  DECFSZ 38,W
02780:  BRA    27B8
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02782:  MOVLB  8
02784:  CLRF   xD7
02786:  CLRF   xD6
02788:  MOVF   xD7,F
0278A:  BNZ   27B4
0278C:  MOVF   xD5,W
0278E:  SUBWF  xD6,W
02790:  BC    27B4
.................... 			fputc(buff[l],STREAM_PI); 
02792:  MOVLW  D5
02794:  ADDWF  xD6,W
02796:  MOVWF  FE9
02798:  MOVLW  07
0279A:  ADDWFC xD7,W
0279C:  MOVWF  FEA
0279E:  MOVFF  FEF,8D9
027A2:  MOVF   xD9,W
027A4:  MOVLB  0
027A6:  CALL   1206
.................... 		} 
027AA:  MOVLB  8
027AC:  INCF   xD6,F
027AE:  BTFSC  FD8.2
027B0:  INCF   xD7,F
027B2:  BRA    2788
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
027B4:  BRA    2870
027B6:  MOVLB  2
027B8:  MOVF   38,W
027BA:  SUBLW  02
027BC:  BNZ   2872
.................... 		/* do something */ 
....................  
.................... 		/* put copy in 11th slot no mater what ... for debugging */ 
.................... 		strncpy_terminate_trim(nmea.sentence[11],buff,NMEA_SENTENCE_LENGTH-1); 
027BE:  MOVLW  06
027C0:  MOVLB  8
027C2:  MOVWF  xDC
027C4:  MOVLW  6F
027C6:  MOVWF  xDB
027C8:  MOVLW  07
027CA:  MOVWF  xDE
027CC:  MOVLW  D5
027CE:  MOVWF  xDD
027D0:  MOVLW  4F
027D2:  MOVWF  xDF
027D4:  MOVLB  0
027D6:  RCALL  2612
.................... 		/* always null terminate final character */ 
.................... 		nmea.sentence[11][NMEA_SENTENCE_LENGTH-1]='\0'; 
027D8:  MOVLB  6
027DA:  CLRF   xBE
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
027DC:  MOVLB  8
027DE:  MOVF   xD5,W
027E0:  SUBLW  05
027E2:  BNC   27E6
.................... 			return; 
027E4:  BRA    2870
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
027E6:  CLRF   xD8
027E8:  MOVF   xD8,W
027EA:  SUBLW  0B
027EC:  BNC   2870
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
027EE:  MOVF   xD8,W
027F0:  MULLW  06
027F2:  MOVF   FF3,W
027F4:  CLRF   03
027F6:  ADDLW  4E
027F8:  MOVWF  01
027FA:  MOVLW  00
027FC:  ADDWFC 03,F
027FE:  MOVFF  01,8D9
02802:  MOVFF  03,8DA
02806:  MOVLW  07
02808:  MOVWF  xDC
0280A:  MOVLW  D5
0280C:  MOVWF  xDB
0280E:  MOVFF  03,8DE
02812:  MOVFF  01,8DD
02816:  CLRF   xE0
02818:  MOVLW  06
0281A:  MOVWF  xDF
0281C:  MOVLB  0
0281E:  BRA    26B8
02820:  MOVF   01,F
02822:  BZ    2826
.................... 				/* no match */ 
.................... 				continue; 
02824:  BRA    286A
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,NMEA_SENTENCE_LENGTH-1); 
02826:  MOVLB  8
02828:  CLRF   xDA
0282A:  MOVFF  8D8,8D9
0282E:  CLRF   xDC
02830:  MOVLW  50
02832:  MOVWF  xDB
02834:  MOVLB  0
02836:  CALL   081A
0283A:  MOVFF  02,03
0283E:  MOVF   01,W
02840:  ADDLW  FF
02842:  MOVWF  01
02844:  MOVLW  02
02846:  ADDWFC 03,F
02848:  MOVFF  01,8D9
0284C:  MOVLB  8
0284E:  MOVFF  03,8DA
02852:  MOVFF  03,8DC
02856:  MOVFF  01,8DB
0285A:  MOVLW  07
0285C:  MOVWF  xDE
0285E:  MOVLW  D5
02860:  MOVWF  xDD
02862:  MOVLW  4F
02864:  MOVWF  xDF
02866:  MOVLB  0
02868:  RCALL  2612
.................... 		} 
0286A:  MOVLB  8
0286C:  INCF   xD8,F
0286E:  BRA    27E8
02870:  MOVLB  2
.................... 	} 
.................... } 
02872:  MOVLB  0
02874:  GOTO   2AAA (RETURN)
....................  
....................  
.................... void main(void) { 
02878:  CLRF   FF8
0287A:  BCF    FF1.2
0287C:  BSF    F9F.1
0287E:  BCF    F9F.5
02880:  BCF    FA5.5
02882:  BSF    FD0.7
02884:  BSF    07.7
02886:  CLRF   FEA
02888:  CLRF   FE9
0288A:  CLRF   35
0288C:  BCF    FB8.3
0288E:  MOVLW  0C
02890:  MOVWF  FAF
02892:  MOVLW  A6
02894:  MOVWF  FAC
02896:  MOVLW  90
02898:  MOVWF  FAB
0289A:  BCF    F70.3
0289C:  MOVLW  4D
0289E:  MOVWF  F75
028A0:  MOVLW  A6
028A2:  MOVWF  F72
028A4:  MOVLW  90
028A6:  MOVWF  F71
028A8:  MOVLB  6
028AA:  BCF    xBF.0
028AC:  CLRF   xC0
028AE:  MOVLB  7
028B0:  CLRF   xCA
028B2:  MOVLB  6
028B4:  BCF    xBF.1
028B6:  BCF    xBF.2
028B8:  BCF    xBF.3
028BA:  BCF    xBF.4
028BC:  BCF    xBF.5
028BE:  BCF    xBF.6
028C0:  MOVLB  7
028C2:  CLRF   xCB
028C4:  CLRF   xCD
028C6:  CLRF   xCC
028C8:  CLRF   xCF
028CA:  CLRF   xCE
028CC:  CLRF   xD1
028CE:  CLRF   xD0
028D0:  MOVF   FC1,W
028D2:  ANDLW  F0
028D4:  MOVWF  FC1
028D6:  MOVLW  00
028D8:  MOVLB  F
028DA:  MOVWF  x38
028DC:  MOVWF  x3C
028DE:  MOVWF  x39
028E0:  MOVWF  x3A
028E2:  MOVWF  x3B
028E4:  MOVLB  1
028E6:  CLRF   x88
028E8:  CLRF   F77
028EA:  CLRF   F78
028EC:  CLRF   F79
028EE:  CLRF   2F
028F0:  CLRF   30
028F2:  MOVLB  7
028F4:  CLRF   xC6
028F6:  CLRF   xC7
028F8:  CLRF   xC8
028FA:  CLRF   xC9
028FC:  CLRF   xD2
028FE:  CLRF   xD3
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02900:  MOVF   FD0,W
02902:  ANDLW  0F
02904:  BTFSS  FD0.4
02906:  MOVLW  00
02908:  BSF    FD0.0
0290A:  BSF    FD0.1
0290C:  BSF    FD0.4
0290E:  BSF    FD8.3
02910:  BSF    FD8.4
02912:  MOVWF  xD4
....................  
.................... 	init(); 
02914:  MOVLB  0
02916:  GOTO   0856
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
0291A:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
0291C:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
0291E:  MOVLW  5C
02920:  MOVWF  FF6
02922:  MOVLW  07
02924:  MOVWF  FF7
02926:  MOVLW  07
02928:  MOVLB  7
0292A:  MOVWF  xD5
0292C:  MOVLB  0
0292E:  CALL   09B4
02932:  MOVLW  68
02934:  MOVWF  FF6
02936:  MOVLW  07
02938:  MOVWF  FF7
0293A:  CALL   09DE
0293E:  MOVLW  0D
02940:  BTFSS  FA4.4
02942:  BRA    2940
02944:  MOVWF  F73
02946:  MOVLW  0A
02948:  BTFSS  FA4.4
0294A:  BRA    2948
0294C:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
0294E:  MOVLW  72
02950:  MOVWF  FF6
02952:  MOVLW  07
02954:  MOVWF  FF7
02956:  MOVLW  12
02958:  MOVLB  7
0295A:  MOVWF  xD5
0295C:  MOVLB  0
0295E:  CALL   09B4
02962:  MOVFF  7D4,7D5
02966:  MOVLW  1B
02968:  MOVLB  7
0296A:  MOVWF  xD6
0296C:  MOVLB  0
0296E:  GOTO   0A2C
02972:  MOVLW  20
02974:  BTFSS  FA4.4
02976:  BRA    2974
02978:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
0297A:  MOVLB  7
0297C:  MOVF   xD4,W
0297E:  XORLW  07
02980:  MOVLB  0
02982:  BZ    299E
02984:  XORLW  0C
02986:  BZ    29AC
02988:  XORLW  04
0298A:  BZ    29BA
0298C:  XORLW  03
0298E:  BZ    29C8
02990:  XORLW  02
02992:  BZ    29D6
02994:  XORLW  0D
02996:  BZ    29E4
02998:  XORLW  03
0299A:  BZ    29F2
0299C:  BRA    2A00
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
0299E:  MOVLW  88
029A0:  MOVWF  FF6
029A2:  MOVLW  07
029A4:  MOVWF  FF7
029A6:  CALL   09DE
029AA:  BRA    2A0C
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
029AC:  MOVLW  94
029AE:  MOVWF  FF6
029B0:  MOVLW  07
029B2:  MOVWF  FF7
029B4:  CALL   09DE
029B8:  BRA    2A0C
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
029BA:  MOVLW  A4
029BC:  MOVWF  FF6
029BE:  MOVLW  07
029C0:  MOVWF  FF7
029C2:  CALL   09DE
029C6:  BRA    2A0C
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
029C8:  MOVLW  B2
029CA:  MOVWF  FF6
029CC:  MOVLW  07
029CE:  MOVWF  FF7
029D0:  CALL   09DE
029D4:  BRA    2A0C
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
029D6:  MOVLW  C2
029D8:  MOVWF  FF6
029DA:  MOVLW  07
029DC:  MOVWF  FF7
029DE:  CALL   09DE
029E2:  BRA    2A0C
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
029E4:  MOVLW  D4
029E6:  MOVWF  FF6
029E8:  MOVLW  07
029EA:  MOVWF  FF7
029EC:  CALL   09DE
029F0:  BRA    2A0C
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
029F2:  MOVLW  E4
029F4:  MOVWF  FF6
029F6:  MOVLW  07
029F8:  MOVWF  FF7
029FA:  CALL   09DE
029FE:  BRA    2A0C
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
02A00:  MOVLW  F6
02A02:  MOVWF  FF6
02A04:  MOVLW  07
02A06:  MOVWF  FF7
02A08:  CALL   09DE
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
02A0C:  MOVLW  00
02A0E:  MOVWF  FF6
02A10:  MOVLW  08
02A12:  MOVWF  FF7
02A14:  CALL   09DE
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02A18:  GOTO   0CB0
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02A1C:  MOVF   36,W
02A1E:  SUBLW  80
02A20:  BC    2A26
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02A22:  CALL   0C38
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02A26:  BSF    FAB.7
02A28:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02A2A:  GOTO   0D0E
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02A2E:  MOVLB  7
02A30:  CLRF   xD4
02A32:  MOVF   xD4,W
02A34:  SUBLW  1D
02A36:  BNC   2A44
.................... 		adc_update(); 
02A38:  MOVLB  0
02A3A:  CALL   0DCC
.................... 	} 
02A3E:  MOVLB  7
02A40:  INCF   xD4,F
02A42:  BRA    2A32
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02A44:  MOVFF  43,1DA
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
02A48:  BTFSS  F72.1
02A4A:  BRA    2A48
.................... 	output_low(RS485_DE); 
02A4C:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02A4E:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02A50:  MOVLW  04
02A52:  MOVWF  FF6
02A54:  MOVLW  08
02A56:  MOVWF  FF7
02A58:  MOVLW  07
02A5A:  MOVWF  xD5
02A5C:  MOVLB  0
02A5E:  GOTO   0E74
02A62:  MOVLW  10
02A64:  MOVWF  FF6
02A66:  MOVLW  08
02A68:  MOVWF  FF7
02A6A:  GOTO   0EA0
02A6E:  MOVLW  0D
02A70:  BTFSS  F9E.4
02A72:  BRA    2A70
02A74:  MOVWF  FAD
02A76:  MOVLW  0A
02A78:  BTFSS  F9E.4
02A7A:  BRA    2A78
02A7C:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02A7E:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
02A80:  MOVLB  1
02A82:  BTFSS  xF9.2
02A84:  BRA    2A8E
.................... 			periodic_millisecond(); 
02A86:  MOVLB  0
02A88:  GOTO   0F4C
02A8C:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02A8E:  BTFSS  xF9.0
02A90:  BRA    2A9A
.................... 			timers.now_adc_sample=0; 
02A92:  BCF    xF9.0
.................... 			adc_update(); 
02A94:  MOVLB  0
02A96:  CALL   0DCC
.................... 		} 
....................  
.................... 		modbus_process(); 
02A9A:  MOVLB  0
02A9C:  BRA    2320
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
02A9E:  MOVLB  1
02AA0:  BTFSS  xFC.0
02AA2:  BRA    2AAC
.................... 			timers.now_parse_rda2=0; 
02AA4:  BCF    xFC.0
.................... 			rs485_to_host(); 
02AA6:  MOVLB  0
02AA8:  BRA    2750
02AAA:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
02AAC:  MOVLB  0
02AAE:  BRA    2A7E
.................... } 
02AB0:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
