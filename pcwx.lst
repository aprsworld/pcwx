CCS PCH C Compiler, Version 4.135, 4375               02-Nov-15 06:38

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 8392 bytes (13%)
                         Largest free fragment is 57140
               RAM used: 711 (18%) at main() level
                         746 (19%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   1FD0
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03B0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   068C
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   0630
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   03E2
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=WEATHER_X_BAUD,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00640:  BTFSS  F9E.5
00642:  BRA    0640
00644:  MOVFF  FAB,35
00648:  MOVFF  FAE,01
0064C:  BTFSS  35.1
0064E:  BRA    0654
00650:  BCF    FAB.4
00652:  BSF    FAB.4
00654:  RETURN 0
*
00E78:  BTFSS  F9E.4
00E7A:  BRA    0E78
00E7C:  MOVWF  FAD
00E7E:  GOTO   0E8A (RETURN)
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00618:  BTFSS  FA4.5
0061A:  BRA    0618
0061C:  MOVFF  F71,35
00620:  MOVFF  F74,01
00624:  BTFSS  35.1
00626:  BRA    062C
00628:  BCF    F71.4
0062A:  BSF    F71.4
0062C:  GOTO   0632 (RETURN)
*
00656:  BTFSS  FA4.4
00658:  BRA    0656
0065A:  MOVWF  F73
0065C:  GOTO   06A0 (RETURN)
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
.................... 	int8 modbus_bridge; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
.................... } struct_time_keep; 
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00B32:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00A92:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00A94:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00A96:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00A98:  MOVLB  2
00A9A:  MOVF   xCA,F
00A9C:  BNZ   0AA4
.................... 		c=0b00011; 
00A9E:  MOVLW  03
00AA0:  MOVWF  xCE
.................... 	else if ( 1 == ch )  
00AA2:  BRA    0AEE
00AA4:  DECFSZ xCA,W
00AA6:  BRA    0AAE
.................... 		c=0b10011; 
00AA8:  MOVLW  13
00AAA:  MOVWF  xCE
.................... 	else if ( 2 == ch )  
00AAC:  BRA    0AEE
00AAE:  MOVF   xCA,W
00AB0:  SUBLW  02
00AB2:  BNZ   0ABA
.................... 		c=0b01011; 
00AB4:  MOVLW  0B
00AB6:  MOVWF  xCE
.................... 	else if ( 3 == ch )  
00AB8:  BRA    0AEE
00ABA:  MOVF   xCA,W
00ABC:  SUBLW  03
00ABE:  BNZ   0AC6
.................... 		c=0b11011; 
00AC0:  MOVLW  1B
00AC2:  MOVWF  xCE
.................... 	else if ( 4 == ch ) 
00AC4:  BRA    0AEE
00AC6:  MOVF   xCA,W
00AC8:  SUBLW  04
00ACA:  BNZ   0AD2
.................... 		c=0b00111; 
00ACC:  MOVLW  07
00ACE:  MOVWF  xCE
.................... 	else if ( 5 == ch )  
00AD0:  BRA    0AEE
00AD2:  MOVF   xCA,W
00AD4:  SUBLW  05
00AD6:  BNZ   0ADE
.................... 		c=0b10111; 
00AD8:  MOVLW  17
00ADA:  MOVWF  xCE
.................... 	else if ( 6 == ch ) 
00ADC:  BRA    0AEE
00ADE:  MOVF   xCA,W
00AE0:  SUBLW  06
00AE2:  BNZ   0AEA
.................... 		c=0b01111; 
00AE4:  MOVLW  0F
00AE6:  MOVWF  xCE
.................... 	else 
00AE8:  BRA    0AEE
.................... 		c=0b11111; 
00AEA:  MOVLW  1F
00AEC:  MOVWF  xCE
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00AEE:  CLRF   xCD
00AF0:  MOVF   xCD,W
00AF2:  SUBLW  04
00AF4:  BNC   0B0C
.................... 		output_low(MCP3208_CLK); 
00AF6:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00AF8:  BTFSC  xCE.0
00AFA:  BRA    0B00
00AFC:  BCF    F8B.5
00AFE:  BRA    0B02
00B00:  BSF    F8B.5
.................... 		c=c>>1; 
00B02:  BCF    FD8.0
00B04:  RRCF   xCE,F
.................... 		output_high(MCP3208_CLK); 
00B06:  BSF    F8B.3
.................... 	} 
00B08:  INCF   xCD,F
00B0A:  BRA    0AF0
....................  
....................  
.................... 	value=0; 
00B0C:  CLRF   xCC
00B0E:  CLRF   xCB
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00B10:  CLRF   xCD
00B12:  MOVF   xCD,W
00B14:  SUBLW  0D
00B16:  BNC   0B2E
.................... 		output_low(MCP3208_CLK); 
00B18:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00B1A:  BTFSC  F82.4
00B1C:  BRA    0B22
00B1E:  BCF    FD8.0
00B20:  BRA    0B24
00B22:  BSF    FD8.0
00B24:  RLCF   xCB,F
00B26:  RLCF   xCC,F
.................... 		output_high(MCP3208_CLK); 
00B28:  BSF    F8B.3
.................... 	} 
00B2A:  INCF   xCD,F
00B2C:  BRA    0B12
....................  
.................... 	bit_clear(value,13); 
00B2E:  BCF    xCC.5
.................... 	bit_clear(value,12); 
00B30:  BCF    xCC.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00B34:  MOVFF  2CB,01
00B38:  MOVFF  2CC,02
.................... } 
00B3C:  MOVLB  0
00B3E:  GOTO   0BAE (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00BE8:  MOVLB  2
00BEA:  CLRF   xE2
00BEC:  MOVFF  2DB,2E1
00BF0:  CLRF   xE4
00BF2:  MOVLW  20
00BF4:  MOVWF  xE3
00BF6:  MOVLB  0
00BF8:  RCALL  0706
00BFA:  MOVFF  02,03
00BFE:  MOVF   01,W
00C00:  ADDLW  82
00C02:  MOVWF  01
00C04:  MOVLW  00
00C06:  ADDWFC 03,F
00C08:  MOVFF  01,2DF
00C0C:  MOVLB  2
00C0E:  MOVFF  03,2E0
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00C12:  CLRF   xDD
00C14:  CLRF   xDC
.................... 	for( i = 0; i < 16 ; i++ ) { 
00C16:  CLRF   xDE
00C18:  MOVF   xDE,W
00C1A:  SUBLW  0F
00C1C:  BNC   0C40
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00C1E:  BCF    FD8.0
00C20:  RLCF   xDE,W
00C22:  CLRF   03
00C24:  ADDWF  xDF,W
00C26:  MOVWF  FE9
00C28:  MOVF   xE0,W
00C2A:  ADDWFC 03,W
00C2C:  MOVWF  FEA
00C2E:  MOVFF  FEC,03
00C32:  MOVF   FED,F
00C34:  MOVF   FEF,W
00C36:  ADDWF  xDC,F
00C38:  MOVF   03,W
00C3A:  ADDWFC xDD,F
.................... 	} 
00C3C:  INCF   xDE,F
00C3E:  BRA    0C18
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00C40:  MOVLW  08
00C42:  ADDWF  xDC,W
00C44:  MOVWF  xE1
00C46:  MOVLW  00
00C48:  ADDWFC xDD,W
00C4A:  MOVWF  xE2
00C4C:  RRCF   xE2,W
00C4E:  MOVWF  03
00C50:  RRCF   xE1,W
00C52:  MOVWF  02
00C54:  RRCF   03,F
00C56:  RRCF   02,F
00C58:  RRCF   03,F
00C5A:  RRCF   02,F
00C5C:  RRCF   03,F
00C5E:  RRCF   02,F
00C60:  MOVLW  0F
00C62:  ANDWF  03,F
00C64:  MOVFF  02,01
00C68:  MOVFF  03,02
.................... } 
00C6C:  MOVLB  0
00C6E:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00B42:  MOVLB  1
00B44:  INCF   x82,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00B46:  MOVF   x82,W
00B48:  SUBLW  0F
00B4A:  BC    0B4E
.................... 		current.adc_buffer_index=0; 
00B4C:  CLRF   x82
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00B4E:  MOVLB  2
00B50:  CLRF   xC7
00B52:  MOVF   xC7,W
00B54:  SUBLW  07
00B56:  BNC   0BE4
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00B58:  CLRF   xE2
00B5A:  MOVFF  2C7,2E1
00B5E:  CLRF   xE4
00B60:  MOVLW  20
00B62:  MOVWF  xE3
00B64:  MOVLB  0
00B66:  RCALL  0706
00B68:  MOVFF  02,03
00B6C:  MOVF   01,W
00B6E:  ADDLW  34
00B70:  MOVLB  2
00B72:  MOVWF  xC8
00B74:  MOVLW  00
00B76:  ADDWFC 02,W
00B78:  MOVWF  xC9
00B7A:  CLRF   03
00B7C:  MOVLB  1
00B7E:  MOVFF  182,02
00B82:  BCF    FD8.0
00B84:  RLCF   02,F
00B86:  RLCF   03,F
00B88:  MOVF   02,W
00B8A:  MOVLB  2
00B8C:  ADDWF  xC8,W
00B8E:  MOVWF  01
00B90:  MOVF   xC9,W
00B92:  ADDWFC 03,F
00B94:  MOVF   01,W
00B96:  ADDLW  4E
00B98:  MOVWF  01
00B9A:  MOVLW  00
00B9C:  ADDWFC 03,F
00B9E:  MOVFF  01,2C8
00BA2:  MOVFF  03,2C9
00BA6:  MOVFF  2C7,2CA
00BAA:  MOVLB  0
00BAC:  BRA    0A92
00BAE:  MOVFF  2C9,FEA
00BB2:  MOVFF  2C8,FE9
00BB6:  MOVFF  02,FEC
00BBA:  MOVF   FED,F
00BBC:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00BC0:  CLRF   03
00BC2:  MOVLB  2
00BC4:  MOVFF  2C7,02
00BC8:  BCF    FD8.0
00BCA:  RLCF   02,F
00BCC:  RLCF   03,F
00BCE:  MOVF   02,W
00BD0:  ADDLW  72
00BD2:  MOVWF  FE9
00BD4:  MOVLW  00
00BD6:  ADDWFC 03,W
00BD8:  MOVWF  FEA
00BDA:  CLRF   FEC
00BDC:  MOVF   FED,F
00BDE:  CLRF   FEF
....................  
.................... 	} 
00BE0:  INCF   xC7,F
00BE2:  BRA    0B52
.................... } 
00BE4:  MOVLB  0
00BE6:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
008D8:  MOVF   xE2,W
008DA:  XORWF  xE3,W
008DC:  MOVWF  01
*
0092A:  MOVF   xE2,W
0092C:  XORWF  xE3,W
0092E:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00862:  MOVLB  2
00864:  CLRF   xD0
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00866:  MOVFF  2CF,03
0086A:  MOVF   xCE,W
0086C:  BTFSC  FD8.2
0086E:  DECF   xCF,F
00870:  DECF   xCE,F
00872:  MOVWF  xD1
00874:  MOVFF  03,2D2
00878:  MOVF   xD1,F
0087A:  BNZ   0880
0087C:  MOVF   xD2,F
0087E:  BZ    08EA
.................... 		*data = read_eeprom( address++ ); 
00880:  MOVFF  2CD,03
00884:  MOVF   xCC,W
00886:  MOVWF  FE9
00888:  MOVFF  03,FEA
0088C:  MOVF   xCB,W
0088E:  MOVWF  03
00890:  MOVF   xCA,W
00892:  INCF   xCA,F
00894:  BTFSC  FD8.2
00896:  INCF   xCB,F
00898:  MOVWF  xD3
0089A:  MOVFF  03,2D4
0089E:  MOVFF  FF2,2D5
008A2:  BCF    FF2.6
008A4:  BCF    FF2.7
008A6:  MOVFF  2D4,FAA
008AA:  MOVFF  2D3,FA9
008AE:  BCF    FA6.6
008B0:  BCF    FA6.7
008B2:  BSF    FA6.0
008B4:  MOVF   FA8,W
008B6:  BTFSC  xD5.6
008B8:  BSF    FF2.6
008BA:  BTFSC  xD5.7
008BC:  BSF    FF2.7
008BE:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
008C0:  MOVFF  2CD,03
008C4:  MOVF   xCC,W
008C6:  MOVWF  FE9
008C8:  MOVFF  03,FEA
008CC:  MOVFF  FEF,2D1
008D0:  MOVFF  2D0,2E2
008D4:  MOVFF  2D1,2E3
*
008DE:  MOVFF  01,2D0
.................... 		data++; 
008E2:  INCF   xCC,F
008E4:  BTFSC  FD8.2
008E6:  INCF   xCD,F
.................... 	} 
008E8:  BRA    0866
.................... 	return crc; 
008EA:  MOVFF  2D0,01
.................... } 
008EE:  MOVLB  0
008F0:  GOTO   0A46 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
008F4:  MOVLB  2
008F6:  CLRF   xE0
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
008F8:  MOVFF  2DF,03
008FC:  MOVF   xDE,W
008FE:  BTFSC  FD8.2
00900:  DECF   xDF,F
00902:  DECF   xDE,F
00904:  MOVWF  xE1
00906:  MOVFF  03,2E2
0090A:  MOVF   xE1,F
0090C:  BNZ   0912
0090E:  MOVF   xE2,F
00910:  BZ    0990
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00912:  MOVFF  2DD,03
00916:  MOVF   xDC,W
00918:  MOVWF  FE9
0091A:  MOVFF  03,FEA
0091E:  MOVFF  FEF,2E1
00922:  MOVFF  2E0,2E2
00926:  MOVFF  2E1,2E3
*
00930:  MOVFF  01,2E0
.................... 		write_eeprom( address++, *data++ ); 
00934:  MOVF   xDB,W
00936:  MOVWF  03
00938:  MOVF   xDA,W
0093A:  INCF   xDA,F
0093C:  BTFSC  FD8.2
0093E:  INCF   xDB,F
00940:  MOVWF  xE1
00942:  MOVFF  03,2E2
00946:  MOVF   xDD,W
00948:  MOVWF  03
0094A:  MOVF   xDC,W
0094C:  INCF   xDC,F
0094E:  BTFSC  FD8.2
00950:  INCF   xDD,F
00952:  MOVWF  FE9
00954:  MOVFF  03,FEA
00958:  MOVFF  FEF,2E3
0095C:  MOVFF  2E2,FAA
00960:  MOVFF  2E1,FA9
00964:  MOVFF  2E3,FA8
00968:  BCF    FA6.6
0096A:  BCF    FA6.7
0096C:  BSF    FA6.2
0096E:  MOVF   FF2,W
00970:  MOVWF  00
00972:  BCF    FF2.6
00974:  BCF    FF2.7
00976:  MOVLB  F
00978:  MOVLW  55
0097A:  MOVWF  FA7
0097C:  MOVLW  AA
0097E:  MOVWF  FA7
00980:  BSF    FA6.1
00982:  BTFSC  FA6.1
00984:  BRA    0982
00986:  BCF    FA6.2
00988:  MOVF   00,W
0098A:  IORWF  FF2,F
.................... 	} 
0098C:  MOVLB  2
0098E:  BRA    08F8
....................  
.................... 	return crc; 
00990:  MOVFF  2E0,01
.................... } 
00994:  MOVLB  0
00996:  GOTO   09BA (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
0099A:  MOVLB  2
0099C:  CLRF   xD9
0099E:  MOVLW  36
009A0:  MOVWF  xD8
009A2:  CLRF   xDB
009A4:  MOVLW  02
009A6:  MOVWF  xDA
009A8:  MOVFF  2D9,2DD
009AC:  MOVFF  2D8,2DC
009B0:  CLRF   xDF
009B2:  MOVLW  18
009B4:  MOVWF  xDE
009B6:  MOVLB  0
009B8:  BRA    08F4
009BA:  MOVFF  01,2D7
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
009BE:  CLRF   FAA
009C0:  CLRF   FA9
009C2:  MOVFF  2D7,FA8
009C6:  BCF    FA6.6
009C8:  BCF    FA6.7
009CA:  BSF    FA6.2
009CC:  MOVF   FF2,W
009CE:  MOVWF  00
009D0:  BCF    FF2.6
009D2:  BCF    FF2.7
009D4:  MOVLB  F
009D6:  MOVLW  55
009D8:  MOVWF  FA7
009DA:  MOVLW  AA
009DC:  MOVWF  FA7
009DE:  BSF    FA6.1
009E0:  BTFSC  FA6.1
009E2:  BRA    09E0
009E4:  BCF    FA6.2
009E6:  MOVF   00,W
009E8:  IORWF  FF2,F
.................... } 
009EA:  MOVLB  0
009EC:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
009EE:  MOVLW  96
009F0:  MOVLB  1
009F2:  MOVWF  xAB
....................  
.................... 	config.modbus_address=38; 
009F4:  MOVLW  26
009F6:  MOVWF  36
.................... 	config.modbus_bridge=1; 
009F8:  MOVLW  01
009FA:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
009FC:  MOVLW  50
009FE:  MOVWF  39
.................... 	config.serial_number=9876; 
00A00:  MOVLW  26
00A02:  MOVWF  3B
00A04:  MOVLW  94
00A06:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00A08:  CLRF   3D
00A0A:  MOVLW  14
00A0C:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00A0E:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00A10:  MOVLW  02
00A12:  MOVWF  40
00A14:  MOVLW  76
00A16:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00A18:  CLRF   42
00A1A:  MOVLW  02
00A1C:  MOVWF  41
.................... 	config.power_startup=0; 
00A1E:  CLRF   43
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00A20:  MOVLB  0
00A22:  RCALL  099A
....................  
.................... } 
00A24:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00A26:  MOVLB  2
00A28:  CLRF   xC9
00A2A:  MOVLW  36
00A2C:  MOVWF  xC8
00A2E:  CLRF   xCB
00A30:  MOVLW  02
00A32:  MOVWF  xCA
00A34:  MOVFF  2C9,2CD
00A38:  MOVFF  2C8,2CC
00A3C:  CLRF   xCF
00A3E:  MOVLW  18
00A40:  MOVWF  xCE
00A42:  MOVLB  0
00A44:  BRA    0862
00A46:  MOVFF  01,2C7
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00A4A:  MOVFF  FF2,2C8
00A4E:  BCF    FF2.6
00A50:  BCF    FF2.7
00A52:  CLRF   FAA
00A54:  CLRF   FA9
00A56:  BCF    FA6.6
00A58:  BCF    FA6.7
00A5A:  BSF    FA6.0
00A5C:  MOVF   FA8,W
00A5E:  MOVLB  2
00A60:  BTFSC  xC8.6
00A62:  BSF    FF2.6
00A64:  BTFSC  xC8.7
00A66:  BSF    FF2.7
00A68:  SUBWF  xC7,W
00A6A:  BZ    0A72
.................... 		write_default_param_file(); 
00A6C:  MOVLB  0
00A6E:  RCALL  09EE
00A70:  MOVLB  2
.................... 	} 
.................... } 
00A72:  MOVLB  0
00A74:  GOTO   207A (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
00EDC:  BTFSS  FAC.1
00EDE:  BRA    0EDC
.................... } 
00EE0:  GOTO   0EFA (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00A78:  BTFSS  F9E.5
00A7A:  BRA    0A80
.................... 		fgetc(STREAM_PI); 
00A7C:  RCALL  0640
.................... 	} 
00A7E:  BRA    0A78
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00A80:  BSF    F9D.5
.................... } 
00A82:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00A84:  RCALL  0A78
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00A86:  MOVLW  C6
00A88:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00A8A:  MOVLW  C0
00A8C:  IORWF  FF2,F
.................... } 
00A8E:  GOTO   208C (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0039C:  BCF    FF2.5
.................... 	if (enable) { 
0039E:  MOVLB  2
003A0:  MOVF   xE7,F
003A2:  BZ    03AC
.................... 		set_timer0(0); 
003A4:  CLRF   FD7
003A6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003A8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003AA:  BSF    FF2.5
.................... 	} 
.................... } 
003AC:  MOVLB  0
003AE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003B0:  MOVLB  1
003B2:  MOVF   xB2,W
003B4:  SUBLW  02
003B6:  BNZ   03CC
003B8:  MOVF   xB3,F
003BA:  BNZ   03CC
003BC:  MOVF   xB4,F
003BE:  BNZ   03CC
003C0:  BTFSC  xB1.0
003C2:  BRA    03CC
....................    { 
....................       modbus_rx.len-=2; 
003C4:  MOVLW  02
003C6:  SUBWF  xB6,F
....................       modbus_serial_new=TRUE; 
003C8:  BSF    xB1.0
....................    } 
....................    else 
003CA:  BRA    03CE
....................       modbus_serial_new=FALSE; 
003CC:  BCF    xB1.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003CE:  SETF   xB4
003D0:  SETF   xB3
....................    modbus_serial_state=MODBUS_GETADDY; 
003D2:  CLRF   xB2
....................    modbus_enable_timeout(FALSE); 
003D4:  MOVLB  2
003D6:  CLRF   xE7
003D8:  MOVLB  0
003DA:  RCALL  039C
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003DC:  BCF    FF2.2
003DE:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00660:  MOVLB  1
00662:  MOVF   xB4,W
00664:  MOVLB  2
00666:  XORWF  xE7,W
00668:  MOVWF  xE8
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0066A:  CLRF   03
0066C:  MOVF   xE8,W
0066E:  MOVLB  0
00670:  RCALL  017C
00672:  MOVWF  01
00674:  MOVLB  1
00676:  MOVF   xB3,W
00678:  XORWF  01,W
0067A:  MOVWF  xB4
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0067C:  CLRF   03
0067E:  MOVLB  2
00680:  MOVF   xE8,W
00682:  MOVLB  0
00684:  RCALL  028C
00686:  MOVFF  FE8,1B3
.................... } 
0068A:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
00E82:  MOVLB  2
00E84:  MOVF   xD9,W
00E86:  MOVLB  0
00E88:  BRA    0E78
00E8A:  CLRF   19
00E8C:  BTFSC  FF2.6
00E8E:  BSF    19.6
00E90:  BCF    FF2.6
00E92:  BTFSC  FF2.7
00E94:  BSF    19.7
00E96:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
00E98:  MOVFF  2D9,2E7
00E9C:  CALL   0660
00EA0:  BTFSC  19.6
00EA2:  BSF    FF2.6
00EA4:  BTFSC  19.7
00EA6:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
00EA8:  CLRWDT
00EAA:  MOVLW  08
00EAC:  MOVWF  00
00EAE:  DECFSZ 00,F
00EB0:  BRA    0EAE
00EB2:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
00EB4:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
00EB6:  MOVLB  1
00EB8:  SETF   xB4
00EBA:  SETF   xB3
....................    modbus_serial_new=FALSE; 
00EBC:  BCF    xB1.0
....................  
....................    RCV_OFF(); 
00EBE:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
00EC0:  CLRWDT
00EC2:  MOVLW  1E
00EC4:  MOVWF  00
00EC6:  DECFSZ 00,F
00EC8:  BRA    0EC6
00ECA:  NOP   
....................  
....................    modbus_serial_putc(to); 
00ECC:  MOVFF  2D7,2D9
00ED0:  MOVLB  0
00ED2:  RCALL  0E82
....................    modbus_serial_putc(func); 
00ED4:  MOVFF  2D8,2D9
00ED8:  RCALL  0E82
.................... } 
00EDA:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
00EE4:  MOVFF  1B4,2D8
....................    crc_low=modbus_serial_crc.b[0]; 
00EE8:  MOVFF  1B3,2D7
....................  
....................    modbus_serial_putc(crc_high); 
00EEC:  MOVFF  2D8,2D9
00EF0:  RCALL  0E82
....................    modbus_serial_putc(crc_low); 
00EF2:  MOVFF  2D7,2D9
00EF6:  RCALL  0E82
....................  
....................    WAIT_FOR_HW_BUFFER(); 
00EF8:  BRA    0EDC
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
00EFA:  CLRWDT
00EFC:  MOVLW  1E
00EFE:  MOVWF  00
00F00:  DECFSZ 00,F
00F02:  BRA    0F00
00F04:  NOP   
....................  
....................  
....................    RCV_ON(); 
00F06:  RCALL  0A78
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
00F08:  MOVLB  1
00F0A:  SETF   xB4
00F0C:  SETF   xB3
.................... } 
00F0E:  MOVLB  0
00F10:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00DD0:  MOVLB  1
00DD2:  BTFSC  xB1.0
00DD4:  BRA    0DDE
....................       return FALSE; 
00DD6:  MOVLW  00
00DD8:  MOVWF  01
00DDA:  BRA    0DF0
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00DDC:  BRA    0DEA
00DDE:  BTFSS  xB7.7
00DE0:  BRA    0DEA
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00DE2:  MOVFF  1B9,1B8
....................       modbus_rx.len = 1; 
00DE6:  MOVLW  01
00DE8:  MOVWF  xB6
....................    } 
....................    modbus_serial_new=FALSE; 
00DEA:  BCF    xB1.0
....................    return TRUE; 
00DEC:  MOVLW  01
00DEE:  MOVWF  01
.................... } 
00DF0:  MOVLB  0
00DF2:  GOTO   1D8A (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01CF6:  MOVFF  2CF,2D7
01CFA:  MOVLW  06
01CFC:  MOVLB  2
01CFE:  MOVWF  xD8
01D00:  MOVLB  0
01D02:  CALL   0EB6
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01D06:  MOVFF  2D1,2D4
01D0A:  MOVFF  2D1,2D9
01D0E:  CALL   0E82
....................    modbus_serial_putc(make8(reg_address,0)); 
01D12:  MOVFF  2D0,2D4
01D16:  MOVFF  2D0,2D9
01D1A:  CALL   0E82
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01D1E:  MOVFF  2D3,2D4
01D22:  MOVFF  2D3,2D9
01D26:  CALL   0E82
....................    modbus_serial_putc(make8(reg_value,0)); 
01D2A:  MOVFF  2D2,2D4
01D2E:  MOVFF  2D2,2D9
01D32:  CALL   0E82
....................  
....................    modbus_serial_send_stop(); 
01D36:  CALL   0EE4
.................... } 
01D3A:  GOTO   1ECA (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01D3E:  MOVFF  2CD,2D7
01D42:  MOVLW  10
01D44:  MOVLB  2
01D46:  MOVWF  xD8
01D48:  MOVLB  0
01D4A:  CALL   0EB6
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01D4E:  MOVFF  2CF,2D2
01D52:  MOVFF  2CF,2D9
01D56:  CALL   0E82
....................    modbus_serial_putc(make8(start_address,0)); 
01D5A:  MOVFF  2CE,2D2
01D5E:  MOVFF  2CE,2D9
01D62:  CALL   0E82
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01D66:  MOVFF  2D1,2D2
01D6A:  MOVFF  2D1,2D9
01D6E:  CALL   0E82
....................    modbus_serial_putc(make8(quantity,0)); 
01D72:  MOVFF  2D0,2D2
01D76:  MOVFF  2D0,2D9
01D7A:  CALL   0E82
....................  
....................    modbus_serial_send_stop(); 
01D7E:  CALL   0EE4
.................... } 
01D82:  GOTO   1F8C (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
00F12:  MOVLB  2
00F14:  MOVF   xCE,W
00F16:  IORLW  80
00F18:  MOVWF  xD1
00F1A:  MOVFF  2CF,2D2
00F1E:  MOVFF  2CD,2D7
00F22:  MOVWF  xD8
00F24:  MOVLB  0
00F26:  RCALL  0EB6
....................    modbus_serial_putc(error); 
00F28:  MOVFF  2D0,2D9
00F2C:  RCALL  0E82
....................    modbus_serial_send_stop(); 
00F2E:  RCALL  0EE4
.................... } 
00F30:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1012 
....................  
.................... #define MIN_EE_REGISTER      2000 
.................... #define MAX_EE_REGISTER      MIN_EE_REGISTER + 512 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
00FF8:  MOVLB  1
00FFA:  CLRF   x84
00FFC:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
00FFE:  CLRF   x86
01000:  CLRF   x85
.................... 	current.modbus_last_error=0; 
01002:  CLRF   x88
01004:  CLRF   x87
.................... } 
01006:  MOVLB  0
01008:  GOTO   192E (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
00F94:  BCF    FF2.6
00F96:  BCF    FF2.7
00F98:  BTFSC  FF2.7
00F9A:  BRA    0F96
....................  
.................... 	current.pulse_count[0]=0; 
00F9C:  CLRF   x61
00F9E:  CLRF   x60
.................... 	current.pulse_count[1]=0; 
00FA0:  CLRF   x63
00FA2:  CLRF   x62
.................... 	current.pulse_count[2]=0; 
00FA4:  CLRF   x65
00FA6:  CLRF   x64
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
00FA8:  SETF   55
00FAA:  SETF   54
.................... 	current.pulse_min_period[1]=65535; 
00FAC:  SETF   57
00FAE:  SETF   56
.................... 	current.pulse_min_period[2]=65535; 
00FB0:  SETF   59
00FB2:  SETF   58
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
00FB4:  CLRF   5B
00FB6:  CLRF   5A
.................... 	current.pulse_max_period[1]=0; 
00FB8:  CLRF   5D
00FBA:  CLRF   5C
.................... 	current.pulse_max_period[2]=0; 
00FBC:  CLRF   5F
00FBE:  CLRF   5E
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
00FC0:  MOVLB  1
00FC2:  CLRF   x8E
00FC4:  CLRF   x8D
....................  
.................... 	enable_interrupts(GLOBAL); 
00FC6:  MOVLW  C0
00FC8:  IORWF  FF2,F
.................... } 
00FCA:  MOVLB  0
00FCC:  GOTO   18DE (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
00FD0:  BCF    FF2.6
00FD2:  BCF    FF2.7
00FD4:  BTFSC  FF2.7
00FD6:  BRA    0FD2
.................... 	current.pulse_sum[0]=0; 
00FD8:  CLRF   x69
00FDA:  CLRF   x68
00FDC:  CLRF   x67
00FDE:  CLRF   x66
.................... 	current.pulse_sum[1]=0; 
00FE0:  CLRF   x6D
00FE2:  CLRF   x6C
00FE4:  CLRF   x6B
00FE6:  CLRF   x6A
.................... 	current.pulse_sum[2]=0; 
00FE8:  CLRF   x71
00FEA:  CLRF   x70
00FEC:  CLRF   x6F
00FEE:  CLRF   x6E
.................... 	enable_interrupts(GLOBAL); 
00FF0:  MOVLW  C0
00FF2:  IORWF  FF2,F
.................... } 
00FF4:  GOTO   18EE (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
00F32:  BCF    FF2.6
00F34:  BCF    FF2.7
00F36:  BTFSC  FF2.7
00F38:  BRA    0F34
.................... 	l=current.pulse_sum[ch]; 
00F3A:  MOVLB  2
00F3C:  CLRF   xE2
00F3E:  MOVFF  2DB,2E1
00F42:  CLRF   xE4
00F44:  MOVLW  04
00F46:  MOVWF  xE3
00F48:  MOVLB  0
00F4A:  CALL   0706
00F4E:  MOVFF  02,03
00F52:  MOVF   01,W
00F54:  ADDLW  66
00F56:  MOVWF  FE9
00F58:  MOVLW  00
00F5A:  ADDWFC 02,W
00F5C:  MOVWF  FEA
00F5E:  MOVFF  FEF,00
00F62:  MOVFF  FEC,01
00F66:  MOVFF  FEC,02
00F6A:  MOVFF  FEC,03
00F6E:  MOVFF  03,2DF
00F72:  MOVFF  02,2DE
00F76:  MOVFF  01,2DD
00F7A:  MOVFF  00,2DC
.................... 	enable_interrupts(GLOBAL); 
00F7E:  MOVLW  C0
00F80:  IORWF  FF2,F
....................  
.................... 	return l; 
00F82:  MOVFF  2DC,00
00F86:  MOVFF  2DD,01
00F8A:  MOVFF  2DE,02
00F8E:  MOVFF  2DF,03
.................... } 
00F92:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
0100C:  MOVLB  2
0100E:  MOVF   xDA,W
01010:  SUBLW  06
01012:  BC    1068
01014:  XORLW  FF
01016:  BNZ   101E
01018:  MOVF   xD9,W
0101A:  SUBLW  CF
0101C:  BC    1068
0101E:  MOVF   xDA,W
01020:  SUBLW  09
01022:  BNC   1068
01024:  BNZ   102C
01026:  MOVF   xD9,W
01028:  SUBLW  CF
0102A:  BNC   1068
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
0102C:  MOVLW  D0
0102E:  SUBWF  xD9,W
01030:  MOVWF  xDB
01032:  MOVLW  07
01034:  SUBWFB xDA,W
01036:  MOVWF  xDC
01038:  MOVLW  02
0103A:  ADDWF  xDC,F
0103C:  MOVFF  FF2,2DD
01040:  BCF    FF2.6
01042:  BCF    FF2.7
01044:  MOVFF  2DC,FAA
01048:  MOVFF  2DB,FA9
0104C:  BCF    FA6.6
0104E:  BCF    FA6.7
01050:  BSF    FA6.0
01052:  MOVF   FA8,W
01054:  BTFSC  xDD.6
01056:  BSF    FF2.6
01058:  BTFSC  xDD.7
0105A:  BSF    FF2.7
0105C:  CLRF   03
0105E:  MOVWF  01
01060:  MOVF   03,W
01062:  MOVWF  02
01064:  GOTO   1A00
.................... 	} 
....................  
.................... 	switch ( addr ) { 
01068:  MOVF   xD9,W
0106A:  MOVWF  00
0106C:  MOVF   xDA,W
0106E:  MOVWF  03
01070:  MOVF   03,W
01072:  BNZ   107E
01074:  MOVF   00,F
01076:  MOVLB  0
01078:  BTFSC  FD8.2
0107A:  BRA    149A
0107C:  MOVLB  2
0107E:  MOVF   03,W
01080:  BNZ   108E
01082:  MOVLW  01
01084:  SUBWF  00,W
01086:  MOVLB  0
01088:  BTFSC  FD8.2
0108A:  BRA    14A8
0108C:  MOVLB  2
0108E:  MOVF   03,W
01090:  BNZ   109E
01092:  MOVLW  02
01094:  SUBWF  00,W
01096:  MOVLB  0
01098:  BTFSC  FD8.2
0109A:  BRA    14B6
0109C:  MOVLB  2
0109E:  MOVF   03,W
010A0:  BNZ   10AE
010A2:  MOVLW  03
010A4:  SUBWF  00,W
010A6:  MOVLB  0
010A8:  BTFSC  FD8.2
010AA:  BRA    14C4
010AC:  MOVLB  2
010AE:  MOVF   03,W
010B0:  BNZ   10BE
010B2:  MOVLW  04
010B4:  SUBWF  00,W
010B6:  MOVLB  0
010B8:  BTFSC  FD8.2
010BA:  BRA    14D2
010BC:  MOVLB  2
010BE:  MOVF   03,W
010C0:  BNZ   10CE
010C2:  MOVLW  05
010C4:  SUBWF  00,W
010C6:  MOVLB  0
010C8:  BTFSC  FD8.2
010CA:  BRA    14F8
010CC:  MOVLB  2
010CE:  MOVF   03,W
010D0:  BNZ   10DE
010D2:  MOVLW  06
010D4:  SUBWF  00,W
010D6:  MOVLB  0
010D8:  BTFSC  FD8.2
010DA:  BRA    1506
010DC:  MOVLB  2
010DE:  MOVF   03,W
010E0:  BNZ   10EE
010E2:  MOVLW  07
010E4:  SUBWF  00,W
010E6:  MOVLB  0
010E8:  BTFSC  FD8.2
010EA:  BRA    1514
010EC:  MOVLB  2
010EE:  MOVF   03,W
010F0:  BNZ   10FE
010F2:  MOVLW  08
010F4:  SUBWF  00,W
010F6:  MOVLB  0
010F8:  BTFSC  FD8.2
010FA:  BRA    1522
010FC:  MOVLB  2
010FE:  MOVF   03,W
01100:  BNZ   110E
01102:  MOVLW  09
01104:  SUBWF  00,W
01106:  MOVLB  0
01108:  BTFSC  FD8.2
0110A:  BRA    1530
0110C:  MOVLB  2
0110E:  MOVF   03,W
01110:  BNZ   111E
01112:  MOVLW  0A
01114:  SUBWF  00,W
01116:  MOVLB  0
01118:  BTFSC  FD8.2
0111A:  BRA    153E
0111C:  MOVLB  2
0111E:  MOVF   03,W
01120:  BNZ   112E
01122:  MOVLW  0B
01124:  SUBWF  00,W
01126:  MOVLB  0
01128:  BTFSC  FD8.2
0112A:  BRA    1566
0112C:  MOVLB  2
0112E:  MOVF   03,W
01130:  BNZ   113E
01132:  MOVLW  0C
01134:  SUBWF  00,W
01136:  MOVLB  0
01138:  BTFSC  FD8.2
0113A:  BRA    1574
0113C:  MOVLB  2
0113E:  MOVF   03,W
01140:  BNZ   114E
01142:  MOVLW  0D
01144:  SUBWF  00,W
01146:  MOVLB  0
01148:  BTFSC  FD8.2
0114A:  BRA    1582
0114C:  MOVLB  2
0114E:  MOVF   03,W
01150:  BNZ   115E
01152:  MOVLW  0E
01154:  SUBWF  00,W
01156:  MOVLB  0
01158:  BTFSC  FD8.2
0115A:  BRA    1590
0115C:  MOVLB  2
0115E:  MOVF   03,W
01160:  BNZ   116E
01162:  MOVLW  0F
01164:  SUBWF  00,W
01166:  MOVLB  0
01168:  BTFSC  FD8.2
0116A:  BRA    159E
0116C:  MOVLB  2
0116E:  MOVF   03,W
01170:  BNZ   117E
01172:  MOVLW  10
01174:  SUBWF  00,W
01176:  MOVLB  0
01178:  BTFSC  FD8.2
0117A:  BRA    15AC
0117C:  MOVLB  2
0117E:  MOVF   03,W
01180:  BNZ   118E
01182:  MOVLW  11
01184:  SUBWF  00,W
01186:  MOVLB  0
01188:  BTFSC  FD8.2
0118A:  BRA    15D4
0118C:  MOVLB  2
0118E:  MOVF   03,W
01190:  BNZ   119E
01192:  MOVLW  12
01194:  SUBWF  00,W
01196:  MOVLB  0
01198:  BTFSC  FD8.2
0119A:  BRA    15E2
0119C:  MOVLB  2
0119E:  MOVF   03,W
011A0:  BNZ   11AE
011A2:  MOVLW  13
011A4:  SUBWF  00,W
011A6:  MOVLB  0
011A8:  BTFSC  FD8.2
011AA:  BRA    1610
011AC:  MOVLB  2
011AE:  MOVF   03,W
011B0:  BNZ   11BE
011B2:  MOVLW  14
011B4:  SUBWF  00,W
011B6:  MOVLB  0
011B8:  BTFSC  FD8.2
011BA:  BRA    1628
011BC:  MOVLB  2
011BE:  MOVF   03,W
011C0:  BNZ   11CE
011C2:  MOVLW  15
011C4:  SUBWF  00,W
011C6:  MOVLB  0
011C8:  BTFSC  FD8.2
011CA:  BRA    1636
011CC:  MOVLB  2
011CE:  MOVF   03,W
011D0:  BNZ   11DE
011D2:  MOVLW  16
011D4:  SUBWF  00,W
011D6:  MOVLB  0
011D8:  BTFSC  FD8.2
011DA:  BRA    1664
011DC:  MOVLB  2
011DE:  MOVF   03,W
011E0:  BNZ   11EE
011E2:  MOVLW  17
011E4:  SUBWF  00,W
011E6:  MOVLB  0
011E8:  BTFSC  FD8.2
011EA:  BRA    167E
011EC:  MOVLB  2
011EE:  MOVF   03,W
011F0:  BNZ   11FE
011F2:  MOVLW  18
011F4:  SUBWF  00,W
011F6:  MOVLB  0
011F8:  BTFSC  FD8.2
011FA:  BRA    168C
011FC:  MOVLB  2
011FE:  MOVF   03,W
01200:  BNZ   120E
01202:  MOVLW  19
01204:  SUBWF  00,W
01206:  MOVLB  0
01208:  BTFSC  FD8.2
0120A:  BRA    16BA
0120C:  MOVLB  2
0120E:  MOVF   03,W
01210:  BNZ   121E
01212:  MOVLW  1A
01214:  SUBWF  00,W
01216:  MOVLB  0
01218:  BTFSC  FD8.2
0121A:  BRA    16D4
0121C:  MOVLB  2
0121E:  MOVF   03,W
01220:  BNZ   122E
01222:  MOVLW  1B
01224:  SUBWF  00,W
01226:  MOVLB  0
01228:  BTFSC  FD8.2
0122A:  BRA    16E2
0122C:  MOVLB  2
0122E:  MOVF   03,W
01230:  BNZ   123E
01232:  MOVLW  1C
01234:  SUBWF  00,W
01236:  MOVLB  0
01238:  BTFSC  FD8.2
0123A:  BRA    1710
0123C:  MOVLB  2
0123E:  MOVF   03,W
01240:  BNZ   124E
01242:  MOVLW  1D
01244:  SUBWF  00,W
01246:  MOVLB  0
01248:  BTFSC  FD8.2
0124A:  BRA    172A
0124C:  MOVLB  2
0124E:  MOVF   03,W
01250:  BNZ   125E
01252:  MOVLW  1E
01254:  SUBWF  00,W
01256:  MOVLB  0
01258:  BTFSC  FD8.2
0125A:  BRA    1738
0125C:  MOVLB  2
0125E:  MOVF   03,W
01260:  BNZ   126E
01262:  MOVLW  1F
01264:  SUBWF  00,W
01266:  MOVLB  0
01268:  BTFSC  FD8.2
0126A:  BRA    1766
0126C:  MOVLB  2
0126E:  MOVF   03,W
01270:  BNZ   127E
01272:  MOVLW  20
01274:  SUBWF  00,W
01276:  MOVLB  0
01278:  BTFSC  FD8.2
0127A:  BRA    1780
0127C:  MOVLB  2
0127E:  MOVF   03,W
01280:  BNZ   128E
01282:  MOVLW  21
01284:  SUBWF  00,W
01286:  MOVLB  0
01288:  BTFSC  FD8.2
0128A:  BRA    178E
0128C:  MOVLB  2
0128E:  MOVF   03,W
01290:  BNZ   129E
01292:  MOVLW  22
01294:  SUBWF  00,W
01296:  MOVLB  0
01298:  BTFSC  FD8.2
0129A:  BRA    17BC
0129C:  MOVLB  2
0129E:  MOVF   03,W
012A0:  BNZ   12AE
012A2:  MOVLW  23
012A4:  SUBWF  00,W
012A6:  MOVLB  0
012A8:  BTFSC  FD8.2
012AA:  BRA    17D6
012AC:  MOVLB  2
012AE:  MOVF   03,W
012B0:  BNZ   12BE
012B2:  MOVLW  24
012B4:  SUBWF  00,W
012B6:  MOVLB  0
012B8:  BTFSC  FD8.2
012BA:  BRA    17E4
012BC:  MOVLB  2
012BE:  MOVF   03,W
012C0:  BNZ   12CE
012C2:  MOVLW  25
012C4:  SUBWF  00,W
012C6:  MOVLB  0
012C8:  BTFSC  FD8.2
012CA:  BRA    1812
012CC:  MOVLB  2
012CE:  MOVF   03,W
012D0:  BNZ   12DE
012D2:  MOVLW  26
012D4:  SUBWF  00,W
012D6:  MOVLB  0
012D8:  BTFSC  FD8.2
012DA:  BRA    182C
012DC:  MOVLB  2
012DE:  MOVF   03,W
012E0:  BNZ   12EE
012E2:  MOVLW  27
012E4:  SUBWF  00,W
012E6:  MOVLB  0
012E8:  BTFSC  FD8.2
012EA:  BRA    183A
012EC:  MOVLB  2
012EE:  MOVF   03,W
012F0:  BNZ   12FE
012F2:  MOVLW  28
012F4:  SUBWF  00,W
012F6:  MOVLB  0
012F8:  BTFSC  FD8.2
012FA:  BRA    1868
012FC:  MOVLB  2
012FE:  MOVF   03,W
01300:  BNZ   130E
01302:  MOVLW  29
01304:  SUBWF  00,W
01306:  MOVLB  0
01308:  BTFSC  FD8.2
0130A:  BRA    1882
0130C:  MOVLB  2
0130E:  MOVF   03,W
01310:  BNZ   131E
01312:  MOVLW  2A
01314:  SUBWF  00,W
01316:  MOVLB  0
01318:  BTFSC  FD8.2
0131A:  BRA    1890
0131C:  MOVLB  2
0131E:  MOVF   03,W
01320:  BNZ   132E
01322:  MOVLW  2B
01324:  SUBWF  00,W
01326:  MOVLB  0
01328:  BTFSC  FD8.2
0132A:  BRA    18AA
0132C:  MOVLB  2
0132E:  MOVF   03,W
01330:  BNZ   133E
01332:  MOVLW  2C
01334:  SUBWF  00,W
01336:  MOVLB  0
01338:  BTFSC  FD8.2
0133A:  BRA    18BA
0133C:  MOVLB  2
0133E:  MOVF   03,W
01340:  BNZ   134E
01342:  MOVLW  2D
01344:  SUBWF  00,W
01346:  MOVLB  0
01348:  BTFSC  FD8.2
0134A:  BRA    18CA
0134C:  MOVLB  2
0134E:  MOVF   03,W
01350:  BNZ   135E
01352:  MOVLW  2E
01354:  SUBWF  00,W
01356:  MOVLB  0
01358:  BTFSC  FD8.2
0135A:  BRA    18DA
0135C:  MOVLB  2
0135E:  MOVF   03,W
01360:  BNZ   136E
01362:  MOVLW  2F
01364:  SUBWF  00,W
01366:  MOVLB  0
01368:  BTFSC  FD8.2
0136A:  BRA    18EA
0136C:  MOVLB  2
0136E:  MOVF   03,W
01370:  BNZ   137E
01372:  MOVLW  30
01374:  SUBWF  00,W
01376:  MOVLB  0
01378:  BTFSC  FD8.2
0137A:  BRA    18FA
0137C:  MOVLB  2
0137E:  MOVF   03,W
01380:  BNZ   138E
01382:  MOVLW  31
01384:  SUBWF  00,W
01386:  MOVLB  0
01388:  BTFSC  FD8.2
0138A:  BRA    190A
0138C:  MOVLB  2
0138E:  MOVF   03,W
01390:  BNZ   139E
01392:  MOVLW  32
01394:  SUBWF  00,W
01396:  MOVLB  0
01398:  BTFSC  FD8.2
0139A:  BRA    191A
0139C:  MOVLB  2
0139E:  MOVF   03,W
013A0:  BNZ   13AE
013A2:  MOVLW  33
013A4:  SUBWF  00,W
013A6:  MOVLB  0
013A8:  BTFSC  FD8.2
013AA:  BRA    192A
013AC:  MOVLB  2
013AE:  MOVLW  03
013B0:  SUBWF  03,W
013B2:  BNZ   13C0
013B4:  MOVLW  E8
013B6:  SUBWF  00,W
013B8:  MOVLB  0
013BA:  BTFSC  FD8.2
013BC:  BRA    193A
013BE:  MOVLB  2
013C0:  MOVLW  03
013C2:  SUBWF  03,W
013C4:  BNZ   13D2
013C6:  MOVLW  E9
013C8:  SUBWF  00,W
013CA:  MOVLB  0
013CC:  BTFSC  FD8.2
013CE:  BRA    194A
013D0:  MOVLB  2
013D2:  MOVLW  03
013D4:  SUBWF  03,W
013D6:  BNZ   13E4
013D8:  MOVLW  EA
013DA:  SUBWF  00,W
013DC:  MOVLB  0
013DE:  BTFSC  FD8.2
013E0:  BRA    1958
013E2:  MOVLB  2
013E4:  MOVLW  03
013E6:  SUBWF  03,W
013E8:  BNZ   13F6
013EA:  MOVLW  EB
013EC:  SUBWF  00,W
013EE:  MOVLB  0
013F0:  BTFSC  FD8.2
013F2:  BRA    1966
013F4:  MOVLB  2
013F6:  MOVLW  03
013F8:  SUBWF  03,W
013FA:  BNZ   1408
013FC:  MOVLW  EC
013FE:  SUBWF  00,W
01400:  MOVLB  0
01402:  BTFSC  FD8.2
01404:  BRA    1974
01406:  MOVLB  2
01408:  MOVLW  03
0140A:  SUBWF  03,W
0140C:  BNZ   141A
0140E:  MOVLW  ED
01410:  SUBWF  00,W
01412:  MOVLB  0
01414:  BTFSC  FD8.2
01416:  BRA    1982
01418:  MOVLB  2
0141A:  MOVLW  03
0141C:  SUBWF  03,W
0141E:  BNZ   142C
01420:  MOVLW  EE
01422:  SUBWF  00,W
01424:  MOVLB  0
01426:  BTFSC  FD8.2
01428:  BRA    1990
0142A:  MOVLB  2
0142C:  MOVLW  03
0142E:  SUBWF  03,W
01430:  BNZ   143E
01432:  MOVLW  EF
01434:  SUBWF  00,W
01436:  MOVLB  0
01438:  BTFSC  FD8.2
0143A:  BRA    19A0
0143C:  MOVLB  2
0143E:  MOVLW  03
01440:  SUBWF  03,W
01442:  BNZ   1450
01444:  MOVLW  F0
01446:  SUBWF  00,W
01448:  MOVLB  0
0144A:  BTFSC  FD8.2
0144C:  BRA    19AE
0144E:  MOVLB  2
01450:  MOVLW  03
01452:  SUBWF  03,W
01454:  BNZ   1462
01456:  MOVLW  F1
01458:  SUBWF  00,W
0145A:  MOVLB  0
0145C:  BTFSC  FD8.2
0145E:  BRA    19BE
01460:  MOVLB  2
01462:  MOVLW  03
01464:  SUBWF  03,W
01466:  BNZ   1474
01468:  MOVLW  F2
0146A:  SUBWF  00,W
0146C:  MOVLB  0
0146E:  BTFSC  FD8.2
01470:  BRA    19CC
01472:  MOVLB  2
01474:  MOVLW  03
01476:  SUBWF  03,W
01478:  BNZ   1486
0147A:  MOVLW  F3
0147C:  SUBWF  00,W
0147E:  MOVLB  0
01480:  BTFSC  FD8.2
01482:  BRA    19DA
01484:  MOVLB  2
01486:  MOVLW  03
01488:  SUBWF  03,W
0148A:  BNZ   1498
0148C:  MOVLW  F4
0148E:  SUBWF  00,W
01490:  MOVLB  0
01492:  BTFSC  FD8.2
01494:  BRA    19EA
01496:  MOVLB  2
01498:  BRA    19F8
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
0149A:  MOVFF  60,01
0149E:  MOVFF  61,02
014A2:  MOVLB  2
014A4:  BRA    1A00
014A6:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
014A8:  MOVF   4E,W
014AA:  MOVWF  01
014AC:  MOVF   4F,W
014AE:  MOVWF  02
014B0:  MOVLB  2
014B2:  BRA    1A00
014B4:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
014B6:  MOVF   54,W
014B8:  MOVWF  01
014BA:  MOVF   55,W
014BC:  MOVWF  02
014BE:  MOVLB  2
014C0:  BRA    1A00
014C2:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
014C4:  MOVF   5A,W
014C6:  MOVWF  01
014C8:  MOVF   5B,W
014CA:  MOVWF  02
014CC:  MOVLB  2
014CE:  BRA    1A00
014D0:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
014D2:  MOVLB  2
014D4:  CLRF   xDB
014D6:  MOVLB  0
014D8:  RCALL  0F32
014DA:  MOVFF  03,2BB
014DE:  MOVFF  02,2BA
014E2:  MOVFF  01,2B9
014E6:  MOVFF  00,2B8
014EA:  MOVLB  2
014EC:  MOVF   xB8,W
014EE:  MOVWF  01
014F0:  MOVF   xB9,W
014F2:  MOVWF  02
014F4:  BRA    1A00
014F6:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
014F8:  MOVLB  2
014FA:  MOVF   xBA,W
014FC:  MOVWF  01
014FE:  MOVF   xBB,W
01500:  MOVWF  02
01502:  BRA    1A00
01504:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01506:  MOVF   x62,W
01508:  MOVWF  01
0150A:  MOVF   x63,W
0150C:  MOVWF  02
0150E:  MOVLB  2
01510:  BRA    1A00
01512:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01514:  MOVF   50,W
01516:  MOVWF  01
01518:  MOVF   51,W
0151A:  MOVWF  02
0151C:  MOVLB  2
0151E:  BRA    1A00
01520:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01522:  MOVF   56,W
01524:  MOVWF  01
01526:  MOVF   57,W
01528:  MOVWF  02
0152A:  MOVLB  2
0152C:  BRA    1A00
0152E:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01530:  MOVF   5C,W
01532:  MOVWF  01
01534:  MOVF   5D,W
01536:  MOVWF  02
01538:  MOVLB  2
0153A:  BRA    1A00
0153C:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
0153E:  MOVLW  01
01540:  MOVLB  2
01542:  MOVWF  xDB
01544:  MOVLB  0
01546:  RCALL  0F32
01548:  MOVFF  03,2BB
0154C:  MOVFF  02,2BA
01550:  MOVFF  01,2B9
01554:  MOVFF  00,2B8
01558:  MOVLB  2
0155A:  MOVF   xB8,W
0155C:  MOVWF  01
0155E:  MOVF   xB9,W
01560:  MOVWF  02
01562:  BRA    1A00
01564:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01566:  MOVLB  2
01568:  MOVF   xBA,W
0156A:  MOVWF  01
0156C:  MOVF   xBB,W
0156E:  MOVWF  02
01570:  BRA    1A00
01572:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01574:  MOVF   x64,W
01576:  MOVWF  01
01578:  MOVF   x65,W
0157A:  MOVWF  02
0157C:  MOVLB  2
0157E:  BRA    1A00
01580:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01582:  MOVF   52,W
01584:  MOVWF  01
01586:  MOVF   53,W
01588:  MOVWF  02
0158A:  MOVLB  2
0158C:  BRA    1A00
0158E:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01590:  MOVF   58,W
01592:  MOVWF  01
01594:  MOVF   59,W
01596:  MOVWF  02
01598:  MOVLB  2
0159A:  BRA    1A00
0159C:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
0159E:  MOVF   5E,W
015A0:  MOVWF  01
015A2:  MOVF   5F,W
015A4:  MOVWF  02
015A6:  MOVLB  2
015A8:  BRA    1A00
015AA:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
015AC:  MOVLW  02
015AE:  MOVLB  2
015B0:  MOVWF  xDB
015B2:  MOVLB  0
015B4:  RCALL  0F32
015B6:  MOVFF  03,2BB
015BA:  MOVFF  02,2BA
015BE:  MOVFF  01,2B9
015C2:  MOVFF  00,2B8
015C6:  MOVLB  2
015C8:  MOVF   xB8,W
015CA:  MOVWF  01
015CC:  MOVF   xB9,W
015CE:  MOVWF  02
015D0:  BRA    1A00
015D2:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
015D4:  MOVLB  2
015D6:  MOVF   xBA,W
015D8:  MOVWF  01
015DA:  MOVF   xBB,W
015DC:  MOVWF  02
015DE:  BRA    1A00
015E0:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
015E2:  CLRF   03
015E4:  MOVLB  1
015E6:  MOVF   x82,W
015E8:  MOVWF  02
015EA:  BCF    FD8.0
015EC:  RLCF   02,F
015EE:  RLCF   03,F
015F0:  MOVF   02,W
015F2:  ADDLW  82
015F4:  MOVWF  FE9
015F6:  MOVLW  00
015F8:  ADDWFC 03,W
015FA:  MOVWF  FEA
015FC:  MOVFF  FEC,03
01600:  MOVF   FED,F
01602:  MOVF   FEF,W
01604:  MOVWF  01
01606:  MOVF   03,W
01608:  MOVWF  02
0160A:  MOVLB  2
0160C:  BRA    1A00
0160E:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01610:  MOVLB  2
01612:  CLRF   xDB
01614:  MOVLB  0
01616:  CALL   0BE8
0161A:  MOVF   01,W
0161C:  MOVWF  01
0161E:  MOVF   02,W
01620:  MOVWF  02
01622:  MOVLB  2
01624:  BRA    1A00
01626:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01628:  MOVF   x72,W
0162A:  MOVWF  01
0162C:  MOVF   x73,W
0162E:  MOVWF  02
01630:  MOVLB  2
01632:  BRA    1A00
01634:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01636:  CLRF   03
01638:  MOVLB  1
0163A:  MOVF   x82,W
0163C:  MOVWF  02
0163E:  BCF    FD8.0
01640:  RLCF   02,F
01642:  RLCF   03,F
01644:  MOVF   02,W
01646:  ADDLW  A2
01648:  MOVWF  FE9
0164A:  MOVLW  00
0164C:  ADDWFC 03,W
0164E:  MOVWF  FEA
01650:  MOVFF  FEC,03
01654:  MOVF   FED,F
01656:  MOVF   FEF,W
01658:  MOVWF  01
0165A:  MOVF   03,W
0165C:  MOVWF  02
0165E:  MOVLB  2
01660:  BRA    1A00
01662:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01664:  MOVLW  01
01666:  MOVLB  2
01668:  MOVWF  xDB
0166A:  MOVLB  0
0166C:  CALL   0BE8
01670:  MOVF   01,W
01672:  MOVWF  01
01674:  MOVF   02,W
01676:  MOVWF  02
01678:  MOVLB  2
0167A:  BRA    1A00
0167C:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0167E:  MOVF   x74,W
01680:  MOVWF  01
01682:  MOVF   x75,W
01684:  MOVWF  02
01686:  MOVLB  2
01688:  BRA    1A00
0168A:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0168C:  CLRF   03
0168E:  MOVLB  1
01690:  MOVF   x82,W
01692:  MOVWF  02
01694:  BCF    FD8.0
01696:  RLCF   02,F
01698:  RLCF   03,F
0169A:  MOVF   02,W
0169C:  ADDLW  C2
0169E:  MOVWF  FE9
016A0:  MOVLW  00
016A2:  ADDWFC 03,W
016A4:  MOVWF  FEA
016A6:  MOVFF  FEC,03
016AA:  MOVF   FED,F
016AC:  MOVF   FEF,W
016AE:  MOVWF  01
016B0:  MOVF   03,W
016B2:  MOVWF  02
016B4:  MOVLB  2
016B6:  BRA    1A00
016B8:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
016BA:  MOVLW  02
016BC:  MOVLB  2
016BE:  MOVWF  xDB
016C0:  MOVLB  0
016C2:  CALL   0BE8
016C6:  MOVF   01,W
016C8:  MOVWF  01
016CA:  MOVF   02,W
016CC:  MOVWF  02
016CE:  MOVLB  2
016D0:  BRA    1A00
016D2:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
016D4:  MOVF   x76,W
016D6:  MOVWF  01
016D8:  MOVF   x77,W
016DA:  MOVWF  02
016DC:  MOVLB  2
016DE:  BRA    1A00
016E0:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
016E2:  CLRF   03
016E4:  MOVLB  1
016E6:  MOVF   x82,W
016E8:  MOVWF  02
016EA:  BCF    FD8.0
016EC:  RLCF   02,F
016EE:  RLCF   03,F
016F0:  MOVF   02,W
016F2:  ADDLW  E2
016F4:  MOVWF  FE9
016F6:  MOVLW  00
016F8:  ADDWFC 03,W
016FA:  MOVWF  FEA
016FC:  MOVFF  FEC,03
01700:  MOVF   FED,F
01702:  MOVF   FEF,W
01704:  MOVWF  01
01706:  MOVF   03,W
01708:  MOVWF  02
0170A:  MOVLB  2
0170C:  BRA    1A00
0170E:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01710:  MOVLW  03
01712:  MOVLB  2
01714:  MOVWF  xDB
01716:  MOVLB  0
01718:  CALL   0BE8
0171C:  MOVF   01,W
0171E:  MOVWF  01
01720:  MOVF   02,W
01722:  MOVWF  02
01724:  MOVLB  2
01726:  BRA    1A00
01728:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
0172A:  MOVF   x78,W
0172C:  MOVWF  01
0172E:  MOVF   x79,W
01730:  MOVWF  02
01732:  MOVLB  2
01734:  BRA    1A00
01736:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01738:  CLRF   03
0173A:  MOVLB  1
0173C:  MOVF   x82,W
0173E:  MOVWF  02
01740:  BCF    FD8.0
01742:  RLCF   02,F
01744:  RLCF   03,F
01746:  MOVF   02,W
01748:  ADDLW  02
0174A:  MOVWF  FE9
0174C:  MOVLW  01
0174E:  ADDWFC 03,W
01750:  MOVWF  FEA
01752:  MOVFF  FEC,03
01756:  MOVF   FED,F
01758:  MOVF   FEF,W
0175A:  MOVWF  01
0175C:  MOVF   03,W
0175E:  MOVWF  02
01760:  MOVLB  2
01762:  BRA    1A00
01764:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01766:  MOVLW  04
01768:  MOVLB  2
0176A:  MOVWF  xDB
0176C:  MOVLB  0
0176E:  CALL   0BE8
01772:  MOVF   01,W
01774:  MOVWF  01
01776:  MOVF   02,W
01778:  MOVWF  02
0177A:  MOVLB  2
0177C:  BRA    1A00
0177E:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01780:  MOVF   x7A,W
01782:  MOVWF  01
01784:  MOVF   x7B,W
01786:  MOVWF  02
01788:  MOVLB  2
0178A:  BRA    1A00
0178C:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
0178E:  CLRF   03
01790:  MOVLB  1
01792:  MOVF   x82,W
01794:  MOVWF  02
01796:  BCF    FD8.0
01798:  RLCF   02,F
0179A:  RLCF   03,F
0179C:  MOVF   02,W
0179E:  ADDLW  22
017A0:  MOVWF  FE9
017A2:  MOVLW  01
017A4:  ADDWFC 03,W
017A6:  MOVWF  FEA
017A8:  MOVFF  FEC,03
017AC:  MOVF   FED,F
017AE:  MOVF   FEF,W
017B0:  MOVWF  01
017B2:  MOVF   03,W
017B4:  MOVWF  02
017B6:  MOVLB  2
017B8:  BRA    1A00
017BA:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
017BC:  MOVLW  05
017BE:  MOVLB  2
017C0:  MOVWF  xDB
017C2:  MOVLB  0
017C4:  CALL   0BE8
017C8:  MOVF   01,W
017CA:  MOVWF  01
017CC:  MOVF   02,W
017CE:  MOVWF  02
017D0:  MOVLB  2
017D2:  BRA    1A00
017D4:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
017D6:  MOVF   x7C,W
017D8:  MOVWF  01
017DA:  MOVF   x7D,W
017DC:  MOVWF  02
017DE:  MOVLB  2
017E0:  BRA    1A00
017E2:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
017E4:  CLRF   03
017E6:  MOVLB  1
017E8:  MOVF   x82,W
017EA:  MOVWF  02
017EC:  BCF    FD8.0
017EE:  RLCF   02,F
017F0:  RLCF   03,F
017F2:  MOVF   02,W
017F4:  ADDLW  42
017F6:  MOVWF  FE9
017F8:  MOVLW  01
017FA:  ADDWFC 03,W
017FC:  MOVWF  FEA
017FE:  MOVFF  FEC,03
01802:  MOVF   FED,F
01804:  MOVF   FEF,W
01806:  MOVWF  01
01808:  MOVF   03,W
0180A:  MOVWF  02
0180C:  MOVLB  2
0180E:  BRA    1A00
01810:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01812:  MOVLW  06
01814:  MOVLB  2
01816:  MOVWF  xDB
01818:  MOVLB  0
0181A:  CALL   0BE8
0181E:  MOVF   01,W
01820:  MOVWF  01
01822:  MOVF   02,W
01824:  MOVWF  02
01826:  MOVLB  2
01828:  BRA    1A00
0182A:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
0182C:  MOVF   x7E,W
0182E:  MOVWF  01
01830:  MOVF   x7F,W
01832:  MOVWF  02
01834:  MOVLB  2
01836:  BRA    1A00
01838:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
0183A:  CLRF   03
0183C:  MOVLB  1
0183E:  MOVF   x82,W
01840:  MOVWF  02
01842:  BCF    FD8.0
01844:  RLCF   02,F
01846:  RLCF   03,F
01848:  MOVF   02,W
0184A:  ADDLW  62
0184C:  MOVWF  FE9
0184E:  MOVLW  01
01850:  ADDWFC 03,W
01852:  MOVWF  FEA
01854:  MOVFF  FEC,03
01858:  MOVF   FED,F
0185A:  MOVF   FEF,W
0185C:  MOVWF  01
0185E:  MOVF   03,W
01860:  MOVWF  02
01862:  MOVLB  2
01864:  BRA    1A00
01866:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01868:  MOVLW  07
0186A:  MOVLB  2
0186C:  MOVWF  xDB
0186E:  MOVLB  0
01870:  CALL   0BE8
01874:  MOVF   01,W
01876:  MOVWF  01
01878:  MOVF   02,W
0187A:  MOVWF  02
0187C:  MOVLB  2
0187E:  BRA    1A00
01880:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01882:  MOVF   x80,W
01884:  MOVWF  01
01886:  MOVF   x81,W
01888:  MOVWF  02
0188A:  MOVLB  2
0188C:  BRA    1A00
0188E:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01890:  MOVLB  1
01892:  MOVF   x8A,W
01894:  MOVWF  03
01896:  MOVF   x89,W
01898:  INCF   x89,F
0189A:  BTFSC  FD8.2
0189C:  INCF   x8A,F
0189E:  MOVWF  01
018A0:  MOVF   03,W
018A2:  MOVWF  02
018A4:  MOVLB  2
018A6:  BRA    1A00
018A8:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
018AA:  MOVLB  1
018AC:  MOVF   x8D,W
018AE:  MOVWF  01
018B0:  MOVF   x8E,W
018B2:  MOVWF  02
018B4:  MOVLB  2
018B6:  BRA    1A00
018B8:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
018BA:  MOVLB  1
018BC:  MOVF   x8B,W
018BE:  MOVWF  01
018C0:  MOVF   x8C,W
018C2:  MOVWF  02
018C4:  MOVLB  2
018C6:  BRA    1A00
018C8:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
018CA:  MOVLB  1
018CC:  MOVF   x91,W
018CE:  MOVWF  01
018D0:  MOVF   x92,W
018D2:  MOVWF  02
018D4:  MOVLB  2
018D6:  BRA    1A00
018D8:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
018DA:  GOTO   0F94
018DE:  MOVLW  00
018E0:  MOVWF  01
018E2:  MOVWF  02
018E4:  MOVLB  2
018E6:  BRA    1A00
018E8:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
018EA:  GOTO   0FD0
018EE:  MOVLW  00
018F0:  MOVWF  01
018F2:  MOVWF  02
018F4:  MOVLB  2
018F6:  BRA    1A00
018F8:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
018FA:  MOVLB  1
018FC:  MOVF   x83,W
018FE:  MOVWF  01
01900:  MOVF   x84,W
01902:  MOVWF  02
01904:  MOVLB  2
01906:  BRA    1A00
01908:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
0190A:  MOVLB  1
0190C:  MOVF   x85,W
0190E:  MOVWF  01
01910:  MOVF   x86,W
01912:  MOVWF  02
01914:  MOVLB  2
01916:  BRA    1A00
01918:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
0191A:  MOVLB  1
0191C:  MOVF   x87,W
0191E:  MOVWF  01
01920:  MOVF   x88,W
01922:  MOVWF  02
01924:  MOVLB  2
01926:  BRA    1A00
01928:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
0192A:  GOTO   0FF8
0192E:  MOVLW  00
01930:  MOVWF  01
01932:  MOVWF  02
01934:  MOVLB  2
01936:  BRA    1A00
01938:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
0193A:  CLRF   03
0193C:  MOVF   39,W
0193E:  MOVWF  01
01940:  MOVF   03,W
01942:  MOVWF  02
01944:  MOVLB  2
01946:  BRA    1A00
01948:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
0194A:  MOVF   3A,W
0194C:  MOVWF  01
0194E:  MOVF   3B,W
01950:  MOVWF  02
01952:  MOVLB  2
01954:  BRA    1A00
01956:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01958:  MOVLW  50
0195A:  MOVWF  01
0195C:  MOVLW  00
0195E:  MOVWF  02
01960:  MOVLB  2
01962:  BRA    1A00
01964:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01966:  MOVLW  57
01968:  MOVWF  01
0196A:  MOVLW  00
0196C:  MOVWF  02
0196E:  MOVLB  2
01970:  BRA    1A00
01972:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01974:  MOVLW  58
01976:  MOVWF  01
01978:  MOVLW  00
0197A:  MOVWF  02
0197C:  MOVLB  2
0197E:  BRA    1A00
01980:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01982:  MOVLW  01
01984:  MOVWF  01
01986:  MOVLW  00
01988:  MOVWF  02
0198A:  MOVLB  2
0198C:  BRA    1A00
0198E:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01990:  CLRF   03
01992:  MOVF   36,W
01994:  MOVWF  01
01996:  MOVF   03,W
01998:  MOVWF  02
0199A:  MOVLB  2
0199C:  BRA    1A00
0199E:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
019A0:  MOVF   3C,W
019A2:  MOVWF  01
019A4:  MOVF   3D,W
019A6:  MOVWF  02
019A8:  MOVLB  2
019AA:  BRA    1A00
019AC:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
019AE:  CLRF   03
019B0:  MOVF   3E,W
019B2:  MOVWF  01
019B4:  MOVF   03,W
019B6:  MOVWF  02
019B8:  MOVLB  2
019BA:  BRA    1A00
019BC:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
019BE:  MOVF   3F,W
019C0:  MOVWF  01
019C2:  MOVF   40,W
019C4:  MOVWF  02
019C6:  MOVLB  2
019C8:  BRA    1A00
019CA:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
019CC:  MOVF   41,W
019CE:  MOVWF  01
019D0:  MOVF   42,W
019D2:  MOVWF  02
019D4:  MOVLB  2
019D6:  BRA    1A00
019D8:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
019DA:  CLRF   03
019DC:  MOVF   43,W
019DE:  MOVWF  01
019E0:  MOVF   03,W
019E2:  MOVWF  02
019E4:  MOVLB  2
019E6:  BRA    1A00
019E8:  MOVLB  0
.................... 		case 1012: return (int16) config.modbus_bridge; 
019EA:  CLRF   03
019EC:  MOVF   38,W
019EE:  MOVWF  01
019F0:  MOVF   03,W
019F2:  MOVWF  02
019F4:  MOVLB  2
019F6:  BRA    1A00
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
019F8:  MOVLW  FF
019FA:  MOVWF  01
019FC:  MOVWF  02
019FE:  BRA    1A00
.................... 	} 
....................  
.................... } 
01A00:  MOVLB  0
01A02:  GOTO   1A54 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
00DF6:  MOVLB  2
00DF8:  MOVF   xCF,W
00DFA:  SUBLW  1F
00DFC:  BNZ   0E16
00DFE:  MOVF   xD0,W
00E00:  SUBLW  4E
00E02:  BNZ   0E16
00E04:  MOVF   xD1,W
00E06:  SUBLW  20
00E08:  BNZ   0E16
00E0A:  MOVF   xD2,W
00E0C:  SUBLW  4E
00E0E:  BNZ   0E16
.................... 		return 1; 
00E10:  MOVLW  01
00E12:  MOVWF  01
00E14:  BRA    0E72
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
00E16:  MOVF   xD0,W
00E18:  SUBLW  02
00E1A:  BC    0E3A
00E1C:  XORLW  FF
00E1E:  BNZ   0E26
00E20:  MOVF   xCF,W
00E22:  SUBLW  E7
00E24:  BC    0E3A
00E26:  MOVF   xD2,W
00E28:  SUBLW  03
00E2A:  BNC   0E3A
00E2C:  BNZ   0E34
00E2E:  MOVF   xD1,W
00E30:  SUBLW  F5
00E32:  BNC   0E3A
.................... 		return 1; 
00E34:  MOVLW  01
00E36:  MOVWF  01
00E38:  BRA    0E72
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
00E3A:  MOVF   xD0,W
00E3C:  SUBLW  06
00E3E:  BC    0E5E
00E40:  XORLW  FF
00E42:  BNZ   0E4A
00E44:  MOVF   xCF,W
00E46:  SUBLW  CF
00E48:  BC    0E5E
00E4A:  MOVF   xD2,W
00E4C:  SUBLW  09
00E4E:  BNC   0E5E
00E50:  BNZ   0E58
00E52:  MOVF   xD1,W
00E54:  SUBLW  D1
00E56:  BNC   0E5E
.................... 		return 1; 
00E58:  MOVLW  01
00E5A:  MOVWF  01
00E5C:  BRA    0E72
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
00E5E:  MOVF   xD2,F
00E60:  BNZ   0E6E
00E62:  MOVF   xD1,W
00E64:  SUBLW  34
00E66:  BNC   0E6E
.................... 		return 1; 
00E68:  MOVLW  01
00E6A:  MOVWF  01
00E6C:  BRA    0E72
....................  
.................... 	return 0; 
00E6E:  MOVLW  00
00E70:  MOVWF  01
.................... } 
00E72:  MOVLB  0
00E74:  GOTO   1E16 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01A06:  MOVFF  2CE,2D7
01A0A:  MOVFF  2CD,2D8
01A0E:  CALL   0EB6
.................... 	modbus_serial_putc(register_count*2); 
01A12:  BCF    FD8.0
01A14:  MOVLB  2
01A16:  RLCF   xD1,W
01A18:  MOVWF  xD7
01A1A:  RLCF   xD2,W
01A1C:  MOVWF  xD8
01A1E:  MOVFF  2D7,2D9
01A22:  MOVLB  0
01A24:  CALL   0E82
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01A28:  MOVLB  2
01A2A:  CLRF   xD4
01A2C:  CLRF   xD3
01A2E:  MOVF   xD4,W
01A30:  SUBWF  xD2,W
01A32:  BNC   1A7E
01A34:  BNZ   1A3C
01A36:  MOVF   xD1,W
01A38:  SUBWF  xD3,W
01A3A:  BC    1A7E
.................... 		l=map_modbus(start_address+i); 
01A3C:  MOVF   xD3,W
01A3E:  ADDWF  xCF,W
01A40:  MOVWF  xD7
01A42:  MOVF   xD4,W
01A44:  ADDWFC xD0,W
01A46:  MOVWF  xD8
01A48:  MOVWF  xDA
01A4A:  MOVFF  2D7,2D9
01A4E:  MOVLB  0
01A50:  GOTO   100C
01A54:  MOVFF  02,2D6
01A58:  MOVFF  01,2D5
.................... 		modbus_serial_putc(make8(l,1)); 
01A5C:  MOVFF  2D6,2D7
01A60:  MOVFF  2D6,2D9
01A64:  CALL   0E82
....................   		modbus_serial_putc(make8(l,0)); 
01A68:  MOVFF  2D5,2D7
01A6C:  MOVFF  2D5,2D9
01A70:  CALL   0E82
.................... 	} 
01A74:  MOVLB  2
01A76:  INCF   xD3,F
01A78:  BTFSC  FD8.2
01A7A:  INCF   xD4,F
01A7C:  BRA    1A2E
....................  
.................... 	modbus_serial_send_stop(); 
01A7E:  MOVLB  0
01A80:  CALL   0EE4
.................... } 
01A84:  GOTO   1E58 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01A88:  MOVLB  2
01A8A:  MOVF   xD4,W
01A8C:  SUBLW  06
01A8E:  BC    1B06
01A90:  XORLW  FF
01A92:  BNZ   1A9A
01A94:  MOVF   xD3,W
01A96:  SUBLW  CF
01A98:  BC    1B06
01A9A:  MOVF   xD4,W
01A9C:  SUBLW  09
01A9E:  BNC   1B06
01AA0:  BNZ   1AA8
01AA2:  MOVF   xD3,W
01AA4:  SUBLW  CF
01AA6:  BNC   1B06
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01AA8:  MOVF   xD6,W
01AAA:  SUBLW  00
01AAC:  BC    1ABE
01AAE:  XORLW  FF
01AB0:  BNZ   1AB8
01AB2:  MOVF   xD5,W
01AB4:  SUBLW  00
01AB6:  BC    1ABE
01AB8:  MOVLW  03
01ABA:  MOVWF  01
01ABC:  BRA    1CF2
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01ABE:  MOVLW  D0
01AC0:  SUBWF  xD3,W
01AC2:  MOVWF  xD7
01AC4:  MOVLW  07
01AC6:  SUBWFB xD4,W
01AC8:  MOVWF  xD8
01ACA:  MOVLW  02
01ACC:  ADDWF  xD8,F
01ACE:  MOVFF  2D8,FAA
01AD2:  MOVFF  2D7,FA9
01AD6:  MOVFF  2D5,FA8
01ADA:  BCF    FA6.6
01ADC:  BCF    FA6.7
01ADE:  BSF    FA6.2
01AE0:  MOVF   FF2,W
01AE2:  MOVWF  00
01AE4:  BCF    FF2.6
01AE6:  BCF    FF2.7
01AE8:  MOVLB  F
01AEA:  MOVLW  55
01AEC:  MOVWF  FA7
01AEE:  MOVLW  AA
01AF0:  MOVWF  FA7
01AF2:  BSF    FA6.1
01AF4:  BTFSC  FA6.1
01AF6:  BRA    1AF4
01AF8:  BCF    FA6.2
01AFA:  MOVF   00,W
01AFC:  IORWF  FF2,F
.................... 		return 0; 
01AFE:  MOVLW  00
01B00:  MOVWF  01
01B02:  MOVLB  2
01B04:  BRA    1CF2
.................... 	} 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01B06:  MOVLB  1
01B08:  MOVF   x8F,F
01B0A:  BZ    1B42
.................... 		if ( 1000 == address ) { 
01B0C:  MOVLB  2
01B0E:  MOVF   xD3,W
01B10:  SUBLW  E8
01B12:  BNZ   1B26
01B14:  MOVF   xD4,W
01B16:  SUBLW  03
01B18:  BNZ   1B26
.................... 			config.serial_prefix=value; 
01B1A:  MOVFF  2D5,39
.................... 			return 0; 
01B1E:  MOVLW  00
01B20:  MOVWF  01
01B22:  BRA    1CF2
.................... 		} else if ( 1001 == address ) { 
01B24:  BRA    1B40
01B26:  MOVF   xD3,W
01B28:  SUBLW  E9
01B2A:  BNZ   1B40
01B2C:  MOVF   xD4,W
01B2E:  SUBLW  03
01B30:  BNZ   1B40
.................... 			config.serial_number=value; 
01B32:  MOVFF  2D6,3B
01B36:  MOVFF  2D5,3A
.................... 			return 0; 
01B3A:  MOVLW  00
01B3C:  MOVWF  01
01B3E:  BRA    1CF2
01B40:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01B42:  MOVLB  2
01B44:  MOVF   xD3,W
01B46:  MOVWF  00
01B48:  MOVF   xD4,W
01B4A:  MOVWF  03
01B4C:  MOVLW  03
01B4E:  SUBWF  03,W
01B50:  BNZ   1B5C
01B52:  MOVLW  EE
01B54:  SUBWF  00,W
01B56:  MOVLB  0
01B58:  BZ    1BF6
01B5A:  MOVLB  2
01B5C:  MOVLW  03
01B5E:  SUBWF  03,W
01B60:  BNZ   1B6C
01B62:  MOVLW  EF
01B64:  SUBWF  00,W
01B66:  MOVLB  0
01B68:  BZ    1C0E
01B6A:  MOVLB  2
01B6C:  MOVLW  03
01B6E:  SUBWF  03,W
01B70:  BNZ   1B7C
01B72:  MOVLW  F0
01B74:  SUBWF  00,W
01B76:  MOVLB  0
01B78:  BZ    1C1E
01B7A:  MOVLB  2
01B7C:  MOVLW  03
01B7E:  SUBWF  03,W
01B80:  BNZ   1B8C
01B82:  MOVLW  F1
01B84:  SUBWF  00,W
01B86:  MOVLB  0
01B88:  BZ    1C36
01B8A:  MOVLB  2
01B8C:  MOVLW  03
01B8E:  SUBWF  03,W
01B90:  BNZ   1B9C
01B92:  MOVLW  F2
01B94:  SUBWF  00,W
01B96:  MOVLB  0
01B98:  BZ    1C42
01B9A:  MOVLB  2
01B9C:  MOVLW  03
01B9E:  SUBWF  03,W
01BA0:  BNZ   1BAC
01BA2:  MOVLW  F3
01BA4:  SUBWF  00,W
01BA6:  MOVLB  0
01BA8:  BZ    1C5C
01BAA:  MOVLB  2
01BAC:  MOVLW  03
01BAE:  SUBWF  03,W
01BB0:  BNZ   1BBE
01BB2:  MOVLW  F4
01BB4:  SUBWF  00,W
01BB6:  MOVLB  0
01BB8:  BTFSC  FD8.2
01BBA:  BRA    1C74
01BBC:  MOVLB  2
01BBE:  MOVLW  07
01BC0:  SUBWF  03,W
01BC2:  BNZ   1BD0
01BC4:  MOVLW  CE
01BC6:  SUBWF  00,W
01BC8:  MOVLB  0
01BCA:  BTFSC  FD8.2
01BCC:  BRA    1C8C
01BCE:  MOVLB  2
01BD0:  MOVLW  07
01BD2:  SUBWF  03,W
01BD4:  BNZ   1BE2
01BD6:  MOVLW  CF
01BD8:  SUBWF  00,W
01BDA:  MOVLB  0
01BDC:  BTFSC  FD8.2
01BDE:  BRA    1CA6
01BE0:  MOVLB  2
01BE2:  MOVLW  4E
01BE4:  SUBWF  03,W
01BE6:  BNZ   1BF4
01BE8:  MOVLW  1F
01BEA:  SUBWF  00,W
01BEC:  MOVLB  0
01BEE:  BTFSC  FD8.2
01BF0:  BRA    1CC0
01BF2:  MOVLB  2
01BF4:  BRA    1CE8
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01BF6:  MOVLB  2
01BF8:  MOVF   xD6,F
01BFA:  BNZ   1C02
01BFC:  MOVF   xD5,W
01BFE:  SUBLW  80
01C00:  BC    1C08
01C02:  MOVLW  03
01C04:  MOVWF  01
01C06:  BRA    1CF2
.................... 			config.modbus_address=value; 
01C08:  MOVFF  2D5,36
.................... 			break; 
01C0C:  BRA    1CEE
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01C0E:  MOVLB  1
01C10:  BSF    xAE.1
.................... 			config.adc_sample_ticks=value; 
01C12:  MOVFF  2D6,3D
01C16:  MOVFF  2D5,3C
.................... 			break; 
01C1A:  MOVLB  2
01C1C:  BRA    1CEE
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01C1E:  MOVLB  2
01C20:  MOVF   xD6,F
01C22:  BNZ   1C2A
01C24:  MOVF   xD5,W
01C26:  SUBLW  01
01C28:  BC    1C30
01C2A:  MOVLW  03
01C2C:  MOVWF  01
01C2E:  BRA    1CF2
.................... 			config.allow_bootload_request=value; 
01C30:  MOVFF  2D5,3E
.................... 			break; 
01C34:  BRA    1CEE
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01C36:  MOVFF  2D6,40
01C3A:  MOVFF  2D5,3F
.................... 			break; 
01C3E:  MOVLB  2
01C40:  BRA    1CEE
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01C42:  MOVLB  2
01C44:  MOVF   xD5,F
01C46:  BNZ   1C52
01C48:  MOVF   xD6,F
01C4A:  BNZ   1C52
01C4C:  MOVLW  03
01C4E:  MOVWF  01
01C50:  BRA    1CF2
.................... 			config.pi_offtime_seconds=value; 
01C52:  MOVFF  2D6,42
01C56:  MOVFF  2D5,41
.................... 			break; 
01C5A:  BRA    1CEE
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01C5C:  MOVLB  2
01C5E:  MOVF   xD6,F
01C60:  BNZ   1C68
01C62:  MOVF   xD5,W
01C64:  SUBLW  01
01C66:  BC    1C6E
01C68:  MOVLW  03
01C6A:  MOVWF  01
01C6C:  BRA    1CF2
.................... 			config.power_startup=value; 
01C6E:  MOVFF  2D5,43
.................... 			break; 
01C72:  BRA    1CEE
....................  
.................... 		case 1012: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01C74:  MOVLB  2
01C76:  MOVF   xD6,F
01C78:  BNZ   1C80
01C7A:  MOVF   xD5,W
01C7C:  SUBLW  01
01C7E:  BC    1C86
01C80:  MOVLW  03
01C82:  MOVWF  01
01C84:  BRA    1CF2
.................... 			config.modbus_bridge=value; 
01C86:  MOVFF  2D5,38
.................... 			break; 
01C8A:  BRA    1CEE
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01C8C:  MOVLB  2
01C8E:  DECFSZ xD5,W
01C90:  BRA    1C96
01C92:  MOVF   xD6,F
01C94:  BZ    1C9C
01C96:  MOVLW  03
01C98:  MOVWF  01
01C9A:  BRA    1CF2
.................... 			write_default_param_file(); 
01C9C:  MOVLB  0
01C9E:  CALL   09EE
.................... 			break; 
01CA2:  MOVLB  2
01CA4:  BRA    1CEE
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01CA6:  MOVLB  2
01CA8:  DECFSZ xD5,W
01CAA:  BRA    1CB0
01CAC:  MOVF   xD6,F
01CAE:  BZ    1CB6
01CB0:  MOVLW  03
01CB2:  MOVWF  01
01CB4:  BRA    1CF2
.................... 			write_param_file(); 
01CB6:  MOVLB  0
01CB8:  CALL   099A
.................... 			break; 
01CBC:  MOVLB  2
01CBE:  BRA    1CEE
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01CC0:  MOVLB  2
01CC2:  MOVF   xD5,W
01CC4:  SUBLW  0A
01CC6:  BNZ   1CCE
01CC8:  MOVF   xD6,W
01CCA:  SUBLW  07
01CCC:  BZ    1CDA
.................... 				current.factory_unlocked=0; 
01CCE:  MOVLB  1
01CD0:  CLRF   x8F
.................... 				return ILLEGAL_DATA_VALUE; 
01CD2:  MOVLW  03
01CD4:  MOVWF  01
01CD6:  MOVLB  2
01CD8:  BRA    1CF2
.................... 			} 
.................... 			current.factory_unlocked=1; 
01CDA:  MOVLW  01
01CDC:  MOVLB  1
01CDE:  MOVWF  x8F
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01CE0:  MOVLW  C8
01CE2:  MOVWF  xAB
.................... 			break; 
01CE4:  MOVLB  2
01CE6:  BRA    1CEE
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01CE8:  MOVLW  02
01CEA:  MOVWF  01
01CEC:  BRA    1CF2
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01CEE:  MOVLW  00
01CF0:  MOVWF  01
.................... } 
01CF2:  MOVLB  0
01CF4:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
01D86:  GOTO   0DD0
01D8A:  MOVF   01,F
01D8C:  BTFSC  FD8.2
01D8E:  BRA    1FCA
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( 1==config.modbus_bridge && modbus_rx.address!=config.modbus_address ) { 
01D90:  DECFSZ 38,W
01D92:  BRA    1DA4
01D94:  MOVF   36,W
01D96:  MOVLB  1
01D98:  SUBWF  xB5,W
01D9A:  BTFSS  FD8.2
01D9C:  BRA    1DA2
01D9E:  MOVLB  0
01DA0:  BRA    1DA4
01DA2:  MOVLB  0
.................... 			/* add to buffer to send to RS-485 network */ 
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
01DA4:  MOVF   36,W
01DA6:  SUBLW  80
01DA8:  BZ    1DB6
01DAA:  MOVF   36,W
01DAC:  MOVLB  1
01DAE:  SUBWF  xB5,W
01DB0:  BTFSS  FD8.2
01DB2:  BRA    1FB6
01DB4:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
01DB6:  MOVLB  1
01DB8:  INCFSZ x83,W
01DBA:  BRA    1DC2
01DBC:  INCFSZ x84,W
01DBE:  BRA    1DC2
01DC0:  BRA    1DC8
.................... 				current.modbus_our_packets++; 
01DC2:  INCF   x83,F
01DC4:  BTFSC  FD8.2
01DC6:  INCF   x84,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
01DC8:  MOVLW  14
01DCA:  MOVWF  xAB
....................  
.................... 			switch(modbus_rx.func) { 
01DCC:  MOVF   xB7,W
01DCE:  XORLW  03
01DD0:  MOVLB  0
01DD2:  BZ    1DE4
01DD4:  XORLW  07
01DD6:  BZ    1DE4
01DD8:  XORLW  02
01DDA:  BZ    1E5C
01DDC:  XORLW  16
01DDE:  BTFSC  FD8.2
01DE0:  BRA    1ECE
01DE2:  BRA    1F90
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01DE4:  MOVFF  1B9,2C8
01DE8:  MOVFF  1BA,2C7
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01DEC:  MOVFF  1BB,2CA
01DF0:  MOVFF  1BC,2C9
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
01DF4:  MOVLB  2
01DF6:  MOVF   xC9,W
01DF8:  ADDWF  xC7,W
01DFA:  MOVWF  xCD
01DFC:  MOVF   xCA,W
01DFE:  ADDWFC xC8,W
01E00:  MOVWF  xCE
01E02:  MOVFF  2C8,2D0
01E06:  MOVFF  2C7,2CF
01E0A:  MOVWF  xD2
01E0C:  MOVFF  2CD,2D1
01E10:  MOVLB  0
01E12:  GOTO   0DF6
01E16:  MOVF   01,F
01E18:  BNZ   1E3E
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
01E1A:  MOVFF  1B5,2CD
01E1E:  MOVLB  2
01E20:  CLRF   xCF
01E22:  MOVFF  1B7,2CE
01E26:  MOVLW  02
01E28:  MOVWF  xD0
01E2A:  MOVLB  0
01E2C:  CALL   0F12
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
01E30:  MOVLB  1
01E32:  CLRF   x88
01E34:  MOVLW  02
01E36:  MOVWF  x87
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
01E38:  CLRF   xAB
.................... 					} else { 
01E3A:  BRA    1E5A
01E3C:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
01E3E:  MOVFF  1B7,2CD
01E42:  MOVFF  1B5,2CE
01E46:  MOVFF  2C8,2D0
01E4A:  MOVFF  2C7,2CF
01E4E:  MOVFF  2CA,2D2
01E52:  MOVFF  2C9,2D1
01E56:  BRA    1A06
01E58:  MOVLB  1
.................... 					} 
.................... 					break; 
01E5A:  BRA    1FB0
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01E5C:  MOVFF  1B9,2C8
01E60:  MOVFF  1BA,2C7
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
01E64:  MOVFF  1BB,2CE
01E68:  MOVFF  1BC,2CD
01E6C:  MOVFF  2C8,2D4
01E70:  MOVFF  2C7,2D3
01E74:  MOVFF  1BB,2D6
01E78:  MOVFF  1BC,2D5
01E7C:  RCALL  1A88
01E7E:  MOVFF  01,2CB
....................  
.................... 					if ( result ) { 
01E82:  MOVLB  2
01E84:  MOVF   xCB,F
01E86:  BZ    1EAA
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
01E88:  MOVFF  1B5,2CD
01E8C:  CLRF   xCF
01E8E:  MOVFF  1B7,2CE
01E92:  MOVFF  2CB,2D0
01E96:  MOVLB  0
01E98:  CALL   0F12
.................... 						current.modbus_last_error=result; 
01E9C:  MOVLB  1
01E9E:  CLRF   x88
01EA0:  MOVFF  2CB,187
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
01EA4:  CLRF   xAB
.................... 					}  else { 
01EA6:  BRA    1ECC
01EA8:  MOVLB  2
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
01EAA:  MOVFF  1BB,2CE
01EAE:  MOVFF  1BC,2CD
01EB2:  MOVFF  1B5,2CF
01EB6:  MOVFF  2C8,2D1
01EBA:  MOVFF  2C7,2D0
01EBE:  MOVFF  1BB,2D3
01EC2:  MOVFF  1BC,2D2
01EC6:  MOVLB  0
01EC8:  BRA    1CF6
01ECA:  MOVLB  1
.................... 					} 
.................... 					break; 
01ECC:  BRA    1FB0
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01ECE:  MOVFF  1B9,2C8
01ED2:  MOVFF  1BA,2C7
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01ED6:  MOVFF  1BB,2CA
01EDA:  MOVFF  1BC,2C9
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
01EDE:  MOVLB  2
01EE0:  CLRF   xCC
01EE2:  MOVF   xCA,F
01EE4:  BNZ   1EEC
01EE6:  MOVF   xC9,W
01EE8:  SUBWF  xCC,W
01EEA:  BC    1F70
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
01EEC:  MOVF   xCC,W
01EEE:  ADDWF  xC7,W
01EF0:  MOVWF  xCD
01EF2:  MOVLW  00
01EF4:  ADDWFC xC8,W
01EF6:  MOVWF  xCE
01EF8:  BCF    FD8.0
01EFA:  RLCF   xCC,W
01EFC:  ADDLW  05
01EFE:  ADDLW  B9
01F00:  MOVWF  FE9
01F02:  MOVLW  01
01F04:  MOVWF  FEA
01F06:  BTFSC  FD8.0
01F08:  INCF   FEA,F
01F0A:  MOVFF  FEF,2CF
01F0E:  BCF    FD8.0
01F10:  RLCF   xCC,W
01F12:  ADDLW  06
01F14:  ADDLW  B9
01F16:  MOVWF  FE9
01F18:  MOVLW  01
01F1A:  MOVWF  FEA
01F1C:  BTFSC  FD8.0
01F1E:  INCF   FEA,F
01F20:  MOVFF  FEF,2D0
01F24:  MOVFF  2CF,2D2
01F28:  MOVFF  2D0,2D1
01F2C:  MOVFF  2CE,2D4
01F30:  MOVFF  2CD,2D3
01F34:  MOVFF  2CF,2D6
01F38:  MOVFF  2D0,2D5
01F3C:  MOVLB  0
01F3E:  RCALL  1A88
01F40:  MOVFF  01,2CB
....................  
.................... 						if ( result ) { 
01F44:  MOVLB  2
01F46:  MOVF   xCB,F
01F48:  BZ    1F6C
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
01F4A:  MOVFF  1B5,2CD
01F4E:  CLRF   xCF
01F50:  MOVFF  1B7,2CE
01F54:  MOVFF  2CB,2D0
01F58:  MOVLB  0
01F5A:  CALL   0F12
.................... 							current.modbus_last_error=result; 
01F5E:  MOVLB  1
01F60:  CLRF   x88
01F62:  MOVFF  2CB,187
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
01F66:  CLRF   xAB
.................... 			 
.................... 							break; 
01F68:  MOVLB  2
01F6A:  BRA    1F70
.................... 						} 
.................... 					} 
01F6C:  INCF   xCC,F
01F6E:  BRA    1EE2
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
01F70:  MOVF   xCB,F
01F72:  BNZ   1F8C
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
01F74:  MOVFF  1B5,2CD
01F78:  MOVFF  2C8,2CF
01F7C:  MOVFF  2C7,2CE
01F80:  MOVFF  2CA,2D1
01F84:  MOVFF  2C9,2D0
01F88:  MOVLB  0
01F8A:  BRA    1D3E
.................... 					} 
....................  
.................... 					break;   
01F8C:  MOVLB  1
01F8E:  BRA    1FB0
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
01F90:  MOVFF  1B5,2CD
01F94:  MOVLB  2
01F96:  CLRF   xCF
01F98:  MOVFF  1B7,2CE
01F9C:  MOVLW  01
01F9E:  MOVWF  xD0
01FA0:  MOVLB  0
01FA2:  CALL   0F12
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
01FA6:  MOVLB  1
01FA8:  CLRF   x88
01FAA:  MOVLW  01
01FAC:  MOVWF  x87
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
01FAE:  CLRF   xAB
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
01FB0:  CLRF   x92
01FB2:  CLRF   x91
....................  
.................... 		} else { 
01FB4:  BRA    1FCA
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
01FB6:  INCFSZ x85,W
01FB8:  BRA    1FC0
01FBA:  INCFSZ x86,W
01FBC:  BRA    1FC0
01FBE:  BRA    1FC6
.................... 				current.modbus_other_packets++; 
01FC0:  INCF   x85,F
01FC2:  BTFSC  FD8.2
01FC4:  INCF   x86,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
01FC6:  MOVLW  14
01FC8:  MOVWF  xAB
01FCA:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
01FCC:  GOTO   20C6 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003E2:  MOVLB  2
003E4:  BTFSS  xE9.0
003E6:  BRA    0400
003E8:  MOVLB  1
003EA:  INCFSZ x9A,W
003EC:  BRA    03F8
003EE:  INCFSZ x9B,W
003F0:  BRA    03F8
003F2:  MOVLB  2
003F4:  BRA    0400
003F6:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
003F8:  INCF   x9A,F
003FA:  BTFSC  FD8.2
003FC:  INCF   x9B,F
003FE:  MOVLB  2
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00400:  BTFSS  xE9.2
00402:  BRA    041C
00404:  MOVLB  1
00406:  INCFSZ x9C,W
00408:  BRA    0414
0040A:  INCFSZ x9D,W
0040C:  BRA    0414
0040E:  MOVLB  2
00410:  BRA    041C
00412:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00414:  INCF   x9C,F
00416:  BTFSC  FD8.2
00418:  INCF   x9D,F
0041A:  MOVLB  2
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0041C:  BTFSS  xE9.4
0041E:  BRA    0438
00420:  MOVLB  1
00422:  INCFSZ x9E,W
00424:  BRA    0430
00426:  INCFSZ x9F,W
00428:  BRA    0430
0042A:  MOVLB  2
0042C:  BRA    0438
0042E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00430:  INCF   x9E,F
00432:  BTFSC  FD8.2
00434:  INCF   x9F,F
00436:  MOVLB  2
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00438:  BCF    xE9.1
0043A:  BTFSC  F81.0
0043C:  BSF    xE9.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0043E:  BTFSC  xE9.1
00440:  BRA    04C0
00442:  MOVLB  1
00444:  BTFSC  xB1.1
00446:  BRA    044C
00448:  MOVLB  2
0044A:  BRA    04C0
.................... 		current.pulse_count[0]++; 
0044C:  MOVLB  0
0044E:  INCF   x60,F
00450:  BTFSC  FD8.2
00452:  INCF   x61,F
.................... 		current.pulse_sum[0]++; 
00454:  MOVLW  01
00456:  ADDWF  x66,F
00458:  BTFSC  FD8.0
0045A:  INCF   x67,F
0045C:  BTFSC  FD8.2
0045E:  INCF   x68,F
00460:  BTFSC  FD8.2
00462:  INCF   x69,F
.................... 		if ( 1 == ext0_state ) { 
00464:  MOVLB  1
00466:  BTFSS  xB1.2
00468:  BRA    04B0
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0046A:  MOVLB  2
0046C:  BCF    xE9.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0046E:  MOVFF  19B,4F
00472:  MOVFF  19A,4E
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
00476:  MOVF   4F,W
00478:  SUBWF  55,W
0047A:  BNC   048C
0047C:  BNZ   0484
0047E:  MOVF   54,W
00480:  SUBWF  4E,W
00482:  BC    048C
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00484:  MOVFF  4F,55
00488:  MOVFF  4E,54
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0048C:  MOVF   5B,W
0048E:  SUBWF  4F,W
00490:  BNC   04AC
00492:  BNZ   049A
00494:  MOVF   4E,W
00496:  SUBWF  5A,W
00498:  BC    04AC
0049A:  INCFSZ 4E,W
0049C:  BRA    04A4
0049E:  INCFSZ 4F,W
004A0:  BRA    04A4
004A2:  BRA    04AC
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004A4:  MOVFF  4F,5B
004A8:  MOVFF  4E,5A
.................... 			} 
.................... 			ext0_state=0; 
004AC:  MOVLB  1
004AE:  BCF    xB1.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004B0:  BTFSC  xB1.2
004B2:  BRA    04C0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004B4:  CLRF   x9B
004B6:  CLRF   x9A
.................... 			ext0_count=1; 
004B8:  MOVLB  2
004BA:  BSF    xE9.0
.................... 			ext0_state=1; 
004BC:  MOVLB  1
004BE:  BSF    xB1.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004C0:  MOVLB  1
004C2:  BCF    xB1.1
004C4:  MOVLB  2
004C6:  BTFSS  xE9.1
004C8:  BRA    04D0
004CA:  MOVLB  1
004CC:  BSF    xB1.1
004CE:  MOVLB  2
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004D0:  BCF    xE9.3
004D2:  BTFSC  F81.1
004D4:  BSF    xE9.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004D6:  BTFSC  xE9.3
004D8:  BRA    0558
004DA:  MOVLB  1
004DC:  BTFSC  xB1.3
004DE:  BRA    04E4
004E0:  MOVLB  2
004E2:  BRA    0558
.................... 		current.pulse_count[1]++; 
004E4:  MOVLB  0
004E6:  INCF   x62,F
004E8:  BTFSC  FD8.2
004EA:  INCF   x63,F
.................... 		current.pulse_sum[1]++; 
004EC:  MOVLW  01
004EE:  ADDWF  x6A,F
004F0:  BTFSC  FD8.0
004F2:  INCF   x6B,F
004F4:  BTFSC  FD8.2
004F6:  INCF   x6C,F
004F8:  BTFSC  FD8.2
004FA:  INCF   x6D,F
.................... 		if ( 1 == ext1_state ) { 
004FC:  MOVLB  1
004FE:  BTFSS  xB1.4
00500:  BRA    0548
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00502:  MOVLB  2
00504:  BCF    xE9.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00506:  MOVFF  19D,51
0050A:  MOVFF  19C,50
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
0050E:  MOVF   51,W
00510:  SUBWF  57,W
00512:  BNC   0524
00514:  BNZ   051C
00516:  MOVF   56,W
00518:  SUBWF  50,W
0051A:  BC    0524
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0051C:  MOVFF  51,57
00520:  MOVFF  50,56
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00524:  MOVF   5D,W
00526:  SUBWF  51,W
00528:  BNC   0544
0052A:  BNZ   0532
0052C:  MOVF   50,W
0052E:  SUBWF  5C,W
00530:  BC    0544
00532:  INCFSZ 50,W
00534:  BRA    053C
00536:  INCFSZ 51,W
00538:  BRA    053C
0053A:  BRA    0544
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
0053C:  MOVFF  51,5D
00540:  MOVFF  50,5C
.................... 			} 
.................... 			ext1_state=0; 
00544:  MOVLB  1
00546:  BCF    xB1.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
00548:  BTFSC  xB1.4
0054A:  BRA    0558
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
0054C:  CLRF   x9D
0054E:  CLRF   x9C
.................... 			ext1_count=1; 
00550:  MOVLB  2
00552:  BSF    xE9.2
.................... 			ext1_state=1; 
00554:  MOVLB  1
00556:  BSF    xB1.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
00558:  MOVLB  1
0055A:  BCF    xB1.3
0055C:  MOVLB  2
0055E:  BTFSS  xE9.3
00560:  BRA    0568
00562:  MOVLB  1
00564:  BSF    xB1.3
00566:  MOVLB  2
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
00568:  BCF    xE9.5
0056A:  BTFSC  F81.2
0056C:  BSF    xE9.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
0056E:  BTFSC  xE9.5
00570:  BRA    05F0
00572:  MOVLB  1
00574:  BTFSC  xB1.5
00576:  BRA    057C
00578:  MOVLB  2
0057A:  BRA    05F0
.................... 		current.pulse_count[2]++; 
0057C:  MOVLB  0
0057E:  INCF   x64,F
00580:  BTFSC  FD8.2
00582:  INCF   x65,F
.................... 		current.pulse_sum[2]++; 
00584:  MOVLW  01
00586:  ADDWF  x6E,F
00588:  BTFSC  FD8.0
0058A:  INCF   x6F,F
0058C:  BTFSC  FD8.2
0058E:  INCF   x70,F
00590:  BTFSC  FD8.2
00592:  INCF   x71,F
.................... 		if ( 1 == ext2_state ) { 
00594:  MOVLB  1
00596:  BTFSS  xB1.6
00598:  BRA    05E0
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0059A:  MOVLB  2
0059C:  BCF    xE9.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
0059E:  MOVFF  19F,53
005A2:  MOVFF  19E,52
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005A6:  MOVF   53,W
005A8:  SUBWF  59,W
005AA:  BNC   05BC
005AC:  BNZ   05B4
005AE:  MOVF   58,W
005B0:  SUBWF  52,W
005B2:  BC    05BC
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005B4:  MOVFF  53,59
005B8:  MOVFF  52,58
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005BC:  MOVF   5F,W
005BE:  SUBWF  53,W
005C0:  BNC   05DC
005C2:  BNZ   05CA
005C4:  MOVF   52,W
005C6:  SUBWF  5E,W
005C8:  BC    05DC
005CA:  INCFSZ 52,W
005CC:  BRA    05D4
005CE:  INCFSZ 53,W
005D0:  BRA    05D4
005D2:  BRA    05DC
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005D4:  MOVFF  53,5F
005D8:  MOVFF  52,5E
.................... 			} 
.................... 			ext2_state=0; 
005DC:  MOVLB  1
005DE:  BCF    xB1.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005E0:  BTFSC  xB1.6
005E2:  BRA    05F0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005E4:  CLRF   x9F
005E6:  CLRF   x9E
.................... 			ext2_count=1; 
005E8:  MOVLB  2
005EA:  BSF    xE9.4
.................... 			ext2_state=1; 
005EC:  MOVLB  1
005EE:  BSF    xB1.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
005F0:  MOVLB  1
005F2:  BCF    xB1.5
005F4:  MOVLB  2
005F6:  BTFSS  xE9.5
005F8:  BRA    0600
005FA:  MOVLB  1
005FC:  BSF    xB1.5
005FE:  MOVLB  2
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00600:  INCF   xBC,F
.................... 	if ( 10 == tick ) { 
00602:  MOVF   xBC,W
00604:  SUBLW  0A
00606:  BNZ   0610
.................... 		tick=0; 
00608:  CLRF   xBC
.................... 		timers.now_millisecond=1; 
0060A:  MOVLB  1
0060C:  BSF    xAE.2
0060E:  MOVLB  2
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
00610:  BCF    F9E.1
00612:  MOVLB  0
00614:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
00630:  BRA    0618
00632:  MOVFF  01,2E6
....................  
.................... 	if ( config.modbus_bridge) { 
00636:  MOVF   38,F
00638:  BZ    063A
.................... 		/* add to buffer to send to PI */ 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
0063A:  BCF    FA4.5
0063C:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
0068C:  RCALL  0640
0068E:  MOVFF  01,2E6
....................  
.................... 	if ( current.bridged_uarts ) { 
00692:  MOVLB  1
00694:  BTFSS  x90.0
00696:  BRA    06A4
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,STREAM_RS485); 
00698:  MOVLB  2
0069A:  MOVF   xE6,W
0069C:  MOVLB  0
0069E:  BRA    0656
.................... 		return; 
006A0:  BRA    06FC
006A2:  MOVLB  1
.................... 	} 
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006A4:  BTFSC  xB1.0
006A6:  BRA    06FE
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
006A8:  MOVF   xB2,F
006AA:  BNZ   06BC
.................... 			modbus_serial_crc.d = 0xFFFF; 
006AC:  SETF   xB4
006AE:  SETF   xB3
.................... 			modbus_rx.address = c; 
006B0:  MOVFF  2E6,1B5
.................... 			modbus_serial_state++; 
006B4:  INCF   xB2,F
.................... 			modbus_rx.len = 0; 
006B6:  CLRF   xB6
.................... 			modbus_rx.error=0; 
006B8:  CLRF   xB8
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
006BA:  BRA    06EA
006BC:  DECFSZ xB2,W
006BE:  BRA    06C8
.................... 			modbus_rx.func = c; 
006C0:  MOVFF  2E6,1B7
.................... 			modbus_serial_state++; 
006C4:  INCF   xB2,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
006C6:  BRA    06EA
006C8:  MOVF   xB2,W
006CA:  SUBLW  02
006CC:  BNZ   06EA
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
006CE:  INCFSZ xB6,W
006D0:  BRA    06D6
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
006D2:  MOVLW  FE
006D4:  MOVWF  xB6
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
006D6:  MOVLW  B9
006D8:  ADDWF  xB6,W
006DA:  MOVWF  FE9
006DC:  MOVLW  01
006DE:  MOVWF  FEA
006E0:  BTFSC  FD8.0
006E2:  INCF   FEA,F
006E4:  MOVFF  2E6,FEF
.................... 			modbus_rx.len++; 
006E8:  INCF   xB6,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
006EA:  MOVFF  2E6,2E7
006EE:  MOVLB  0
006F0:  RCALL  0660
.................... 		modbus_enable_timeout(TRUE); 
006F2:  MOVLW  01
006F4:  MOVLB  2
006F6:  MOVWF  xE7
006F8:  MOVLB  0
006FA:  RCALL  039C
006FC:  MOVLB  1
.................... 	} 
.................... } 
....................  
....................  
....................  
006FE:  BCF    F9E.5
00700:  MOVLB  0
00702:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00728:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
0072A:  MOVLW  08
0072C:  MOVWF  F61
0072E:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
00730:  MOVLW  00
00732:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
00734:  MOVLW  FF
00736:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00738:  MOVLW  92
0073A:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
0073C:  MOVLW  80
0073E:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00740:  BCF    F96.0
00742:  BCF    F96.1
00744:  BCF    F96.2
00746:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00748:  MOVLB  1
0074A:  CLRF   xAB
.................... 	timers.load_off_seconds=2; 
0074C:  CLRF   xAD
0074E:  MOVLW  02
00750:  MOVWF  xAC
.................... 	timers.now_adc_sample=0; 
00752:  BCF    xAE.0
.................... 	timers.now_adc_reset_count=0; 
00754:  BCF    xAE.1
.................... 	timers.now_millisecond=0; 
00756:  BCF    xAE.2
.................... 	timers.port_b=0b11111111; 
00758:  SETF   xAF
.................... 	timers.port_c=0b11111111; 
0075A:  SETF   xB0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
0075C:  MOVLB  2
0075E:  CLRF   xC7
00760:  MOVF   xC7,W
00762:  SUBLW  02
00764:  BNC   0812
.................... 		current.pulse_period[i]=0; 
00766:  CLRF   03
00768:  MOVFF  2C7,02
0076C:  BCF    FD8.0
0076E:  RLCF   02,F
00770:  RLCF   03,F
00772:  MOVF   02,W
00774:  ADDLW  4E
00776:  MOVWF  FE9
00778:  MOVLW  00
0077A:  ADDWFC 03,W
0077C:  MOVWF  FEA
0077E:  CLRF   FEC
00780:  MOVF   FED,F
00782:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
00784:  CLRF   03
00786:  MOVFF  2C7,02
0078A:  BCF    FD8.0
0078C:  RLCF   02,F
0078E:  RLCF   03,F
00790:  MOVF   02,W
00792:  ADDLW  54
00794:  MOVWF  FE9
00796:  MOVLW  00
00798:  ADDWFC 03,W
0079A:  MOVWF  FEA
0079C:  SETF   FEC
0079E:  MOVF   FED,F
007A0:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
007A2:  CLRF   03
007A4:  MOVFF  2C7,02
007A8:  BCF    FD8.0
007AA:  RLCF   02,F
007AC:  RLCF   03,F
007AE:  MOVF   02,W
007B0:  ADDLW  5A
007B2:  MOVWF  FE9
007B4:  MOVLW  00
007B6:  ADDWFC 03,W
007B8:  MOVWF  FEA
007BA:  CLRF   FEC
007BC:  MOVF   FED,F
007BE:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
007C0:  CLRF   03
007C2:  MOVFF  2C7,02
007C6:  BCF    FD8.0
007C8:  RLCF   02,F
007CA:  RLCF   03,F
007CC:  MOVF   02,W
007CE:  ADDLW  60
007D0:  MOVWF  FE9
007D2:  MOVLW  00
007D4:  ADDWFC 03,W
007D6:  MOVWF  FEA
007D8:  CLRF   FEC
007DA:  MOVF   FED,F
007DC:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
007DE:  CLRF   xE2
007E0:  MOVFF  2C7,2E1
007E4:  CLRF   xE4
007E6:  MOVLW  04
007E8:  MOVWF  xE3
007EA:  MOVLB  0
007EC:  RCALL  0706
007EE:  MOVF   01,W
007F0:  ADDLW  66
007F2:  MOVWF  FE9
007F4:  MOVLW  00
007F6:  ADDWFC 02,W
007F8:  MOVWF  FEA
007FA:  MOVF   FEE,F
007FC:  MOVF   FEE,F
007FE:  CLRF   FEC
00800:  MOVF   FED,F
00802:  CLRF   FEF
00804:  MOVF   FED,F
00806:  CLRF   FEF
00808:  MOVF   FED,F
0080A:  CLRF   FEF
.................... 	} 
0080C:  MOVLB  2
0080E:  INCF   xC7,F
00810:  BRA    0760
....................  
.................... 	current.modbus_our_packets=0; 
00812:  MOVLB  1
00814:  CLRF   x84
00816:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
00818:  CLRF   x86
0081A:  CLRF   x85
.................... 	current.modbus_last_error=0; 
0081C:  CLRF   x88
0081E:  CLRF   x87
.................... 	current.sequence_number=0; 
00820:  CLRF   x8A
00822:  CLRF   x89
.................... 	current.uptime_minutes=0; 
00824:  CLRF   x8C
00826:  CLRF   x8B
.................... 	current.interval_milliseconds=0; 
00828:  CLRF   x8E
0082A:  CLRF   x8D
.................... 	current.adc_buffer_index=0; 
0082C:  CLRF   x82
.................... 	current.factory_unlocked=0; 
0082E:  CLRF   x8F
.................... 	current.bridged_uarts=0; 
00830:  BCF    x90.0
.................... 	current.watchdog_seconds=0; 
00832:  CLRF   x92
00834:  CLRF   x91
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00836:  MOVFF  4B,195
0083A:  MOVFF  4A,194
.................... 	current.power_off_delay=config.power_off_below_delay; 
0083E:  MOVFF  47,197
00842:  MOVFF  46,196
.................... 	current.power_override_timeout=0; 
00846:  CLRF   x99
00848:  CLRF   x98
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
0084A:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
0084C:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
0084E:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00850:  MOVLW  00
00852:  IORLW  05
00854:  MOVWF  FBA
00856:  MOVLW  4A
00858:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
0085A:  BSF    F9D.1
.................... //	enable_interrupts(INT_RDA2); /* debug cable */ 
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
0085C:  MOVLB  0
0085E:  GOTO   2072 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00C70:  MOVLB  1
00C72:  BCF    xAE.2
....................  
.................... //	fputc('.',DEBUG); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(DEBUG,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00C74:  BCF    FD8.0
00C76:  MOVLB  2
00C78:  RLCF   xC2,W
00C7A:  MOVWF  xC7
00C7C:  RLCF   xC3,W
00C7E:  MOVWF  xC8
00C80:  MOVLW  00
00C82:  MOVLB  1
00C84:  BTFSS  xB0.5
00C86:  MOVLW  01
00C88:  MOVLB  2
00C8A:  IORWF  xC7,F
00C8C:  MOVFF  2C7,2C2
00C90:  MOVF   xC8,W
00C92:  IORLW  E0
00C94:  MOVWF  xC3
.................... 	if ( b2_state==0xf000) { 
00C96:  MOVF   xC2,F
00C98:  BNZ   0CA0
00C9A:  MOVF   xC3,W
00C9C:  SUBLW  F0
00C9E:  BNZ   0CA0
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00CA0:  MOVLB  1
00CA2:  INCFSZ x9A,W
00CA4:  BRA    0CAE
00CA6:  INCFSZ x9B,W
00CA8:  BRA    0CAE
.................... 				current.pulse_period[0]=0; 
00CAA:  CLRF   4F
00CAC:  CLRF   4E
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00CAE:  INCFSZ x9C,W
00CB0:  BRA    0CBA
00CB2:  INCFSZ x9D,W
00CB4:  BRA    0CBA
.................... 				current.pulse_period[1]=0; 
00CB6:  CLRF   51
00CB8:  CLRF   50
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00CBA:  INCFSZ x9E,W
00CBC:  BRA    0CC6
00CBE:  INCFSZ x9F,W
00CC0:  BRA    0CC6
.................... 				current.pulse_period[2]=0; 
00CC2:  CLRF   53
00CC4:  CLRF   52
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00CC6:  MOVFF  F81,1AF
.................... 	timers.port_c=port_c; 
00CCA:  MOVFF  F82,1B0
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00CCE:  BTFSS  x90.0
00CD0:  BRA    0CD6
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00CD2:  BSF    F89.3
.................... 	} else { 
00CD4:  BRA    0CE2
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00CD6:  MOVF   xAB,F
00CD8:  BNZ   0CDE
.................... 			output_low(LED_GREEN); 
00CDA:  BCF    F89.3
.................... 		} else { 
00CDC:  BRA    0CE2
.................... 			output_high(LED_GREEN); 
00CDE:  BSF    F89.3
.................... 			timers.led_on_green--; 
00CE0:  DECF   xAB,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00CE2:  INCFSZ x8D,W
00CE4:  BRA    0CEC
00CE6:  INCFSZ x8E,W
00CE8:  BRA    0CEC
00CEA:  BRA    0CF2
.................... 		current.interval_milliseconds++; 
00CEC:  INCF   x8D,F
00CEE:  BTFSC  FD8.2
00CF0:  INCF   x8E,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00CF2:  MOVLB  2
00CF4:  INCF   xC0,F
00CF6:  BTFSC  FD8.2
00CF8:  INCF   xC1,F
.................... 	if ( 1000 == ticks ) { 
00CFA:  MOVF   xC0,W
00CFC:  SUBLW  E8
00CFE:  BNZ   0D84
00D00:  MOVF   xC1,W
00D02:  SUBLW  03
00D04:  BNZ   0D84
.................... 		ticks=0; 
00D06:  CLRF   xC1
00D08:  CLRF   xC0
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00D0A:  MOVLB  1
00D0C:  INCFSZ x91,W
00D0E:  BRA    0D16
00D10:  INCFSZ x92,W
00D12:  BRA    0D16
00D14:  BRA    0D1C
.................... 			current.watchdog_seconds++; 
00D16:  INCF   x91,F
00D18:  BTFSC  FD8.2
00D1A:  INCF   x92,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00D1C:  MOVF   3F,F
00D1E:  BNZ   0D24
00D20:  MOVF   40,F
00D22:  BZ    0D42
00D24:  MOVF   40,W
00D26:  SUBWF  x92,W
00D28:  BNC   0D42
00D2A:  BNZ   0D32
00D2C:  MOVF   x91,W
00D2E:  SUBWF  3F,W
00D30:  BC    0D42
00D32:  MOVF   xAC,F
00D34:  BNZ   0D42
00D36:  MOVF   xAD,F
00D38:  BNZ   0D42
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00D3A:  MOVFF  42,1AD
00D3E:  MOVFF  41,1AC
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00D42:  MOVF   xAC,F
00D44:  BNZ   0D4E
00D46:  MOVF   xAD,F
00D48:  BNZ   0D4E
.................... 			output_high(PI_POWER_EN); 
00D4A:  BSF    F8B.0
.................... 		} else { 
00D4C:  BRA    0D64
.................... 			output_low(PI_POWER_EN); 
00D4E:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00D50:  MOVF   xAC,W
00D52:  BTFSC  FD8.2
00D54:  DECF   xAD,F
00D56:  DECF   xAC,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00D58:  MOVF   xAC,F
00D5A:  BNZ   0D64
00D5C:  MOVF   xAD,F
00D5E:  BNZ   0D64
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00D60:  CLRF   x92
00D62:  CLRF   x91
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00D64:  MOVLB  2
00D66:  INCF   xBD,F
.................... 		if ( 60 == uptimeTicks ) { 
00D68:  MOVF   xBD,W
00D6A:  SUBLW  3C
00D6C:  BNZ   0D84
.................... 			uptimeTicks=0; 
00D6E:  CLRF   xBD
.................... 			if ( current.uptime_minutes < 65535 )  
00D70:  MOVLB  1
00D72:  INCFSZ x8B,W
00D74:  BRA    0D7C
00D76:  INCFSZ x8C,W
00D78:  BRA    0D7C
00D7A:  BRA    0D82
.................... 				current.uptime_minutes++; 
00D7C:  INCF   x8B,F
00D7E:  BTFSC  FD8.2
00D80:  INCF   x8C,F
00D82:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00D84:  INCFSZ xC4,W
00D86:  BRA    0D9A
00D88:  INCFSZ xC5,W
00D8A:  BRA    0D9A
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00D8C:  CLRF   xDB
00D8E:  MOVLB  0
00D90:  RCALL  0BE8
00D92:  MOVFF  02,2C5
00D96:  MOVFF  01,2C4
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00D9A:  MOVLB  1
00D9C:  BTFSS  xAE.1
00D9E:  BRA    0DA8
.................... 		timers.now_adc_reset_count=0; 
00DA0:  BCF    xAE.1
.................... 		adcTicks=0; 
00DA2:  MOVLB  2
00DA4:  CLRF   xBF
00DA6:  CLRF   xBE
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00DA8:  MOVLB  2
00DAA:  INCF   xBE,F
00DAC:  BTFSC  FD8.2
00DAE:  INCF   xBF,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00DB0:  MOVF   3C,W
00DB2:  SUBWF  xBE,W
00DB4:  BNZ   0DCA
00DB6:  MOVF   3D,W
00DB8:  SUBWF  xBF,W
00DBA:  BNZ   0DCA
.................... 		adcTicks=0; 
00DBC:  CLRF   xBF
00DBE:  CLRF   xBE
.................... 		timers.now_adc_sample=1; 
00DC0:  MOVLB  1
00DC2:  BSF    xAE.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00DC4:  MOVLB  2
00DC6:  SETF   xC5
00DC8:  SETF   xC4
.................... 	} 
....................  
....................  
....................  
.................... } 
00DCA:  MOVLB  0
00DCC:  GOTO   20B4 (RETURN)
....................  
....................  
.................... void main(void) { 
*
01FD0:  CLRF   FF8
01FD2:  BCF    FF1.2
01FD4:  BSF    F9F.1
01FD6:  BCF    F9F.5
01FD8:  BCF    FA5.5
01FDA:  BSF    FD0.7
01FDC:  BSF    07.7
01FDE:  CLRF   FEA
01FE0:  CLRF   FE9
01FE2:  CLRF   35
01FE4:  BCF    FB8.3
01FE6:  MOVLW  0C
01FE8:  MOVWF  FAF
01FEA:  MOVLW  A6
01FEC:  MOVWF  FAC
01FEE:  MOVLW  90
01FF0:  MOVWF  FAB
01FF2:  BCF    F70.3
01FF4:  MOVLW  4D
01FF6:  MOVWF  F75
01FF8:  MOVLW  A6
01FFA:  MOVWF  F72
01FFC:  MOVLW  90
01FFE:  MOVWF  F71
02000:  MOVLB  1
02002:  BCF    xB1.0
02004:  CLRF   xB2
02006:  MOVLB  2
02008:  CLRF   xBC
0200A:  MOVLB  1
0200C:  BCF    xB1.1
0200E:  BCF    xB1.2
02010:  BCF    xB1.3
02012:  BCF    xB1.4
02014:  BCF    xB1.5
02016:  BCF    xB1.6
02018:  MOVLB  2
0201A:  CLRF   xBD
0201C:  CLRF   xBF
0201E:  CLRF   xBE
02020:  CLRF   xC1
02022:  CLRF   xC0
02024:  CLRF   xC3
02026:  CLRF   xC2
02028:  MOVF   FC1,W
0202A:  ANDLW  F0
0202C:  MOVWF  FC1
0202E:  MOVLW  00
02030:  MOVLB  F
02032:  MOVWF  x38
02034:  MOVWF  x3C
02036:  MOVWF  x39
02038:  MOVWF  x3A
0203A:  MOVWF  x3B
0203C:  MOVLB  1
0203E:  CLRF   x88
02040:  CLRF   F77
02042:  CLRF   F78
02044:  CLRF   F79
02046:  CLRF   2F
02048:  CLRF   30
0204A:  MOVLB  2
0204C:  CLRF   xB8
0204E:  CLRF   xB9
02050:  CLRF   xBA
02052:  CLRF   xBB
02054:  CLRF   xC4
02056:  CLRF   xC5
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02058:  MOVF   FD0,W
0205A:  ANDLW  0F
0205C:  BTFSS  FD0.4
0205E:  MOVLW  00
02060:  BSF    FD0.0
02062:  BSF    FD0.1
02064:  BSF    FD0.4
02066:  BSF    FD8.3
02068:  BSF    FD8.4
0206A:  MOVWF  xC6
....................  
.................... 	init(); 
0206C:  MOVLB  0
0206E:  GOTO   0728
....................  
....................  
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
02072:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
02074:  BSF    F8C.0
....................  
.................... #if 0 
.................... 	fprintf(DEBUG,"# pcwx %s\r\n",__DATE__); 
.................... 	fprintf(DEBUG,"# restart_cause()=%u ",i); 
.................... 	switch ( i ) { 
.................... 		case WDT_TIMEOUT: fprintf(DEBUG,"WDT_TIMEOUT"); break; 
.................... 		case MCLR_FROM_SLEEP: fprintf(DEBUG,"MCLR_FROM_SLEEP"); break; 
.................... 		case MCLR_FROM_RUN: fprintf(DEBUG,"MCLR_FROM_RUN"); break; 
.................... 		case NORMAL_POWER_UP: fprintf(DEBUG,"NORMAL_POWER_UP"); break; 
.................... 		case BROWNOUT_RESTART: fprintf(DEBUG,"BROWNOUT_RESTART"); break; 
.................... 		case WDT_FROM_SLEEP: fprintf(DEBUG,"WDT_FROM_SLEEP"); break; 
.................... 		case RESET_INSTRUCTION: fprintf(DEBUG,"RESET_INSTRUCTION"); break; 
.................... 		default: fprintf(DEBUG,"unknown!"); 
.................... 	} 
.................... 	fprintf(DEBUG,"\r\n"); 
.................... #endif 
....................  
.................... //	fprintf(DEBUG,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02076:  GOTO   0A26
.................... //	fprintf(DEBUG," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
0207A:  MOVF   36,W
0207C:  SUBLW  80
0207E:  BC    2084
.................... //		fprintf(DEBUG,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02080:  CALL   09EE
.................... //		fprintf(DEBUG," complete\r\n"); 
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02084:  BSF    FAB.7
02086:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(DEBUG,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02088:  GOTO   0A84
.................... //	fprintf(DEBUG," complete\r\n"); 
....................  
.................... //	fprintf(DEBUG,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
0208C:  MOVLB  2
0208E:  CLRF   xC6
02090:  MOVF   xC6,W
02092:  SUBLW  1D
02094:  BNC   20A2
.................... 		adc_update(); 
02096:  MOVLB  0
02098:  CALL   0B42
.................... 	} 
0209C:  MOVLB  2
0209E:  INCF   xC6,F
020A0:  BRA    2090
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
020A2:  MOVFF  43,193
....................  
....................  
.................... #if 0 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
.................... 	output_low(RS485_DE); 
.................... 	output_low(RS485_NRE); 
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
020A6:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(DEBUG) ) { 
.................... 				fputc(fgetc(DEBUG),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
020A8:  MOVLB  1
020AA:  BTFSS  xAE.2
020AC:  BRA    20B6
.................... 			periodic_millisecond(); 
020AE:  MOVLB  0
020B0:  GOTO   0C70
020B4:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
020B6:  BTFSS  xAE.0
020B8:  BRA    20C2
.................... 			timers.now_adc_sample=0; 
020BA:  BCF    xAE.0
.................... 			adc_update(); 
020BC:  MOVLB  0
020BE:  CALL   0B42
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
020C2:  MOVLB  0
020C4:  BRA    1D86
.................... //		} 
....................  
.................... 	} 
020C6:  MOVLB  2
020C8:  BRA    20A6
.................... } 
020CA:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
