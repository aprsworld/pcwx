CCS PCH C Compiler, Version 4.135, 4375               23-Nov-15 16:53

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 11686 bytes (18%)
                         Largest free fragment is 53846
               RAM used: 2265 (58%) at main() level
                         2541 (65%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   2B3E
*
00008:  GOTO   00E2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   041C
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   07A6
0007C:  BTFSS  F9D.4
0007E:  GOTO   0088
00082:  BTFSC  F9E.4
00084:  GOTO   0732
00088:  BTFSS  FA3.5
0008A:  GOTO   0094
0008E:  BTFSC  FA4.5
00090:  GOTO   06AA
00094:  MOVFF  0E,00
00098:  MOVFF  0F,01
0009C:  MOVFF  10,02
000A0:  MOVFF  11,03
000A4:  MOVFF  0C,FE9
000A8:  MOVFF  07,FEA
000AC:  BSF    07.7
000AE:  MOVFF  08,FE1
000B2:  MOVFF  09,FE2
000B6:  MOVFF  0A,FD9
000BA:  MOVFF  0B,FDA
000BE:  MOVFF  12,FF3
000C2:  MOVFF  13,FF4
000C6:  MOVFF  14,FFA
000CA:  MOVFF  15,FF5
000CE:  MOVFF  16,FF6
000D2:  MOVFF  17,FF7
000D6:  MOVF   04,W
000D8:  MOVFF  06,FE0
000DC:  MOVFF  05,FD8
000E0:  RETFIE 0
000E2:  MOVWF  1A
000E4:  MOVFF  FD8,1B
000E8:  MOVFF  FE0,1C
000EC:  MOVLB  0
000EE:  MOVFF  FE9,22
000F2:  MOVFF  FEA,1D
000F6:  MOVFF  FE1,1E
000FA:  MOVFF  FE2,1F
000FE:  MOVFF  FD9,20
00102:  MOVFF  FDA,21
00106:  MOVFF  FF3,28
0010A:  MOVFF  FF4,29
0010E:  MOVFF  FFA,2A
00112:  MOVFF  FF5,2B
00116:  MOVFF  FF6,2C
0011A:  MOVFF  FF7,2D
0011E:  MOVFF  00,24
00122:  MOVFF  01,25
00126:  MOVFF  02,26
0012A:  MOVFF  03,27
0012E:  BTFSS  F9D.1
00130:  GOTO   013A
00134:  BTFSC  F9E.1
00136:  GOTO   044E
0013A:  MOVFF  24,00
0013E:  MOVFF  25,01
00142:  MOVFF  26,02
00146:  MOVFF  27,03
0014A:  MOVFF  22,FE9
0014E:  MOVFF  1D,FEA
00152:  BSF    1D.7
00154:  MOVFF  1E,FE1
00158:  MOVFF  1F,FE2
0015C:  MOVFF  20,FD9
00160:  MOVFF  21,FDA
00164:  MOVFF  28,FF3
00168:  MOVFF  29,FF4
0016C:  MOVFF  2A,FFA
00170:  MOVFF  2B,FF5
00174:  MOVFF  2C,FF6
00178:  MOVFF  2D,FF7
0017C:  MOVF   1A,W
0017E:  MOVFF  1C,FE0
00182:  MOVFF  1B,FD8
00186:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
0297A:  MOVLB  9
0297C:  MOVF   xE3,F
0297E:  BNZ   2984
02980:  MOVF   xE4,F
02982:  BZ    2A08
....................       if (*s1 != *s2) 
02984:  MOVFF  9DF,FE9
02988:  MOVFF  9E0,FEA
0298C:  MOVFF  FEF,9E5
02990:  MOVFF  9E2,03
02994:  MOVFF  9E1,FE9
02998:  MOVFF  9E2,FEA
0299C:  MOVF   FEF,W
0299E:  SUBWF  xE5,W
029A0:  BZ    29D0
....................          return((*s1 <*s2) ? -1: 1); 
029A2:  MOVFF  9E0,03
029A6:  MOVFF  9DF,FE9
029AA:  MOVFF  9E0,FEA
029AE:  MOVFF  FEF,9E5
029B2:  MOVFF  9E2,03
029B6:  MOVFF  9E1,FE9
029BA:  MOVFF  9E2,FEA
029BE:  MOVF   FEF,W
029C0:  SUBWF  xE5,W
029C2:  BC    29C8
029C4:  MOVLW  FF
029C6:  BRA    29CA
029C8:  MOVLW  01
029CA:  MOVWF  01
029CC:  BRA    2A0C
....................       else if (*s1 == '\0') 
029CE:  BRA    29E6
029D0:  MOVFF  9E0,03
029D4:  MOVFF  9DF,FE9
029D8:  MOVFF  9E0,FEA
029DC:  MOVF   FEF,F
029DE:  BNZ   29E6
....................          return(0); 
029E0:  MOVLW  00
029E2:  MOVWF  01
029E4:  BRA    2A0C
029E6:  MOVFF  9E0,03
029EA:  MOVF   xDF,W
029EC:  INCF   xDF,F
029EE:  BTFSC  FD8.2
029F0:  INCF   xE0,F
029F2:  MOVFF  9E2,03
029F6:  MOVF   xE1,W
029F8:  INCF   xE1,F
029FA:  BTFSC  FD8.2
029FC:  INCF   xE2,F
029FE:  MOVF   xE3,W
02A00:  BTFSC  FD8.2
02A02:  DECF   xE4,F
02A04:  DECF   xE3,F
02A06:  BRA    297C
....................    return(0); 
02A08:  MOVLW  00
02A0A:  MOVWF  01
.................... } 
02A0C:  MOVLB  0
02A0E:  GOTO   2AE2 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
011D0:  MOVLW  05
011D2:  MOVLB  8
011D4:  SUBWF  xE0,F
011D6:  BNC   11EC
011D8:  MOVLW  08
011DA:  MOVWF  FEA
011DC:  MOVLW  E0
011DE:  MOVWF  FE9
011E0:  MOVF   FEF,W
011E2:  BZ    11EC
011E4:  BRA    11E8
011E6:  CLRWDT
011E8:  DECFSZ FEF,F
011EA:  BRA    11E6
011EC:  MOVLB  0
011EE:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0072A:  BTFSS  F9E.4
0072C:  BRA    072A
0072E:  MOVWF  FAD
00730:  RETURN 0
*
00764:  BTFSS  F9E.5
00766:  BRA    0764
00768:  MOVFF  FAB,35
0076C:  MOVFF  FAE,01
00770:  BTFSS  35.1
00772:  BRA    0778
00774:  BCF    FAB.4
00776:  BSF    FAB.4
00778:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00692:  BTFSS  FA4.5
00694:  BRA    0692
00696:  MOVFF  F71,35
0069A:  MOVFF  F74,01
0069E:  BTFSS  35.1
006A0:  BRA    06A6
006A2:  BCF    F71.4
006A4:  BSF    F71.4
006A6:  GOTO   06AC (RETURN)
*
011F0:  BTFSS  FA4.4
011F2:  BRA    11F0
011F4:  MOVWF  F73
011F6:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define _PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
....................  
.................... 	/* transmit buffer for PIC to PI */ 
.................... 	int8 rda_tx_buff[256]; 
.................... 	int8 rda_tx_length; 
.................... 	int8 rda_tx_pos; 
.................... 	int1 now_rda_tx_ready; 
.................... 	int1 now_rda_tx_done; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00F3A:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00E9A:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00E9C:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00E9E:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00EA0:  MOVLB  8
00EA2:  MOVF   xDC,F
00EA4:  BNZ   0EAC
.................... 		c=0b00011; 
00EA6:  MOVLW  03
00EA8:  MOVWF  xE0
.................... 	else if ( 1 == ch )  
00EAA:  BRA    0EF6
00EAC:  DECFSZ xDC,W
00EAE:  BRA    0EB6
.................... 		c=0b10011; 
00EB0:  MOVLW  13
00EB2:  MOVWF  xE0
.................... 	else if ( 2 == ch )  
00EB4:  BRA    0EF6
00EB6:  MOVF   xDC,W
00EB8:  SUBLW  02
00EBA:  BNZ   0EC2
.................... 		c=0b01011; 
00EBC:  MOVLW  0B
00EBE:  MOVWF  xE0
.................... 	else if ( 3 == ch )  
00EC0:  BRA    0EF6
00EC2:  MOVF   xDC,W
00EC4:  SUBLW  03
00EC6:  BNZ   0ECE
.................... 		c=0b11011; 
00EC8:  MOVLW  1B
00ECA:  MOVWF  xE0
.................... 	else if ( 4 == ch ) 
00ECC:  BRA    0EF6
00ECE:  MOVF   xDC,W
00ED0:  SUBLW  04
00ED2:  BNZ   0EDA
.................... 		c=0b00111; 
00ED4:  MOVLW  07
00ED6:  MOVWF  xE0
.................... 	else if ( 5 == ch )  
00ED8:  BRA    0EF6
00EDA:  MOVF   xDC,W
00EDC:  SUBLW  05
00EDE:  BNZ   0EE6
.................... 		c=0b10111; 
00EE0:  MOVLW  17
00EE2:  MOVWF  xE0
.................... 	else if ( 6 == ch ) 
00EE4:  BRA    0EF6
00EE6:  MOVF   xDC,W
00EE8:  SUBLW  06
00EEA:  BNZ   0EF2
.................... 		c=0b01111; 
00EEC:  MOVLW  0F
00EEE:  MOVWF  xE0
.................... 	else 
00EF0:  BRA    0EF6
.................... 		c=0b11111; 
00EF2:  MOVLW  1F
00EF4:  MOVWF  xE0
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00EF6:  CLRF   xDF
00EF8:  MOVF   xDF,W
00EFA:  SUBLW  04
00EFC:  BNC   0F14
.................... 		output_low(MCP3208_CLK); 
00EFE:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00F00:  BTFSC  xE0.0
00F02:  BRA    0F08
00F04:  BCF    F8B.5
00F06:  BRA    0F0A
00F08:  BSF    F8B.5
.................... 		c=c>>1; 
00F0A:  BCF    FD8.0
00F0C:  RRCF   xE0,F
.................... 		output_high(MCP3208_CLK); 
00F0E:  BSF    F8B.3
.................... 	} 
00F10:  INCF   xDF,F
00F12:  BRA    0EF8
....................  
....................  
.................... 	value=0; 
00F14:  CLRF   xDE
00F16:  CLRF   xDD
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00F18:  CLRF   xDF
00F1A:  MOVF   xDF,W
00F1C:  SUBLW  0D
00F1E:  BNC   0F36
.................... 		output_low(MCP3208_CLK); 
00F20:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00F22:  BTFSC  F82.4
00F24:  BRA    0F2A
00F26:  BCF    FD8.0
00F28:  BRA    0F2C
00F2A:  BSF    FD8.0
00F2C:  RLCF   xDD,F
00F2E:  RLCF   xDE,F
.................... 		output_high(MCP3208_CLK); 
00F30:  BSF    F8B.3
.................... 	} 
00F32:  INCF   xDF,F
00F34:  BRA    0F1A
....................  
.................... 	bit_clear(value,13); 
00F36:  BCF    xDE.5
.................... 	bit_clear(value,12); 
00F38:  BCF    xDE.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00F3C:  MOVFF  8DD,01
00F40:  MOVFF  8DE,02
.................... } 
00F44:  MOVLB  0
00F46:  GOTO   0FB8 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
013DA:  MOVLB  9
013DC:  CLRF   xDE
013DE:  MOVFF  8F1,9DD
013E2:  CLRF   xE0
013E4:  MOVLW  20
013E6:  MOVWF  xDF
013E8:  MOVLB  0
013EA:  CALL   08D6
013EE:  MOVFF  02,03
013F2:  MOVF   01,W
013F4:  ADDLW  CB
013F6:  MOVWF  01
013F8:  MOVLW  00
013FA:  ADDWFC 03,F
013FC:  MOVFF  01,8F5
01400:  MOVLB  8
01402:  MOVFF  03,8F6
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
01406:  CLRF   xF3
01408:  CLRF   xF2
.................... 	for( i = 0; i < 16 ; i++ ) { 
0140A:  CLRF   xF4
0140C:  MOVF   xF4,W
0140E:  SUBLW  0F
01410:  BNC   1434
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
01412:  BCF    FD8.0
01414:  RLCF   xF4,W
01416:  CLRF   03
01418:  ADDWF  xF5,W
0141A:  MOVWF  FE9
0141C:  MOVF   xF6,W
0141E:  ADDWFC 03,W
01420:  MOVWF  FEA
01422:  MOVFF  FEC,03
01426:  MOVF   FED,F
01428:  MOVF   FEF,W
0142A:  ADDWF  xF2,F
0142C:  MOVF   03,W
0142E:  ADDWFC xF3,F
.................... 	} 
01430:  INCF   xF4,F
01432:  BRA    140C
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
01434:  MOVLW  08
01436:  ADDWF  xF2,W
01438:  MOVWF  xF7
0143A:  MOVLW  00
0143C:  ADDWFC xF3,W
0143E:  MOVWF  xF8
01440:  RRCF   xF8,W
01442:  MOVWF  03
01444:  RRCF   xF7,W
01446:  MOVWF  02
01448:  RRCF   03,F
0144A:  RRCF   02,F
0144C:  RRCF   03,F
0144E:  RRCF   02,F
01450:  RRCF   03,F
01452:  RRCF   02,F
01454:  MOVLW  0F
01456:  ANDWF  03,F
01458:  MOVFF  02,01
0145C:  MOVFF  03,02
.................... } 
01460:  MOVLB  0
01462:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00F4A:  MOVLB  1
00F4C:  INCF   xCB,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00F4E:  MOVF   xCB,W
00F50:  SUBLW  0F
00F52:  BC    0F56
.................... 		current.adc_buffer_index=0; 
00F54:  CLRF   xCB
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00F56:  MOVLB  8
00F58:  CLRF   xD9
00F5A:  MOVF   xD9,W
00F5C:  SUBLW  07
00F5E:  BNC   0FEE
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00F60:  MOVLB  9
00F62:  CLRF   xDE
00F64:  MOVFF  8D9,9DD
00F68:  CLRF   xE0
00F6A:  MOVLW  20
00F6C:  MOVWF  xDF
00F6E:  MOVLB  0
00F70:  RCALL  08D6
00F72:  MOVFF  02,03
00F76:  MOVF   01,W
00F78:  ADDLW  34
00F7A:  MOVLB  8
00F7C:  MOVWF  xDA
00F7E:  MOVLW  00
00F80:  ADDWFC 02,W
00F82:  MOVWF  xDB
00F84:  CLRF   03
00F86:  MOVLB  1
00F88:  MOVFF  1CB,02
00F8C:  BCF    FD8.0
00F8E:  RLCF   02,F
00F90:  RLCF   03,F
00F92:  MOVF   02,W
00F94:  MOVLB  8
00F96:  ADDWF  xDA,W
00F98:  MOVWF  01
00F9A:  MOVF   xDB,W
00F9C:  ADDWFC 03,F
00F9E:  MOVF   01,W
00FA0:  ADDLW  97
00FA2:  MOVWF  01
00FA4:  MOVLW  00
00FA6:  ADDWFC 03,F
00FA8:  MOVFF  01,8DA
00FAC:  MOVFF  03,8DB
00FB0:  MOVFF  8D9,8DC
00FB4:  MOVLB  0
00FB6:  BRA    0E9A
00FB8:  MOVFF  8DB,FEA
00FBC:  MOVFF  8DA,FE9
00FC0:  MOVFF  02,FEC
00FC4:  MOVF   FED,F
00FC6:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00FCA:  CLRF   03
00FCC:  MOVLB  8
00FCE:  MOVFF  8D9,02
00FD2:  BCF    FD8.0
00FD4:  RLCF   02,F
00FD6:  RLCF   03,F
00FD8:  MOVF   02,W
00FDA:  ADDLW  BB
00FDC:  MOVWF  FE9
00FDE:  MOVLW  00
00FE0:  ADDWFC 03,W
00FE2:  MOVWF  FEA
00FE4:  CLRF   FEC
00FE6:  MOVF   FED,F
00FE8:  CLRF   FEF
....................  
.................... 	} 
00FEA:  INCF   xD9,F
00FEC:  BRA    0F5A
.................... } 
00FEE:  MOVLB  0
00FF0:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00C6C:  MOVF   xF6,W
00C6E:  XORWF  xF7,W
00C70:  MOVWF  01
*
00CBE:  MOVF   xF6,W
00CC0:  XORWF  xF7,W
00CC2:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00BF6:  MOVLB  8
00BF8:  CLRF   xE2
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BFA:  MOVFF  8E1,03
00BFE:  MOVF   xE0,W
00C00:  BTFSC  FD8.2
00C02:  DECF   xE1,F
00C04:  DECF   xE0,F
00C06:  MOVWF  xE3
00C08:  MOVFF  03,8E4
00C0C:  MOVF   xE3,F
00C0E:  BNZ   0C14
00C10:  MOVF   xE4,F
00C12:  BZ    0C7E
.................... 		*data = read_eeprom( address++ ); 
00C14:  MOVFF  8DF,03
00C18:  MOVF   xDE,W
00C1A:  MOVWF  FE9
00C1C:  MOVFF  03,FEA
00C20:  MOVF   xDD,W
00C22:  MOVWF  03
00C24:  MOVF   xDC,W
00C26:  INCF   xDC,F
00C28:  BTFSC  FD8.2
00C2A:  INCF   xDD,F
00C2C:  MOVWF  xE5
00C2E:  MOVFF  03,8E6
00C32:  MOVFF  FF2,8E7
00C36:  BCF    FF2.6
00C38:  BCF    FF2.7
00C3A:  MOVFF  8E6,FAA
00C3E:  MOVFF  8E5,FA9
00C42:  BCF    FA6.6
00C44:  BCF    FA6.7
00C46:  BSF    FA6.0
00C48:  MOVF   FA8,W
00C4A:  BTFSC  xE7.6
00C4C:  BSF    FF2.6
00C4E:  BTFSC  xE7.7
00C50:  BSF    FF2.7
00C52:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00C54:  MOVFF  8DF,03
00C58:  MOVF   xDE,W
00C5A:  MOVWF  FE9
00C5C:  MOVFF  03,FEA
00C60:  MOVFF  FEF,8E3
00C64:  MOVFF  8E2,8F6
00C68:  MOVFF  8E3,8F7
*
00C72:  MOVFF  01,8E2
.................... 		data++; 
00C76:  INCF   xDE,F
00C78:  BTFSC  FD8.2
00C7A:  INCF   xDF,F
.................... 	} 
00C7C:  BRA    0BFA
.................... 	return crc; 
00C7E:  MOVFF  8E2,01
.................... } 
00C82:  MOVLB  0
00C84:  GOTO   0E4E (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00C88:  MOVLB  8
00C8A:  CLRF   xF4
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00C8C:  MOVFF  8F3,03
00C90:  MOVF   xF2,W
00C92:  BTFSC  FD8.2
00C94:  DECF   xF3,F
00C96:  DECF   xF2,F
00C98:  MOVWF  xF5
00C9A:  MOVFF  03,8F6
00C9E:  MOVF   xF5,F
00CA0:  BNZ   0CA6
00CA2:  MOVF   xF6,F
00CA4:  BZ    0D24
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00CA6:  MOVFF  8F1,03
00CAA:  MOVF   xF0,W
00CAC:  MOVWF  FE9
00CAE:  MOVFF  03,FEA
00CB2:  MOVFF  FEF,8F5
00CB6:  MOVFF  8F4,8F6
00CBA:  MOVFF  8F5,8F7
*
00CC4:  MOVFF  01,8F4
.................... 		write_eeprom( address++, *data++ ); 
00CC8:  MOVF   xEF,W
00CCA:  MOVWF  03
00CCC:  MOVF   xEE,W
00CCE:  INCF   xEE,F
00CD0:  BTFSC  FD8.2
00CD2:  INCF   xEF,F
00CD4:  MOVWF  xF5
00CD6:  MOVFF  03,8F6
00CDA:  MOVF   xF1,W
00CDC:  MOVWF  03
00CDE:  MOVF   xF0,W
00CE0:  INCF   xF0,F
00CE2:  BTFSC  FD8.2
00CE4:  INCF   xF1,F
00CE6:  MOVWF  FE9
00CE8:  MOVFF  03,FEA
00CEC:  MOVFF  FEF,8F7
00CF0:  MOVFF  8F6,FAA
00CF4:  MOVFF  8F5,FA9
00CF8:  MOVFF  8F7,FA8
00CFC:  BCF    FA6.6
00CFE:  BCF    FA6.7
00D00:  BSF    FA6.2
00D02:  MOVF   FF2,W
00D04:  MOVWF  00
00D06:  BCF    FF2.6
00D08:  BCF    FF2.7
00D0A:  MOVLB  F
00D0C:  MOVLW  55
00D0E:  MOVWF  FA7
00D10:  MOVLW  AA
00D12:  MOVWF  FA7
00D14:  BSF    FA6.1
00D16:  BTFSC  FA6.1
00D18:  BRA    0D16
00D1A:  BCF    FA6.2
00D1C:  MOVF   00,W
00D1E:  IORWF  FF2,F
.................... 	} 
00D20:  MOVLB  8
00D22:  BRA    0C8C
....................  
.................... 	return crc; 
00D24:  MOVFF  8F4,01
.................... } 
00D28:  MOVLB  0
00D2A:  GOTO   0D4E (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00D2E:  MOVLB  8
00D30:  CLRF   xED
00D32:  MOVLW  36
00D34:  MOVWF  xEC
00D36:  CLRF   xEF
00D38:  MOVLW  02
00D3A:  MOVWF  xEE
00D3C:  MOVFF  8ED,8F1
00D40:  MOVFF  8EC,8F0
00D44:  CLRF   xF3
00D46:  MOVLW  61
00D48:  MOVWF  xF2
00D4A:  MOVLB  0
00D4C:  BRA    0C88
00D4E:  MOVFF  01,8EB
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00D52:  CLRF   FAA
00D54:  CLRF   FA9
00D56:  MOVFF  8EB,FA8
00D5A:  BCF    FA6.6
00D5C:  BCF    FA6.7
00D5E:  BSF    FA6.2
00D60:  MOVF   FF2,W
00D62:  MOVWF  00
00D64:  BCF    FF2.6
00D66:  BCF    FF2.7
00D68:  MOVLB  F
00D6A:  MOVLW  55
00D6C:  MOVWF  FA7
00D6E:  MOVLW  AA
00D70:  MOVWF  FA7
00D72:  BSF    FA6.1
00D74:  BTFSC  FA6.1
00D76:  BRA    0D74
00D78:  BCF    FA6.2
00D7A:  MOVF   00,W
00D7C:  IORWF  FF2,F
.................... } 
00D7E:  MOVLB  0
00D80:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00D82:  MOVLW  96
00D84:  MOVLB  1
00D86:  MOVWF  xF7
....................  
.................... 	config.modbus_address=38; 
00D88:  MOVLW  26
00D8A:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00D8C:  MOVLW  03
00D8E:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00D90:  MOVLW  02
00D92:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00D94:  MOVLW  50
00D96:  MOVWF  3A
.................... 	config.serial_number=9876; 
00D98:  MOVLW  26
00D9A:  MOVWF  3C
00D9C:  MOVLW  94
00D9E:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00DA0:  CLRF   3E
00DA2:  MOVLW  14
00DA4:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00DA6:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00DA8:  MOVLW  02
00DAA:  MOVWF  41
00DAC:  MOVLW  76
00DAE:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00DB0:  CLRF   43
00DB2:  MOVLW  02
00DB4:  MOVWF  42
.................... 	config.power_startup=0; 
00DB6:  CLRF   44
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00DB8:  CLRF   FEA
00DBA:  MOVLW  4F
00DBC:  MOVWF  FE9
00DBE:  CLRF   00
00DC0:  CLRF   02
00DC2:  MOVLW  48
00DC4:  MOVWF  01
00DC6:  MOVLB  0
00DC8:  RCALL  08F8
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00DCA:  CLRF   FEA
00DCC:  MOVLW  4F
00DCE:  MOVWF  FE9
00DD0:  MOVLW  00
00DD2:  CALL   0188
00DD6:  TBLRD*-
00DD8:  TBLRD*+
00DDA:  MOVF   FF5,W
00DDC:  MOVWF  FEE
00DDE:  IORLW  00
00DE0:  BNZ   0DD8
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00DE2:  CLRF   FEA
00DE4:  MOVLW  55
00DE6:  MOVWF  FE9
00DE8:  MOVLW  00
00DEA:  CALL   01A0
00DEE:  TBLRD*-
00DF0:  TBLRD*+
00DF2:  MOVF   FF5,W
00DF4:  MOVWF  FEE
00DF6:  IORLW  00
00DF8:  BNZ   0DF0
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00DFA:  CLRF   FEA
00DFC:  MOVLW  5B
00DFE:  MOVWF  FE9
00E00:  MOVLW  00
00E02:  CALL   01B8
00E06:  TBLRD*-
00E08:  TBLRD*+
00E0A:  MOVF   FF5,W
00E0C:  MOVWF  FEE
00E0E:  IORLW  00
00E10:  BNZ   0E08
....................  
.................... 	strcpy(config.nmea0183_sentence[10],"$WIMDA"); 
00E12:  CLRF   FEA
00E14:  MOVLW  8B
00E16:  MOVWF  FE9
00E18:  MOVLW  00
00E1A:  CALL   01D0
00E1E:  TBLRD*-
00E20:  TBLRD*+
00E22:  MOVF   FF5,W
00E24:  MOVWF  FEE
00E26:  IORLW  00
00E28:  BNZ   0E20
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00E2A:  RCALL  0D2E
....................  
.................... } 
00E2C:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00E2E:  MOVLB  8
00E30:  CLRF   xDB
00E32:  MOVLW  36
00E34:  MOVWF  xDA
00E36:  CLRF   xDD
00E38:  MOVLW  02
00E3A:  MOVWF  xDC
00E3C:  MOVFF  8DB,8DF
00E40:  MOVFF  8DA,8DE
00E44:  CLRF   xE1
00E46:  MOVLW  61
00E48:  MOVWF  xE0
00E4A:  MOVLB  0
00E4C:  BRA    0BF6
00E4E:  MOVFF  01,8D9
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00E52:  MOVFF  FF2,8DA
00E56:  BCF    FF2.6
00E58:  BCF    FF2.7
00E5A:  CLRF   FAA
00E5C:  CLRF   FA9
00E5E:  BCF    FA6.6
00E60:  BCF    FA6.7
00E62:  BSF    FA6.0
00E64:  MOVF   FA8,W
00E66:  MOVLB  8
00E68:  BTFSC  xDA.6
00E6A:  BSF    FF2.6
00E6C:  BTFSC  xDA.7
00E6E:  BSF    FF2.7
00E70:  SUBWF  xD9,W
00E72:  BZ    0E7A
.................... 		write_default_param_file(); 
00E74:  MOVLB  0
00E76:  RCALL  0D82
00E78:  MOVLB  8
.................... 	} 
.................... } 
00E7A:  MOVLB  0
00E7C:  GOTO   2CE4 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
.................... } 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
00E80:  BTFSS  F9E.5
00E82:  BRA    0E88
.................... 		fgetc(STREAM_PI); 
00E84:  RCALL  0764
.................... 	} 
00E86:  BRA    0E80
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00E88:  BSF    F9D.5
.................... } 
00E8A:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00E8C:  RCALL  0E80
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00E8E:  MOVLW  C6
00E90:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00E92:  MOVLW  C0
00E94:  IORWF  FF2,F
.................... } 
00E96:  GOTO   2CF6 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
00408:  BCF    FF2.5
.................... 	if (enable) { 
0040A:  MOVLB  9
0040C:  MOVF   xEA,F
0040E:  BZ    0418
.................... 		set_timer0(0); 
00410:  CLRF   FD7
00412:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00414:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00416:  BSF    FF2.5
.................... 	} 
.................... } 
00418:  MOVLB  0
0041A:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0041C:  MOVLB  7
0041E:  MOVF   xC4,W
00420:  SUBLW  02
00422:  BNZ   0438
00424:  MOVF   xC5,F
00426:  BNZ   0438
00428:  MOVF   xC6,F
0042A:  BNZ   0438
0042C:  BTFSC  xC3.0
0042E:  BRA    0438
....................    { 
....................       modbus_rx.len-=2; 
00430:  MOVLW  02
00432:  SUBWF  xC8,F
....................       modbus_serial_new=TRUE; 
00434:  BSF    xC3.0
....................    } 
....................    else 
00436:  BRA    043A
....................       modbus_serial_new=FALSE; 
00438:  BCF    xC3.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0043A:  SETF   xC6
0043C:  SETF   xC5
....................    modbus_serial_state=MODBUS_GETADDY; 
0043E:  CLRF   xC4
....................    modbus_enable_timeout(FALSE); 
00440:  MOVLB  9
00442:  CLRF   xEA
00444:  MOVLB  0
00446:  RCALL  0408
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
00448:  BCF    FF2.2
0044A:  GOTO   0094
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
0077A:  MOVLB  7
0077C:  MOVF   xC6,W
0077E:  MOVLB  9
00780:  XORWF  xEA,W
00782:  MOVWF  xEB
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00784:  CLRF   03
00786:  MOVF   xEB,W
00788:  MOVLB  0
0078A:  RCALL  01E8
0078C:  MOVWF  01
0078E:  MOVLB  7
00790:  MOVF   xC5,W
00792:  XORWF  01,W
00794:  MOVWF  xC6
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00796:  CLRF   03
00798:  MOVLB  9
0079A:  MOVF   xEB,W
0079C:  MOVLB  0
0079E:  RCALL  02F8
007A0:  MOVFF  FE8,7C5
.................... } 
007A4:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	timers.rda_tx_buff[timers.rda_tx_length]=c; 
*
012E6:  MOVLB  4
012E8:  MOVFF  400,FE9
012EC:  MOVLW  03
012EE:  MOVWF  FEA
012F0:  MOVFF  8EB,FEF
.................... 	timers.rda_tx_length++; 
012F4:  INCF   x00,F
012F6:  CLRF   19
012F8:  BTFSC  FF2.6
012FA:  BSF    19.6
012FC:  BCF    FF2.6
012FE:  BTFSC  FF2.7
01300:  BSF    19.7
01302:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
01304:  MOVFF  8EB,9EA
01308:  MOVLB  0
0130A:  CALL   077A
0130E:  BTFSC  19.6
01310:  BSF    FF2.6
01312:  BTFSC  19.7
01314:  BSF    FF2.7
.................... } 
01316:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) { 
.................... 	/* reset out transmit buffer */ 
.................... 	timers.rda_tx_length=0; 
01318:  MOVLB  4
0131A:  CLRF   x00
.................... 	timers.rda_tx_pos=0; 
0131C:  CLRF   x01
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
0131E:  MOVLB  7
01320:  SETF   xC6
01322:  SETF   xC5
.................... 	modbus_serial_new=FALSE; 
01324:  BCF    xC3.0
....................  
.................... 	modbus_serial_putc(to); 
01326:  MOVFF  8E9,8EB
0132A:  MOVLB  0
0132C:  RCALL  12E6
.................... 	modbus_serial_putc(func); 
0132E:  MOVFF  8EA,8EB
01332:  RCALL  12E6
.................... } 
01334:  RETURN 0
....................  
.................... void modbus_serial_send_stop() { 
.................... 	int8 crc_low, crc_high; 
....................  
.................... 	crc_high=modbus_serial_crc.b[1]; 
01336:  MOVFF  7C6,8EA
.................... 	crc_low=modbus_serial_crc.b[0]; 
0133A:  MOVFF  7C5,8E9
....................  
.................... 	modbus_serial_putc(crc_high); 
0133E:  MOVFF  8EA,8EB
01342:  RCALL  12E6
.................... 	modbus_serial_putc(crc_low); 
01344:  MOVFF  8E9,8EB
01348:  RCALL  12E6
....................  
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
0134A:  MOVLB  7
0134C:  SETF   xC6
0134E:  SETF   xC5
....................  
.................... 	/* ready to transmit from buffer flag set. Elsewhere we start sending */ 
.................... 	timers.now_rda_tx_ready=1; 
01350:  MOVLB  4
01352:  BSF    x02.0
.................... } 
01354:  MOVLB  0
01356:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
011AA:  MOVLB  7
011AC:  BTFSC  xC3.0
011AE:  BRA    11B8
....................       return FALSE; 
011B0:  MOVLW  00
011B2:  MOVWF  01
011B4:  BRA    11CA
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
011B6:  BRA    11C4
011B8:  BTFSS  xC9.7
011BA:  BRA    11C4
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
011BC:  MOVFF  7CB,7CA
....................       modbus_rx.len = 1; 
011C0:  MOVLW  01
011C2:  MOVWF  xC8
....................    } 
....................    modbus_serial_new=FALSE; 
011C4:  BCF    xC3.0
....................    return TRUE; 
011C6:  MOVLW  01
011C8:  MOVWF  01
.................... } 
011CA:  MOVLB  0
011CC:  GOTO   25E6 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02552:  MOVFF  8E1,8E9
02556:  MOVLW  06
02558:  MOVLB  8
0255A:  MOVWF  xEA
0255C:  MOVLB  0
0255E:  CALL   1318
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02562:  MOVFF  8E3,8E6
02566:  MOVFF  8E3,8EB
0256A:  CALL   12E6
....................    modbus_serial_putc(make8(reg_address,0)); 
0256E:  MOVFF  8E2,8E6
02572:  MOVFF  8E2,8EB
02576:  CALL   12E6
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
0257A:  MOVFF  8E5,8E6
0257E:  MOVFF  8E5,8EB
02582:  CALL   12E6
....................    modbus_serial_putc(make8(reg_value,0)); 
02586:  MOVFF  8E4,8E6
0258A:  MOVFF  8E4,8EB
0258E:  CALL   12E6
....................  
....................    modbus_serial_send_stop(); 
02592:  CALL   1336
.................... } 
02596:  GOTO   27CA (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
0259A:  MOVFF  8DF,8E9
0259E:  MOVLW  10
025A0:  MOVLB  8
025A2:  MOVWF  xEA
025A4:  MOVLB  0
025A6:  CALL   1318
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
025AA:  MOVFF  8E1,8E4
025AE:  MOVFF  8E1,8EB
025B2:  CALL   12E6
....................    modbus_serial_putc(make8(start_address,0)); 
025B6:  MOVFF  8E0,8E4
025BA:  MOVFF  8E0,8EB
025BE:  CALL   12E6
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
025C2:  MOVFF  8E3,8E4
025C6:  MOVFF  8E3,8EB
025CA:  CALL   12E6
....................    modbus_serial_putc(make8(quantity,0)); 
025CE:  MOVFF  8E2,8E4
025D2:  MOVFF  8E2,8EB
025D6:  CALL   12E6
....................  
....................    modbus_serial_send_stop(); 
025DA:  CALL   1336
.................... } 
025DE:  GOTO   288C (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01358:  MOVLB  8
0135A:  MOVF   xE0,W
0135C:  IORLW  80
0135E:  MOVWF  xE3
01360:  MOVFF  8E1,8E4
01364:  MOVFF  8DF,8E9
01368:  MOVWF  xEA
0136A:  MOVLB  0
0136C:  RCALL  1318
....................    modbus_serial_putc(error); 
0136E:  MOVFF  8E2,8EB
01372:  RCALL  12E6
....................    modbus_serial_send_stop(); 
01374:  RCALL  1336
.................... } 
01376:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          53 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1013 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
014C8:  MOVLB  1
014CA:  CLRF   xCD
014CC:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
014CE:  CLRF   xCF
014D0:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
014D2:  CLRF   xD1
014D4:  CLRF   xD0
.................... } 
014D6:  MOVLB  0
014D8:  GOTO   1F70 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
01464:  BCF    FF2.6
01466:  BCF    FF2.7
01468:  BTFSC  FF2.7
0146A:  BRA    1466
....................  
.................... 	current.pulse_count[0]=0; 
0146C:  CLRF   xAA
0146E:  CLRF   xA9
.................... 	current.pulse_count[1]=0; 
01470:  CLRF   xAC
01472:  CLRF   xAB
.................... 	current.pulse_count[2]=0; 
01474:  CLRF   xAE
01476:  CLRF   xAD
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
01478:  SETF   x9E
0147A:  SETF   x9D
.................... 	current.pulse_min_period[1]=65535; 
0147C:  SETF   xA0
0147E:  SETF   x9F
.................... 	current.pulse_min_period[2]=65535; 
01480:  SETF   xA2
01482:  SETF   xA1
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
01484:  CLRF   xA4
01486:  CLRF   xA3
.................... 	current.pulse_max_period[1]=0; 
01488:  CLRF   xA6
0148A:  CLRF   xA5
.................... 	current.pulse_max_period[2]=0; 
0148C:  CLRF   xA8
0148E:  CLRF   xA7
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01490:  MOVLB  1
01492:  CLRF   xD7
01494:  CLRF   xD6
....................  
.................... 	enable_interrupts(GLOBAL); 
01496:  MOVLW  C0
01498:  IORWF  FF2,F
.................... } 
0149A:  MOVLB  0
0149C:  GOTO   1F20 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
014A0:  BCF    FF2.6
014A2:  BCF    FF2.7
014A4:  BTFSC  FF2.7
014A6:  BRA    14A2
.................... 	current.pulse_sum[0]=0; 
014A8:  CLRF   xB2
014AA:  CLRF   xB1
014AC:  CLRF   xB0
014AE:  CLRF   xAF
.................... 	current.pulse_sum[1]=0; 
014B0:  CLRF   xB6
014B2:  CLRF   xB5
014B4:  CLRF   xB4
014B6:  CLRF   xB3
.................... 	current.pulse_sum[2]=0; 
014B8:  CLRF   xBA
014BA:  CLRF   xB9
014BC:  CLRF   xB8
014BE:  CLRF   xB7
.................... 	enable_interrupts(GLOBAL); 
014C0:  MOVLW  C0
014C2:  IORWF  FF2,F
.................... } 
014C4:  GOTO   1F30 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01378:  BCF    FF2.6
0137A:  BCF    FF2.7
0137C:  BTFSC  FF2.7
0137E:  BRA    137A
.................... 	l=current.pulse_sum[ch]; 
01380:  MOVLB  9
01382:  CLRF   xDE
01384:  MOVFF  8F1,9DD
01388:  CLRF   xE0
0138A:  MOVLW  04
0138C:  MOVWF  xDF
0138E:  MOVLB  0
01390:  CALL   08D6
01394:  MOVFF  02,03
01398:  MOVF   01,W
0139A:  ADDLW  AF
0139C:  MOVWF  FE9
0139E:  MOVLW  00
013A0:  ADDWFC 02,W
013A2:  MOVWF  FEA
013A4:  MOVFF  FEF,00
013A8:  MOVFF  FEC,01
013AC:  MOVFF  FEC,02
013B0:  MOVFF  FEC,03
013B4:  MOVFF  03,8F5
013B8:  MOVFF  02,8F4
013BC:  MOVFF  01,8F3
013C0:  MOVFF  00,8F2
.................... 	enable_interrupts(GLOBAL); 
013C4:  MOVLW  C0
013C6:  IORWF  FF2,F
....................  
.................... 	return l; 
013C8:  MOVFF  8F2,00
013CC:  MOVFF  8F3,01
013D0:  MOVFF  8F4,02
013D4:  MOVFF  8F5,03
.................... } 
013D8:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
014DC:  MOVLB  8
014DE:  MOVF   xEC,W
014E0:  SUBLW  06
014E2:  BC    1538
014E4:  XORLW  FF
014E6:  BNZ   14EE
014E8:  MOVF   xEB,W
014EA:  SUBLW  CF
014EC:  BC    1538
014EE:  MOVF   xEC,W
014F0:  SUBLW  09
014F2:  BNC   1538
014F4:  BNZ   14FC
014F6:  MOVF   xEB,W
014F8:  SUBLW  CF
014FA:  BNC   1538
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
014FC:  MOVLW  D0
014FE:  SUBWF  xEB,W
01500:  MOVWF  xF1
01502:  MOVLW  07
01504:  SUBWFB xEC,W
01506:  MOVWF  xF2
01508:  MOVLW  02
0150A:  ADDWF  xF2,F
0150C:  MOVFF  FF2,8F3
01510:  BCF    FF2.6
01512:  BCF    FF2.7
01514:  MOVFF  8F2,FAA
01518:  MOVFF  8F1,FA9
0151C:  BCF    FA6.6
0151E:  BCF    FA6.7
01520:  BSF    FA6.0
01522:  MOVF   FA8,W
01524:  BTFSC  xF3.6
01526:  BSF    FF2.6
01528:  BTFSC  xF3.7
0152A:  BSF    FF2.7
0152C:  CLRF   03
0152E:  MOVWF  01
01530:  MOVF   03,W
01532:  MOVWF  02
01534:  GOTO   20E4
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
01538:  MOVF   xEC,W
0153A:  SUBLW  03
0153C:  BC    15BC
0153E:  XORLW  FF
01540:  BNZ   1548
01542:  MOVF   xEB,W
01544:  SUBLW  4B
01546:  BC    15BC
01548:  MOVF   xEC,W
0154A:  SUBLW  04
0154C:  BNC   15BC
0154E:  BNZ   1556
01550:  MOVF   xEB,W
01552:  SUBLW  93
01554:  BNC   15BC
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
01556:  MOVLW  4C
01558:  SUBWF  xEB,W
0155A:  MOVWF  xED
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
0155C:  MOVFF  8ED,8F1
01560:  MOVLW  06
01562:  MOVWF  xF2
01564:  MOVLB  0
01566:  CALL   0B4A
0156A:  MOVFF  00,8EE
.................... 		n = n / 6; /* number of sentence */ 
0156E:  MOVFF  8ED,8F1
01572:  MOVLW  06
01574:  MOVLB  8
01576:  MOVWF  xF2
01578:  MOVLB  0
0157A:  CALL   0B4A
0157E:  MOVFF  01,8ED
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
01582:  MOVLB  8
01584:  MOVF   xED,W
01586:  MULLW  06
01588:  MOVF   FF3,W
0158A:  CLRF   03
0158C:  ADDLW  19
0158E:  MOVWF  xF1
01590:  MOVLW  00
01592:  ADDWFC 03,W
01594:  MOVWF  xF2
01596:  CLRF   03
01598:  MOVF   xEE,W
0159A:  ADDWF  xF1,W
0159C:  MOVWF  01
0159E:  MOVF   xF2,W
015A0:  ADDWFC 03,F
015A2:  MOVF   01,W
015A4:  ADDLW  36
015A6:  MOVWF  FE9
015A8:  MOVLW  00
015AA:  ADDWFC 03,W
015AC:  MOVWF  FEA
015AE:  MOVF   FEF,W
015B0:  CLRF   03
015B2:  MOVWF  01
015B4:  MOVFF  03,02
015B8:  GOTO   20E4
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
015BC:  MOVF   xEC,W
015BE:  SUBLW  12
015C0:  BC    1604
015C2:  XORLW  FF
015C4:  BNZ   15CC
015C6:  MOVF   xEB,W
015C8:  SUBLW  87
015CA:  BC    1604
015CC:  MOVF   xEC,W
015CE:  SUBLW  17
015D0:  BNC   1604
015D2:  BNZ   15DA
015D4:  MOVF   xEB,W
015D6:  SUBLW  47
015D8:  BNC   1604
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
015DA:  MOVLW  88
015DC:  SUBWF  xEB,F
015DE:  MOVLW  13
015E0:  SUBWFB xEC,F
....................  
....................  		p  = nmea.sentence[0]; 
015E2:  MOVLW  04
015E4:  MOVWF  xF0
015E6:  MOVLW  03
015E8:  MOVWF  xEF
.................... 		return (int16) p[addr]; 
015EA:  MOVF   xEF,W
015EC:  ADDWF  xEB,W
015EE:  MOVWF  FE9
015F0:  MOVF   xF0,W
015F2:  ADDWFC xEC,W
015F4:  MOVWF  FEA
015F6:  MOVF   FEF,W
015F8:  CLRF   03
015FA:  MOVWF  01
015FC:  MOVFF  03,02
01600:  GOTO   20E4
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
01604:  MOVF   xEC,W
01606:  SUBLW  16
01608:  BC    1674
0160A:  XORLW  FF
0160C:  BNZ   1614
0160E:  MOVF   xEB,W
01610:  SUBLW  6F
01612:  BC    1674
01614:  MOVF   xEC,W
01616:  SUBLW  19
01618:  BNC   1674
0161A:  BNZ   1622
0161C:  MOVF   xEB,W
0161E:  SUBLW  4F
01620:  BNC   1674
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01622:  MOVLW  70
01624:  SUBWF  xEB,F
01626:  MOVLW  17
01628:  SUBWFB xEC,F
.................... 		addr = addr * 2; 
0162A:  BCF    FD8.0
0162C:  RLCF   xEB,F
0162E:  RLCF   xEC,F
....................  
....................  		p  = nmea.sentence[0]; 
01630:  MOVLW  04
01632:  MOVWF  xF0
01634:  MOVLW  03
01636:  MOVWF  xEF
.................... 		return (int16) make16(p[addr],p[addr+1]); 
01638:  MOVF   xEF,W
0163A:  ADDWF  xEB,W
0163C:  MOVWF  FE9
0163E:  MOVF   xF0,W
01640:  ADDWFC xEC,W
01642:  MOVWF  FEA
01644:  MOVFF  FEF,8F1
01648:  MOVLW  01
0164A:  ADDWF  xEB,W
0164C:  MOVWF  xF2
0164E:  MOVLW  00
01650:  ADDWFC xEC,W
01652:  MOVWF  xF3
01654:  MOVF   xEF,W
01656:  ADDWF  xF2,W
01658:  MOVWF  FE9
0165A:  MOVF   xF0,W
0165C:  ADDWFC xF3,W
0165E:  MOVWF  FEA
01660:  MOVFF  FEF,8F4
01664:  MOVFF  8F1,03
01668:  MOVFF  8F4,01
0166C:  MOVFF  8F1,02
01670:  GOTO   20E4
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
01674:  MOVF   xEB,W
01676:  MOVWF  00
01678:  MOVF   xEC,W
0167A:  MOVWF  03
0167C:  MOVF   03,W
0167E:  BNZ   168A
01680:  MOVF   00,F
01682:  MOVLB  0
01684:  BTFSC  FD8.2
01686:  BRA    1AD8
01688:  MOVLB  8
0168A:  MOVF   03,W
0168C:  BNZ   169A
0168E:  MOVLW  01
01690:  SUBWF  00,W
01692:  MOVLB  0
01694:  BTFSC  FD8.2
01696:  BRA    1AE6
01698:  MOVLB  8
0169A:  MOVF   03,W
0169C:  BNZ   16AA
0169E:  MOVLW  02
016A0:  SUBWF  00,W
016A2:  MOVLB  0
016A4:  BTFSC  FD8.2
016A6:  BRA    1AF4
016A8:  MOVLB  8
016AA:  MOVF   03,W
016AC:  BNZ   16BA
016AE:  MOVLW  03
016B0:  SUBWF  00,W
016B2:  MOVLB  0
016B4:  BTFSC  FD8.2
016B6:  BRA    1B02
016B8:  MOVLB  8
016BA:  MOVF   03,W
016BC:  BNZ   16CA
016BE:  MOVLW  04
016C0:  SUBWF  00,W
016C2:  MOVLB  0
016C4:  BTFSC  FD8.2
016C6:  BRA    1B10
016C8:  MOVLB  8
016CA:  MOVF   03,W
016CC:  BNZ   16DA
016CE:  MOVLW  05
016D0:  SUBWF  00,W
016D2:  MOVLB  0
016D4:  BTFSC  FD8.2
016D6:  BRA    1B36
016D8:  MOVLB  8
016DA:  MOVF   03,W
016DC:  BNZ   16EA
016DE:  MOVLW  06
016E0:  SUBWF  00,W
016E2:  MOVLB  0
016E4:  BTFSC  FD8.2
016E6:  BRA    1B44
016E8:  MOVLB  8
016EA:  MOVF   03,W
016EC:  BNZ   16FA
016EE:  MOVLW  07
016F0:  SUBWF  00,W
016F2:  MOVLB  0
016F4:  BTFSC  FD8.2
016F6:  BRA    1B52
016F8:  MOVLB  8
016FA:  MOVF   03,W
016FC:  BNZ   170A
016FE:  MOVLW  08
01700:  SUBWF  00,W
01702:  MOVLB  0
01704:  BTFSC  FD8.2
01706:  BRA    1B60
01708:  MOVLB  8
0170A:  MOVF   03,W
0170C:  BNZ   171A
0170E:  MOVLW  09
01710:  SUBWF  00,W
01712:  MOVLB  0
01714:  BTFSC  FD8.2
01716:  BRA    1B6E
01718:  MOVLB  8
0171A:  MOVF   03,W
0171C:  BNZ   172A
0171E:  MOVLW  0A
01720:  SUBWF  00,W
01722:  MOVLB  0
01724:  BTFSC  FD8.2
01726:  BRA    1B7C
01728:  MOVLB  8
0172A:  MOVF   03,W
0172C:  BNZ   173A
0172E:  MOVLW  0B
01730:  SUBWF  00,W
01732:  MOVLB  0
01734:  BTFSC  FD8.2
01736:  BRA    1BA6
01738:  MOVLB  8
0173A:  MOVF   03,W
0173C:  BNZ   174A
0173E:  MOVLW  0C
01740:  SUBWF  00,W
01742:  MOVLB  0
01744:  BTFSC  FD8.2
01746:  BRA    1BB4
01748:  MOVLB  8
0174A:  MOVF   03,W
0174C:  BNZ   175A
0174E:  MOVLW  0D
01750:  SUBWF  00,W
01752:  MOVLB  0
01754:  BTFSC  FD8.2
01756:  BRA    1BC2
01758:  MOVLB  8
0175A:  MOVF   03,W
0175C:  BNZ   176A
0175E:  MOVLW  0E
01760:  SUBWF  00,W
01762:  MOVLB  0
01764:  BTFSC  FD8.2
01766:  BRA    1BD0
01768:  MOVLB  8
0176A:  MOVF   03,W
0176C:  BNZ   177A
0176E:  MOVLW  0F
01770:  SUBWF  00,W
01772:  MOVLB  0
01774:  BTFSC  FD8.2
01776:  BRA    1BDE
01778:  MOVLB  8
0177A:  MOVF   03,W
0177C:  BNZ   178A
0177E:  MOVLW  10
01780:  SUBWF  00,W
01782:  MOVLB  0
01784:  BTFSC  FD8.2
01786:  BRA    1BEC
01788:  MOVLB  8
0178A:  MOVF   03,W
0178C:  BNZ   179A
0178E:  MOVLW  11
01790:  SUBWF  00,W
01792:  MOVLB  0
01794:  BTFSC  FD8.2
01796:  BRA    1C16
01798:  MOVLB  8
0179A:  MOVF   03,W
0179C:  BNZ   17AA
0179E:  MOVLW  12
017A0:  SUBWF  00,W
017A2:  MOVLB  0
017A4:  BTFSC  FD8.2
017A6:  BRA    1C24
017A8:  MOVLB  8
017AA:  MOVF   03,W
017AC:  BNZ   17BA
017AE:  MOVLW  13
017B0:  SUBWF  00,W
017B2:  MOVLB  0
017B4:  BTFSC  FD8.2
017B6:  BRA    1C52
017B8:  MOVLB  8
017BA:  MOVF   03,W
017BC:  BNZ   17CA
017BE:  MOVLW  14
017C0:  SUBWF  00,W
017C2:  MOVLB  0
017C4:  BTFSC  FD8.2
017C6:  BRA    1C6A
017C8:  MOVLB  8
017CA:  MOVF   03,W
017CC:  BNZ   17DA
017CE:  MOVLW  15
017D0:  SUBWF  00,W
017D2:  MOVLB  0
017D4:  BTFSC  FD8.2
017D6:  BRA    1C78
017D8:  MOVLB  8
017DA:  MOVF   03,W
017DC:  BNZ   17EA
017DE:  MOVLW  16
017E0:  SUBWF  00,W
017E2:  MOVLB  0
017E4:  BTFSC  FD8.2
017E6:  BRA    1CA6
017E8:  MOVLB  8
017EA:  MOVF   03,W
017EC:  BNZ   17FA
017EE:  MOVLW  17
017F0:  SUBWF  00,W
017F2:  MOVLB  0
017F4:  BTFSC  FD8.2
017F6:  BRA    1CC0
017F8:  MOVLB  8
017FA:  MOVF   03,W
017FC:  BNZ   180A
017FE:  MOVLW  18
01800:  SUBWF  00,W
01802:  MOVLB  0
01804:  BTFSC  FD8.2
01806:  BRA    1CCE
01808:  MOVLB  8
0180A:  MOVF   03,W
0180C:  BNZ   181A
0180E:  MOVLW  19
01810:  SUBWF  00,W
01812:  MOVLB  0
01814:  BTFSC  FD8.2
01816:  BRA    1CFC
01818:  MOVLB  8
0181A:  MOVF   03,W
0181C:  BNZ   182A
0181E:  MOVLW  1A
01820:  SUBWF  00,W
01822:  MOVLB  0
01824:  BTFSC  FD8.2
01826:  BRA    1D16
01828:  MOVLB  8
0182A:  MOVF   03,W
0182C:  BNZ   183A
0182E:  MOVLW  1B
01830:  SUBWF  00,W
01832:  MOVLB  0
01834:  BTFSC  FD8.2
01836:  BRA    1D24
01838:  MOVLB  8
0183A:  MOVF   03,W
0183C:  BNZ   184A
0183E:  MOVLW  1C
01840:  SUBWF  00,W
01842:  MOVLB  0
01844:  BTFSC  FD8.2
01846:  BRA    1D52
01848:  MOVLB  8
0184A:  MOVF   03,W
0184C:  BNZ   185A
0184E:  MOVLW  1D
01850:  SUBWF  00,W
01852:  MOVLB  0
01854:  BTFSC  FD8.2
01856:  BRA    1D6C
01858:  MOVLB  8
0185A:  MOVF   03,W
0185C:  BNZ   186A
0185E:  MOVLW  1E
01860:  SUBWF  00,W
01862:  MOVLB  0
01864:  BTFSC  FD8.2
01866:  BRA    1D7A
01868:  MOVLB  8
0186A:  MOVF   03,W
0186C:  BNZ   187A
0186E:  MOVLW  1F
01870:  SUBWF  00,W
01872:  MOVLB  0
01874:  BTFSC  FD8.2
01876:  BRA    1DA8
01878:  MOVLB  8
0187A:  MOVF   03,W
0187C:  BNZ   188A
0187E:  MOVLW  20
01880:  SUBWF  00,W
01882:  MOVLB  0
01884:  BTFSC  FD8.2
01886:  BRA    1DC2
01888:  MOVLB  8
0188A:  MOVF   03,W
0188C:  BNZ   189A
0188E:  MOVLW  21
01890:  SUBWF  00,W
01892:  MOVLB  0
01894:  BTFSC  FD8.2
01896:  BRA    1DD0
01898:  MOVLB  8
0189A:  MOVF   03,W
0189C:  BNZ   18AA
0189E:  MOVLW  22
018A0:  SUBWF  00,W
018A2:  MOVLB  0
018A4:  BTFSC  FD8.2
018A6:  BRA    1DFE
018A8:  MOVLB  8
018AA:  MOVF   03,W
018AC:  BNZ   18BA
018AE:  MOVLW  23
018B0:  SUBWF  00,W
018B2:  MOVLB  0
018B4:  BTFSC  FD8.2
018B6:  BRA    1E18
018B8:  MOVLB  8
018BA:  MOVF   03,W
018BC:  BNZ   18CA
018BE:  MOVLW  24
018C0:  SUBWF  00,W
018C2:  MOVLB  0
018C4:  BTFSC  FD8.2
018C6:  BRA    1E26
018C8:  MOVLB  8
018CA:  MOVF   03,W
018CC:  BNZ   18DA
018CE:  MOVLW  25
018D0:  SUBWF  00,W
018D2:  MOVLB  0
018D4:  BTFSC  FD8.2
018D6:  BRA    1E54
018D8:  MOVLB  8
018DA:  MOVF   03,W
018DC:  BNZ   18EA
018DE:  MOVLW  26
018E0:  SUBWF  00,W
018E2:  MOVLB  0
018E4:  BTFSC  FD8.2
018E6:  BRA    1E6E
018E8:  MOVLB  8
018EA:  MOVF   03,W
018EC:  BNZ   18FA
018EE:  MOVLW  27
018F0:  SUBWF  00,W
018F2:  MOVLB  0
018F4:  BTFSC  FD8.2
018F6:  BRA    1E7C
018F8:  MOVLB  8
018FA:  MOVF   03,W
018FC:  BNZ   190A
018FE:  MOVLW  28
01900:  SUBWF  00,W
01902:  MOVLB  0
01904:  BTFSC  FD8.2
01906:  BRA    1EAA
01908:  MOVLB  8
0190A:  MOVF   03,W
0190C:  BNZ   191A
0190E:  MOVLW  29
01910:  SUBWF  00,W
01912:  MOVLB  0
01914:  BTFSC  FD8.2
01916:  BRA    1EC4
01918:  MOVLB  8
0191A:  MOVF   03,W
0191C:  BNZ   192A
0191E:  MOVLW  2A
01920:  SUBWF  00,W
01922:  MOVLB  0
01924:  BTFSC  FD8.2
01926:  BRA    1ED2
01928:  MOVLB  8
0192A:  MOVF   03,W
0192C:  BNZ   193A
0192E:  MOVLW  2B
01930:  SUBWF  00,W
01932:  MOVLB  0
01934:  BTFSC  FD8.2
01936:  BRA    1EEC
01938:  MOVLB  8
0193A:  MOVF   03,W
0193C:  BNZ   194A
0193E:  MOVLW  2C
01940:  SUBWF  00,W
01942:  MOVLB  0
01944:  BTFSC  FD8.2
01946:  BRA    1EFC
01948:  MOVLB  8
0194A:  MOVF   03,W
0194C:  BNZ   195A
0194E:  MOVLW  2D
01950:  SUBWF  00,W
01952:  MOVLB  0
01954:  BTFSC  FD8.2
01956:  BRA    1F0C
01958:  MOVLB  8
0195A:  MOVF   03,W
0195C:  BNZ   196A
0195E:  MOVLW  2E
01960:  SUBWF  00,W
01962:  MOVLB  0
01964:  BTFSC  FD8.2
01966:  BRA    1F1C
01968:  MOVLB  8
0196A:  MOVF   03,W
0196C:  BNZ   197A
0196E:  MOVLW  2F
01970:  SUBWF  00,W
01972:  MOVLB  0
01974:  BTFSC  FD8.2
01976:  BRA    1F2C
01978:  MOVLB  8
0197A:  MOVF   03,W
0197C:  BNZ   198A
0197E:  MOVLW  30
01980:  SUBWF  00,W
01982:  MOVLB  0
01984:  BTFSC  FD8.2
01986:  BRA    1F3C
01988:  MOVLB  8
0198A:  MOVF   03,W
0198C:  BNZ   199A
0198E:  MOVLW  31
01990:  SUBWF  00,W
01992:  MOVLB  0
01994:  BTFSC  FD8.2
01996:  BRA    1F4C
01998:  MOVLB  8
0199A:  MOVF   03,W
0199C:  BNZ   19AA
0199E:  MOVLW  32
019A0:  SUBWF  00,W
019A2:  MOVLB  0
019A4:  BTFSC  FD8.2
019A6:  BRA    1F5C
019A8:  MOVLB  8
019AA:  MOVF   03,W
019AC:  BNZ   19BA
019AE:  MOVLW  33
019B0:  SUBWF  00,W
019B2:  MOVLB  0
019B4:  BTFSC  FD8.2
019B6:  BRA    1F6C
019B8:  MOVLB  8
019BA:  MOVF   03,W
019BC:  BNZ   19CA
019BE:  MOVLW  34
019C0:  SUBWF  00,W
019C2:  MOVLB  0
019C4:  BTFSC  FD8.2
019C6:  BRA    1F7C
019C8:  MOVLB  8
019CA:  MOVF   03,W
019CC:  BNZ   19DA
019CE:  MOVLW  35
019D0:  SUBWF  00,W
019D2:  MOVLB  0
019D4:  BTFSC  FD8.2
019D6:  BRA    1F8C
019D8:  MOVLB  8
019DA:  MOVLW  03
019DC:  SUBWF  03,W
019DE:  BNZ   19EC
019E0:  MOVLW  E8
019E2:  SUBWF  00,W
019E4:  MOVLB  0
019E6:  BTFSC  FD8.2
019E8:  BRA    1F9C
019EA:  MOVLB  8
019EC:  MOVLW  03
019EE:  SUBWF  03,W
019F0:  BNZ   19FE
019F2:  MOVLW  E9
019F4:  SUBWF  00,W
019F6:  MOVLB  0
019F8:  BTFSC  FD8.2
019FA:  BRA    1FAC
019FC:  MOVLB  8
019FE:  MOVLW  03
01A00:  SUBWF  03,W
01A02:  BNZ   1A10
01A04:  MOVLW  EA
01A06:  SUBWF  00,W
01A08:  MOVLB  0
01A0A:  BTFSC  FD8.2
01A0C:  BRA    1FBA
01A0E:  MOVLB  8
01A10:  MOVLW  03
01A12:  SUBWF  03,W
01A14:  BNZ   1A22
01A16:  MOVLW  EB
01A18:  SUBWF  00,W
01A1A:  MOVLB  0
01A1C:  BTFSC  FD8.2
01A1E:  BRA    1FC8
01A20:  MOVLB  8
01A22:  MOVLW  03
01A24:  SUBWF  03,W
01A26:  BNZ   1A34
01A28:  MOVLW  EC
01A2A:  SUBWF  00,W
01A2C:  MOVLB  0
01A2E:  BTFSC  FD8.2
01A30:  BRA    1FD6
01A32:  MOVLB  8
01A34:  MOVLW  03
01A36:  SUBWF  03,W
01A38:  BNZ   1A46
01A3A:  MOVLW  ED
01A3C:  SUBWF  00,W
01A3E:  MOVLB  0
01A40:  BTFSC  FD8.2
01A42:  BRA    1FE4
01A44:  MOVLB  8
01A46:  MOVLW  03
01A48:  SUBWF  03,W
01A4A:  BNZ   1A58
01A4C:  MOVLW  EE
01A4E:  SUBWF  00,W
01A50:  MOVLB  0
01A52:  BTFSC  FD8.2
01A54:  BRA    1FF2
01A56:  MOVLB  8
01A58:  MOVLW  03
01A5A:  SUBWF  03,W
01A5C:  BNZ   1A6A
01A5E:  MOVLW  EF
01A60:  SUBWF  00,W
01A62:  MOVLB  0
01A64:  BTFSC  FD8.2
01A66:  BRA    2002
01A68:  MOVLB  8
01A6A:  MOVLW  03
01A6C:  SUBWF  03,W
01A6E:  BNZ   1A7C
01A70:  MOVLW  F0
01A72:  SUBWF  00,W
01A74:  MOVLB  0
01A76:  BTFSC  FD8.2
01A78:  BRA    2010
01A7A:  MOVLB  8
01A7C:  MOVLW  03
01A7E:  SUBWF  03,W
01A80:  BNZ   1A8E
01A82:  MOVLW  F1
01A84:  SUBWF  00,W
01A86:  MOVLB  0
01A88:  BTFSC  FD8.2
01A8A:  BRA    2020
01A8C:  MOVLB  8
01A8E:  MOVLW  03
01A90:  SUBWF  03,W
01A92:  BNZ   1AA0
01A94:  MOVLW  F2
01A96:  SUBWF  00,W
01A98:  MOVLB  0
01A9A:  BTFSC  FD8.2
01A9C:  BRA    202E
01A9E:  MOVLB  8
01AA0:  MOVLW  03
01AA2:  SUBWF  03,W
01AA4:  BNZ   1AB2
01AA6:  MOVLW  F3
01AA8:  SUBWF  00,W
01AAA:  MOVLB  0
01AAC:  BTFSC  FD8.2
01AAE:  BRA    203C
01AB0:  MOVLB  8
01AB2:  MOVLW  03
01AB4:  SUBWF  03,W
01AB6:  BNZ   1AC4
01AB8:  MOVLW  F4
01ABA:  SUBWF  00,W
01ABC:  MOVLB  0
01ABE:  BTFSC  FD8.2
01AC0:  BRA    204C
01AC2:  MOVLB  8
01AC4:  MOVLW  03
01AC6:  SUBWF  03,W
01AC8:  BNZ   1AD6
01ACA:  MOVLW  F5
01ACC:  SUBWF  00,W
01ACE:  MOVLB  0
01AD0:  BTFSC  FD8.2
01AD2:  BRA    205C
01AD4:  MOVLB  8
01AD6:  BRA    20DC
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01AD8:  MOVFF  A9,01
01ADC:  MOVFF  AA,02
01AE0:  MOVLB  8
01AE2:  BRA    20E4
01AE4:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01AE6:  MOVF   x97,W
01AE8:  MOVWF  01
01AEA:  MOVF   x98,W
01AEC:  MOVWF  02
01AEE:  MOVLB  8
01AF0:  BRA    20E4
01AF2:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01AF4:  MOVF   x9D,W
01AF6:  MOVWF  01
01AF8:  MOVF   x9E,W
01AFA:  MOVWF  02
01AFC:  MOVLB  8
01AFE:  BRA    20E4
01B00:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01B02:  MOVF   xA3,W
01B04:  MOVWF  01
01B06:  MOVF   xA4,W
01B08:  MOVWF  02
01B0A:  MOVLB  8
01B0C:  BRA    20E4
01B0E:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01B10:  MOVLB  8
01B12:  CLRF   xF1
01B14:  MOVLB  0
01B16:  RCALL  1378
01B18:  MOVFF  03,8CD
01B1C:  MOVFF  02,8CC
01B20:  MOVFF  01,8CB
01B24:  MOVFF  00,8CA
01B28:  MOVLB  8
01B2A:  MOVF   xCA,W
01B2C:  MOVWF  01
01B2E:  MOVF   xCB,W
01B30:  MOVWF  02
01B32:  BRA    20E4
01B34:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01B36:  MOVLB  8
01B38:  MOVF   xCC,W
01B3A:  MOVWF  01
01B3C:  MOVF   xCD,W
01B3E:  MOVWF  02
01B40:  BRA    20E4
01B42:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01B44:  MOVF   xAB,W
01B46:  MOVWF  01
01B48:  MOVF   xAC,W
01B4A:  MOVWF  02
01B4C:  MOVLB  8
01B4E:  BRA    20E4
01B50:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01B52:  MOVF   x99,W
01B54:  MOVWF  01
01B56:  MOVF   x9A,W
01B58:  MOVWF  02
01B5A:  MOVLB  8
01B5C:  BRA    20E4
01B5E:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01B60:  MOVF   x9F,W
01B62:  MOVWF  01
01B64:  MOVF   xA0,W
01B66:  MOVWF  02
01B68:  MOVLB  8
01B6A:  BRA    20E4
01B6C:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01B6E:  MOVF   xA5,W
01B70:  MOVWF  01
01B72:  MOVF   xA6,W
01B74:  MOVWF  02
01B76:  MOVLB  8
01B78:  BRA    20E4
01B7A:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01B7C:  MOVLW  01
01B7E:  MOVLB  8
01B80:  MOVWF  xF1
01B82:  MOVLB  0
01B84:  CALL   1378
01B88:  MOVFF  03,8CD
01B8C:  MOVFF  02,8CC
01B90:  MOVFF  01,8CB
01B94:  MOVFF  00,8CA
01B98:  MOVLB  8
01B9A:  MOVF   xCA,W
01B9C:  MOVWF  01
01B9E:  MOVF   xCB,W
01BA0:  MOVWF  02
01BA2:  BRA    20E4
01BA4:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01BA6:  MOVLB  8
01BA8:  MOVF   xCC,W
01BAA:  MOVWF  01
01BAC:  MOVF   xCD,W
01BAE:  MOVWF  02
01BB0:  BRA    20E4
01BB2:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01BB4:  MOVF   xAD,W
01BB6:  MOVWF  01
01BB8:  MOVF   xAE,W
01BBA:  MOVWF  02
01BBC:  MOVLB  8
01BBE:  BRA    20E4
01BC0:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01BC2:  MOVF   x9B,W
01BC4:  MOVWF  01
01BC6:  MOVF   x9C,W
01BC8:  MOVWF  02
01BCA:  MOVLB  8
01BCC:  BRA    20E4
01BCE:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01BD0:  MOVF   xA1,W
01BD2:  MOVWF  01
01BD4:  MOVF   xA2,W
01BD6:  MOVWF  02
01BD8:  MOVLB  8
01BDA:  BRA    20E4
01BDC:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01BDE:  MOVF   xA7,W
01BE0:  MOVWF  01
01BE2:  MOVF   xA8,W
01BE4:  MOVWF  02
01BE6:  MOVLB  8
01BE8:  BRA    20E4
01BEA:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01BEC:  MOVLW  02
01BEE:  MOVLB  8
01BF0:  MOVWF  xF1
01BF2:  MOVLB  0
01BF4:  CALL   1378
01BF8:  MOVFF  03,8CD
01BFC:  MOVFF  02,8CC
01C00:  MOVFF  01,8CB
01C04:  MOVFF  00,8CA
01C08:  MOVLB  8
01C0A:  MOVF   xCA,W
01C0C:  MOVWF  01
01C0E:  MOVF   xCB,W
01C10:  MOVWF  02
01C12:  BRA    20E4
01C14:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01C16:  MOVLB  8
01C18:  MOVF   xCC,W
01C1A:  MOVWF  01
01C1C:  MOVF   xCD,W
01C1E:  MOVWF  02
01C20:  BRA    20E4
01C22:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01C24:  CLRF   03
01C26:  MOVLB  1
01C28:  MOVF   xCB,W
01C2A:  MOVWF  02
01C2C:  BCF    FD8.0
01C2E:  RLCF   02,F
01C30:  RLCF   03,F
01C32:  MOVF   02,W
01C34:  ADDLW  CB
01C36:  MOVWF  FE9
01C38:  MOVLW  00
01C3A:  ADDWFC 03,W
01C3C:  MOVWF  FEA
01C3E:  MOVFF  FEC,03
01C42:  MOVF   FED,F
01C44:  MOVF   FEF,W
01C46:  MOVWF  01
01C48:  MOVF   03,W
01C4A:  MOVWF  02
01C4C:  MOVLB  8
01C4E:  BRA    20E4
01C50:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01C52:  MOVLB  8
01C54:  CLRF   xF1
01C56:  MOVLB  0
01C58:  CALL   13DA
01C5C:  MOVF   01,W
01C5E:  MOVWF  01
01C60:  MOVF   02,W
01C62:  MOVWF  02
01C64:  MOVLB  8
01C66:  BRA    20E4
01C68:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01C6A:  MOVF   xBB,W
01C6C:  MOVWF  01
01C6E:  MOVF   xBC,W
01C70:  MOVWF  02
01C72:  MOVLB  8
01C74:  BRA    20E4
01C76:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01C78:  CLRF   03
01C7A:  MOVLB  1
01C7C:  MOVF   xCB,W
01C7E:  MOVWF  02
01C80:  BCF    FD8.0
01C82:  RLCF   02,F
01C84:  RLCF   03,F
01C86:  MOVF   02,W
01C88:  ADDLW  EB
01C8A:  MOVWF  FE9
01C8C:  MOVLW  00
01C8E:  ADDWFC 03,W
01C90:  MOVWF  FEA
01C92:  MOVFF  FEC,03
01C96:  MOVF   FED,F
01C98:  MOVF   FEF,W
01C9A:  MOVWF  01
01C9C:  MOVF   03,W
01C9E:  MOVWF  02
01CA0:  MOVLB  8
01CA2:  BRA    20E4
01CA4:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01CA6:  MOVLW  01
01CA8:  MOVLB  8
01CAA:  MOVWF  xF1
01CAC:  MOVLB  0
01CAE:  CALL   13DA
01CB2:  MOVF   01,W
01CB4:  MOVWF  01
01CB6:  MOVF   02,W
01CB8:  MOVWF  02
01CBA:  MOVLB  8
01CBC:  BRA    20E4
01CBE:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01CC0:  MOVF   xBD,W
01CC2:  MOVWF  01
01CC4:  MOVF   xBE,W
01CC6:  MOVWF  02
01CC8:  MOVLB  8
01CCA:  BRA    20E4
01CCC:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01CCE:  CLRF   03
01CD0:  MOVLB  1
01CD2:  MOVF   xCB,W
01CD4:  MOVWF  02
01CD6:  BCF    FD8.0
01CD8:  RLCF   02,F
01CDA:  RLCF   03,F
01CDC:  MOVF   02,W
01CDE:  ADDLW  0B
01CE0:  MOVWF  FE9
01CE2:  MOVLW  01
01CE4:  ADDWFC 03,W
01CE6:  MOVWF  FEA
01CE8:  MOVFF  FEC,03
01CEC:  MOVF   FED,F
01CEE:  MOVF   FEF,W
01CF0:  MOVWF  01
01CF2:  MOVF   03,W
01CF4:  MOVWF  02
01CF6:  MOVLB  8
01CF8:  BRA    20E4
01CFA:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01CFC:  MOVLW  02
01CFE:  MOVLB  8
01D00:  MOVWF  xF1
01D02:  MOVLB  0
01D04:  CALL   13DA
01D08:  MOVF   01,W
01D0A:  MOVWF  01
01D0C:  MOVF   02,W
01D0E:  MOVWF  02
01D10:  MOVLB  8
01D12:  BRA    20E4
01D14:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01D16:  MOVF   xBF,W
01D18:  MOVWF  01
01D1A:  MOVF   xC0,W
01D1C:  MOVWF  02
01D1E:  MOVLB  8
01D20:  BRA    20E4
01D22:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01D24:  CLRF   03
01D26:  MOVLB  1
01D28:  MOVF   xCB,W
01D2A:  MOVWF  02
01D2C:  BCF    FD8.0
01D2E:  RLCF   02,F
01D30:  RLCF   03,F
01D32:  MOVF   02,W
01D34:  ADDLW  2B
01D36:  MOVWF  FE9
01D38:  MOVLW  01
01D3A:  ADDWFC 03,W
01D3C:  MOVWF  FEA
01D3E:  MOVFF  FEC,03
01D42:  MOVF   FED,F
01D44:  MOVF   FEF,W
01D46:  MOVWF  01
01D48:  MOVF   03,W
01D4A:  MOVWF  02
01D4C:  MOVLB  8
01D4E:  BRA    20E4
01D50:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01D52:  MOVLW  03
01D54:  MOVLB  8
01D56:  MOVWF  xF1
01D58:  MOVLB  0
01D5A:  CALL   13DA
01D5E:  MOVF   01,W
01D60:  MOVWF  01
01D62:  MOVF   02,W
01D64:  MOVWF  02
01D66:  MOVLB  8
01D68:  BRA    20E4
01D6A:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01D6C:  MOVF   xC1,W
01D6E:  MOVWF  01
01D70:  MOVF   xC2,W
01D72:  MOVWF  02
01D74:  MOVLB  8
01D76:  BRA    20E4
01D78:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01D7A:  CLRF   03
01D7C:  MOVLB  1
01D7E:  MOVF   xCB,W
01D80:  MOVWF  02
01D82:  BCF    FD8.0
01D84:  RLCF   02,F
01D86:  RLCF   03,F
01D88:  MOVF   02,W
01D8A:  ADDLW  4B
01D8C:  MOVWF  FE9
01D8E:  MOVLW  01
01D90:  ADDWFC 03,W
01D92:  MOVWF  FEA
01D94:  MOVFF  FEC,03
01D98:  MOVF   FED,F
01D9A:  MOVF   FEF,W
01D9C:  MOVWF  01
01D9E:  MOVF   03,W
01DA0:  MOVWF  02
01DA2:  MOVLB  8
01DA4:  BRA    20E4
01DA6:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01DA8:  MOVLW  04
01DAA:  MOVLB  8
01DAC:  MOVWF  xF1
01DAE:  MOVLB  0
01DB0:  CALL   13DA
01DB4:  MOVF   01,W
01DB6:  MOVWF  01
01DB8:  MOVF   02,W
01DBA:  MOVWF  02
01DBC:  MOVLB  8
01DBE:  BRA    20E4
01DC0:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01DC2:  MOVF   xC3,W
01DC4:  MOVWF  01
01DC6:  MOVF   xC4,W
01DC8:  MOVWF  02
01DCA:  MOVLB  8
01DCC:  BRA    20E4
01DCE:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01DD0:  CLRF   03
01DD2:  MOVLB  1
01DD4:  MOVF   xCB,W
01DD6:  MOVWF  02
01DD8:  BCF    FD8.0
01DDA:  RLCF   02,F
01DDC:  RLCF   03,F
01DDE:  MOVF   02,W
01DE0:  ADDLW  6B
01DE2:  MOVWF  FE9
01DE4:  MOVLW  01
01DE6:  ADDWFC 03,W
01DE8:  MOVWF  FEA
01DEA:  MOVFF  FEC,03
01DEE:  MOVF   FED,F
01DF0:  MOVF   FEF,W
01DF2:  MOVWF  01
01DF4:  MOVF   03,W
01DF6:  MOVWF  02
01DF8:  MOVLB  8
01DFA:  BRA    20E4
01DFC:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01DFE:  MOVLW  05
01E00:  MOVLB  8
01E02:  MOVWF  xF1
01E04:  MOVLB  0
01E06:  CALL   13DA
01E0A:  MOVF   01,W
01E0C:  MOVWF  01
01E0E:  MOVF   02,W
01E10:  MOVWF  02
01E12:  MOVLB  8
01E14:  BRA    20E4
01E16:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01E18:  MOVF   xC5,W
01E1A:  MOVWF  01
01E1C:  MOVF   xC6,W
01E1E:  MOVWF  02
01E20:  MOVLB  8
01E22:  BRA    20E4
01E24:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01E26:  CLRF   03
01E28:  MOVLB  1
01E2A:  MOVF   xCB,W
01E2C:  MOVWF  02
01E2E:  BCF    FD8.0
01E30:  RLCF   02,F
01E32:  RLCF   03,F
01E34:  MOVF   02,W
01E36:  ADDLW  8B
01E38:  MOVWF  FE9
01E3A:  MOVLW  01
01E3C:  ADDWFC 03,W
01E3E:  MOVWF  FEA
01E40:  MOVFF  FEC,03
01E44:  MOVF   FED,F
01E46:  MOVF   FEF,W
01E48:  MOVWF  01
01E4A:  MOVF   03,W
01E4C:  MOVWF  02
01E4E:  MOVLB  8
01E50:  BRA    20E4
01E52:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01E54:  MOVLW  06
01E56:  MOVLB  8
01E58:  MOVWF  xF1
01E5A:  MOVLB  0
01E5C:  CALL   13DA
01E60:  MOVF   01,W
01E62:  MOVWF  01
01E64:  MOVF   02,W
01E66:  MOVWF  02
01E68:  MOVLB  8
01E6A:  BRA    20E4
01E6C:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01E6E:  MOVF   xC7,W
01E70:  MOVWF  01
01E72:  MOVF   xC8,W
01E74:  MOVWF  02
01E76:  MOVLB  8
01E78:  BRA    20E4
01E7A:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01E7C:  CLRF   03
01E7E:  MOVLB  1
01E80:  MOVF   xCB,W
01E82:  MOVWF  02
01E84:  BCF    FD8.0
01E86:  RLCF   02,F
01E88:  RLCF   03,F
01E8A:  MOVF   02,W
01E8C:  ADDLW  AB
01E8E:  MOVWF  FE9
01E90:  MOVLW  01
01E92:  ADDWFC 03,W
01E94:  MOVWF  FEA
01E96:  MOVFF  FEC,03
01E9A:  MOVF   FED,F
01E9C:  MOVF   FEF,W
01E9E:  MOVWF  01
01EA0:  MOVF   03,W
01EA2:  MOVWF  02
01EA4:  MOVLB  8
01EA6:  BRA    20E4
01EA8:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01EAA:  MOVLW  07
01EAC:  MOVLB  8
01EAE:  MOVWF  xF1
01EB0:  MOVLB  0
01EB2:  CALL   13DA
01EB6:  MOVF   01,W
01EB8:  MOVWF  01
01EBA:  MOVF   02,W
01EBC:  MOVWF  02
01EBE:  MOVLB  8
01EC0:  BRA    20E4
01EC2:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01EC4:  MOVF   xC9,W
01EC6:  MOVWF  01
01EC8:  MOVF   xCA,W
01ECA:  MOVWF  02
01ECC:  MOVLB  8
01ECE:  BRA    20E4
01ED0:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01ED2:  MOVLB  1
01ED4:  MOVF   xD3,W
01ED6:  MOVWF  03
01ED8:  MOVF   xD2,W
01EDA:  INCF   xD2,F
01EDC:  BTFSC  FD8.2
01EDE:  INCF   xD3,F
01EE0:  MOVWF  01
01EE2:  MOVF   03,W
01EE4:  MOVWF  02
01EE6:  MOVLB  8
01EE8:  BRA    20E4
01EEA:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01EEC:  MOVLB  1
01EEE:  MOVF   xD6,W
01EF0:  MOVWF  01
01EF2:  MOVF   xD7,W
01EF4:  MOVWF  02
01EF6:  MOVLB  8
01EF8:  BRA    20E4
01EFA:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01EFC:  MOVLB  1
01EFE:  MOVF   xD4,W
01F00:  MOVWF  01
01F02:  MOVF   xD5,W
01F04:  MOVWF  02
01F06:  MOVLB  8
01F08:  BRA    20E4
01F0A:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01F0C:  MOVLB  1
01F0E:  MOVF   xD9,W
01F10:  MOVWF  01
01F12:  MOVF   xDA,W
01F14:  MOVWF  02
01F16:  MOVLB  8
01F18:  BRA    20E4
01F1A:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01F1C:  GOTO   1464
01F20:  MOVLW  00
01F22:  MOVWF  01
01F24:  MOVWF  02
01F26:  MOVLB  8
01F28:  BRA    20E4
01F2A:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01F2C:  GOTO   14A0
01F30:  MOVLW  00
01F32:  MOVWF  01
01F34:  MOVWF  02
01F36:  MOVLB  8
01F38:  BRA    20E4
01F3A:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01F3C:  MOVLB  1
01F3E:  MOVF   xCC,W
01F40:  MOVWF  01
01F42:  MOVF   xCD,W
01F44:  MOVWF  02
01F46:  MOVLB  8
01F48:  BRA    20E4
01F4A:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01F4C:  MOVLB  1
01F4E:  MOVF   xCE,W
01F50:  MOVWF  01
01F52:  MOVF   xCF,W
01F54:  MOVWF  02
01F56:  MOVLB  8
01F58:  BRA    20E4
01F5A:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01F5C:  MOVLB  1
01F5E:  MOVF   xD0,W
01F60:  MOVWF  01
01F62:  MOVF   xD1,W
01F64:  MOVWF  02
01F66:  MOVLB  8
01F68:  BRA    20E4
01F6A:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01F6C:  GOTO   14C8
01F70:  MOVLW  00
01F72:  MOVWF  01
01F74:  MOVWF  02
01F76:  MOVLB  8
01F78:  BRA    20E4
01F7A:  MOVLB  0
.................... 		case 52: return (int16) current.rda_bytes_received; 
01F7C:  MOVLB  1
01F7E:  MOVF   xE2,W
01F80:  MOVWF  01
01F82:  MOVF   xE3,W
01F84:  MOVWF  02
01F86:  MOVLB  8
01F88:  BRA    20E4
01F8A:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
01F8C:  MOVLB  1
01F8E:  MOVF   xE4,W
01F90:  MOVWF  01
01F92:  MOVF   xE5,W
01F94:  MOVWF  02
01F96:  MOVLB  8
01F98:  BRA    20E4
01F9A:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
01F9C:  CLRF   03
01F9E:  MOVF   3A,W
01FA0:  MOVWF  01
01FA2:  MOVF   03,W
01FA4:  MOVWF  02
01FA6:  MOVLB  8
01FA8:  BRA    20E4
01FAA:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01FAC:  MOVF   3B,W
01FAE:  MOVWF  01
01FB0:  MOVF   3C,W
01FB2:  MOVWF  02
01FB4:  MOVLB  8
01FB6:  BRA    20E4
01FB8:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01FBA:  MOVLW  50
01FBC:  MOVWF  01
01FBE:  MOVLW  00
01FC0:  MOVWF  02
01FC2:  MOVLB  8
01FC4:  BRA    20E4
01FC6:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01FC8:  MOVLW  57
01FCA:  MOVWF  01
01FCC:  MOVLW  00
01FCE:  MOVWF  02
01FD0:  MOVLB  8
01FD2:  BRA    20E4
01FD4:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01FD6:  MOVLW  58
01FD8:  MOVWF  01
01FDA:  MOVLW  00
01FDC:  MOVWF  02
01FDE:  MOVLB  8
01FE0:  BRA    20E4
01FE2:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01FE4:  MOVLW  01
01FE6:  MOVWF  01
01FE8:  MOVLW  00
01FEA:  MOVWF  02
01FEC:  MOVLB  8
01FEE:  BRA    20E4
01FF0:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01FF2:  CLRF   03
01FF4:  MOVF   36,W
01FF6:  MOVWF  01
01FF8:  MOVF   03,W
01FFA:  MOVWF  02
01FFC:  MOVLB  8
01FFE:  BRA    20E4
02000:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
02002:  MOVF   3D,W
02004:  MOVWF  01
02006:  MOVF   3E,W
02008:  MOVWF  02
0200A:  MOVLB  8
0200C:  BRA    20E4
0200E:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
02010:  CLRF   03
02012:  MOVF   3F,W
02014:  MOVWF  01
02016:  MOVF   03,W
02018:  MOVWF  02
0201A:  MOVLB  8
0201C:  BRA    20E4
0201E:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
02020:  MOVF   40,W
02022:  MOVWF  01
02024:  MOVF   41,W
02026:  MOVWF  02
02028:  MOVLB  8
0202A:  BRA    20E4
0202C:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
0202E:  MOVF   42,W
02030:  MOVWF  01
02032:  MOVF   43,W
02034:  MOVWF  02
02036:  MOVLB  8
02038:  BRA    20E4
0203A:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
0203C:  CLRF   03
0203E:  MOVF   44,W
02040:  MOVWF  01
02042:  MOVF   03,W
02044:  MOVWF  02
02046:  MOVLB  8
02048:  BRA    20E4
0204A:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
0204C:  CLRF   03
0204E:  MOVF   38,W
02050:  MOVWF  01
02052:  MOVF   03,W
02054:  MOVWF  02
02056:  MOVLB  8
02058:  BRA    20E4
0205A:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
0205C:  MOVF   39,F
0205E:  BNZ   206E
02060:  MOVLW  B0
02062:  MOVWF  01
02064:  MOVLW  04
02066:  MOVWF  02
02068:  MOVLB  8
0206A:  BRA    20E4
0206C:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
0206E:  DECFSZ 39,W
02070:  BRA    2080
02072:  MOVLW  60
02074:  MOVWF  01
02076:  MOVLW  09
02078:  MOVWF  02
0207A:  MOVLB  8
0207C:  BRA    20E4
0207E:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
02080:  MOVF   39,W
02082:  SUBLW  02
02084:  BNZ   2094
02086:  MOVLW  C0
02088:  MOVWF  01
0208A:  MOVLW  12
0208C:  MOVWF  02
0208E:  MOVLB  8
02090:  BRA    20E4
02092:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
02094:  MOVF   39,W
02096:  SUBLW  04
02098:  BNZ   20A8
0209A:  MOVLW  00
0209C:  MOVWF  01
0209E:  MOVLW  4B
020A0:  MOVWF  02
020A2:  MOVLB  8
020A4:  BRA    20E4
020A6:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
020A8:  MOVF   39,W
020AA:  SUBLW  05
020AC:  BNZ   20BC
020AE:  MOVLW  00
020B0:  MOVWF  01
020B2:  MOVLW  96
020B4:  MOVWF  02
020B6:  MOVLB  8
020B8:  BRA    20E4
020BA:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
020BC:  MOVF   39,W
020BE:  SUBLW  06
020C0:  BNZ   20D0
020C2:  MOVLW  00
020C4:  MOVWF  01
020C6:  MOVLW  E1
020C8:  MOVWF  02
020CA:  MOVLB  8
020CC:  BRA    20E4
020CE:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
020D0:  MOVLW  80
020D2:  MOVWF  01
020D4:  MOVLW  25
020D6:  MOVWF  02
020D8:  MOVLB  8
020DA:  BRA    20E4
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
020DC:  MOVLW  FF
020DE:  MOVWF  01
020E0:  MOVWF  02
020E2:  BRA    20E4
.................... 	} 
....................  
.................... } 
020E4:  MOVLB  0
020E6:  GOTO   2138 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
011F8:  MOVLB  8
011FA:  MOVF   xE1,W
011FC:  SUBLW  1F
011FE:  BNZ   1218
01200:  MOVF   xE2,W
01202:  SUBLW  4E
01204:  BNZ   1218
01206:  MOVF   xE3,W
01208:  SUBLW  20
0120A:  BNZ   1218
0120C:  MOVF   xE4,W
0120E:  SUBLW  4E
01210:  BNZ   1218
.................... 		return 1; 
01212:  MOVLW  01
01214:  MOVWF  01
01216:  BRA    12E0
....................  
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
01218:  MOVF   xE2,W
0121A:  SUBLW  16
0121C:  BC    123C
0121E:  XORLW  FF
01220:  BNZ   1228
01222:  MOVF   xE1,W
01224:  SUBLW  6F
01226:  BC    123C
01228:  MOVF   xE4,W
0122A:  SUBLW  19
0122C:  BNC   123C
0122E:  BNZ   1236
01230:  MOVF   xE3,W
01232:  SUBLW  50
01234:  BNC   123C
.................... 		return 1; 
01236:  MOVLW  01
01238:  MOVWF  01
0123A:  BRA    12E0
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
0123C:  MOVF   xE2,W
0123E:  SUBLW  12
01240:  BC    1260
01242:  XORLW  FF
01244:  BNZ   124C
01246:  MOVF   xE1,W
01248:  SUBLW  87
0124A:  BC    1260
0124C:  MOVF   xE4,W
0124E:  SUBLW  17
01250:  BNC   1260
01252:  BNZ   125A
01254:  MOVF   xE3,W
01256:  SUBLW  48
01258:  BNC   1260
.................... 		return 1; 
0125A:  MOVLW  01
0125C:  MOVWF  01
0125E:  BRA    12E0
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01260:  MOVF   xE2,W
01262:  SUBLW  03
01264:  BC    1284
01266:  XORLW  FF
01268:  BNZ   1270
0126A:  MOVF   xE1,W
0126C:  SUBLW  4B
0126E:  BC    1284
01270:  MOVF   xE4,W
01272:  SUBLW  04
01274:  BNC   1284
01276:  BNZ   127E
01278:  MOVF   xE3,W
0127A:  SUBLW  94
0127C:  BNC   1284
.................... 		return 1; 
0127E:  MOVLW  01
01280:  MOVWF  01
01282:  BRA    12E0
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
01284:  MOVF   xE2,W
01286:  SUBLW  02
01288:  BC    12A8
0128A:  XORLW  FF
0128C:  BNZ   1294
0128E:  MOVF   xE1,W
01290:  SUBLW  E7
01292:  BC    12A8
01294:  MOVF   xE4,W
01296:  SUBLW  03
01298:  BNC   12A8
0129A:  BNZ   12A2
0129C:  MOVF   xE3,W
0129E:  SUBLW  F6
012A0:  BNC   12A8
.................... 		return 1; 
012A2:  MOVLW  01
012A4:  MOVWF  01
012A6:  BRA    12E0
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
012A8:  MOVF   xE2,W
012AA:  SUBLW  06
012AC:  BC    12CC
012AE:  XORLW  FF
012B0:  BNZ   12B8
012B2:  MOVF   xE1,W
012B4:  SUBLW  CF
012B6:  BC    12CC
012B8:  MOVF   xE4,W
012BA:  SUBLW  09
012BC:  BNC   12CC
012BE:  BNZ   12C6
012C0:  MOVF   xE3,W
012C2:  SUBLW  D1
012C4:  BNC   12CC
.................... 		return 1; 
012C6:  MOVLW  01
012C8:  MOVWF  01
012CA:  BRA    12E0
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
012CC:  MOVF   xE4,F
012CE:  BNZ   12DC
012D0:  MOVF   xE3,W
012D2:  SUBLW  36
012D4:  BNC   12DC
.................... 		return 1; 
012D6:  MOVLW  01
012D8:  MOVWF  01
012DA:  BRA    12E0
....................  
.................... 	return 0; 
012DC:  MOVLW  00
012DE:  MOVWF  01
.................... } 
012E0:  MOVLB  0
012E2:  GOTO   2716 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
020EA:  MOVFF  8E0,8E9
020EE:  MOVFF  8DF,8EA
020F2:  CALL   1318
.................... 	modbus_serial_putc(register_count*2); 
020F6:  BCF    FD8.0
020F8:  MOVLB  8
020FA:  RLCF   xE3,W
020FC:  MOVWF  xE9
020FE:  RLCF   xE4,W
02100:  MOVWF  xEA
02102:  MOVFF  8E9,8EB
02106:  MOVLB  0
02108:  CALL   12E6
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
0210C:  MOVLB  8
0210E:  CLRF   xE6
02110:  CLRF   xE5
02112:  MOVF   xE6,W
02114:  SUBWF  xE4,W
02116:  BNC   2162
02118:  BNZ   2120
0211A:  MOVF   xE3,W
0211C:  SUBWF  xE5,W
0211E:  BC    2162
.................... 		l=map_modbus(start_address+i); 
02120:  MOVF   xE5,W
02122:  ADDWF  xE1,W
02124:  MOVWF  xE9
02126:  MOVF   xE6,W
02128:  ADDWFC xE2,W
0212A:  MOVWF  xEA
0212C:  MOVWF  xEC
0212E:  MOVFF  8E9,8EB
02132:  MOVLB  0
02134:  GOTO   14DC
02138:  MOVFF  02,8E8
0213C:  MOVFF  01,8E7
.................... 		modbus_serial_putc(make8(l,1)); 
02140:  MOVFF  8E8,8E9
02144:  MOVFF  8E8,8EB
02148:  CALL   12E6
....................   		modbus_serial_putc(make8(l,0)); 
0214C:  MOVFF  8E7,8E9
02150:  MOVFF  8E7,8EB
02154:  CALL   12E6
.................... 	} 
02158:  MOVLB  8
0215A:  INCF   xE5,F
0215C:  BTFSC  FD8.2
0215E:  INCF   xE6,F
02160:  BRA    2112
....................  
.................... 	modbus_serial_send_stop(); 
02162:  MOVLB  0
02164:  CALL   1336
.................... } 
02168:  GOTO   2758 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
0216C:  MOVLB  8
0216E:  MOVF   xE6,W
02170:  SUBLW  06
02172:  BC    21EA
02174:  XORLW  FF
02176:  BNZ   217E
02178:  MOVF   xE5,W
0217A:  SUBLW  CF
0217C:  BC    21EA
0217E:  MOVF   xE6,W
02180:  SUBLW  09
02182:  BNC   21EA
02184:  BNZ   218C
02186:  MOVF   xE5,W
02188:  SUBLW  CF
0218A:  BNC   21EA
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
0218C:  MOVF   xE8,W
0218E:  SUBLW  00
02190:  BC    21A2
02192:  XORLW  FF
02194:  BNZ   219C
02196:  MOVF   xE7,W
02198:  SUBLW  00
0219A:  BC    21A2
0219C:  MOVLW  03
0219E:  MOVWF  01
021A0:  BRA    254E
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
021A2:  MOVLW  D0
021A4:  SUBWF  xE5,W
021A6:  MOVWF  xEB
021A8:  MOVLW  07
021AA:  SUBWFB xE6,W
021AC:  MOVWF  xEC
021AE:  MOVLW  02
021B0:  ADDWF  xEC,F
021B2:  MOVFF  8EC,FAA
021B6:  MOVFF  8EB,FA9
021BA:  MOVFF  8E7,FA8
021BE:  BCF    FA6.6
021C0:  BCF    FA6.7
021C2:  BSF    FA6.2
021C4:  MOVF   FF2,W
021C6:  MOVWF  00
021C8:  BCF    FF2.6
021CA:  BCF    FF2.7
021CC:  MOVLB  F
021CE:  MOVLW  55
021D0:  MOVWF  FA7
021D2:  MOVLW  AA
021D4:  MOVWF  FA7
021D6:  BSF    FA6.1
021D8:  BTFSC  FA6.1
021DA:  BRA    21D8
021DC:  BCF    FA6.2
021DE:  MOVF   00,W
021E0:  IORWF  FF2,F
.................... 		return 0; 
021E2:  MOVLW  00
021E4:  MOVWF  01
021E6:  MOVLB  8
021E8:  BRA    254E
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
021EA:  MOVF   xE6,W
021EC:  SUBLW  03
021EE:  BC    2280
021F0:  XORLW  FF
021F2:  BNZ   21FA
021F4:  MOVF   xE5,W
021F6:  SUBLW  4B
021F8:  BC    2280
021FA:  MOVF   xE6,W
021FC:  SUBLW  04
021FE:  BNC   2280
02200:  BNZ   2208
02202:  MOVF   xE5,W
02204:  SUBLW  93
02206:  BNC   2280
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02208:  MOVF   xE8,W
0220A:  SUBLW  00
0220C:  BC    221E
0220E:  XORLW  FF
02210:  BNZ   2218
02212:  MOVF   xE7,W
02214:  SUBLW  00
02216:  BC    221E
02218:  MOVLW  03
0221A:  MOVWF  01
0221C:  BRA    254E
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
0221E:  MOVLW  4C
02220:  SUBWF  xE5,W
02222:  MOVWF  xE9
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
02224:  MOVFF  8E9,8F1
02228:  MOVLW  06
0222A:  MOVWF  xF2
0222C:  MOVLB  0
0222E:  CALL   0B4A
02232:  MOVFF  00,8EA
.................... 		n = n / 6; /* number of sentence */ 
02236:  MOVFF  8E9,8F1
0223A:  MOVLW  06
0223C:  MOVLB  8
0223E:  MOVWF  xF2
02240:  MOVLB  0
02242:  CALL   0B4A
02246:  MOVFF  01,8E9
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
0224A:  MOVLB  8
0224C:  MOVF   xE9,W
0224E:  MULLW  06
02250:  MOVF   FF3,W
02252:  CLRF   03
02254:  ADDLW  19
02256:  MOVWF  xEB
02258:  MOVLW  00
0225A:  ADDWFC 03,W
0225C:  MOVWF  xEC
0225E:  CLRF   03
02260:  MOVF   xEA,W
02262:  ADDWF  xEB,W
02264:  MOVWF  01
02266:  MOVF   xEC,W
02268:  ADDWFC 03,F
0226A:  MOVF   01,W
0226C:  ADDLW  36
0226E:  MOVWF  FE9
02270:  MOVLW  00
02272:  ADDWFC 03,W
02274:  MOVWF  FEA
02276:  MOVFF  8E7,FEF
.................... 		 
.................... 		return 0; 
0227A:  MOVLW  00
0227C:  MOVWF  01
0227E:  BRA    254E
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
02280:  MOVLB  1
02282:  MOVF   xD8,F
02284:  BZ    22BC
.................... 		if ( 1000 == address ) { 
02286:  MOVLB  8
02288:  MOVF   xE5,W
0228A:  SUBLW  E8
0228C:  BNZ   22A0
0228E:  MOVF   xE6,W
02290:  SUBLW  03
02292:  BNZ   22A0
.................... 			config.serial_prefix=value; 
02294:  MOVFF  8E7,3A
.................... 			return 0; 
02298:  MOVLW  00
0229A:  MOVWF  01
0229C:  BRA    254E
.................... 		} else if ( 1001 == address ) { 
0229E:  BRA    22BA
022A0:  MOVF   xE5,W
022A2:  SUBLW  E9
022A4:  BNZ   22BA
022A6:  MOVF   xE6,W
022A8:  SUBLW  03
022AA:  BNZ   22BA
.................... 			config.serial_number=value; 
022AC:  MOVFF  8E8,3C
022B0:  MOVFF  8E7,3B
.................... 			return 0; 
022B4:  MOVLW  00
022B6:  MOVWF  01
022B8:  BRA    254E
022BA:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
022BC:  MOVLB  8
022BE:  MOVF   xE5,W
022C0:  MOVWF  00
022C2:  MOVF   xE6,W
022C4:  MOVWF  03
022C6:  MOVLW  03
022C8:  SUBWF  03,W
022CA:  BNZ   22D8
022CC:  MOVLW  EE
022CE:  SUBWF  00,W
022D0:  MOVLB  0
022D2:  BTFSC  FD8.2
022D4:  BRA    23A0
022D6:  MOVLB  8
022D8:  MOVLW  03
022DA:  SUBWF  03,W
022DC:  BNZ   22EA
022DE:  MOVLW  EF
022E0:  SUBWF  00,W
022E2:  MOVLB  0
022E4:  BTFSC  FD8.2
022E6:  BRA    23B8
022E8:  MOVLB  8
022EA:  MOVLW  03
022EC:  SUBWF  03,W
022EE:  BNZ   22FC
022F0:  MOVLW  F0
022F2:  SUBWF  00,W
022F4:  MOVLB  0
022F6:  BTFSC  FD8.2
022F8:  BRA    23C8
022FA:  MOVLB  8
022FC:  MOVLW  03
022FE:  SUBWF  03,W
02300:  BNZ   230E
02302:  MOVLW  F1
02304:  SUBWF  00,W
02306:  MOVLB  0
02308:  BTFSC  FD8.2
0230A:  BRA    23E0
0230C:  MOVLB  8
0230E:  MOVLW  03
02310:  SUBWF  03,W
02312:  BNZ   2320
02314:  MOVLW  F2
02316:  SUBWF  00,W
02318:  MOVLB  0
0231A:  BTFSC  FD8.2
0231C:  BRA    23EC
0231E:  MOVLB  8
02320:  MOVLW  03
02322:  SUBWF  03,W
02324:  BNZ   2332
02326:  MOVLW  F3
02328:  SUBWF  00,W
0232A:  MOVLB  0
0232C:  BTFSC  FD8.2
0232E:  BRA    2406
02330:  MOVLB  8
02332:  MOVLW  03
02334:  SUBWF  03,W
02336:  BNZ   2344
02338:  MOVLW  F4
0233A:  SUBWF  00,W
0233C:  MOVLB  0
0233E:  BTFSC  FD8.2
02340:  BRA    241E
02342:  MOVLB  8
02344:  MOVLW  03
02346:  SUBWF  03,W
02348:  BNZ   2356
0234A:  MOVLW  F5
0234C:  SUBWF  00,W
0234E:  MOVLB  0
02350:  BTFSC  FD8.2
02352:  BRA    2436
02354:  MOVLB  8
02356:  MOVLW  07
02358:  SUBWF  03,W
0235A:  BNZ   2368
0235C:  MOVLW  CD
0235E:  SUBWF  00,W
02360:  MOVLB  0
02362:  BTFSC  FD8.2
02364:  BRA    24D4
02366:  MOVLB  8
02368:  MOVLW  07
0236A:  SUBWF  03,W
0236C:  BNZ   237A
0236E:  MOVLW  CE
02370:  SUBWF  00,W
02372:  MOVLB  0
02374:  BTFSC  FD8.2
02376:  BRA    24E8
02378:  MOVLB  8
0237A:  MOVLW  07
0237C:  SUBWF  03,W
0237E:  BNZ   238C
02380:  MOVLW  CF
02382:  SUBWF  00,W
02384:  MOVLB  0
02386:  BTFSC  FD8.2
02388:  BRA    2502
0238A:  MOVLB  8
0238C:  MOVLW  4E
0238E:  SUBWF  03,W
02390:  BNZ   239E
02392:  MOVLW  1F
02394:  SUBWF  00,W
02396:  MOVLB  0
02398:  BTFSC  FD8.2
0239A:  BRA    251C
0239C:  MOVLB  8
0239E:  BRA    2544
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
023A0:  MOVLB  8
023A2:  MOVF   xE8,F
023A4:  BNZ   23AC
023A6:  MOVF   xE7,W
023A8:  SUBLW  80
023AA:  BC    23B2
023AC:  MOVLW  03
023AE:  MOVWF  01
023B0:  BRA    254E
.................... 			config.modbus_address=value; 
023B2:  MOVFF  8E7,36
.................... 			break; 
023B6:  BRA    254A
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
023B8:  MOVLB  1
023BA:  BSF    xFA.1
.................... 			config.adc_sample_ticks=value; 
023BC:  MOVFF  8E8,3E
023C0:  MOVFF  8E7,3D
.................... 			break; 
023C4:  MOVLB  8
023C6:  BRA    254A
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
023C8:  MOVLB  8
023CA:  MOVF   xE8,F
023CC:  BNZ   23D4
023CE:  MOVF   xE7,W
023D0:  SUBLW  01
023D2:  BC    23DA
023D4:  MOVLW  03
023D6:  MOVWF  01
023D8:  BRA    254E
.................... 			config.allow_bootload_request=value; 
023DA:  MOVFF  8E7,3F
.................... 			break; 
023DE:  BRA    254A
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
023E0:  MOVFF  8E8,41
023E4:  MOVFF  8E7,40
.................... 			break; 
023E8:  MOVLB  8
023EA:  BRA    254A
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
023EC:  MOVLB  8
023EE:  MOVF   xE7,F
023F0:  BNZ   23FC
023F2:  MOVF   xE8,F
023F4:  BNZ   23FC
023F6:  MOVLW  03
023F8:  MOVWF  01
023FA:  BRA    254E
.................... 			config.pi_offtime_seconds=value; 
023FC:  MOVFF  8E8,43
02400:  MOVFF  8E7,42
.................... 			break; 
02404:  BRA    254A
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02406:  MOVLB  8
02408:  MOVF   xE8,F
0240A:  BNZ   2412
0240C:  MOVF   xE7,W
0240E:  SUBLW  01
02410:  BC    2418
02412:  MOVLW  03
02414:  MOVWF  01
02416:  BRA    254E
.................... 			config.power_startup=value; 
02418:  MOVFF  8E7,44
.................... 			break; 
0241C:  BRA    254A
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
0241E:  MOVLB  8
02420:  MOVF   xE8,F
02422:  BNZ   242A
02424:  MOVF   xE7,W
02426:  SUBLW  02
02428:  BC    2430
0242A:  MOVLW  03
0242C:  MOVWF  01
0242E:  BRA    254E
.................... 			config.rs485_port_mode=value; 
02430:  MOVFF  8E7,38
.................... 			break; 
02434:  BRA    254A
.................... 		 
.................... 		case 1013: 
....................  
.................... 			n=0; 
02436:  MOVLB  8
02438:  CLRF   xE9
.................... 			if ( 1200 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_1200; } 
0243A:  MOVF   xE7,W
0243C:  SUBLW  B0
0243E:  BNZ   244C
02440:  MOVF   xE8,W
02442:  SUBLW  04
02444:  BNZ   244C
02446:  MOVLW  01
02448:  MOVWF  xE9
0244A:  CLRF   39
.................... 			if ( 2400 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_2400; } 
0244C:  MOVF   xE7,W
0244E:  SUBLW  60
02450:  BNZ   245E
02452:  MOVF   xE8,W
02454:  SUBLW  09
02456:  BNZ   245E
02458:  MOVLW  01
0245A:  MOVWF  xE9
0245C:  MOVWF  39
.................... 			if ( 4800 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_4800; } 
0245E:  MOVF   xE7,W
02460:  SUBLW  C0
02462:  BNZ   2472
02464:  MOVF   xE8,W
02466:  SUBLW  12
02468:  BNZ   2472
0246A:  MOVLW  01
0246C:  MOVWF  xE9
0246E:  MOVLW  02
02470:  MOVWF  39
.................... 			if ( 9600 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_9600; } 
02472:  MOVF   xE7,W
02474:  SUBLW  80
02476:  BNZ   2486
02478:  MOVF   xE8,W
0247A:  SUBLW  25
0247C:  BNZ   2486
0247E:  MOVLW  01
02480:  MOVWF  xE9
02482:  MOVLW  03
02484:  MOVWF  39
.................... 			if ( 19200 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_19200; } 
02486:  MOVF   xE7,F
02488:  BNZ   2498
0248A:  MOVF   xE8,W
0248C:  SUBLW  4B
0248E:  BNZ   2498
02490:  MOVLW  01
02492:  MOVWF  xE9
02494:  MOVLW  04
02496:  MOVWF  39
.................... 			if ( 38400 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_38400; } 
02498:  MOVF   xE7,F
0249A:  BNZ   24AA
0249C:  MOVF   xE8,W
0249E:  SUBLW  96
024A0:  BNZ   24AA
024A2:  MOVLW  01
024A4:  MOVWF  xE9
024A6:  MOVLW  05
024A8:  MOVWF  39
.................... 			if ( 57600 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_57600; } 
024AA:  MOVF   xE7,F
024AC:  BNZ   24BC
024AE:  MOVF   xE8,W
024B0:  SUBLW  E1
024B2:  BNZ   24BC
024B4:  MOVLW  01
024B6:  MOVWF  xE9
024B8:  MOVLW  06
024BA:  MOVWF  39
....................  
.................... 			if (  1==n ) { 
024BC:  DECFSZ xE9,W
024BE:  BRA    24CA
.................... 				set_rs485_speed(); 
024C0:  MOVLB  0
024C2:  CALL   0912
.................... 			}  else { 
024C6:  BRA    24D0
024C8:  MOVLB  8
.................... 				return ILLEGAL_DATA_VALUE; 
024CA:  MOVLW  03
024CC:  MOVWF  01
024CE:  BRA    254E
.................... 			} 
.................... 			break; 
024D0:  MOVLB  8
024D2:  BRA    254A
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
024D4:  MOVLB  8
024D6:  DECFSZ xE7,W
024D8:  BRA    24DE
024DA:  MOVF   xE8,F
024DC:  BZ    24E4
024DE:  MOVLW  03
024E0:  MOVWF  01
024E2:  BRA    254E
.................... 			reset_cpu(); 
024E4:  RESET
024E6:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
024E8:  MOVLB  8
024EA:  DECFSZ xE7,W
024EC:  BRA    24F2
024EE:  MOVF   xE8,F
024F0:  BZ    24F8
024F2:  MOVLW  03
024F4:  MOVWF  01
024F6:  BRA    254E
.................... 			write_default_param_file(); 
024F8:  MOVLB  0
024FA:  CALL   0D82
.................... 			break; 
024FE:  MOVLB  8
02500:  BRA    254A
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02502:  MOVLB  8
02504:  DECFSZ xE7,W
02506:  BRA    250C
02508:  MOVF   xE8,F
0250A:  BZ    2512
0250C:  MOVLW  03
0250E:  MOVWF  01
02510:  BRA    254E
.................... 			write_param_file(); 
02512:  MOVLB  0
02514:  CALL   0D2E
.................... 			break; 
02518:  MOVLB  8
0251A:  BRA    254A
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
0251C:  MOVLB  8
0251E:  MOVF   xE7,W
02520:  SUBLW  0A
02522:  BNZ   252A
02524:  MOVF   xE8,W
02526:  SUBLW  07
02528:  BZ    2536
.................... 				current.factory_unlocked=0; 
0252A:  MOVLB  1
0252C:  CLRF   xD8
.................... 				return ILLEGAL_DATA_VALUE; 
0252E:  MOVLW  03
02530:  MOVWF  01
02532:  MOVLB  8
02534:  BRA    254E
.................... 			} 
.................... 			current.factory_unlocked=1; 
02536:  MOVLW  01
02538:  MOVLB  1
0253A:  MOVWF  xD8
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
0253C:  MOVLW  C8
0253E:  MOVWF  xF7
.................... 			break; 
02540:  MOVLB  8
02542:  BRA    254A
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02544:  MOVLW  02
02546:  MOVWF  01
02548:  BRA    254E
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
0254A:  MOVLW  00
0254C:  MOVWF  01
.................... } 
0254E:  MOVLB  0
02550:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
025E2:  GOTO   11AA
025E6:  MOVF   01,F
025E8:  BTFSC  FD8.2
025EA:  BRA    28CE
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
025EC:  DECFSZ 38,W
025EE:  BRA    26A2
025F0:  MOVF   36,W
025F2:  MOVLB  7
025F4:  SUBWF  xC7,W
025F6:  BTFSS  FD8.2
025F8:  BRA    25FE
025FA:  MOVLB  0
025FC:  BRA    26A2
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
025FE:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02600:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02602:  CLRWDT
02604:  MOVLW  02
02606:  MOVLB  8
02608:  MOVWF  xDF
0260A:  MOVLW  B5
0260C:  MOVWF  xE0
0260E:  MOVLB  0
02610:  CALL   11D0
02614:  MOVLB  8
02616:  DECFSZ xDF,F
02618:  BRA    260A
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
0261A:  MOVLB  7
0261C:  MOVF   xC7,W
0261E:  MOVLB  0
02620:  CALL   11F0
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02624:  CLRWDT
02626:  MOVLW  67
02628:  MOVWF  00
0262A:  DECFSZ 00,F
0262C:  BRA    262A
0262E:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02630:  MOVLB  7
02632:  MOVF   xC9,W
02634:  MOVLB  0
02636:  CALL   11F0
.................... 			delay_us(104); //one stop bit @ 9600 baud 
0263A:  CLRWDT
0263C:  MOVLW  67
0263E:  MOVWF  00
02640:  DECFSZ 00,F
02642:  BRA    2640
02644:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02646:  MOVLB  8
02648:  CLRF   xDE
0264A:  MOVLW  02
0264C:  MOVLB  7
0264E:  ADDWF  xC8,W
02650:  MOVLB  8
02652:  SUBWF  xDE,W
02654:  BC    2682
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02656:  MOVLW  CB
02658:  ADDWF  xDE,W
0265A:  MOVWF  FE9
0265C:  MOVLW  07
0265E:  MOVWF  FEA
02660:  BTFSC  FD8.0
02662:  INCF   FEA,F
02664:  MOVFF  FEF,8DF
02668:  MOVF   xDF,W
0266A:  MOVLB  0
0266C:  CALL   11F0
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02670:  CLRWDT
02672:  MOVLW  67
02674:  MOVWF  00
02676:  DECFSZ 00,F
02678:  BRA    2676
0267A:  NOP   
.................... 			} 
0267C:  MOVLB  8
0267E:  INCF   xDE,F
02680:  BRA    264A
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02682:  BTFSS  F72.1
02684:  BRA    2682
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02686:  CLRWDT
02688:  MOVLW  02
0268A:  MOVWF  xDF
0268C:  MOVLW  B5
0268E:  MOVWF  xE0
02690:  MOVLB  0
02692:  CALL   11D0
02696:  MOVLB  8
02698:  DECFSZ xDF,F
0269A:  BRA    268C
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
0269C:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
0269E:  BCF    F8C.0
026A0:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
026A2:  MOVF   36,W
026A4:  SUBLW  80
026A6:  BZ    26B4
026A8:  MOVF   36,W
026AA:  MOVLB  7
026AC:  SUBWF  xC7,W
026AE:  BTFSS  FD8.2
026B0:  BRA    28B8
026B2:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
026B4:  MOVLB  1
026B6:  INCFSZ xCC,W
026B8:  BRA    26C0
026BA:  INCFSZ xCD,W
026BC:  BRA    26C0
026BE:  BRA    26C6
.................... 				current.modbus_our_packets++; 
026C0:  INCF   xCC,F
026C2:  BTFSC  FD8.2
026C4:  INCF   xCD,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
026C6:  MOVLW  14
026C8:  MOVWF  xF7
....................  
.................... 			switch(modbus_rx.func) { 
026CA:  MOVLB  7
026CC:  MOVF   xC9,W
026CE:  XORLW  03
026D0:  MOVLB  0
026D2:  BZ    26E4
026D4:  XORLW  07
026D6:  BZ    26E4
026D8:  XORLW  02
026DA:  BZ    275C
026DC:  XORLW  16
026DE:  BTFSC  FD8.2
026E0:  BRA    27CE
026E2:  BRA    2890
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
026E4:  MOVFF  7CB,8DA
026E8:  MOVFF  7CC,8D9
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
026EC:  MOVFF  7CD,8DC
026F0:  MOVFF  7CE,8DB
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
026F4:  MOVLB  8
026F6:  MOVF   xDB,W
026F8:  ADDWF  xD9,W
026FA:  MOVWF  xDF
026FC:  MOVF   xDC,W
026FE:  ADDWFC xDA,W
02700:  MOVWF  xE0
02702:  MOVFF  8DA,8E2
02706:  MOVFF  8D9,8E1
0270A:  MOVWF  xE4
0270C:  MOVFF  8DF,8E3
02710:  MOVLB  0
02712:  GOTO   11F8
02716:  MOVF   01,F
02718:  BNZ   273E
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0271A:  MOVFF  7C7,8DF
0271E:  MOVLB  8
02720:  CLRF   xE1
02722:  MOVFF  7C9,8E0
02726:  MOVLW  02
02728:  MOVWF  xE2
0272A:  MOVLB  0
0272C:  CALL   1358
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02730:  MOVLB  1
02732:  CLRF   xD1
02734:  MOVLW  02
02736:  MOVWF  xD0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02738:  CLRF   xF7
.................... 					} else { 
0273A:  BRA    275A
0273C:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
0273E:  MOVFF  7C9,8DF
02742:  MOVFF  7C7,8E0
02746:  MOVFF  8DA,8E2
0274A:  MOVFF  8D9,8E1
0274E:  MOVFF  8DC,8E4
02752:  MOVFF  8DB,8E3
02756:  BRA    20EA
02758:  MOVLB  1
.................... 					} 
.................... 					break; 
0275A:  BRA    28B0
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0275C:  MOVFF  7CB,8DA
02760:  MOVFF  7CC,8D9
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02764:  MOVFF  7CD,8E0
02768:  MOVFF  7CE,8DF
0276C:  MOVFF  8DA,8E6
02770:  MOVFF  8D9,8E5
02774:  MOVFF  7CD,8E8
02778:  MOVFF  7CE,8E7
0277C:  RCALL  216C
0277E:  MOVFF  01,8DD
....................  
.................... 					if ( result ) { 
02782:  MOVLB  8
02784:  MOVF   xDD,F
02786:  BZ    27AA
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02788:  MOVFF  7C7,8DF
0278C:  CLRF   xE1
0278E:  MOVFF  7C9,8E0
02792:  MOVFF  8DD,8E2
02796:  MOVLB  0
02798:  CALL   1358
.................... 						current.modbus_last_error=result; 
0279C:  MOVLB  1
0279E:  CLRF   xD1
027A0:  MOVFF  8DD,1D0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
027A4:  CLRF   xF7
.................... 					}  else { 
027A6:  BRA    27CC
027A8:  MOVLB  8
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
027AA:  MOVFF  7CD,8E0
027AE:  MOVFF  7CE,8DF
027B2:  MOVFF  7C7,8E1
027B6:  MOVFF  8DA,8E3
027BA:  MOVFF  8D9,8E2
027BE:  MOVFF  7CD,8E5
027C2:  MOVFF  7CE,8E4
027C6:  MOVLB  0
027C8:  BRA    2552
027CA:  MOVLB  1
.................... 					} 
.................... 					break; 
027CC:  BRA    28B0
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
027CE:  MOVFF  7CB,8DA
027D2:  MOVFF  7CC,8D9
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
027D6:  MOVFF  7CD,8DC
027DA:  MOVFF  7CE,8DB
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
027DE:  MOVLB  8
027E0:  CLRF   xDE
027E2:  MOVF   xDC,F
027E4:  BNZ   27EC
027E6:  MOVF   xDB,W
027E8:  SUBWF  xDE,W
027EA:  BC    2870
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
027EC:  MOVF   xDE,W
027EE:  ADDWF  xD9,W
027F0:  MOVWF  xDF
027F2:  MOVLW  00
027F4:  ADDWFC xDA,W
027F6:  MOVWF  xE0
027F8:  BCF    FD8.0
027FA:  RLCF   xDE,W
027FC:  ADDLW  05
027FE:  ADDLW  CB
02800:  MOVWF  FE9
02802:  MOVLW  07
02804:  MOVWF  FEA
02806:  BTFSC  FD8.0
02808:  INCF   FEA,F
0280A:  MOVFF  FEF,8E1
0280E:  BCF    FD8.0
02810:  RLCF   xDE,W
02812:  ADDLW  06
02814:  ADDLW  CB
02816:  MOVWF  FE9
02818:  MOVLW  07
0281A:  MOVWF  FEA
0281C:  BTFSC  FD8.0
0281E:  INCF   FEA,F
02820:  MOVFF  FEF,8E2
02824:  MOVFF  8E1,8E4
02828:  MOVFF  8E2,8E3
0282C:  MOVFF  8E0,8E6
02830:  MOVFF  8DF,8E5
02834:  MOVFF  8E1,8E8
02838:  MOVFF  8E2,8E7
0283C:  MOVLB  0
0283E:  RCALL  216C
02840:  MOVFF  01,8DD
....................  
.................... 						if ( result ) { 
02844:  MOVLB  8
02846:  MOVF   xDD,F
02848:  BZ    286C
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
0284A:  MOVFF  7C7,8DF
0284E:  CLRF   xE1
02850:  MOVFF  7C9,8E0
02854:  MOVFF  8DD,8E2
02858:  MOVLB  0
0285A:  CALL   1358
.................... 							current.modbus_last_error=result; 
0285E:  MOVLB  1
02860:  CLRF   xD1
02862:  MOVFF  8DD,1D0
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02866:  CLRF   xF7
.................... 			 
.................... 							break; 
02868:  MOVLB  8
0286A:  BRA    2870
.................... 						} 
.................... 					} 
0286C:  INCF   xDE,F
0286E:  BRA    27E2
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02870:  MOVF   xDD,F
02872:  BNZ   288C
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02874:  MOVFF  7C7,8DF
02878:  MOVFF  8DA,8E1
0287C:  MOVFF  8D9,8E0
02880:  MOVFF  8DC,8E3
02884:  MOVFF  8DB,8E2
02888:  MOVLB  0
0288A:  BRA    259A
.................... 					} 
....................  
.................... 					break;   
0288C:  MOVLB  1
0288E:  BRA    28B0
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02890:  MOVFF  7C7,8DF
02894:  MOVLB  8
02896:  CLRF   xE1
02898:  MOVFF  7C9,8E0
0289C:  MOVLW  01
0289E:  MOVWF  xE2
028A0:  MOVLB  0
028A2:  CALL   1358
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
028A6:  MOVLB  1
028A8:  CLRF   xD1
028AA:  MOVLW  01
028AC:  MOVWF  xD0
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
028AE:  CLRF   xF7
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
028B0:  CLRF   xDA
028B2:  CLRF   xD9
....................  
.................... 		} else { 
028B4:  BRA    28CE
028B6:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
028B8:  MOVLB  1
028BA:  INCFSZ xCE,W
028BC:  BRA    28C4
028BE:  INCFSZ xCF,W
028C0:  BRA    28C4
028C2:  BRA    28CA
.................... 				current.modbus_other_packets++; 
028C4:  INCF   xCE,F
028C6:  BTFSC  FD8.2
028C8:  INCF   xCF,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
028CA:  MOVLW  0A
028CC:  MOVWF  xF7
028CE:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
028D0:  GOTO   2D66 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
0044E:  MOVLB  9
00450:  BTFSS  xEC.0
00452:  BRA    046C
00454:  MOVLB  1
00456:  INCFSZ xE6,W
00458:  BRA    0464
0045A:  INCFSZ xE7,W
0045C:  BRA    0464
0045E:  MOVLB  9
00460:  BRA    046C
00462:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00464:  INCF   xE6,F
00466:  BTFSC  FD8.2
00468:  INCF   xE7,F
0046A:  MOVLB  9
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0046C:  BTFSS  xEC.2
0046E:  BRA    0488
00470:  MOVLB  1
00472:  INCFSZ xE8,W
00474:  BRA    0480
00476:  INCFSZ xE9,W
00478:  BRA    0480
0047A:  MOVLB  9
0047C:  BRA    0488
0047E:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00480:  INCF   xE8,F
00482:  BTFSC  FD8.2
00484:  INCF   xE9,F
00486:  MOVLB  9
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
00488:  BTFSS  xEC.4
0048A:  BRA    04A4
0048C:  MOVLB  1
0048E:  INCFSZ xEA,W
00490:  BRA    049C
00492:  INCFSZ xEB,W
00494:  BRA    049C
00496:  MOVLB  9
00498:  BRA    04A4
0049A:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
0049C:  INCF   xEA,F
0049E:  BTFSC  FD8.2
004A0:  INCF   xEB,F
004A2:  MOVLB  9
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
004A4:  BCF    xEC.1
004A6:  BTFSC  F81.0
004A8:  BSF    xEC.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
004AA:  BTFSC  xEC.1
004AC:  BRA    0530
004AE:  MOVLB  7
004B0:  BTFSC  xC3.1
004B2:  BRA    04B8
004B4:  MOVLB  9
004B6:  BRA    0530
.................... 		current.pulse_count[0]++; 
004B8:  MOVLB  0
004BA:  INCF   xA9,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xAA,F
.................... 		current.pulse_sum[0]++; 
004C0:  MOVLW  01
004C2:  ADDWF  xAF,F
004C4:  BTFSC  FD8.0
004C6:  INCF   xB0,F
004C8:  BTFSC  FD8.2
004CA:  INCF   xB1,F
004CC:  BTFSC  FD8.2
004CE:  INCF   xB2,F
.................... 		if ( 1 == ext0_state ) { 
004D0:  MOVLB  7
004D2:  BTFSS  xC3.2
004D4:  BRA    051E
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004D6:  MOVLB  9
004D8:  BCF    xEC.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004DA:  MOVFF  1E7,98
004DE:  MOVFF  1E6,97
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004E2:  MOVLB  0
004E4:  MOVF   x98,W
004E6:  SUBWF  x9E,W
004E8:  BNC   04FA
004EA:  BNZ   04F2
004EC:  MOVF   x9D,W
004EE:  SUBWF  x97,W
004F0:  BC    04FA
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004F2:  MOVFF  98,9E
004F6:  MOVFF  97,9D
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004FA:  MOVF   xA4,W
004FC:  SUBWF  x98,W
004FE:  BNC   051A
00500:  BNZ   0508
00502:  MOVF   x97,W
00504:  SUBWF  xA3,W
00506:  BC    051A
00508:  INCFSZ x97,W
0050A:  BRA    0512
0050C:  INCFSZ x98,W
0050E:  BRA    0512
00510:  BRA    051A
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00512:  MOVFF  98,A4
00516:  MOVFF  97,A3
.................... 			} 
.................... 			ext0_state=0; 
0051A:  MOVLB  7
0051C:  BCF    xC3.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
0051E:  BTFSC  xC3.2
00520:  BRA    0530
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00522:  MOVLB  1
00524:  CLRF   xE7
00526:  CLRF   xE6
.................... 			ext0_count=1; 
00528:  MOVLB  9
0052A:  BSF    xEC.0
.................... 			ext0_state=1; 
0052C:  MOVLB  7
0052E:  BSF    xC3.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00530:  MOVLB  7
00532:  BCF    xC3.1
00534:  MOVLB  9
00536:  BTFSS  xEC.1
00538:  BRA    0540
0053A:  MOVLB  7
0053C:  BSF    xC3.1
0053E:  MOVLB  9
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00540:  BCF    xEC.3
00542:  BTFSC  F81.1
00544:  BSF    xEC.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
00546:  BTFSC  xEC.3
00548:  BRA    05CC
0054A:  MOVLB  7
0054C:  BTFSC  xC3.3
0054E:  BRA    0554
00550:  MOVLB  9
00552:  BRA    05CC
.................... 		current.pulse_count[1]++; 
00554:  MOVLB  0
00556:  INCF   xAB,F
00558:  BTFSC  FD8.2
0055A:  INCF   xAC,F
.................... 		current.pulse_sum[1]++; 
0055C:  MOVLW  01
0055E:  ADDWF  xB3,F
00560:  BTFSC  FD8.0
00562:  INCF   xB4,F
00564:  BTFSC  FD8.2
00566:  INCF   xB5,F
00568:  BTFSC  FD8.2
0056A:  INCF   xB6,F
.................... 		if ( 1 == ext1_state ) { 
0056C:  MOVLB  7
0056E:  BTFSS  xC3.4
00570:  BRA    05BA
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00572:  MOVLB  9
00574:  BCF    xEC.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00576:  MOVFF  1E9,9A
0057A:  MOVFF  1E8,99
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
0057E:  MOVLB  0
00580:  MOVF   x9A,W
00582:  SUBWF  xA0,W
00584:  BNC   0596
00586:  BNZ   058E
00588:  MOVF   x9F,W
0058A:  SUBWF  x99,W
0058C:  BC    0596
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0058E:  MOVFF  9A,A0
00592:  MOVFF  99,9F
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00596:  MOVF   xA6,W
00598:  SUBWF  x9A,W
0059A:  BNC   05B6
0059C:  BNZ   05A4
0059E:  MOVF   x99,W
005A0:  SUBWF  xA5,W
005A2:  BC    05B6
005A4:  INCFSZ x99,W
005A6:  BRA    05AE
005A8:  INCFSZ x9A,W
005AA:  BRA    05AE
005AC:  BRA    05B6
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005AE:  MOVFF  9A,A6
005B2:  MOVFF  99,A5
.................... 			} 
.................... 			ext1_state=0; 
005B6:  MOVLB  7
005B8:  BCF    xC3.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005BA:  BTFSC  xC3.4
005BC:  BRA    05CC
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005BE:  MOVLB  1
005C0:  CLRF   xE9
005C2:  CLRF   xE8
.................... 			ext1_count=1; 
005C4:  MOVLB  9
005C6:  BSF    xEC.2
.................... 			ext1_state=1; 
005C8:  MOVLB  7
005CA:  BSF    xC3.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005CC:  MOVLB  7
005CE:  BCF    xC3.3
005D0:  MOVLB  9
005D2:  BTFSS  xEC.3
005D4:  BRA    05DC
005D6:  MOVLB  7
005D8:  BSF    xC3.3
005DA:  MOVLB  9
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005DC:  BCF    xEC.5
005DE:  BTFSC  F81.2
005E0:  BSF    xEC.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005E2:  BTFSC  xEC.5
005E4:  BRA    0668
005E6:  MOVLB  7
005E8:  BTFSC  xC3.5
005EA:  BRA    05F0
005EC:  MOVLB  9
005EE:  BRA    0668
.................... 		current.pulse_count[2]++; 
005F0:  MOVLB  0
005F2:  INCF   xAD,F
005F4:  BTFSC  FD8.2
005F6:  INCF   xAE,F
.................... 		current.pulse_sum[2]++; 
005F8:  MOVLW  01
005FA:  ADDWF  xB7,F
005FC:  BTFSC  FD8.0
005FE:  INCF   xB8,F
00600:  BTFSC  FD8.2
00602:  INCF   xB9,F
00604:  BTFSC  FD8.2
00606:  INCF   xBA,F
.................... 		if ( 1 == ext2_state ) { 
00608:  MOVLB  7
0060A:  BTFSS  xC3.6
0060C:  BRA    0656
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0060E:  MOVLB  9
00610:  BCF    xEC.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00612:  MOVFF  1EB,9C
00616:  MOVFF  1EA,9B
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0061A:  MOVLB  0
0061C:  MOVF   x9C,W
0061E:  SUBWF  xA2,W
00620:  BNC   0632
00622:  BNZ   062A
00624:  MOVF   xA1,W
00626:  SUBWF  x9B,W
00628:  BC    0632
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0062A:  MOVFF  9C,A2
0062E:  MOVFF  9B,A1
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00632:  MOVF   xA8,W
00634:  SUBWF  x9C,W
00636:  BNC   0652
00638:  BNZ   0640
0063A:  MOVF   x9B,W
0063C:  SUBWF  xA7,W
0063E:  BC    0652
00640:  INCFSZ x9B,W
00642:  BRA    064A
00644:  INCFSZ x9C,W
00646:  BRA    064A
00648:  BRA    0652
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0064A:  MOVFF  9C,A8
0064E:  MOVFF  9B,A7
.................... 			} 
.................... 			ext2_state=0; 
00652:  MOVLB  7
00654:  BCF    xC3.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
00656:  BTFSC  xC3.6
00658:  BRA    0668
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0065A:  MOVLB  1
0065C:  CLRF   xEB
0065E:  CLRF   xEA
.................... 			ext2_count=1; 
00660:  MOVLB  9
00662:  BSF    xEC.4
.................... 			ext2_state=1; 
00664:  MOVLB  7
00666:  BSF    xC3.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
00668:  MOVLB  7
0066A:  BCF    xC3.5
0066C:  MOVLB  9
0066E:  BTFSS  xEC.5
00670:  BRA    0678
00672:  MOVLB  7
00674:  BSF    xC3.5
00676:  MOVLB  9
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00678:  MOVLB  8
0067A:  INCF   xCE,F
.................... 	if ( 10 == tick ) { 
0067C:  MOVF   xCE,W
0067E:  SUBLW  0A
00680:  BNZ   068A
.................... 		tick=0; 
00682:  CLRF   xCE
.................... 		timers.now_millisecond=1; 
00684:  MOVLB  1
00686:  BSF    xFA.2
00688:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0068A:  BCF    F9E.1
0068C:  MOVLB  0
0068E:  GOTO   013A
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
006AA:  BRA    0692
006AC:  MOVFF  01,9E9
.................... 	current.rda2_bytes_received++; 
006B0:  MOVLB  1
006B2:  INCF   xE4,F
006B4:  BTFSC  FD8.2
006B6:  INCF   xE5,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
006B8:  DECFSZ 38,W
006BA:  BRA    06DE
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006BC:  MOVLB  2
006BE:  CLRF   xFF
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006C0:  INCFSZ xFE,W
006C2:  BRA    06C6
006C4:  BRA    06DA
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006C6:  MOVLW  FE
006C8:  ADDWF  xFE,W
006CA:  MOVWF  FE9
006CC:  MOVLW  01
006CE:  MOVWF  FEA
006D0:  BTFSC  FD8.0
006D2:  INCF   FEA,F
006D4:  MOVFF  9E9,FEF
.................... 			timers.rda2_buff_pos++; 
006D8:  INCF   xFE,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006DA:  BRA    0720
006DC:  MOVLB  1
006DE:  MOVF   38,W
006E0:  SUBLW  02
006E2:  BNZ   0722
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
006E4:  MOVLB  9
006E6:  MOVF   xE9,W
006E8:  SUBLW  0A
006EA:  BZ    06F2
006EC:  MOVF   xE9,W
006EE:  SUBLW  0D
006F0:  BNZ   0702
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
006F2:  MOVLB  2
006F4:  MOVF   xFE,F
006F6:  BZ    06FE
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
006F8:  MOVLW  14
006FA:  MOVWF  xFF
.................... 			}  else { 
006FC:  BRA    06FE
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
006FE:  BRA    0720
00700:  MOVLB  9
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
00702:  MOVLB  2
00704:  CLRF   xFF
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
00706:  INCFSZ xFE,W
00708:  BRA    070C
0070A:  BRA    0720
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
0070C:  MOVLW  FE
0070E:  ADDWF  xFE,W
00710:  MOVWF  FE9
00712:  MOVLW  01
00714:  MOVWF  FEA
00716:  BTFSC  FD8.0
00718:  INCF   FEA,F
0071A:  MOVFF  9E9,FEF
.................... 				timers.rda2_buff_pos++; 
0071E:  INCF   xFE,F
00720:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... #if 1 
.................... /* transmit buffer empty for Modbus to raspberry pi buffer */ 
00722:  BCF    FA4.5
00724:  MOVLB  0
00726:  GOTO   0094
.................... #int_tbe 
.................... void isr_uart1_tbe() { 
.................... 	output_high(_PIC_TO_PI); 
*
00732:  BSF    F8C.3
.................... 	if ( timers.rda_tx_pos >= timers.rda_tx_length ) { 
00734:  MOVLB  4
00736:  MOVF   x00,W
00738:  SUBWF  x01,W
0073A:  BNC   0742
.................... 		/* done transmitting */ 
.................... 		timers.now_rda_tx_done=1; 
0073C:  BSF    x02.1
.................... 		disable_interrupts(INT_TBE); 
0073E:  BCF    F9D.4
.................... 	} else { 
00740:  BRA    075A
.................... 		/* put another character into TX buffer */ 
.................... 		fputc(timers.rda_tx_buff[timers.rda_tx_pos], STREAM_PI); 
00742:  MOVF   x01,W
00744:  MOVWF  FE9
00746:  MOVLW  03
00748:  MOVWF  FEA
0074A:  MOVFF  FEF,9E9
0074E:  MOVLB  9
00750:  MOVF   xE9,W
00752:  MOVLB  0
00754:  RCALL  072A
.................... 		timers.rda_tx_pos++; 
00756:  MOVLB  4
00758:  INCF   x01,F
.................... 	} 
.................... 	output_low(_PIC_TO_PI); 
0075A:  BCF    F8C.3
.................... } 
.................... #endif 
....................  
.................... /*  Raspberry PI connected serial port*/ 
0075C:  BCF    F9E.4
0075E:  MOVLB  0
00760:  GOTO   0094
.................... #int_rda 
.................... void isr_uart1_rx() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
007A6:  RCALL  0764
007A8:  MOVFF  01,9E9
....................  
.................... 	current.rda_bytes_received++; 
007AC:  MOVLB  1
007AE:  INCF   xE2,F
007B0:  BTFSC  FD8.2
007B2:  INCF   xE3,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
007B4:  MOVLB  7
007B6:  BTFSC  xC3.0
007B8:  BRA    0810
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
007BA:  MOVF   xC4,F
007BC:  BNZ   07CE
.................... 			modbus_serial_crc.d = 0xFFFF; 
007BE:  SETF   xC6
007C0:  SETF   xC5
.................... 			modbus_rx.address = c; 
007C2:  MOVFF  9E9,7C7
.................... 			modbus_serial_state++; 
007C6:  INCF   xC4,F
.................... 			modbus_rx.len = 0; 
007C8:  CLRF   xC8
.................... 			modbus_rx.error=0; 
007CA:  CLRF   xCA
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
007CC:  BRA    07FC
007CE:  DECFSZ xC4,W
007D0:  BRA    07DA
.................... 			modbus_rx.func = c; 
007D2:  MOVFF  9E9,7C9
.................... 			modbus_serial_state++; 
007D6:  INCF   xC4,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
007D8:  BRA    07FC
007DA:  MOVF   xC4,W
007DC:  SUBLW  02
007DE:  BNZ   07FC
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
007E0:  INCFSZ xC8,W
007E2:  BRA    07E8
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
007E4:  MOVLW  FE
007E6:  MOVWF  xC8
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
007E8:  MOVLW  CB
007EA:  ADDWF  xC8,W
007EC:  MOVWF  FE9
007EE:  MOVLW  07
007F0:  MOVWF  FEA
007F2:  BTFSC  FD8.0
007F4:  INCF   FEA,F
007F6:  MOVFF  9E9,FEF
.................... 			modbus_rx.len++; 
007FA:  INCF   xC8,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
007FC:  MOVFF  9E9,9EA
00800:  MOVLB  0
00802:  RCALL  077A
.................... 		modbus_enable_timeout(TRUE); 
00804:  MOVLW  01
00806:  MOVLB  9
00808:  MOVWF  xEA
0080A:  MOVLB  0
0080C:  RCALL  0408
0080E:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
00810:  BCF    F9E.5
00812:  MOVLB  0
00814:  GOTO   0094
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
00912:  MOVF   39,W
00914:  XORLW  00
00916:  BZ    092E
00918:  XORLW  01
0091A:  BZ    093E
0091C:  XORLW  03
0091E:  BZ    094E
00920:  XORLW  06
00922:  BZ    095E
00924:  XORLW  01
00926:  BZ    096A
00928:  XORLW  03
0092A:  BZ    097A
0092C:  BRA    0986
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
0092E:  BSF    F70.3
00930:  MOVLW  C3
00932:  MOVWF  F75
00934:  MOVLW  09
00936:  MOVWF  F76
00938:  MOVLW  A6
0093A:  MOVWF  F72
0093C:  BRA    0992
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
0093E:  BSF    F70.3
00940:  MOVLW  E1
00942:  MOVWF  F75
00944:  MOVLW  04
00946:  MOVWF  F76
00948:  MOVLW  A6
0094A:  MOVWF  F72
0094C:  BRA    0992
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
0094E:  BSF    F70.3
00950:  MOVLW  70
00952:  MOVWF  F75
00954:  MOVLW  02
00956:  MOVWF  F76
00958:  MOVLW  A6
0095A:  MOVWF  F72
0095C:  BRA    0992
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
0095E:  BCF    F70.3
00960:  MOVLW  26
00962:  MOVWF  F75
00964:  MOVLW  A6
00966:  MOVWF  F72
00968:  BRA    0992
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
0096A:  BSF    F70.3
0096C:  MOVLW  4D
0096E:  MOVWF  F75
00970:  MOVLW  00
00972:  MOVWF  F76
00974:  MOVLW  A6
00976:  MOVWF  F72
00978:  BRA    0992
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
0097A:  BCF    F70.3
0097C:  MOVLW  0C
0097E:  MOVWF  F75
00980:  MOVLW  A6
00982:  MOVWF  F72
00984:  BRA    0992
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
00986:  BCF    F70.3
00988:  MOVLW  4D
0098A:  MOVWF  F75
0098C:  MOVLW  A6
0098E:  MOVWF  F72
00990:  BRA    0992
.................... 	} 
.................... } 
00992:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... 	setup_adc(ADC_OFF); 
00994:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00996:  MOVLW  08
00998:  MOVWF  F61
0099A:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
0099C:  MOVLW  00
0099E:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
009A0:  MOVLW  FF
009A2:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
009A4:  MOVLW  92
009A6:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
009A8:  MOVLW  80
009AA:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
009AC:  BCF    F96.0
009AE:  BCF    F96.1
009B0:  BCF    F96.2
009B2:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
009B4:  MOVLB  1
009B6:  CLRF   xF7
.................... 	timers.load_off_seconds=2; 
009B8:  CLRF   xF9
009BA:  MOVLW  02
009BC:  MOVWF  xF8
.................... 	timers.now_adc_sample=0; 
009BE:  BCF    xFA.0
.................... 	timers.now_adc_reset_count=0; 
009C0:  BCF    xFA.1
.................... 	timers.now_millisecond=0; 
009C2:  BCF    xFA.2
.................... 	timers.port_b=0b11111111; 
009C4:  SETF   xFB
.................... 	timers.port_c=0b11111111; 
009C6:  SETF   xFC
....................  
.................... 	timers.rda2_buff_pos=0; 
009C8:  MOVLB  2
009CA:  CLRF   xFE
.................... 	timers.rda2_buff_gap=255; 
009CC:  SETF   xFF
.................... 	timers.now_parse_rda2=0; 
009CE:  MOVLB  1
009D0:  BCF    xFD.0
....................  
.................... 	timers.rda_tx_length=0; 
009D2:  MOVLB  4
009D4:  CLRF   x00
.................... 	timers.rda_tx_pos=0; 
009D6:  CLRF   x01
.................... 	timers.now_rda_tx_ready=0; 
009D8:  BCF    x02.0
.................... 	timers.now_rda_tx_done=0; 
009DA:  BCF    x02.1
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
009DC:  MOVLB  8
009DE:  CLRF   xD9
009E0:  MOVF   xD9,W
009E2:  SUBLW  02
009E4:  BNC   0A94
.................... 		current.pulse_period[i]=0; 
009E6:  CLRF   03
009E8:  MOVFF  8D9,02
009EC:  BCF    FD8.0
009EE:  RLCF   02,F
009F0:  RLCF   03,F
009F2:  MOVF   02,W
009F4:  ADDLW  97
009F6:  MOVWF  FE9
009F8:  MOVLW  00
009FA:  ADDWFC 03,W
009FC:  MOVWF  FEA
009FE:  CLRF   FEC
00A00:  MOVF   FED,F
00A02:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
00A04:  CLRF   03
00A06:  MOVFF  8D9,02
00A0A:  BCF    FD8.0
00A0C:  RLCF   02,F
00A0E:  RLCF   03,F
00A10:  MOVF   02,W
00A12:  ADDLW  9D
00A14:  MOVWF  FE9
00A16:  MOVLW  00
00A18:  ADDWFC 03,W
00A1A:  MOVWF  FEA
00A1C:  SETF   FEC
00A1E:  MOVF   FED,F
00A20:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00A22:  CLRF   03
00A24:  MOVFF  8D9,02
00A28:  BCF    FD8.0
00A2A:  RLCF   02,F
00A2C:  RLCF   03,F
00A2E:  MOVF   02,W
00A30:  ADDLW  A3
00A32:  MOVWF  FE9
00A34:  MOVLW  00
00A36:  ADDWFC 03,W
00A38:  MOVWF  FEA
00A3A:  CLRF   FEC
00A3C:  MOVF   FED,F
00A3E:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00A40:  CLRF   03
00A42:  MOVFF  8D9,02
00A46:  BCF    FD8.0
00A48:  RLCF   02,F
00A4A:  RLCF   03,F
00A4C:  MOVF   02,W
00A4E:  ADDLW  A9
00A50:  MOVWF  FE9
00A52:  MOVLW  00
00A54:  ADDWFC 03,W
00A56:  MOVWF  FEA
00A58:  CLRF   FEC
00A5A:  MOVF   FED,F
00A5C:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00A5E:  MOVLB  9
00A60:  CLRF   xDE
00A62:  MOVFF  8D9,9DD
00A66:  CLRF   xE0
00A68:  MOVLW  04
00A6A:  MOVWF  xDF
00A6C:  MOVLB  0
00A6E:  RCALL  08D6
00A70:  MOVF   01,W
00A72:  ADDLW  AF
00A74:  MOVWF  FE9
00A76:  MOVLW  00
00A78:  ADDWFC 02,W
00A7A:  MOVWF  FEA
00A7C:  MOVF   FEE,F
00A7E:  MOVF   FEE,F
00A80:  CLRF   FEC
00A82:  MOVF   FED,F
00A84:  CLRF   FEF
00A86:  MOVF   FED,F
00A88:  CLRF   FEF
00A8A:  MOVF   FED,F
00A8C:  CLRF   FEF
.................... 	} 
00A8E:  MOVLB  8
00A90:  INCF   xD9,F
00A92:  BRA    09E0
....................  
.................... 	current.modbus_our_packets=0; 
00A94:  MOVLB  1
00A96:  CLRF   xCD
00A98:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
00A9A:  CLRF   xCF
00A9C:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
00A9E:  CLRF   xD1
00AA0:  CLRF   xD0
.................... 	current.sequence_number=0; 
00AA2:  CLRF   xD3
00AA4:  CLRF   xD2
.................... 	current.uptime_minutes=0; 
00AA6:  CLRF   xD5
00AA8:  CLRF   xD4
.................... 	current.interval_milliseconds=0; 
00AAA:  CLRF   xD7
00AAC:  CLRF   xD6
.................... 	current.adc_buffer_index=0; 
00AAE:  CLRF   xCB
.................... 	current.factory_unlocked=0; 
00AB0:  CLRF   xD8
.................... 	current.watchdog_seconds=0; 
00AB2:  CLRF   xDA
00AB4:  CLRF   xD9
.................... 	current.rda_bytes_received=0; 
00AB6:  CLRF   xE3
00AB8:  CLRF   xE2
.................... 	current.rda2_bytes_received=0; 
00ABA:  CLRF   xE5
00ABC:  CLRF   xE4
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
00ABE:  MOVLW  04
00AC0:  MOVWF  FEA
00AC2:  MOVLW  03
00AC4:  MOVWF  FE9
00AC6:  CLRF   00
00AC8:  MOVWF  02
00ACA:  MOVLW  C0
00ACC:  MOVWF  01
00ACE:  MOVLB  0
00AD0:  RCALL  08F8
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00AD2:  MOVFF  4C,1DD
00AD6:  MOVFF  4B,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
00ADA:  MOVFF  48,1DF
00ADE:  MOVFF  47,1DE
.................... 	current.power_override_timeout=0; 
00AE2:  MOVLB  1
00AE4:  CLRF   xE1
00AE6:  CLRF   xE0
....................  
.................... 	/* UART2 - RS-485 port */ 
.................... 	set_rs485_speed(); 
00AE8:  MOVLB  0
00AEA:  RCALL  0912
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00AEC:  MOVLW  00
00AEE:  IORLW  05
00AF0:  MOVWF  FBA
00AF2:  MOVLW  4A
00AF4:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00AF6:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00AF8:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00AFA:  GOTO   2BE2 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
01042:  MOVLB  1
01044:  BCF    xFA.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
01046:  BCF    FD8.0
01048:  MOVLB  8
0104A:  RLCF   xD4,W
0104C:  MOVWF  xD9
0104E:  RLCF   xD5,W
01050:  MOVWF  xDA
01052:  MOVLW  00
01054:  MOVLB  1
01056:  BTFSS  xFC.5
01058:  MOVLW  01
0105A:  MOVLB  8
0105C:  IORWF  xD9,F
0105E:  MOVFF  8D9,8D4
01062:  MOVF   xDA,W
01064:  IORLW  E0
01066:  MOVWF  xD5
.................... 	if ( b2_state==0xf000) { 
01068:  MOVF   xD4,F
0106A:  BNZ   1072
0106C:  MOVF   xD5,W
0106E:  SUBLW  F0
01070:  BNZ   1072
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
01072:  MOVLB  1
01074:  INCFSZ xE6,W
01076:  BRA    1084
01078:  INCFSZ xE7,W
0107A:  BRA    1084
.................... 				current.pulse_period[0]=0; 
0107C:  MOVLB  0
0107E:  CLRF   x98
01080:  CLRF   x97
01082:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
01084:  INCFSZ xE8,W
01086:  BRA    1094
01088:  INCFSZ xE9,W
0108A:  BRA    1094
.................... 				current.pulse_period[1]=0; 
0108C:  MOVLB  0
0108E:  CLRF   x9A
01090:  CLRF   x99
01092:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
01094:  INCFSZ xEA,W
01096:  BRA    10A4
01098:  INCFSZ xEB,W
0109A:  BRA    10A4
.................... 				current.pulse_period[2]=0; 
0109C:  MOVLB  0
0109E:  CLRF   x9C
010A0:  CLRF   x9B
010A2:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
010A4:  MOVFF  F81,1FB
.................... 	timers.port_c=port_c; 
010A8:  MOVFF  F82,1FC
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
010AC:  MOVF   xF7,F
010AE:  BNZ   10B4
.................... 		output_low(LED_GREEN); 
010B0:  BCF    F89.3
.................... 	} else { 
010B2:  BRA    10B8
.................... 		output_high(LED_GREEN); 
010B4:  BSF    F89.3
.................... 		timers.led_on_green--; 
010B6:  DECF   xF7,F
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
010B8:  INCFSZ xD6,W
010BA:  BRA    10C2
010BC:  INCFSZ xD7,W
010BE:  BRA    10C2
010C0:  BRA    10C8
.................... 		current.interval_milliseconds++; 
010C2:  INCF   xD6,F
010C4:  BTFSC  FD8.2
010C6:  INCF   xD7,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
010C8:  MOVLB  8
010CA:  INCF   xD2,F
010CC:  BTFSC  FD8.2
010CE:  INCF   xD3,F
.................... 	if ( 1000 == ticks ) { 
010D0:  MOVF   xD2,W
010D2:  SUBLW  E8
010D4:  BNZ   115A
010D6:  MOVF   xD3,W
010D8:  SUBLW  03
010DA:  BNZ   115A
.................... 		ticks=0; 
010DC:  CLRF   xD3
010DE:  CLRF   xD2
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
010E0:  MOVLB  1
010E2:  INCFSZ xD9,W
010E4:  BRA    10EC
010E6:  INCFSZ xDA,W
010E8:  BRA    10EC
010EA:  BRA    10F2
.................... 			current.watchdog_seconds++; 
010EC:  INCF   xD9,F
010EE:  BTFSC  FD8.2
010F0:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
010F2:  MOVF   40,F
010F4:  BNZ   10FA
010F6:  MOVF   41,F
010F8:  BZ    1118
010FA:  MOVF   41,W
010FC:  SUBWF  xDA,W
010FE:  BNC   1118
01100:  BNZ   1108
01102:  MOVF   xD9,W
01104:  SUBWF  40,W
01106:  BC    1118
01108:  MOVF   xF8,F
0110A:  BNZ   1118
0110C:  MOVF   xF9,F
0110E:  BNZ   1118
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
01110:  MOVFF  43,1F9
01114:  MOVFF  42,1F8
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
01118:  MOVF   xF8,F
0111A:  BNZ   1124
0111C:  MOVF   xF9,F
0111E:  BNZ   1124
.................... 			output_high(PI_POWER_EN); 
01120:  BSF    F8B.0
.................... 		} else { 
01122:  BRA    113A
.................... 			output_low(PI_POWER_EN); 
01124:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01126:  MOVF   xF8,W
01128:  BTFSC  FD8.2
0112A:  DECF   xF9,F
0112C:  DECF   xF8,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
0112E:  MOVF   xF8,F
01130:  BNZ   113A
01132:  MOVF   xF9,F
01134:  BNZ   113A
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01136:  CLRF   xDA
01138:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
0113A:  MOVLB  8
0113C:  INCF   xCF,F
.................... 		if ( 60 == uptimeTicks ) { 
0113E:  MOVF   xCF,W
01140:  SUBLW  3C
01142:  BNZ   115A
.................... 			uptimeTicks=0; 
01144:  CLRF   xCF
.................... 			if ( current.uptime_minutes < 65535 )  
01146:  MOVLB  1
01148:  INCFSZ xD4,W
0114A:  BRA    1152
0114C:  INCFSZ xD5,W
0114E:  BRA    1152
01150:  BRA    1158
.................... 				current.uptime_minutes++; 
01152:  INCF   xD4,F
01154:  BTFSC  FD8.2
01156:  INCF   xD5,F
01158:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
.................... #if 0 
.................... 	LVD code  
.................... 	if ( 65535 == adcValue ) { 
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
.................... 	} 
....................  
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
0115A:  MOVLB  1
0115C:  BTFSS  xFA.1
0115E:  BRA    1168
.................... 		timers.now_adc_reset_count=0; 
01160:  BCF    xFA.1
.................... 		adcTicks=0; 
01162:  MOVLB  8
01164:  CLRF   xD1
01166:  CLRF   xD0
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01168:  MOVLB  8
0116A:  INCF   xD0,F
0116C:  BTFSC  FD8.2
0116E:  INCF   xD1,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
01170:  MOVF   3D,W
01172:  SUBWF  xD0,W
01174:  BNZ   118A
01176:  MOVF   3E,W
01178:  SUBWF  xD1,W
0117A:  BNZ   118A
.................... 		adcTicks=0; 
0117C:  CLRF   xD1
0117E:  CLRF   xD0
.................... 		timers.now_adc_sample=1; 
01180:  MOVLB  1
01182:  BSF    xFA.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
01184:  MOVLB  8
01186:  SETF   xD7
01188:  SETF   xD6
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
0118A:  MOVLB  2
0118C:  INCFSZ xFF,W
0118E:  BRA    1192
01190:  BRA    1194
.................... 		timers.rda2_buff_gap++; 
01192:  INCF   xFF,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
01194:  MOVF   xFF,W
01196:  SUBLW  09
01198:  BC    11A4
0119A:  MOVF   xFE,F
0119C:  BZ    11A4
.................... 		timers.now_parse_rda2=1;	 
0119E:  MOVLB  1
011A0:  BSF    xFD.0
011A2:  MOVLB  2
.................... 	} 
.................... } 
011A4:  MOVLB  0
011A6:  GOTO   2D54 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
028D4:  MOVLB  9
028D6:  CLRF   xE5
028D8:  MOVF   xE3,W
028DA:  SUBWF  xE5,W
028DC:  BC    294A
028DE:  CLRF   03
028E0:  MOVF   xE5,W
028E2:  ADDWF  xE1,W
028E4:  MOVWF  FE9
028E6:  MOVF   xE2,W
028E8:  ADDWFC 03,W
028EA:  MOVWF  FEA
028EC:  MOVF   FEF,F
028EE:  BZ    294A
028F0:  CLRF   03
028F2:  MOVF   xE5,W
028F4:  ADDWF  xE1,W
028F6:  MOVWF  FE9
028F8:  MOVF   xE2,W
028FA:  ADDWFC 03,W
028FC:  MOVWF  FEA
028FE:  MOVF   FEF,W
02900:  SUBLW  0A
02902:  BZ    294A
02904:  CLRF   03
02906:  MOVF   xE5,W
02908:  ADDWF  xE1,W
0290A:  MOVWF  FE9
0290C:  MOVF   xE2,W
0290E:  ADDWFC 03,W
02910:  MOVWF  FEA
02912:  MOVF   FEF,W
02914:  SUBLW  0D
02916:  BZ    294A
.................... 		dest[i] = src[i]; 
02918:  CLRF   03
0291A:  MOVF   xE5,W
0291C:  ADDWF  xDF,W
0291E:  MOVWF  01
02920:  MOVF   xE0,W
02922:  ADDWFC 03,F
02924:  MOVFF  03,9E7
02928:  CLRF   03
0292A:  MOVF   xE5,W
0292C:  ADDWF  xE1,W
0292E:  MOVWF  FE9
02930:  MOVF   xE2,W
02932:  ADDWFC 03,W
02934:  MOVWF  FEA
02936:  MOVFF  FEF,9E8
0293A:  MOVFF  9E7,FEA
0293E:  MOVFF  01,FE9
02942:  MOVFF  9E8,FEF
.................... 	} 
02946:  INCF   xE5,F
02948:  BRA    28D8
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
0294A:  MOVF   xE4,W
0294C:  SUBWF  xE5,W
0294E:  BC    2964
.................... 		dest[i] = '\0'; 
02950:  CLRF   03
02952:  MOVF   xE5,W
02954:  ADDWF  xDF,W
02956:  MOVWF  FE9
02958:  MOVF   xE0,W
0295A:  ADDWFC 03,W
0295C:  MOVWF  FEA
0295E:  CLRF   FEF
.................... 	} 
02960:  INCF   xE5,F
02962:  BRA    294A
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
02964:  MOVLW  01
02966:  SUBWF  xE4,W
02968:  CLRF   03
0296A:  ADDWF  xDF,W
0296C:  MOVWF  FE9
0296E:  MOVF   xE0,W
02970:  ADDWFC 03,W
02972:  MOVWF  FEA
02974:  CLRF   FEF
.................... } 
02976:  MOVLB  0
02978:  RETURN 0
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02A12:  MOVFF  2FE,9D9
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02A16:  MOVLB  2
02A18:  SETF   xFE
.................... 	memcpy(buff,timers.rda2_buff,length); 
02A1A:  MOVLW  08
02A1C:  MOVWF  FEA
02A1E:  MOVLW  D9
02A20:  MOVWF  FE9
02A22:  MOVLW  01
02A24:  MOVWF  FE2
02A26:  MOVLW  FE
02A28:  MOVWF  FE1
02A2A:  MOVLB  9
02A2C:  MOVF   xD9,W
02A2E:  MOVWF  01
02A30:  BZ    2A3A
02A32:  MOVFF  FE6,FEE
02A36:  DECFSZ 01,F
02A38:  BRA    2A32
.................... 	timers.rda2_buff_gap=0; 
02A3A:  MOVLB  2
02A3C:  CLRF   xFF
.................... 	timers.rda2_buff_pos=0; 
02A3E:  CLRF   xFE
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02A40:  DECFSZ 38,W
02A42:  BRA    2A7A
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02A44:  MOVLB  9
02A46:  CLRF   xDB
02A48:  CLRF   xDA
02A4A:  MOVF   xDB,F
02A4C:  BNZ   2A76
02A4E:  MOVF   xD9,W
02A50:  SUBWF  xDA,W
02A52:  BC    2A76
.................... 			fputc(buff[l],STREAM_PI); 
02A54:  MOVLW  D9
02A56:  ADDWF  xDA,W
02A58:  MOVWF  FE9
02A5A:  MOVLW  08
02A5C:  ADDWFC xDB,W
02A5E:  MOVWF  FEA
02A60:  MOVFF  FEF,9DD
02A64:  MOVF   xDD,W
02A66:  MOVLB  0
02A68:  CALL   072A
.................... 		} 
02A6C:  MOVLB  9
02A6E:  INCF   xDA,F
02A70:  BTFSC  FD8.2
02A72:  INCF   xDB,F
02A74:  BRA    2A4A
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
02A76:  BRA    2B36
02A78:  MOVLB  2
02A7A:  MOVF   38,W
02A7C:  SUBLW  02
02A7E:  BNZ   2B38
.................... 		/* do something */ 
....................  
.................... 		/* put copy in 11th slot no mater what ... for debugging */ 
.................... 		strncpy_terminate_trim(nmea.sentence[11],buff,length,NMEA_SENTENCE_LENGTH); 
02A80:  MOVLW  07
02A82:  MOVLB  9
02A84:  MOVWF  xE0
02A86:  MOVLW  73
02A88:  MOVWF  xDF
02A8A:  MOVLW  08
02A8C:  MOVWF  xE2
02A8E:  MOVLW  D9
02A90:  MOVWF  xE1
02A92:  MOVFF  9D9,9E3
02A96:  MOVLW  50
02A98:  MOVWF  xE4
02A9A:  MOVLB  0
02A9C:  RCALL  28D4
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
02A9E:  MOVLB  9
02AA0:  MOVF   xD9,W
02AA2:  SUBLW  05
02AA4:  BNC   2AA8
.................... 			return; 
02AA6:  BRA    2B36
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
02AA8:  CLRF   xDC
02AAA:  MOVF   xDC,W
02AAC:  SUBLW  0B
02AAE:  BNC   2B36
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
02AB0:  MOVF   xDC,W
02AB2:  MULLW  06
02AB4:  MOVF   FF3,W
02AB6:  CLRF   03
02AB8:  ADDLW  4F
02ABA:  MOVWF  01
02ABC:  MOVLW  00
02ABE:  ADDWFC 03,F
02AC0:  MOVFF  01,9DD
02AC4:  MOVFF  03,9DE
02AC8:  MOVLW  08
02ACA:  MOVWF  xE0
02ACC:  MOVLW  D9
02ACE:  MOVWF  xDF
02AD0:  MOVFF  03,9E2
02AD4:  MOVFF  01,9E1
02AD8:  CLRF   xE4
02ADA:  MOVLW  06
02ADC:  MOVWF  xE3
02ADE:  MOVLB  0
02AE0:  BRA    297A
02AE2:  MOVF   01,F
02AE4:  BZ    2AE8
.................... 				/* no match */ 
.................... 				continue; 
02AE6:  BRA    2B30
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
02AE8:  MOVLB  9
02AEA:  CLRF   xDE
02AEC:  MOVFF  9DC,9DD
02AF0:  CLRF   xE0
02AF2:  MOVLW  50
02AF4:  MOVWF  xDF
02AF6:  MOVLB  0
02AF8:  CALL   08D6
02AFC:  MOVFF  02,03
02B00:  MOVF   01,W
02B02:  ADDLW  03
02B04:  MOVWF  01
02B06:  MOVLW  04
02B08:  ADDWFC 03,F
02B0A:  MOVFF  01,9DD
02B0E:  MOVLB  9
02B10:  MOVFF  03,9DE
02B14:  MOVFF  03,9E0
02B18:  MOVFF  01,9DF
02B1C:  MOVLW  08
02B1E:  MOVWF  xE2
02B20:  MOVLW  D9
02B22:  MOVWF  xE1
02B24:  MOVFF  9D9,9E3
02B28:  MOVLW  50
02B2A:  MOVWF  xE4
02B2C:  MOVLB  0
02B2E:  RCALL  28D4
.................... 		} 
02B30:  MOVLB  9
02B32:  INCF   xDC,F
02B34:  BRA    2AAA
02B36:  MOVLB  2
.................... 	} 
.................... } 
02B38:  MOVLB  0
02B3A:  GOTO   2DA2 (RETURN)
....................  
....................  
.................... void main(void) { 
02B3E:  CLRF   FF8
02B40:  BCF    FF1.2
02B42:  BSF    F9F.1
02B44:  BCF    F9F.5
02B46:  BCF    F9F.4
02B48:  BCF    FA5.5
02B4A:  BSF    FD0.7
02B4C:  BSF    07.7
02B4E:  CLRF   FEA
02B50:  CLRF   FE9
02B52:  CLRF   35
02B54:  BCF    FB8.3
02B56:  MOVLW  0C
02B58:  MOVWF  FAF
02B5A:  MOVLW  A6
02B5C:  MOVWF  FAC
02B5E:  MOVLW  90
02B60:  MOVWF  FAB
02B62:  BCF    F70.3
02B64:  MOVLW  4D
02B66:  MOVWF  F75
02B68:  MOVLW  A6
02B6A:  MOVWF  F72
02B6C:  MOVLW  90
02B6E:  MOVWF  F71
02B70:  MOVLB  7
02B72:  BCF    xC3.0
02B74:  CLRF   xC4
02B76:  MOVLB  8
02B78:  CLRF   xCE
02B7A:  MOVLB  7
02B7C:  BCF    xC3.1
02B7E:  BCF    xC3.2
02B80:  BCF    xC3.3
02B82:  BCF    xC3.4
02B84:  BCF    xC3.5
02B86:  BCF    xC3.6
02B88:  MOVLB  8
02B8A:  CLRF   xCF
02B8C:  CLRF   xD1
02B8E:  CLRF   xD0
02B90:  CLRF   xD3
02B92:  CLRF   xD2
02B94:  CLRF   xD5
02B96:  CLRF   xD4
02B98:  MOVF   FC1,W
02B9A:  ANDLW  F0
02B9C:  MOVWF  FC1
02B9E:  MOVLW  00
02BA0:  MOVLB  F
02BA2:  MOVWF  x38
02BA4:  MOVWF  x3C
02BA6:  MOVWF  x39
02BA8:  MOVWF  x3A
02BAA:  MOVWF  x3B
02BAC:  MOVLB  1
02BAE:  CLRF   x88
02BB0:  CLRF   F77
02BB2:  CLRF   F78
02BB4:  CLRF   F79
02BB6:  CLRF   2F
02BB8:  CLRF   30
02BBA:  MOVLB  8
02BBC:  CLRF   xCA
02BBE:  CLRF   xCB
02BC0:  CLRF   xCC
02BC2:  CLRF   xCD
02BC4:  CLRF   xD6
02BC6:  CLRF   xD7
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02BC8:  MOVF   FD0,W
02BCA:  ANDLW  0F
02BCC:  BTFSS  FD0.4
02BCE:  MOVLW  00
02BD0:  BSF    FD0.0
02BD2:  BSF    FD0.1
02BD4:  BSF    FD0.4
02BD6:  BSF    FD8.3
02BD8:  BSF    FD8.4
02BDA:  MOVWF  xD8
....................  
.................... 	init(); 
02BDC:  MOVLB  0
02BDE:  GOTO   0994
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
02BE2:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
02BE4:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
02BE6:  MOVLW  18
02BE8:  MOVWF  FF6
02BEA:  MOVLW  08
02BEC:  MOVWF  FF7
02BEE:  MOVLW  07
02BF0:  MOVLB  8
02BF2:  MOVWF  xD9
02BF4:  MOVLB  0
02BF6:  CALL   0AFE
02BFA:  MOVLW  24
02BFC:  MOVWF  FF6
02BFE:  MOVLW  08
02C00:  MOVWF  FF7
02C02:  CALL   0B28
02C06:  MOVLW  0D
02C08:  BTFSS  FA4.4
02C0A:  BRA    2C08
02C0C:  MOVWF  F73
02C0E:  MOVLW  0A
02C10:  BTFSS  FA4.4
02C12:  BRA    2C10
02C14:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
02C16:  MOVLW  2E
02C18:  MOVWF  FF6
02C1A:  MOVLW  08
02C1C:  MOVWF  FF7
02C1E:  MOVLW  12
02C20:  MOVLB  8
02C22:  MOVWF  xD9
02C24:  MOVLB  0
02C26:  CALL   0AFE
02C2A:  MOVFF  8D8,8D9
02C2E:  MOVLW  1B
02C30:  MOVLB  8
02C32:  MOVWF  xDA
02C34:  MOVLB  0
02C36:  GOTO   0B76
02C3A:  MOVLW  20
02C3C:  BTFSS  FA4.4
02C3E:  BRA    2C3C
02C40:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
02C42:  MOVLB  8
02C44:  MOVF   xD8,W
02C46:  XORLW  07
02C48:  MOVLB  0
02C4A:  BZ    2C66
02C4C:  XORLW  0C
02C4E:  BZ    2C74
02C50:  XORLW  04
02C52:  BZ    2C82
02C54:  XORLW  03
02C56:  BZ    2C90
02C58:  XORLW  02
02C5A:  BZ    2C9E
02C5C:  XORLW  0D
02C5E:  BZ    2CAC
02C60:  XORLW  03
02C62:  BZ    2CBA
02C64:  BRA    2CC8
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
02C66:  MOVLW  44
02C68:  MOVWF  FF6
02C6A:  MOVLW  08
02C6C:  MOVWF  FF7
02C6E:  CALL   0B28
02C72:  BRA    2CD4
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
02C74:  MOVLW  50
02C76:  MOVWF  FF6
02C78:  MOVLW  08
02C7A:  MOVWF  FF7
02C7C:  CALL   0B28
02C80:  BRA    2CD4
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
02C82:  MOVLW  60
02C84:  MOVWF  FF6
02C86:  MOVLW  08
02C88:  MOVWF  FF7
02C8A:  CALL   0B28
02C8E:  BRA    2CD4
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
02C90:  MOVLW  6E
02C92:  MOVWF  FF6
02C94:  MOVLW  08
02C96:  MOVWF  FF7
02C98:  CALL   0B28
02C9C:  BRA    2CD4
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
02C9E:  MOVLW  7E
02CA0:  MOVWF  FF6
02CA2:  MOVLW  08
02CA4:  MOVWF  FF7
02CA6:  CALL   0B28
02CAA:  BRA    2CD4
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
02CAC:  MOVLW  90
02CAE:  MOVWF  FF6
02CB0:  MOVLW  08
02CB2:  MOVWF  FF7
02CB4:  CALL   0B28
02CB8:  BRA    2CD4
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
02CBA:  MOVLW  A0
02CBC:  MOVWF  FF6
02CBE:  MOVLW  08
02CC0:  MOVWF  FF7
02CC2:  CALL   0B28
02CC6:  BRA    2CD4
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
02CC8:  MOVLW  B2
02CCA:  MOVWF  FF6
02CCC:  MOVLW  08
02CCE:  MOVWF  FF7
02CD0:  CALL   0B28
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
02CD4:  MOVLW  BC
02CD6:  MOVWF  FF6
02CD8:  MOVLW  08
02CDA:  MOVWF  FF7
02CDC:  CALL   0B28
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02CE0:  GOTO   0E2E
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02CE4:  MOVF   36,W
02CE6:  SUBLW  80
02CE8:  BC    2CEE
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02CEA:  CALL   0D82
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02CEE:  BSF    FAB.7
02CF0:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02CF2:  GOTO   0E8C
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02CF6:  MOVLB  8
02CF8:  CLRF   xD8
02CFA:  MOVF   xD8,W
02CFC:  SUBLW  1D
02CFE:  BNC   2D0C
.................... 		adc_update(); 
02D00:  MOVLB  0
02D02:  CALL   0F4A
.................... 	} 
02D06:  MOVLB  8
02D08:  INCF   xD8,F
02D0A:  BRA    2CFA
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02D0C:  MOVFF  44,1DB
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
02D10:  BTFSS  F72.1
02D12:  BRA    2D10
.................... 	output_low(RS485_DE); 
02D14:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02D16:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02D18:  MOVLW  C0
02D1A:  MOVWF  FF6
02D1C:  MOVLW  08
02D1E:  MOVWF  FF7
02D20:  MOVLW  07
02D22:  MOVWF  xD9
02D24:  MOVLB  0
02D26:  GOTO   0FF2
02D2A:  MOVLW  CC
02D2C:  MOVWF  FF6
02D2E:  MOVLW  08
02D30:  MOVWF  FF7
02D32:  GOTO   101E
02D36:  MOVLW  0D
02D38:  BTFSS  F9E.4
02D3A:  BRA    2D38
02D3C:  MOVWF  FAD
02D3E:  MOVLW  0A
02D40:  BTFSS  F9E.4
02D42:  BRA    2D40
02D44:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02D46:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
02D48:  MOVLB  1
02D4A:  BTFSS  xFA.2
02D4C:  BRA    2D56
.................... 			periodic_millisecond(); 
02D4E:  MOVLB  0
02D50:  GOTO   1042
02D54:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02D56:  BTFSS  xFA.0
02D58:  BRA    2D62
.................... 			timers.now_adc_sample=0; 
02D5A:  BCF    xFA.0
.................... 			adc_update(); 
02D5C:  MOVLB  0
02D5E:  CALL   0F4A
.................... 		} 
....................  
.................... 		modbus_process(); 
02D62:  MOVLB  0
02D64:  BRA    25E2
....................  
....................  
.................... 		/* buffered modbus transmit */ 
....................  
.................... 		/* start transmitting */ 
.................... 		if ( timers.now_rda_tx_ready ) { 
02D66:  MOVLB  4
02D68:  BTFSS  x02.0
02D6A:  BRA    2D7E
.................... 			timers.now_rda_tx_ready=0; 
02D6C:  BCF    x02.0
....................  
.................... //			output_high(_PIC_TO_PI); 
....................  
.................... 			RCV_OFF(); 
02D6E:  BCF    F9D.5
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
02D70:  CLRWDT
02D72:  MOVLW  3C
02D74:  MOVWF  00
02D76:  DECFSZ 00,F
02D78:  BRA    2D76
02D7A:  NOP   
....................  
.................... 			/* enable transmit buffer empty interrupt. It will feed itself */ 
.................... 			enable_interrupts(INT_TBE); 
02D7C:  BSF    F9D.4
.................... 		} 
....................  
.................... 		/* done transmitting */ 
.................... 		if ( timers.now_rda_tx_done ) { 
02D7E:  BTFSS  x02.1
02D80:  BRA    2D96
.................... 			timers.now_rda_tx_done=0; 
02D82:  BCF    x02.1
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
02D84:  CLRWDT
02D86:  MOVLW  3C
02D88:  MOVWF  00
02D8A:  DECFSZ 00,F
02D8C:  BRA    2D8A
02D8E:  NOP   
....................    			RCV_ON(); 
02D90:  MOVLB  0
02D92:  CALL   0E80
....................  
.................... //			output_low(_PIC_TO_PI); 
.................... 		} 
....................  
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
02D96:  MOVLB  1
02D98:  BTFSS  xFD.0
02D9A:  BRA    2DA4
.................... 			timers.now_parse_rda2=0; 
02D9C:  BCF    xFD.0
.................... 			rs485_to_host(); 
02D9E:  MOVLB  0
02DA0:  BRA    2A12
02DA2:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
02DA4:  MOVLB  0
02DA6:  BRA    2D46
.................... } 
02DA8:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
