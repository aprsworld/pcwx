CCS PCH C Compiler, Version 4.135, 4375               13-Sep-15 09:47

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 9050 bytes (14%)
                         Largest free fragment is 56482
               RAM used: 711 (18%) at main() level
                         745 (19%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   20A6
*
00008:  GOTO   00CA
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   044E
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0706
0007C:  MOVFF  0E,00
00080:  MOVFF  0F,01
00084:  MOVFF  10,02
00088:  MOVFF  11,03
0008C:  MOVFF  0C,FE9
00090:  MOVFF  07,FEA
00094:  BSF    07.7
00096:  MOVFF  08,FE1
0009A:  MOVFF  09,FE2
0009E:  MOVFF  0A,FD9
000A2:  MOVFF  0B,FDA
000A6:  MOVFF  12,FF3
000AA:  MOVFF  13,FF4
000AE:  MOVFF  14,FFA
000B2:  MOVFF  15,FF5
000B6:  MOVFF  16,FF6
000BA:  MOVFF  17,FF7
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
000CA:  MOVWF  1A
000CC:  MOVFF  FD8,1B
000D0:  MOVFF  FE0,1C
000D4:  MOVLB  0
000D6:  MOVFF  FE9,22
000DA:  MOVFF  FEA,1D
000DE:  MOVFF  FE1,1E
000E2:  MOVFF  FE2,1F
000E6:  MOVFF  FD9,20
000EA:  MOVFF  FDA,21
000EE:  MOVFF  FF3,28
000F2:  MOVFF  FF4,29
000F6:  MOVFF  FFA,2A
000FA:  MOVFF  FF5,2B
000FE:  MOVFF  FF6,2C
00102:  MOVFF  FF7,2D
00106:  MOVFF  00,24
0010A:  MOVFF  01,25
0010E:  MOVFF  02,26
00112:  MOVFF  03,27
00116:  BTFSS  F9D.1
00118:  GOTO   0122
0011C:  BTFSC  F9E.1
0011E:  GOTO   0480
00122:  MOVFF  24,00
00126:  MOVFF  25,01
0012A:  MOVFF  26,02
0012E:  MOVFF  27,03
00132:  MOVFF  22,FE9
00136:  MOVFF  1D,FEA
0013A:  BSF    1D.7
0013C:  MOVFF  1E,FE1
00140:  MOVFF  1F,FE2
00144:  MOVFF  20,FD9
00148:  MOVFF  21,FDA
0014C:  MOVFF  28,FF3
00150:  MOVFF  29,FF4
00154:  MOVFF  2A,FFA
00158:  MOVFF  2B,FF5
0015C:  MOVFF  2C,FF6
00160:  MOVFF  2D,FF7
00164:  MOVF   1A,W
00166:  MOVFF  1C,FE0
0016A:  MOVFF  1B,FD8
0016E:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
00A28:  MOVLW  02
00A2A:  MOVWF  FEA
00A2C:  MOVLW  C6
00A2E:  MOVWF  FE9
00A30:  MOVF   FEF,W
00A32:  BZ    0A54
00A34:  MOVLW  03
00A36:  MOVWF  01
00A38:  MOVLW  BF
00A3A:  MOVWF  00
00A3C:  CLRWDT
00A3E:  DECFSZ 00,F
00A40:  BRA    0A3C
00A42:  DECFSZ 01,F
00A44:  BRA    0A38
00A46:  MOVLW  E3
00A48:  MOVWF  00
00A4A:  DECFSZ 00,F
00A4C:  BRA    0A4A
00A4E:  CLRWDT
00A50:  DECFSZ FEF,F
00A52:  BRA    0A34
00A54:  GOTO   2156 (RETURN)
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=WEATHER_X_BAUD,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
006BC:  BTFSS  F9E.5
006BE:  BRA    06BC
006C0:  MOVFF  FAB,35
006C4:  MOVFF  FAE,01
006C8:  BTFSS  35.1
006CA:  BRA    06D0
006CC:  BCF    FAB.4
006CE:  BSF    FAB.4
006D0:  RETURN 0
*
0118E:  BTFSS  F9E.4
01190:  BRA    118E
01192:  MOVWF  FAD
01194:  GOTO   11A0 (RETURN)
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=DEBUG, baud=9600,errors)	 
*
006D2:  BTFSS  FA4.4
006D4:  BRA    06D2
006D6:  MOVWF  F73
006D8:  RETURN 0
*
00D5E:  BTFSS  FA4.5
00D60:  BRA    0D5E
00D62:  MOVFF  F71,35
00D66:  MOVFF  F74,01
00D6A:  BTFSS  35.1
00D6C:  BRA    0D72
00D6E:  BCF    F71.4
00D70:  BSF    F71.4
00D72:  GOTO   227C (RETURN)
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
....................  
.................... #if 0 
.................... /* analog channels */ 
.................... #define AN_USER_USER_0 1 
.................... #define AN_USER_USER_1 2 
.................... #define AN_USER_USER_2 4 
.................... #define AN_USER_USER_3 5 
....................  
.................... #define AN_TEMPERATURE 0 /* not connected */ 
.................... #define AN_IN_VOLTS    0 
.................... #define AN_WIND_DIR_0  6 
.................... #define AN_WIND_DIR_1  7 
.................... #endif 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
.................... } struct_time_keep; 
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00E6C:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00DCC:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00DCE:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00DD0:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00DD2:  MOVLB  2
00DD4:  MOVF   xC9,F
00DD6:  BNZ   0DDE
.................... 		c=0b00011; 
00DD8:  MOVLW  03
00DDA:  MOVWF  xCD
.................... 	else if ( 1 == ch )  
00DDC:  BRA    0E28
00DDE:  DECFSZ xC9,W
00DE0:  BRA    0DE8
.................... 		c=0b10011; 
00DE2:  MOVLW  13
00DE4:  MOVWF  xCD
.................... 	else if ( 2 == ch )  
00DE6:  BRA    0E28
00DE8:  MOVF   xC9,W
00DEA:  SUBLW  02
00DEC:  BNZ   0DF4
.................... 		c=0b01011; 
00DEE:  MOVLW  0B
00DF0:  MOVWF  xCD
.................... 	else if ( 3 == ch )  
00DF2:  BRA    0E28
00DF4:  MOVF   xC9,W
00DF6:  SUBLW  03
00DF8:  BNZ   0E00
.................... 		c=0b11011; 
00DFA:  MOVLW  1B
00DFC:  MOVWF  xCD
.................... 	else if ( 4 == ch ) 
00DFE:  BRA    0E28
00E00:  MOVF   xC9,W
00E02:  SUBLW  04
00E04:  BNZ   0E0C
.................... 		c=0b00111; 
00E06:  MOVLW  07
00E08:  MOVWF  xCD
.................... 	else if ( 5 == ch )  
00E0A:  BRA    0E28
00E0C:  MOVF   xC9,W
00E0E:  SUBLW  05
00E10:  BNZ   0E18
.................... 		c=0b10111; 
00E12:  MOVLW  17
00E14:  MOVWF  xCD
.................... 	else if ( 6 == ch ) 
00E16:  BRA    0E28
00E18:  MOVF   xC9,W
00E1A:  SUBLW  06
00E1C:  BNZ   0E24
.................... 		c=0b01111; 
00E1E:  MOVLW  0F
00E20:  MOVWF  xCD
.................... 	else 
00E22:  BRA    0E28
.................... 		c=0b11111; 
00E24:  MOVLW  1F
00E26:  MOVWF  xCD
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00E28:  CLRF   xCC
00E2A:  MOVF   xCC,W
00E2C:  SUBLW  04
00E2E:  BNC   0E46
.................... 		output_low(MCP3208_CLK); 
00E30:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00E32:  BTFSC  xCD.0
00E34:  BRA    0E3A
00E36:  BCF    F8B.5
00E38:  BRA    0E3C
00E3A:  BSF    F8B.5
.................... 		c=c>>1; 
00E3C:  BCF    FD8.0
00E3E:  RRCF   xCD,F
.................... 		output_high(MCP3208_CLK); 
00E40:  BSF    F8B.3
.................... 	} 
00E42:  INCF   xCC,F
00E44:  BRA    0E2A
....................  
....................  
.................... 	value=0; 
00E46:  CLRF   xCB
00E48:  CLRF   xCA
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00E4A:  CLRF   xCC
00E4C:  MOVF   xCC,W
00E4E:  SUBLW  0D
00E50:  BNC   0E68
.................... 		output_low(MCP3208_CLK); 
00E52:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00E54:  BTFSC  F82.4
00E56:  BRA    0E5C
00E58:  BCF    FD8.0
00E5A:  BRA    0E5E
00E5C:  BSF    FD8.0
00E5E:  RLCF   xCA,F
00E60:  RLCF   xCB,F
.................... 		output_high(MCP3208_CLK); 
00E62:  BSF    F8B.3
.................... 	} 
00E64:  INCF   xCC,F
00E66:  BRA    0E4C
....................  
.................... 	bit_clear(value,13); 
00E68:  BCF    xCB.5
.................... 	bit_clear(value,12); 
00E6A:  BCF    xCB.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00E6E:  MOVFF  2CA,01
00E72:  MOVFF  2CB,02
.................... } 
00E76:  MOVLB  0
00E78:  GOTO   0EE8 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00F22:  MOVLB  2
00F24:  CLRF   xE1
00F26:  MOVFF  2DA,2E0
00F2A:  CLRF   xE3
00F2C:  MOVLW  20
00F2E:  MOVWF  xE2
00F30:  MOVLB  0
00F32:  RCALL  08CC
00F34:  MOVFF  02,03
00F38:  MOVF   01,W
00F3A:  ADDLW  81
00F3C:  MOVWF  01
00F3E:  MOVLW  00
00F40:  ADDWFC 03,F
00F42:  MOVFF  01,2DE
00F46:  MOVLB  2
00F48:  MOVFF  03,2DF
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00F4C:  CLRF   xDC
00F4E:  CLRF   xDB
.................... 	for( i = 0; i < 16 ; i++ ) { 
00F50:  CLRF   xDD
00F52:  MOVF   xDD,W
00F54:  SUBLW  0F
00F56:  BNC   0F7A
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00F58:  BCF    FD8.0
00F5A:  RLCF   xDD,W
00F5C:  CLRF   03
00F5E:  ADDWF  xDE,W
00F60:  MOVWF  FE9
00F62:  MOVF   xDF,W
00F64:  ADDWFC 03,W
00F66:  MOVWF  FEA
00F68:  MOVFF  FEC,03
00F6C:  MOVF   FED,F
00F6E:  MOVF   FEF,W
00F70:  ADDWF  xDB,F
00F72:  MOVF   03,W
00F74:  ADDWFC xDC,F
.................... 	} 
00F76:  INCF   xDD,F
00F78:  BRA    0F52
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00F7A:  MOVLW  08
00F7C:  ADDWF  xDB,W
00F7E:  MOVWF  xE0
00F80:  MOVLW  00
00F82:  ADDWFC xDC,W
00F84:  MOVWF  xE1
00F86:  RRCF   xE1,W
00F88:  MOVWF  03
00F8A:  RRCF   xE0,W
00F8C:  MOVWF  02
00F8E:  RRCF   03,F
00F90:  RRCF   02,F
00F92:  RRCF   03,F
00F94:  RRCF   02,F
00F96:  RRCF   03,F
00F98:  RRCF   02,F
00F9A:  MOVLW  0F
00F9C:  ANDWF  03,F
00F9E:  MOVFF  02,01
00FA2:  MOVFF  03,02
.................... } 
00FA6:  MOVLB  0
00FA8:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00E7C:  MOVLB  1
00E7E:  INCF   x81,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00E80:  MOVF   x81,W
00E82:  SUBLW  0F
00E84:  BC    0E88
.................... 		current.adc_buffer_index=0; 
00E86:  CLRF   x81
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00E88:  MOVLB  2
00E8A:  CLRF   xC6
00E8C:  MOVF   xC6,W
00E8E:  SUBLW  07
00E90:  BNC   0F1E
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00E92:  CLRF   xE1
00E94:  MOVFF  2C6,2E0
00E98:  CLRF   xE3
00E9A:  MOVLW  20
00E9C:  MOVWF  xE2
00E9E:  MOVLB  0
00EA0:  RCALL  08CC
00EA2:  MOVFF  02,03
00EA6:  MOVF   01,W
00EA8:  ADDLW  34
00EAA:  MOVLB  2
00EAC:  MOVWF  xC7
00EAE:  MOVLW  00
00EB0:  ADDWFC 02,W
00EB2:  MOVWF  xC8
00EB4:  CLRF   03
00EB6:  MOVLB  1
00EB8:  MOVFF  181,02
00EBC:  BCF    FD8.0
00EBE:  RLCF   02,F
00EC0:  RLCF   03,F
00EC2:  MOVF   02,W
00EC4:  MOVLB  2
00EC6:  ADDWF  xC7,W
00EC8:  MOVWF  01
00ECA:  MOVF   xC8,W
00ECC:  ADDWFC 03,F
00ECE:  MOVF   01,W
00ED0:  ADDLW  4D
00ED2:  MOVWF  01
00ED4:  MOVLW  00
00ED6:  ADDWFC 03,F
00ED8:  MOVFF  01,2C7
00EDC:  MOVFF  03,2C8
00EE0:  MOVFF  2C6,2C9
00EE4:  MOVLB  0
00EE6:  BRA    0DCC
00EE8:  MOVFF  2C8,FEA
00EEC:  MOVFF  2C7,FE9
00EF0:  MOVFF  02,FEC
00EF4:  MOVF   FED,F
00EF6:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00EFA:  CLRF   03
00EFC:  MOVLB  2
00EFE:  MOVFF  2C6,02
00F02:  BCF    FD8.0
00F04:  RLCF   02,F
00F06:  RLCF   03,F
00F08:  MOVF   02,W
00F0A:  ADDLW  71
00F0C:  MOVWF  FE9
00F0E:  MOVLW  00
00F10:  ADDWFC 03,W
00F12:  MOVWF  FEA
00F14:  CLRF   FEC
00F16:  MOVF   FED,F
00F18:  CLRF   FEF
....................  
.................... 	} 
00F1A:  INCF   xC6,F
00F1C:  BRA    0E8C
.................... } 
00F1E:  MOVLB  0
00F20:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00BC4:  MOVF   xE1,W
00BC6:  XORWF  xE2,W
00BC8:  MOVWF  01
*
00C16:  MOVF   xE1,W
00C18:  XORWF  xE2,W
00C1A:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00B4E:  MOVLB  2
00B50:  CLRF   xCF
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B52:  MOVFF  2CE,03
00B56:  MOVF   xCD,W
00B58:  BTFSC  FD8.2
00B5A:  DECF   xCE,F
00B5C:  DECF   xCD,F
00B5E:  MOVWF  xD0
00B60:  MOVFF  03,2D1
00B64:  MOVF   xD0,F
00B66:  BNZ   0B6C
00B68:  MOVF   xD1,F
00B6A:  BZ    0BD6
.................... 		*data = read_eeprom( address++ ); 
00B6C:  MOVFF  2CC,03
00B70:  MOVF   xCB,W
00B72:  MOVWF  FE9
00B74:  MOVFF  03,FEA
00B78:  MOVF   xCA,W
00B7A:  MOVWF  03
00B7C:  MOVF   xC9,W
00B7E:  INCF   xC9,F
00B80:  BTFSC  FD8.2
00B82:  INCF   xCA,F
00B84:  MOVWF  xD2
00B86:  MOVFF  03,2D3
00B8A:  MOVFF  FF2,2D4
00B8E:  BCF    FF2.6
00B90:  BCF    FF2.7
00B92:  MOVFF  2D3,FAA
00B96:  MOVFF  2D2,FA9
00B9A:  BCF    FA6.6
00B9C:  BCF    FA6.7
00B9E:  BSF    FA6.0
00BA0:  MOVF   FA8,W
00BA2:  BTFSC  xD4.6
00BA4:  BSF    FF2.6
00BA6:  BTFSC  xD4.7
00BA8:  BSF    FF2.7
00BAA:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00BAC:  MOVFF  2CC,03
00BB0:  MOVF   xCB,W
00BB2:  MOVWF  FE9
00BB4:  MOVFF  03,FEA
00BB8:  MOVFF  FEF,2D0
00BBC:  MOVFF  2CF,2E1
00BC0:  MOVFF  2D0,2E2
*
00BCA:  MOVFF  01,2CF
.................... 		data++; 
00BCE:  INCF   xCB,F
00BD0:  BTFSC  FD8.2
00BD2:  INCF   xCC,F
.................... 	} 
00BD4:  BRA    0B52
.................... 	return crc; 
00BD6:  MOVFF  2CF,01
.................... } 
00BDA:  MOVLB  0
00BDC:  GOTO   0D2C (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00BE0:  MOVLB  2
00BE2:  CLRF   xDF
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BE4:  MOVFF  2DE,03
00BE8:  MOVF   xDD,W
00BEA:  BTFSC  FD8.2
00BEC:  DECF   xDE,F
00BEE:  DECF   xDD,F
00BF0:  MOVWF  xE0
00BF2:  MOVFF  03,2E1
00BF6:  MOVF   xE0,F
00BF8:  BNZ   0BFE
00BFA:  MOVF   xE1,F
00BFC:  BZ    0C7C
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00BFE:  MOVFF  2DC,03
00C02:  MOVF   xDB,W
00C04:  MOVWF  FE9
00C06:  MOVFF  03,FEA
00C0A:  MOVFF  FEF,2E0
00C0E:  MOVFF  2DF,2E1
00C12:  MOVFF  2E0,2E2
*
00C1C:  MOVFF  01,2DF
.................... 		write_eeprom( address++, *data++ ); 
00C20:  MOVF   xDA,W
00C22:  MOVWF  03
00C24:  MOVF   xD9,W
00C26:  INCF   xD9,F
00C28:  BTFSC  FD8.2
00C2A:  INCF   xDA,F
00C2C:  MOVWF  xE0
00C2E:  MOVFF  03,2E1
00C32:  MOVF   xDC,W
00C34:  MOVWF  03
00C36:  MOVF   xDB,W
00C38:  INCF   xDB,F
00C3A:  BTFSC  FD8.2
00C3C:  INCF   xDC,F
00C3E:  MOVWF  FE9
00C40:  MOVFF  03,FEA
00C44:  MOVFF  FEF,2E2
00C48:  MOVFF  2E1,FAA
00C4C:  MOVFF  2E0,FA9
00C50:  MOVFF  2E2,FA8
00C54:  BCF    FA6.6
00C56:  BCF    FA6.7
00C58:  BSF    FA6.2
00C5A:  MOVF   FF2,W
00C5C:  MOVWF  00
00C5E:  BCF    FF2.6
00C60:  BCF    FF2.7
00C62:  MOVLB  F
00C64:  MOVLW  55
00C66:  MOVWF  FA7
00C68:  MOVLW  AA
00C6A:  MOVWF  FA7
00C6C:  BSF    FA6.1
00C6E:  BTFSC  FA6.1
00C70:  BRA    0C6E
00C72:  BCF    FA6.2
00C74:  MOVF   00,W
00C76:  IORWF  FF2,F
.................... 	} 
00C78:  MOVLB  2
00C7A:  BRA    0BE4
....................  
.................... 	return crc; 
00C7C:  MOVFF  2DF,01
.................... } 
00C80:  MOVLB  0
00C82:  GOTO   0CA6 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00C86:  MOVLB  2
00C88:  CLRF   xD8
00C8A:  MOVLW  36
00C8C:  MOVWF  xD7
00C8E:  CLRF   xDA
00C90:  MOVLW  02
00C92:  MOVWF  xD9
00C94:  MOVFF  2D8,2DC
00C98:  MOVFF  2D7,2DB
00C9C:  CLRF   xDE
00C9E:  MOVLW  17
00CA0:  MOVWF  xDD
00CA2:  MOVLB  0
00CA4:  BRA    0BE0
00CA6:  MOVFF  01,2D6
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00CAA:  CLRF   FAA
00CAC:  CLRF   FA9
00CAE:  MOVFF  2D6,FA8
00CB2:  BCF    FA6.6
00CB4:  BCF    FA6.7
00CB6:  BSF    FA6.2
00CB8:  MOVF   FF2,W
00CBA:  MOVWF  00
00CBC:  BCF    FF2.6
00CBE:  BCF    FF2.7
00CC0:  MOVLB  F
00CC2:  MOVLW  55
00CC4:  MOVWF  FA7
00CC6:  MOVLW  AA
00CC8:  MOVWF  FA7
00CCA:  BSF    FA6.1
00CCC:  BTFSC  FA6.1
00CCE:  BRA    0CCC
00CD0:  BCF    FA6.2
00CD2:  MOVF   00,W
00CD4:  IORWF  FF2,F
.................... } 
00CD6:  MOVLB  0
00CD8:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00CDA:  MOVLW  96
00CDC:  MOVLB  1
00CDE:  MOVWF  xAA
....................  
.................... //	config.modbus_address=38; 
.................... 	config.modbus_address=255; /* use any address */ 
00CE0:  SETF   36
....................  
.................... 	config.serial_prefix='P'; 
00CE2:  MOVLW  50
00CE4:  MOVWF  38
.................... 	config.serial_number=9876; 
00CE6:  MOVLW  26
00CE8:  MOVWF  3A
00CEA:  MOVLW  94
00CEC:  MOVWF  39
....................  
.................... 	config.adc_sample_ticks=20; 
00CEE:  CLRF   3C
00CF0:  MOVLW  14
00CF2:  MOVWF  3B
.................... 	config.allow_bootload_request=0; 
00CF4:  CLRF   3D
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00CF6:  MOVLW  02
00CF8:  MOVWF  3F
00CFA:  MOVLW  76
00CFC:  MOVWF  3E
.................... 	config.pi_offtime_seconds=2; 
00CFE:  CLRF   41
00D00:  MOVLW  02
00D02:  MOVWF  40
.................... 	config.power_startup=0; 
00D04:  CLRF   42
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00D06:  MOVLB  0
00D08:  RCALL  0C86
....................  
.................... } 
00D0A:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00D0C:  MOVLB  2
00D0E:  CLRF   xC8
00D10:  MOVLW  36
00D12:  MOVWF  xC7
00D14:  CLRF   xCA
00D16:  MOVLW  02
00D18:  MOVWF  xC9
00D1A:  MOVFF  2C8,2CC
00D1E:  MOVFF  2C7,2CB
00D22:  CLRF   xCE
00D24:  MOVLW  17
00D26:  MOVWF  xCD
00D28:  MOVLB  0
00D2A:  BRA    0B4E
00D2C:  MOVFF  01,2C6
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00D30:  MOVFF  FF2,2C7
00D34:  BCF    FF2.6
00D36:  BCF    FF2.7
00D38:  CLRF   FAA
00D3A:  CLRF   FA9
00D3C:  BCF    FA6.6
00D3E:  BCF    FA6.7
00D40:  BSF    FA6.0
00D42:  MOVF   FA8,W
00D44:  MOVLB  2
00D46:  BTFSC  xC7.6
00D48:  BSF    FF2.6
00D4A:  BTFSC  xC7.7
00D4C:  BSF    FF2.7
00D4E:  SUBWF  xC6,W
00D50:  BZ    0D58
.................... 		write_default_param_file(); 
00D52:  MOVLB  0
00D54:  RCALL  0CDA
00D56:  MOVLB  2
.................... 	} 
.................... } 
00D58:  MOVLB  0
00D5A:  GOTO   2260 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
011F2:  BTFSS  FAC.1
011F4:  BRA    11F2
.................... } 
011F6:  GOTO   1210 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(MODBUS_SERIAL) ) { 
*
00D76:  BTFSS  F9E.5
00D78:  BRA    0D92
.................... 		fprintf(DEBUG,"# reading starting ..."); 
00D7A:  MOVLW  90
00D7C:  MOVWF  FF6
00D7E:  MOVLW  03
00D80:  MOVWF  FF7
00D82:  RCALL  0A82
.................... 		fgetc(MODBUS_SERIAL); 
00D84:  RCALL  06BC
.................... 		fprintf(DEBUG," complete"); 
00D86:  MOVLW  A8
00D88:  MOVWF  FF6
00D8A:  MOVLW  03
00D8C:  MOVWF  FF7
00D8E:  RCALL  0A82
.................... 	} 
00D90:  BRA    0D76
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00D92:  BSF    F9D.5
.................... } 
00D94:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... //	fprintf(DEBUG,"# rcv_on() starting ...\r\n"); 
.................... 	RCV_ON(); 
00D96:  RCALL  0D76
.................... //	fprintf(DEBUG,"# rcv_on() complete\r\n"); 
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	fprintf(DEBUG,"# setup_timer_0 starting ...\r\n"); 
00D98:  MOVLW  B2
00D9A:  MOVWF  FF6
00D9C:  MOVLW  03
00D9E:  MOVWF  FF7
00DA0:  RCALL  0A82
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00DA2:  MOVLW  C6
00DA4:  MOVWF  FD5
.................... 	fprintf(DEBUG,"# setup_timer_0 complete\r\n"); 
00DA6:  MOVLW  D2
00DA8:  MOVWF  FF6
00DAA:  MOVLW  03
00DAC:  MOVWF  FF7
00DAE:  RCALL  0A82
....................  
.................... 	fprintf(DEBUG,"# enable_interrupts(GLOBAL) starting ...\r\n"); 
00DB0:  MOVLW  EE
00DB2:  MOVWF  FF6
00DB4:  MOVLW  03
00DB6:  MOVWF  FF7
00DB8:  RCALL  0A82
.................... 	enable_interrupts(GLOBAL); 
00DBA:  MOVLW  C0
00DBC:  IORWF  FF2,F
.................... 	fprintf(DEBUG,"# enable interrupts complete\r\n"); 
00DBE:  MOVLW  1A
00DC0:  MOVWF  FF6
00DC2:  MOVLW  04
00DC4:  MOVWF  FF7
00DC6:  RCALL  0A82
.................... } 
00DC8:  GOTO   22D4 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0043A:  BCF    FF2.5
.................... 	if (enable) { 
0043C:  MOVLB  2
0043E:  MOVF   xE6,F
00440:  BZ    044A
.................... 		set_timer0(0); 
00442:  CLRF   FD7
00444:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00446:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00448:  BSF    FF2.5
.................... 	} 
.................... } 
0044A:  MOVLB  0
0044C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0044E:  MOVLB  1
00450:  MOVF   xB1,W
00452:  SUBLW  02
00454:  BNZ   046A
00456:  MOVF   xB2,F
00458:  BNZ   046A
0045A:  MOVF   xB3,F
0045C:  BNZ   046A
0045E:  BTFSC  xB0.0
00460:  BRA    046A
....................    { 
....................       modbus_rx.len-=2; 
00462:  MOVLW  02
00464:  SUBWF  xB5,F
....................       modbus_serial_new=TRUE; 
00466:  BSF    xB0.0
....................    } 
....................    else 
00468:  BRA    046C
....................       modbus_serial_new=FALSE; 
0046A:  BCF    xB0.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0046C:  SETF   xB3
0046E:  SETF   xB2
....................    modbus_serial_state=MODBUS_GETADDY; 
00470:  CLRF   xB1
....................    modbus_enable_timeout(FALSE); 
00472:  MOVLB  2
00474:  CLRF   xE6
00476:  MOVLB  0
00478:  RCALL  043A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0047A:  BCF    FF2.2
0047C:  GOTO   007C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
006DA:  MOVLB  1
006DC:  MOVF   xB3,W
006DE:  MOVLB  2
006E0:  XORWF  xE6,W
006E2:  MOVWF  xE7
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
006E4:  CLRF   03
006E6:  MOVF   xE7,W
006E8:  MOVLB  0
006EA:  RCALL  0170
006EC:  MOVWF  01
006EE:  MOVLB  1
006F0:  MOVF   xB2,W
006F2:  XORWF  01,W
006F4:  MOVWF  xB3
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006F6:  CLRF   03
006F8:  MOVLB  2
006FA:  MOVF   xE7,W
006FC:  MOVLB  0
006FE:  RCALL  0280
00700:  MOVFF  FE8,1B2
.................... } 
00704:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, MODBUS_SERIAL); 
*
01198:  MOVLB  2
0119A:  MOVF   xD8,W
0119C:  MOVLB  0
0119E:  BRA    118E
011A0:  CLRF   19
011A2:  BTFSC  FF2.6
011A4:  BSF    19.6
011A6:  BCF    FF2.6
011A8:  BTFSC  FF2.7
011AA:  BSF    19.7
011AC:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
011AE:  MOVFF  2D8,2E6
011B2:  CALL   06DA
011B6:  BTFSC  19.6
011B8:  BSF    FF2.6
011BA:  BTFSC  19.7
011BC:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
011BE:  CLRWDT
011C0:  MOVLW  08
011C2:  MOVWF  00
011C4:  DECFSZ 00,F
011C6:  BRA    11C4
011C8:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
011CA:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
011CC:  MOVLB  1
011CE:  SETF   xB3
011D0:  SETF   xB2
....................    modbus_serial_new=FALSE; 
011D2:  BCF    xB0.0
....................  
....................    RCV_OFF(); 
011D4:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
011D6:  CLRWDT
011D8:  MOVLW  1E
011DA:  MOVWF  00
011DC:  DECFSZ 00,F
011DE:  BRA    11DC
011E0:  NOP   
....................  
....................    modbus_serial_putc(to); 
011E2:  MOVFF  2D6,2D8
011E6:  MOVLB  0
011E8:  RCALL  1198
....................    modbus_serial_putc(func); 
011EA:  MOVFF  2D7,2D8
011EE:  RCALL  1198
.................... } 
011F0:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
011FA:  MOVFF  1B3,2D7
....................    crc_low=modbus_serial_crc.b[0]; 
011FE:  MOVFF  1B2,2D6
....................  
....................    modbus_serial_putc(crc_high); 
01202:  MOVFF  2D7,2D8
01206:  RCALL  1198
....................    modbus_serial_putc(crc_low); 
01208:  MOVFF  2D6,2D8
0120C:  RCALL  1198
....................  
....................    WAIT_FOR_HW_BUFFER(); 
0120E:  BRA    11F2
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
01210:  CLRWDT
01212:  MOVLW  1E
01214:  MOVWF  00
01216:  DECFSZ 00,F
01218:  BRA    1216
0121A:  NOP   
....................  
....................  
....................    RCV_ON(); 
0121C:  RCALL  0D76
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0121E:  MOVLB  1
01220:  SETF   xB3
01222:  SETF   xB2
.................... } 
01224:  MOVLB  0
01226:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
0110A:  MOVLB  1
0110C:  BTFSC  xB0.0
0110E:  BRA    1118
....................       return FALSE; 
01110:  MOVLW  00
01112:  MOVWF  01
01114:  BRA    112A
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
01116:  BRA    1124
01118:  BTFSS  xB6.7
0111A:  BRA    1124
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0111C:  MOVFF  1B8,1B7
....................       modbus_rx.len = 1; 
01120:  MOVLW  01
01122:  MOVWF  xB5
....................    } 
....................    modbus_serial_new=FALSE; 
01124:  BCF    xB0.0
....................    return TRUE; 
01126:  MOVLW  01
01128:  MOVWF  01
.................... } 
0112A:  MOVLB  0
0112C:  GOTO   1E74 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01DE0:  MOVFF  2CE,2D6
01DE4:  MOVLW  06
01DE6:  MOVLB  2
01DE8:  MOVWF  xD7
01DEA:  MOVLB  0
01DEC:  CALL   11CC
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01DF0:  MOVFF  2D0,2D3
01DF4:  MOVFF  2D0,2D8
01DF8:  CALL   1198
....................    modbus_serial_putc(make8(reg_address,0)); 
01DFC:  MOVFF  2CF,2D3
01E00:  MOVFF  2CF,2D8
01E04:  CALL   1198
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01E08:  MOVFF  2D2,2D3
01E0C:  MOVFF  2D2,2D8
01E10:  CALL   1198
....................    modbus_serial_putc(make8(reg_value,0)); 
01E14:  MOVFF  2D1,2D3
01E18:  MOVFF  2D1,2D8
01E1C:  CALL   1198
....................  
....................    modbus_serial_send_stop(); 
01E20:  CALL   11FA
.................... } 
01E24:  GOTO   1FA0 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01E28:  MOVFF  2CC,2D6
01E2C:  MOVLW  10
01E2E:  MOVLB  2
01E30:  MOVWF  xD7
01E32:  MOVLB  0
01E34:  CALL   11CC
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01E38:  MOVFF  2CE,2D1
01E3C:  MOVFF  2CE,2D8
01E40:  CALL   1198
....................    modbus_serial_putc(make8(start_address,0)); 
01E44:  MOVFF  2CD,2D1
01E48:  MOVFF  2CD,2D8
01E4C:  CALL   1198
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01E50:  MOVFF  2D0,2D1
01E54:  MOVFF  2D0,2D8
01E58:  CALL   1198
....................    modbus_serial_putc(make8(quantity,0)); 
01E5C:  MOVFF  2CF,2D1
01E60:  MOVFF  2CF,2D8
01E64:  CALL   1198
....................  
....................    modbus_serial_send_stop(); 
01E68:  CALL   11FA
.................... } 
01E6C:  GOTO   2062 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01228:  MOVLB  2
0122A:  MOVF   xCD,W
0122C:  IORLW  80
0122E:  MOVWF  xD0
01230:  MOVFF  2CE,2D1
01234:  MOVFF  2CC,2D6
01238:  MOVWF  xD7
0123A:  MOVLB  0
0123C:  RCALL  11CC
....................    modbus_serial_putc(error); 
0123E:  MOVFF  2CF,2D8
01242:  RCALL  1198
....................    modbus_serial_send_stop(); 
01244:  RCALL  11FA
.................... } 
01246:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1011 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
0130E:  MOVLB  1
01310:  CLRF   x83
01312:  CLRF   x82
.................... 	current.modbus_other_packets=0; 
01314:  CLRF   x85
01316:  CLRF   x84
.................... 	current.modbus_last_error=0; 
01318:  CLRF   x87
0131A:  CLRF   x86
.................... } 
0131C:  MOVLB  0
0131E:  GOTO   1AF6 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
012AA:  BCF    FF2.6
012AC:  BCF    FF2.7
012AE:  BTFSC  FF2.7
012B0:  BRA    12AC
....................  
.................... 	current.pulse_count[0]=0; 
012B2:  CLRF   x60
012B4:  CLRF   5F
.................... 	current.pulse_count[1]=0; 
012B6:  CLRF   x62
012B8:  CLRF   x61
.................... 	current.pulse_count[2]=0; 
012BA:  CLRF   x64
012BC:  CLRF   x63
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
012BE:  SETF   54
012C0:  SETF   53
.................... 	current.pulse_min_period[1]=65535; 
012C2:  SETF   56
012C4:  SETF   55
.................... 	current.pulse_min_period[2]=65535; 
012C6:  SETF   58
012C8:  SETF   57
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
012CA:  CLRF   5A
012CC:  CLRF   59
.................... 	current.pulse_max_period[1]=0; 
012CE:  CLRF   5C
012D0:  CLRF   5B
.................... 	current.pulse_max_period[2]=0; 
012D2:  CLRF   5E
012D4:  CLRF   5D
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
012D6:  MOVLB  1
012D8:  CLRF   x8D
012DA:  CLRF   x8C
....................  
.................... 	enable_interrupts(GLOBAL); 
012DC:  MOVLW  C0
012DE:  IORWF  FF2,F
.................... } 
012E0:  MOVLB  0
012E2:  GOTO   1ABE (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
012E6:  BCF    FF2.6
012E8:  BCF    FF2.7
012EA:  BTFSC  FF2.7
012EC:  BRA    12E8
.................... 	current.pulse_sum[0]=0; 
012EE:  CLRF   x68
012F0:  CLRF   x67
012F2:  CLRF   x66
012F4:  CLRF   x65
.................... 	current.pulse_sum[1]=0; 
012F6:  CLRF   x6C
012F8:  CLRF   x6B
012FA:  CLRF   x6A
012FC:  CLRF   x69
.................... 	current.pulse_sum[2]=0; 
012FE:  CLRF   x70
01300:  CLRF   x6F
01302:  CLRF   x6E
01304:  CLRF   x6D
.................... 	enable_interrupts(GLOBAL); 
01306:  MOVLW  C0
01308:  IORWF  FF2,F
.................... } 
0130A:  GOTO   1AC8 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01248:  BCF    FF2.6
0124A:  BCF    FF2.7
0124C:  BTFSC  FF2.7
0124E:  BRA    124A
.................... 	l=current.pulse_sum[ch]; 
01250:  MOVLB  2
01252:  CLRF   xE1
01254:  MOVFF  2DA,2E0
01258:  CLRF   xE3
0125A:  MOVLW  04
0125C:  MOVWF  xE2
0125E:  MOVLB  0
01260:  CALL   08CC
01264:  MOVFF  02,03
01268:  MOVF   01,W
0126A:  ADDLW  65
0126C:  MOVWF  FE9
0126E:  MOVLW  00
01270:  ADDWFC 02,W
01272:  MOVWF  FEA
01274:  MOVFF  FEF,00
01278:  MOVFF  FEC,01
0127C:  MOVFF  FEC,02
01280:  MOVFF  FEC,03
01284:  MOVFF  03,2DE
01288:  MOVFF  02,2DD
0128C:  MOVFF  01,2DC
01290:  MOVFF  00,2DB
.................... 	enable_interrupts(GLOBAL); 
01294:  MOVLW  C0
01296:  IORWF  FF2,F
....................  
.................... 	return l; 
01298:  MOVFF  2DB,00
0129C:  MOVFF  2DC,01
012A0:  MOVFF  2DD,02
012A4:  MOVFF  2DE,03
.................... } 
012A8:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
....................  
.................... 	switch ( addr ) { 
*
01322:  MOVLB  2
01324:  MOVF   xD8,W
01326:  MOVWF  00
01328:  MOVF   xD9,W
0132A:  MOVWF  03
0132C:  MOVF   03,W
0132E:  BNZ   133A
01330:  MOVF   00,F
01332:  MOVLB  0
01334:  BTFSC  FD8.2
01336:  BRA    1744
01338:  MOVLB  2
0133A:  MOVF   03,W
0133C:  BNZ   134A
0133E:  MOVLW  01
01340:  SUBWF  00,W
01342:  MOVLB  0
01344:  BTFSC  FD8.2
01346:  BRA    174E
01348:  MOVLB  2
0134A:  MOVF   03,W
0134C:  BNZ   135A
0134E:  MOVLW  02
01350:  SUBWF  00,W
01352:  MOVLB  0
01354:  BTFSC  FD8.2
01356:  BRA    1758
01358:  MOVLB  2
0135A:  MOVF   03,W
0135C:  BNZ   136A
0135E:  MOVLW  03
01360:  SUBWF  00,W
01362:  MOVLB  0
01364:  BTFSC  FD8.2
01366:  BRA    1762
01368:  MOVLB  2
0136A:  MOVF   03,W
0136C:  BNZ   137A
0136E:  MOVLW  04
01370:  SUBWF  00,W
01372:  MOVLB  0
01374:  BTFSC  FD8.2
01376:  BRA    176C
01378:  MOVLB  2
0137A:  MOVF   03,W
0137C:  BNZ   138A
0137E:  MOVLW  05
01380:  SUBWF  00,W
01382:  MOVLB  0
01384:  BTFSC  FD8.2
01386:  BRA    1790
01388:  MOVLB  2
0138A:  MOVF   03,W
0138C:  BNZ   139A
0138E:  MOVLW  06
01390:  SUBWF  00,W
01392:  MOVLB  0
01394:  BTFSC  FD8.2
01396:  BRA    179C
01398:  MOVLB  2
0139A:  MOVF   03,W
0139C:  BNZ   13AA
0139E:  MOVLW  07
013A0:  SUBWF  00,W
013A2:  MOVLB  0
013A4:  BTFSC  FD8.2
013A6:  BRA    17A6
013A8:  MOVLB  2
013AA:  MOVF   03,W
013AC:  BNZ   13BA
013AE:  MOVLW  08
013B0:  SUBWF  00,W
013B2:  MOVLB  0
013B4:  BTFSC  FD8.2
013B6:  BRA    17B0
013B8:  MOVLB  2
013BA:  MOVF   03,W
013BC:  BNZ   13CA
013BE:  MOVLW  09
013C0:  SUBWF  00,W
013C2:  MOVLB  0
013C4:  BTFSC  FD8.2
013C6:  BRA    17BA
013C8:  MOVLB  2
013CA:  MOVF   03,W
013CC:  BNZ   13DA
013CE:  MOVLW  0A
013D0:  SUBWF  00,W
013D2:  MOVLB  0
013D4:  BTFSC  FD8.2
013D6:  BRA    17C4
013D8:  MOVLB  2
013DA:  MOVF   03,W
013DC:  BNZ   13EA
013DE:  MOVLW  0B
013E0:  SUBWF  00,W
013E2:  MOVLB  0
013E4:  BTFSC  FD8.2
013E6:  BRA    17EA
013E8:  MOVLB  2
013EA:  MOVF   03,W
013EC:  BNZ   13FA
013EE:  MOVLW  0C
013F0:  SUBWF  00,W
013F2:  MOVLB  0
013F4:  BTFSC  FD8.2
013F6:  BRA    17F6
013F8:  MOVLB  2
013FA:  MOVF   03,W
013FC:  BNZ   140A
013FE:  MOVLW  0D
01400:  SUBWF  00,W
01402:  MOVLB  0
01404:  BTFSC  FD8.2
01406:  BRA    1800
01408:  MOVLB  2
0140A:  MOVF   03,W
0140C:  BNZ   141A
0140E:  MOVLW  0E
01410:  SUBWF  00,W
01412:  MOVLB  0
01414:  BTFSC  FD8.2
01416:  BRA    180A
01418:  MOVLB  2
0141A:  MOVF   03,W
0141C:  BNZ   142A
0141E:  MOVLW  0F
01420:  SUBWF  00,W
01422:  MOVLB  0
01424:  BTFSC  FD8.2
01426:  BRA    1814
01428:  MOVLB  2
0142A:  MOVF   03,W
0142C:  BNZ   143A
0142E:  MOVLW  10
01430:  SUBWF  00,W
01432:  MOVLB  0
01434:  BTFSC  FD8.2
01436:  BRA    181E
01438:  MOVLB  2
0143A:  MOVF   03,W
0143C:  BNZ   144A
0143E:  MOVLW  11
01440:  SUBWF  00,W
01442:  MOVLB  0
01444:  BTFSC  FD8.2
01446:  BRA    1844
01448:  MOVLB  2
0144A:  MOVF   03,W
0144C:  BNZ   145A
0144E:  MOVLW  12
01450:  SUBWF  00,W
01452:  MOVLB  0
01454:  BTFSC  FD8.2
01456:  BRA    1850
01458:  MOVLB  2
0145A:  MOVF   03,W
0145C:  BNZ   146A
0145E:  MOVLW  13
01460:  SUBWF  00,W
01462:  MOVLB  0
01464:  BTFSC  FD8.2
01466:  BRA    187C
01468:  MOVLB  2
0146A:  MOVF   03,W
0146C:  BNZ   147A
0146E:  MOVLW  14
01470:  SUBWF  00,W
01472:  MOVLB  0
01474:  BTFSC  FD8.2
01476:  BRA    188A
01478:  MOVLB  2
0147A:  MOVF   03,W
0147C:  BNZ   148A
0147E:  MOVLW  15
01480:  SUBWF  00,W
01482:  MOVLB  0
01484:  BTFSC  FD8.2
01486:  BRA    1894
01488:  MOVLB  2
0148A:  MOVF   03,W
0148C:  BNZ   149A
0148E:  MOVLW  16
01490:  SUBWF  00,W
01492:  MOVLB  0
01494:  BTFSC  FD8.2
01496:  BRA    18C0
01498:  MOVLB  2
0149A:  MOVF   03,W
0149C:  BNZ   14AA
0149E:  MOVLW  17
014A0:  SUBWF  00,W
014A2:  MOVLB  0
014A4:  BTFSC  FD8.2
014A6:  BRA    18D0
014A8:  MOVLB  2
014AA:  MOVF   03,W
014AC:  BNZ   14BA
014AE:  MOVLW  18
014B0:  SUBWF  00,W
014B2:  MOVLB  0
014B4:  BTFSC  FD8.2
014B6:  BRA    18DA
014B8:  MOVLB  2
014BA:  MOVF   03,W
014BC:  BNZ   14CA
014BE:  MOVLW  19
014C0:  SUBWF  00,W
014C2:  MOVLB  0
014C4:  BTFSC  FD8.2
014C6:  BRA    1906
014C8:  MOVLB  2
014CA:  MOVF   03,W
014CC:  BNZ   14DA
014CE:  MOVLW  1A
014D0:  SUBWF  00,W
014D2:  MOVLB  0
014D4:  BTFSC  FD8.2
014D6:  BRA    1916
014D8:  MOVLB  2
014DA:  MOVF   03,W
014DC:  BNZ   14EA
014DE:  MOVLW  1B
014E0:  SUBWF  00,W
014E2:  MOVLB  0
014E4:  BTFSC  FD8.2
014E6:  BRA    1920
014E8:  MOVLB  2
014EA:  MOVF   03,W
014EC:  BNZ   14FA
014EE:  MOVLW  1C
014F0:  SUBWF  00,W
014F2:  MOVLB  0
014F4:  BTFSC  FD8.2
014F6:  BRA    194C
014F8:  MOVLB  2
014FA:  MOVF   03,W
014FC:  BNZ   150A
014FE:  MOVLW  1D
01500:  SUBWF  00,W
01502:  MOVLB  0
01504:  BTFSC  FD8.2
01506:  BRA    195C
01508:  MOVLB  2
0150A:  MOVF   03,W
0150C:  BNZ   151A
0150E:  MOVLW  1E
01510:  SUBWF  00,W
01512:  MOVLB  0
01514:  BTFSC  FD8.2
01516:  BRA    1966
01518:  MOVLB  2
0151A:  MOVF   03,W
0151C:  BNZ   152A
0151E:  MOVLW  1F
01520:  SUBWF  00,W
01522:  MOVLB  0
01524:  BTFSC  FD8.2
01526:  BRA    1992
01528:  MOVLB  2
0152A:  MOVF   03,W
0152C:  BNZ   153A
0152E:  MOVLW  20
01530:  SUBWF  00,W
01532:  MOVLB  0
01534:  BTFSC  FD8.2
01536:  BRA    19A2
01538:  MOVLB  2
0153A:  MOVF   03,W
0153C:  BNZ   154A
0153E:  MOVLW  21
01540:  SUBWF  00,W
01542:  MOVLB  0
01544:  BTFSC  FD8.2
01546:  BRA    19AC
01548:  MOVLB  2
0154A:  MOVF   03,W
0154C:  BNZ   155A
0154E:  MOVLW  22
01550:  SUBWF  00,W
01552:  MOVLB  0
01554:  BTFSC  FD8.2
01556:  BRA    19D8
01558:  MOVLB  2
0155A:  MOVF   03,W
0155C:  BNZ   156A
0155E:  MOVLW  23
01560:  SUBWF  00,W
01562:  MOVLB  0
01564:  BTFSC  FD8.2
01566:  BRA    19E8
01568:  MOVLB  2
0156A:  MOVF   03,W
0156C:  BNZ   157A
0156E:  MOVLW  24
01570:  SUBWF  00,W
01572:  MOVLB  0
01574:  BTFSC  FD8.2
01576:  BRA    19F2
01578:  MOVLB  2
0157A:  MOVF   03,W
0157C:  BNZ   158A
0157E:  MOVLW  25
01580:  SUBWF  00,W
01582:  MOVLB  0
01584:  BTFSC  FD8.2
01586:  BRA    1A1E
01588:  MOVLB  2
0158A:  MOVF   03,W
0158C:  BNZ   159A
0158E:  MOVLW  26
01590:  SUBWF  00,W
01592:  MOVLB  0
01594:  BTFSC  FD8.2
01596:  BRA    1A2E
01598:  MOVLB  2
0159A:  MOVF   03,W
0159C:  BNZ   15AA
0159E:  MOVLW  27
015A0:  SUBWF  00,W
015A2:  MOVLB  0
015A4:  BTFSC  FD8.2
015A6:  BRA    1A38
015A8:  MOVLB  2
015AA:  MOVF   03,W
015AC:  BNZ   15BA
015AE:  MOVLW  28
015B0:  SUBWF  00,W
015B2:  MOVLB  0
015B4:  BTFSC  FD8.2
015B6:  BRA    1A64
015B8:  MOVLB  2
015BA:  MOVF   03,W
015BC:  BNZ   15CA
015BE:  MOVLW  29
015C0:  SUBWF  00,W
015C2:  MOVLB  0
015C4:  BTFSC  FD8.2
015C6:  BRA    1A74
015C8:  MOVLB  2
015CA:  MOVF   03,W
015CC:  BNZ   15DA
015CE:  MOVLW  2A
015D0:  SUBWF  00,W
015D2:  MOVLB  0
015D4:  BTFSC  FD8.2
015D6:  BRA    1A7E
015D8:  MOVLB  2
015DA:  MOVF   03,W
015DC:  BNZ   15EA
015DE:  MOVLW  2B
015E0:  SUBWF  00,W
015E2:  MOVLB  0
015E4:  BTFSC  FD8.2
015E6:  BRA    1A96
015E8:  MOVLB  2
015EA:  MOVF   03,W
015EC:  BNZ   15FA
015EE:  MOVLW  2C
015F0:  SUBWF  00,W
015F2:  MOVLB  0
015F4:  BTFSC  FD8.2
015F6:  BRA    1AA2
015F8:  MOVLB  2
015FA:  MOVF   03,W
015FC:  BNZ   160A
015FE:  MOVLW  2D
01600:  SUBWF  00,W
01602:  MOVLB  0
01604:  BTFSC  FD8.2
01606:  BRA    1AAE
01608:  MOVLB  2
0160A:  MOVF   03,W
0160C:  BNZ   161A
0160E:  MOVLW  2E
01610:  SUBWF  00,W
01612:  MOVLB  0
01614:  BTFSC  FD8.2
01616:  BRA    1ABA
01618:  MOVLB  2
0161A:  MOVF   03,W
0161C:  BNZ   162A
0161E:  MOVLW  2F
01620:  SUBWF  00,W
01622:  MOVLB  0
01624:  BTFSC  FD8.2
01626:  BRA    1AC6
01628:  MOVLB  2
0162A:  MOVF   03,W
0162C:  BNZ   163A
0162E:  MOVLW  30
01630:  SUBWF  00,W
01632:  MOVLB  0
01634:  BTFSC  FD8.2
01636:  BRA    1AD0
01638:  MOVLB  2
0163A:  MOVF   03,W
0163C:  BNZ   164A
0163E:  MOVLW  31
01640:  SUBWF  00,W
01642:  MOVLB  0
01644:  BTFSC  FD8.2
01646:  BRA    1ADC
01648:  MOVLB  2
0164A:  MOVF   03,W
0164C:  BNZ   165A
0164E:  MOVLW  32
01650:  SUBWF  00,W
01652:  MOVLB  0
01654:  BTFSC  FD8.2
01656:  BRA    1AE8
01658:  MOVLB  2
0165A:  MOVF   03,W
0165C:  BNZ   166A
0165E:  MOVLW  33
01660:  SUBWF  00,W
01662:  MOVLB  0
01664:  BTFSC  FD8.2
01666:  BRA    1AF4
01668:  MOVLB  2
0166A:  MOVLW  03
0166C:  SUBWF  03,W
0166E:  BNZ   167C
01670:  MOVLW  E8
01672:  SUBWF  00,W
01674:  MOVLB  0
01676:  BTFSC  FD8.2
01678:  BRA    1AFE
0167A:  MOVLB  2
0167C:  MOVLW  03
0167E:  SUBWF  03,W
01680:  BNZ   168E
01682:  MOVLW  E9
01684:  SUBWF  00,W
01686:  MOVLB  0
01688:  BTFSC  FD8.2
0168A:  BRA    1B0E
0168C:  MOVLB  2
0168E:  MOVLW  03
01690:  SUBWF  03,W
01692:  BNZ   16A0
01694:  MOVLW  EA
01696:  SUBWF  00,W
01698:  MOVLB  0
0169A:  BTFSC  FD8.2
0169C:  BRA    1B18
0169E:  MOVLB  2
016A0:  MOVLW  03
016A2:  SUBWF  03,W
016A4:  BNZ   16B2
016A6:  MOVLW  EB
016A8:  SUBWF  00,W
016AA:  MOVLB  0
016AC:  BTFSC  FD8.2
016AE:  BRA    1B22
016B0:  MOVLB  2
016B2:  MOVLW  03
016B4:  SUBWF  03,W
016B6:  BNZ   16C4
016B8:  MOVLW  EC
016BA:  SUBWF  00,W
016BC:  MOVLB  0
016BE:  BTFSC  FD8.2
016C0:  BRA    1B2C
016C2:  MOVLB  2
016C4:  MOVLW  03
016C6:  SUBWF  03,W
016C8:  BNZ   16D6
016CA:  MOVLW  ED
016CC:  SUBWF  00,W
016CE:  MOVLB  0
016D0:  BTFSC  FD8.2
016D2:  BRA    1B36
016D4:  MOVLB  2
016D6:  MOVLW  03
016D8:  SUBWF  03,W
016DA:  BNZ   16E8
016DC:  MOVLW  EE
016DE:  SUBWF  00,W
016E0:  MOVLB  0
016E2:  BTFSC  FD8.2
016E4:  BRA    1B40
016E6:  MOVLB  2
016E8:  MOVLW  03
016EA:  SUBWF  03,W
016EC:  BNZ   16FA
016EE:  MOVLW  EF
016F0:  SUBWF  00,W
016F2:  MOVLB  0
016F4:  BTFSC  FD8.2
016F6:  BRA    1B4C
016F8:  MOVLB  2
016FA:  MOVLW  03
016FC:  SUBWF  03,W
016FE:  BNZ   170C
01700:  MOVLW  F0
01702:  SUBWF  00,W
01704:  MOVLB  0
01706:  BTFSC  FD8.2
01708:  BRA    1B56
0170A:  MOVLB  2
0170C:  MOVLW  03
0170E:  SUBWF  03,W
01710:  BNZ   171E
01712:  MOVLW  F1
01714:  SUBWF  00,W
01716:  MOVLB  0
01718:  BTFSC  FD8.2
0171A:  BRA    1B62
0171C:  MOVLB  2
0171E:  MOVLW  03
01720:  SUBWF  03,W
01722:  BNZ   1730
01724:  MOVLW  F2
01726:  SUBWF  00,W
01728:  MOVLB  0
0172A:  BTFSC  FD8.2
0172C:  BRA    1B6C
0172E:  MOVLB  2
01730:  MOVLW  03
01732:  SUBWF  03,W
01734:  BNZ   1742
01736:  MOVLW  F3
01738:  SUBWF  00,W
0173A:  MOVLB  0
0173C:  BTFSC  FD8.2
0173E:  BRA    1B76
01740:  MOVLB  2
01742:  BRA    1B84
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01744:  MOVFF  5F,01
01748:  MOVFF  60,02
0174C:  BRA    1B8E
.................... 		case 1:  return (int16) current.pulse_period[0]; 
0174E:  MOVFF  4D,01
01752:  MOVFF  4E,02
01756:  BRA    1B8E
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01758:  MOVFF  53,01
0175C:  MOVFF  54,02
01760:  BRA    1B8E
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01762:  MOVFF  59,01
01766:  MOVFF  5A,02
0176A:  BRA    1B8E
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
0176C:  MOVLB  2
0176E:  CLRF   xDA
01770:  MOVLB  0
01772:  RCALL  1248
01774:  MOVFF  03,2BA
01778:  MOVFF  02,2B9
0177C:  MOVFF  01,2B8
01780:  MOVFF  00,2B7
01784:  MOVFF  2B7,01
01788:  MOVFF  2B8,02
0178C:  MOVLB  0
0178E:  BRA    1B8E
.................... 		case 5:  return (int16) ps.l[1]; 
01790:  MOVFF  2B9,01
01794:  MOVFF  2BA,02
01798:  MOVLB  0
0179A:  BRA    1B8E
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
0179C:  MOVFF  61,01
017A0:  MOVFF  62,02
017A4:  BRA    1B8E
.................... 		case 7:  return (int16) current.pulse_period[1]; 
017A6:  MOVFF  4F,01
017AA:  MOVFF  50,02
017AE:  BRA    1B8E
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
017B0:  MOVFF  55,01
017B4:  MOVFF  56,02
017B8:  BRA    1B8E
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
017BA:  MOVFF  5B,01
017BE:  MOVFF  5C,02
017C2:  BRA    1B8E
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
017C4:  MOVLW  01
017C6:  MOVLB  2
017C8:  MOVWF  xDA
017CA:  MOVLB  0
017CC:  RCALL  1248
017CE:  MOVFF  03,2BA
017D2:  MOVFF  02,2B9
017D6:  MOVFF  01,2B8
017DA:  MOVFF  00,2B7
017DE:  MOVFF  2B7,01
017E2:  MOVFF  2B8,02
017E6:  MOVLB  0
017E8:  BRA    1B8E
.................... 		case 11: return (int16) ps.l[1]; 
017EA:  MOVFF  2B9,01
017EE:  MOVFF  2BA,02
017F2:  MOVLB  0
017F4:  BRA    1B8E
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
017F6:  MOVFF  63,01
017FA:  MOVFF  64,02
017FE:  BRA    1B8E
.................... 		case 13: return (int16) current.pulse_period[2]; 
01800:  MOVFF  51,01
01804:  MOVFF  52,02
01808:  BRA    1B8E
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
0180A:  MOVFF  57,01
0180E:  MOVFF  58,02
01812:  BRA    1B8E
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01814:  MOVFF  5D,01
01818:  MOVFF  5E,02
0181C:  BRA    1B8E
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
0181E:  MOVLW  02
01820:  MOVLB  2
01822:  MOVWF  xDA
01824:  MOVLB  0
01826:  RCALL  1248
01828:  MOVFF  03,2BA
0182C:  MOVFF  02,2B9
01830:  MOVFF  01,2B8
01834:  MOVFF  00,2B7
01838:  MOVFF  2B7,01
0183C:  MOVFF  2B8,02
01840:  MOVLB  0
01842:  BRA    1B8E
.................... 		case 17: return (int16) ps.l[1]; 
01844:  MOVFF  2B9,01
01848:  MOVFF  2BA,02
0184C:  MOVLB  0
0184E:  BRA    1B8E
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01850:  CLRF   03
01852:  MOVLB  1
01854:  MOVFF  181,02
01858:  BCF    FD8.0
0185A:  RLCF   02,F
0185C:  RLCF   03,F
0185E:  MOVF   02,W
01860:  ADDLW  81
01862:  MOVWF  FE9
01864:  MOVLW  00
01866:  ADDWFC 03,W
01868:  MOVWF  FEA
0186A:  MOVFF  FEC,03
0186E:  MOVF   FED,F
01870:  MOVFF  FEF,01
01874:  MOVFF  03,02
01878:  MOVLB  0
0187A:  BRA    1B8E
.................... 		case 19: return (int16) adc_get(0); 
0187C:  MOVLB  2
0187E:  CLRF   xDA
01880:  MOVLB  0
01882:  CALL   0F22
01886:  MOVF   02,W
01888:  BRA    1B8E
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
0188A:  MOVFF  71,01
0188E:  MOVFF  72,02
01892:  BRA    1B8E
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01894:  CLRF   03
01896:  MOVLB  1
01898:  MOVFF  181,02
0189C:  BCF    FD8.0
0189E:  RLCF   02,F
018A0:  RLCF   03,F
018A2:  MOVF   02,W
018A4:  ADDLW  A1
018A6:  MOVWF  FE9
018A8:  MOVLW  00
018AA:  ADDWFC 03,W
018AC:  MOVWF  FEA
018AE:  MOVFF  FEC,03
018B2:  MOVF   FED,F
018B4:  MOVFF  FEF,01
018B8:  MOVFF  03,02
018BC:  MOVLB  0
018BE:  BRA    1B8E
.................... 		case 22: return (int16) adc_get(1); 
018C0:  MOVLW  01
018C2:  MOVLB  2
018C4:  MOVWF  xDA
018C6:  MOVLB  0
018C8:  CALL   0F22
018CC:  MOVF   02,W
018CE:  BRA    1B8E
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
018D0:  MOVFF  73,01
018D4:  MOVFF  74,02
018D8:  BRA    1B8E
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
018DA:  CLRF   03
018DC:  MOVLB  1
018DE:  MOVFF  181,02
018E2:  BCF    FD8.0
018E4:  RLCF   02,F
018E6:  RLCF   03,F
018E8:  MOVF   02,W
018EA:  ADDLW  C1
018EC:  MOVWF  FE9
018EE:  MOVLW  00
018F0:  ADDWFC 03,W
018F2:  MOVWF  FEA
018F4:  MOVFF  FEC,03
018F8:  MOVF   FED,F
018FA:  MOVFF  FEF,01
018FE:  MOVFF  03,02
01902:  MOVLB  0
01904:  BRA    1B8E
.................... 		case 25: return (int16) adc_get(2); 
01906:  MOVLW  02
01908:  MOVLB  2
0190A:  MOVWF  xDA
0190C:  MOVLB  0
0190E:  CALL   0F22
01912:  MOVF   02,W
01914:  BRA    1B8E
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01916:  MOVFF  75,01
0191A:  MOVFF  76,02
0191E:  BRA    1B8E
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01920:  CLRF   03
01922:  MOVLB  1
01924:  MOVFF  181,02
01928:  BCF    FD8.0
0192A:  RLCF   02,F
0192C:  RLCF   03,F
0192E:  MOVF   02,W
01930:  ADDLW  E1
01932:  MOVWF  FE9
01934:  MOVLW  00
01936:  ADDWFC 03,W
01938:  MOVWF  FEA
0193A:  MOVFF  FEC,03
0193E:  MOVF   FED,F
01940:  MOVFF  FEF,01
01944:  MOVFF  03,02
01948:  MOVLB  0
0194A:  BRA    1B8E
.................... 		case 28: return (int16) adc_get(3); 
0194C:  MOVLW  03
0194E:  MOVLB  2
01950:  MOVWF  xDA
01952:  MOVLB  0
01954:  CALL   0F22
01958:  MOVF   02,W
0195A:  BRA    1B8E
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
0195C:  MOVFF  77,01
01960:  MOVFF  78,02
01964:  BRA    1B8E
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01966:  CLRF   03
01968:  MOVLB  1
0196A:  MOVFF  181,02
0196E:  BCF    FD8.0
01970:  RLCF   02,F
01972:  RLCF   03,F
01974:  MOVF   02,W
01976:  ADDLW  01
01978:  MOVWF  FE9
0197A:  MOVLW  01
0197C:  ADDWFC 03,W
0197E:  MOVWF  FEA
01980:  MOVFF  FEC,03
01984:  MOVF   FED,F
01986:  MOVFF  FEF,01
0198A:  MOVFF  03,02
0198E:  MOVLB  0
01990:  BRA    1B8E
.................... 		case 31: return (int16) adc_get(4); 
01992:  MOVLW  04
01994:  MOVLB  2
01996:  MOVWF  xDA
01998:  MOVLB  0
0199A:  CALL   0F22
0199E:  MOVF   02,W
019A0:  BRA    1B8E
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
019A2:  MOVFF  79,01
019A6:  MOVFF  7A,02
019AA:  BRA    1B8E
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
019AC:  CLRF   03
019AE:  MOVLB  1
019B0:  MOVFF  181,02
019B4:  BCF    FD8.0
019B6:  RLCF   02,F
019B8:  RLCF   03,F
019BA:  MOVF   02,W
019BC:  ADDLW  21
019BE:  MOVWF  FE9
019C0:  MOVLW  01
019C2:  ADDWFC 03,W
019C4:  MOVWF  FEA
019C6:  MOVFF  FEC,03
019CA:  MOVF   FED,F
019CC:  MOVFF  FEF,01
019D0:  MOVFF  03,02
019D4:  MOVLB  0
019D6:  BRA    1B8E
.................... 		case 34: return (int16) adc_get(5); 
019D8:  MOVLW  05
019DA:  MOVLB  2
019DC:  MOVWF  xDA
019DE:  MOVLB  0
019E0:  CALL   0F22
019E4:  MOVF   02,W
019E6:  BRA    1B8E
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
019E8:  MOVFF  7B,01
019EC:  MOVFF  7C,02
019F0:  BRA    1B8E
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
019F2:  CLRF   03
019F4:  MOVLB  1
019F6:  MOVFF  181,02
019FA:  BCF    FD8.0
019FC:  RLCF   02,F
019FE:  RLCF   03,F
01A00:  MOVF   02,W
01A02:  ADDLW  41
01A04:  MOVWF  FE9
01A06:  MOVLW  01
01A08:  ADDWFC 03,W
01A0A:  MOVWF  FEA
01A0C:  MOVFF  FEC,03
01A10:  MOVF   FED,F
01A12:  MOVFF  FEF,01
01A16:  MOVFF  03,02
01A1A:  MOVLB  0
01A1C:  BRA    1B8E
.................... 		case 37: return (int16) adc_get(6); 
01A1E:  MOVLW  06
01A20:  MOVLB  2
01A22:  MOVWF  xDA
01A24:  MOVLB  0
01A26:  CALL   0F22
01A2A:  MOVF   02,W
01A2C:  BRA    1B8E
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01A2E:  MOVFF  7D,01
01A32:  MOVFF  7E,02
01A36:  BRA    1B8E
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01A38:  CLRF   03
01A3A:  MOVLB  1
01A3C:  MOVFF  181,02
01A40:  BCF    FD8.0
01A42:  RLCF   02,F
01A44:  RLCF   03,F
01A46:  MOVF   02,W
01A48:  ADDLW  61
01A4A:  MOVWF  FE9
01A4C:  MOVLW  01
01A4E:  ADDWFC 03,W
01A50:  MOVWF  FEA
01A52:  MOVFF  FEC,03
01A56:  MOVF   FED,F
01A58:  MOVFF  FEF,01
01A5C:  MOVFF  03,02
01A60:  MOVLB  0
01A62:  BRA    1B8E
.................... 		case 40: return (int16) adc_get(7); 
01A64:  MOVLW  07
01A66:  MOVLB  2
01A68:  MOVWF  xDA
01A6A:  MOVLB  0
01A6C:  CALL   0F22
01A70:  MOVF   02,W
01A72:  BRA    1B8E
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01A74:  MOVFF  7F,01
01A78:  MOVFF  80,02
01A7C:  BRA    1B8E
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01A7E:  MOVLB  1
01A80:  MOVFF  189,03
01A84:  MOVF   x88,W
01A86:  INCF   x88,F
01A88:  BTFSC  FD8.2
01A8A:  INCF   x89,F
01A8C:  MOVWF  01
01A8E:  MOVFF  03,02
01A92:  MOVLB  0
01A94:  BRA    1B8E
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01A96:  MOVFF  18C,01
01A9A:  MOVFF  18D,02
01A9E:  MOVLB  0
01AA0:  BRA    1B8E
.................... 		case 44: return (int16) current.uptime_minutes;  
01AA2:  MOVFF  18A,01
01AA6:  MOVFF  18B,02
01AAA:  MOVLB  0
01AAC:  BRA    1B8E
.................... 		case 45: return (int16) current.watchdog_seconds;  
01AAE:  MOVFF  190,01
01AB2:  MOVFF  191,02
01AB6:  MOVLB  0
01AB8:  BRA    1B8E
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01ABA:  GOTO   12AA
01ABE:  MOVLW  00
01AC0:  MOVWF  01
01AC2:  MOVWF  02
01AC4:  BRA    1B8E
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01AC6:  BRA    12E6
01AC8:  MOVLW  00
01ACA:  MOVWF  01
01ACC:  MOVWF  02
01ACE:  BRA    1B8E
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01AD0:  MOVFF  182,01
01AD4:  MOVFF  183,02
01AD8:  MOVLB  0
01ADA:  BRA    1B8E
.................... 		case 49: return (int16) current.modbus_other_packets; 
01ADC:  MOVFF  184,01
01AE0:  MOVFF  185,02
01AE4:  MOVLB  0
01AE6:  BRA    1B8E
.................... 		case 50: return (int16) current.modbus_last_error; 
01AE8:  MOVFF  186,01
01AEC:  MOVFF  187,02
01AF0:  MOVLB  0
01AF2:  BRA    1B8E
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01AF4:  BRA    130E
01AF6:  MOVLW  00
01AF8:  MOVWF  01
01AFA:  MOVWF  02
01AFC:  BRA    1B8E
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) input(BUTTON); 
01AFE:  MOVLW  00
01B00:  BTFSC  F81.3
01B02:  MOVLW  01
01B04:  CLRF   03
01B06:  MOVWF  01
01B08:  MOVFF  03,02
01B0C:  BRA    1B8E
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... //		case 1000: return (int16) config.serial_prefix; 
.................... 		case 1001: return (int16) config.serial_number; 
01B0E:  MOVFF  39,01
01B12:  MOVFF  3A,02
01B16:  BRA    1B8E
.................... 		case 1002: return (int16) 'P'; 
01B18:  MOVLW  50
01B1A:  MOVWF  01
01B1C:  MOVLW  00
01B1E:  MOVWF  02
01B20:  BRA    1B8E
.................... 		case 1003: return (int16) 'W'; 
01B22:  MOVLW  57
01B24:  MOVWF  01
01B26:  MOVLW  00
01B28:  MOVWF  02
01B2A:  BRA    1B8E
.................... 		case 1004: return (int16) 'X'; 
01B2C:  MOVLW  58
01B2E:  MOVWF  01
01B30:  MOVLW  00
01B32:  MOVWF  02
01B34:  BRA    1B8E
.................... 		case 1005: return (int16) 1; 
01B36:  MOVLW  01
01B38:  MOVWF  01
01B3A:  MOVLW  00
01B3C:  MOVWF  02
01B3E:  BRA    1B8E
.................... 		case 1006: return (int16) config.modbus_address; 
01B40:  CLRF   03
01B42:  MOVFF  36,01
01B46:  MOVFF  03,02
01B4A:  BRA    1B8E
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01B4C:  MOVFF  3B,01
01B50:  MOVFF  3C,02
01B54:  BRA    1B8E
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01B56:  CLRF   03
01B58:  MOVFF  3D,01
01B5C:  MOVFF  03,02
01B60:  BRA    1B8E
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01B62:  MOVFF  3E,01
01B66:  MOVFF  3F,02
01B6A:  BRA    1B8E
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01B6C:  MOVFF  40,01
01B70:  MOVFF  41,02
01B74:  BRA    1B8E
.................... 		case 1011: return (int16) config.power_startup; 
01B76:  CLRF   03
01B78:  MOVFF  42,01
01B7C:  MOVFF  03,02
01B80:  BRA    1B8E
01B82:  MOVLB  2
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01B84:  MOVLW  FF
01B86:  MOVWF  01
01B88:  MOVWF  02
01B8A:  MOVLB  0
01B8C:  BRA    1B8E
.................... 	} 
....................  
.................... } 
01B8E:  GOTO   1BE0 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01130:  MOVLB  2
01132:  MOVF   xCE,W
01134:  SUBLW  1F
01136:  BNZ   1150
01138:  MOVF   xCF,W
0113A:  SUBLW  4E
0113C:  BNZ   1150
0113E:  MOVF   xD0,W
01140:  SUBLW  20
01142:  BNZ   1150
01144:  MOVF   xD1,W
01146:  SUBLW  4E
01148:  BNZ   1150
.................... 		return 1; 
0114A:  MOVLW  01
0114C:  MOVWF  01
0114E:  BRA    1188
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
01150:  MOVF   xCF,W
01152:  SUBLW  02
01154:  BC    1174
01156:  XORLW  FF
01158:  BNZ   1160
0115A:  MOVF   xCE,W
0115C:  SUBLW  E7
0115E:  BC    1174
01160:  MOVF   xD1,W
01162:  SUBLW  03
01164:  BNC   1174
01166:  BNZ   116E
01168:  MOVF   xD0,W
0116A:  SUBLW  F4
0116C:  BNC   1174
.................... 		return 1; 
0116E:  MOVLW  01
01170:  MOVWF  01
01172:  BRA    1188
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01174:  MOVF   xD1,F
01176:  BNZ   1184
01178:  MOVF   xD0,W
0117A:  SUBLW  34
0117C:  BNC   1184
.................... 		return 1; 
0117E:  MOVLW  01
01180:  MOVWF  01
01182:  BRA    1188
....................  
.................... 	return 0; 
01184:  MOVLW  00
01186:  MOVWF  01
.................... } 
01188:  MOVLB  0
0118A:  GOTO   1EEC (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01B92:  MOVFF  2CD,2D6
01B96:  MOVFF  2CC,2D7
01B9A:  CALL   11CC
.................... 	modbus_serial_putc(register_count*2); 
01B9E:  BCF    FD8.0
01BA0:  MOVLB  2
01BA2:  RLCF   xD0,W
01BA4:  MOVWF  xD6
01BA6:  RLCF   xD1,W
01BA8:  MOVWF  xD7
01BAA:  MOVFF  2D6,2D8
01BAE:  MOVLB  0
01BB0:  CALL   1198
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01BB4:  MOVLB  2
01BB6:  CLRF   xD3
01BB8:  CLRF   xD2
01BBA:  MOVF   xD3,W
01BBC:  SUBWF  xD1,W
01BBE:  BNC   1C0A
01BC0:  BNZ   1BC8
01BC2:  MOVF   xD0,W
01BC4:  SUBWF  xD2,W
01BC6:  BC    1C0A
.................... 		l=map_modbus(start_address+i); 
01BC8:  MOVF   xD2,W
01BCA:  ADDWF  xCE,W
01BCC:  MOVWF  xD6
01BCE:  MOVF   xD3,W
01BD0:  ADDWFC xCF,W
01BD2:  MOVWF  xD7
01BD4:  MOVWF  xD9
01BD6:  MOVFF  2D6,2D8
01BDA:  MOVLB  0
01BDC:  GOTO   1322
01BE0:  MOVFF  02,2D5
01BE4:  MOVFF  01,2D4
.................... 		modbus_serial_putc(make8(l,1)); 
01BE8:  MOVFF  2D5,2D6
01BEC:  MOVFF  2D5,2D8
01BF0:  CALL   1198
....................   		modbus_serial_putc(make8(l,0)); 
01BF4:  MOVFF  2D4,2D6
01BF8:  MOVFF  2D4,2D8
01BFC:  CALL   1198
.................... 	} 
01C00:  MOVLB  2
01C02:  INCF   xD2,F
01C04:  BTFSC  FD8.2
01C06:  INCF   xD3,F
01C08:  BRA    1BBA
....................  
.................... 	modbus_serial_send_stop(); 
01C0A:  MOVLB  0
01C0C:  CALL   11FA
.................... } 
01C10:  GOTO   1F2E (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01C14:  MOVLB  1
01C16:  MOVF   x8E,F
01C18:  BZ    1C50
.................... 		if ( 1000 == address ) { 
01C1A:  MOVLB  2
01C1C:  MOVF   xD2,W
01C1E:  SUBLW  E8
01C20:  BNZ   1C34
01C22:  MOVF   xD3,W
01C24:  SUBLW  03
01C26:  BNZ   1C34
.................... 			config.serial_prefix=value; 
01C28:  MOVFF  2D4,38
.................... 			return 0; 
01C2C:  MOVLW  00
01C2E:  MOVWF  01
01C30:  BRA    1DDC
.................... 		} else if ( 1001 == address ) { 
01C32:  BRA    1C4E
01C34:  MOVF   xD2,W
01C36:  SUBLW  E9
01C38:  BNZ   1C4E
01C3A:  MOVF   xD3,W
01C3C:  SUBLW  03
01C3E:  BNZ   1C4E
.................... 			config.serial_number=value; 
01C40:  MOVFF  2D5,3A
01C44:  MOVFF  2D4,39
.................... 			return 0; 
01C48:  MOVLW  00
01C4A:  MOVWF  01
01C4C:  BRA    1DDC
01C4E:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01C50:  MOVLB  2
01C52:  MOVF   xD2,W
01C54:  MOVWF  00
01C56:  MOVF   xD3,W
01C58:  MOVWF  03
01C5A:  MOVLW  03
01C5C:  SUBWF  03,W
01C5E:  BNZ   1C6A
01C60:  MOVLW  EE
01C62:  SUBWF  00,W
01C64:  MOVLB  0
01C66:  BZ    1CF0
01C68:  MOVLB  2
01C6A:  MOVLW  03
01C6C:  SUBWF  03,W
01C6E:  BNZ   1C7A
01C70:  MOVLW  EF
01C72:  SUBWF  00,W
01C74:  MOVLB  0
01C76:  BZ    1D10
01C78:  MOVLB  2
01C7A:  MOVLW  03
01C7C:  SUBWF  03,W
01C7E:  BNZ   1C8A
01C80:  MOVLW  F0
01C82:  SUBWF  00,W
01C84:  MOVLB  0
01C86:  BZ    1D20
01C88:  MOVLB  2
01C8A:  MOVLW  03
01C8C:  SUBWF  03,W
01C8E:  BNZ   1C9A
01C90:  MOVLW  F1
01C92:  SUBWF  00,W
01C94:  MOVLB  0
01C96:  BZ    1D38
01C98:  MOVLB  2
01C9A:  MOVLW  03
01C9C:  SUBWF  03,W
01C9E:  BNZ   1CAA
01CA0:  MOVLW  F2
01CA2:  SUBWF  00,W
01CA4:  MOVLB  0
01CA6:  BZ    1D44
01CA8:  MOVLB  2
01CAA:  MOVLW  03
01CAC:  SUBWF  03,W
01CAE:  BNZ   1CBA
01CB0:  MOVLW  F3
01CB2:  SUBWF  00,W
01CB4:  MOVLB  0
01CB6:  BZ    1D5E
01CB8:  MOVLB  2
01CBA:  MOVLW  07
01CBC:  SUBWF  03,W
01CBE:  BNZ   1CCA
01CC0:  MOVLW  CE
01CC2:  SUBWF  00,W
01CC4:  MOVLB  0
01CC6:  BZ    1D76
01CC8:  MOVLB  2
01CCA:  MOVLW  07
01CCC:  SUBWF  03,W
01CCE:  BNZ   1CDC
01CD0:  MOVLW  CF
01CD2:  SUBWF  00,W
01CD4:  MOVLB  0
01CD6:  BTFSC  FD8.2
01CD8:  BRA    1D90
01CDA:  MOVLB  2
01CDC:  MOVLW  4E
01CDE:  SUBWF  03,W
01CE0:  BNZ   1CEE
01CE2:  MOVLW  1F
01CE4:  SUBWF  00,W
01CE6:  MOVLB  0
01CE8:  BTFSC  FD8.2
01CEA:  BRA    1DAA
01CEC:  MOVLB  2
01CEE:  BRA    1DD2
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127} */ 
.................... 			if ( value != 255 && value > 127 ) return ILLEGAL_DATA_VALUE; 
01CF0:  MOVLB  2
01CF2:  INCFSZ xD4,W
01CF4:  BRA    1CFA
01CF6:  MOVF   xD5,F
01CF8:  BZ    1D0A
01CFA:  MOVF   xD5,F
01CFC:  BNZ   1D04
01CFE:  MOVF   xD4,W
01D00:  SUBLW  7F
01D02:  BC    1D0A
01D04:  MOVLW  03
01D06:  MOVWF  01
01D08:  BRA    1DDC
.................... 			config.modbus_address=value; 
01D0A:  MOVFF  2D4,36
.................... 			break; 
01D0E:  BRA    1DD8
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01D10:  MOVLB  1
01D12:  BSF    xAD.1
.................... 			config.adc_sample_ticks=value; 
01D14:  MOVFF  2D5,3C
01D18:  MOVFF  2D4,3B
.................... 			break; 
01D1C:  MOVLB  2
01D1E:  BRA    1DD8
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01D20:  MOVLB  2
01D22:  MOVF   xD5,F
01D24:  BNZ   1D2C
01D26:  MOVF   xD4,W
01D28:  SUBLW  01
01D2A:  BC    1D32
01D2C:  MOVLW  03
01D2E:  MOVWF  01
01D30:  BRA    1DDC
.................... 			config.allow_bootload_request=value; 
01D32:  MOVFF  2D4,3D
.................... 			break; 
01D36:  BRA    1DD8
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01D38:  MOVFF  2D5,3F
01D3C:  MOVFF  2D4,3E
.................... 			break; 
01D40:  MOVLB  2
01D42:  BRA    1DD8
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01D44:  MOVLB  2
01D46:  MOVF   xD4,F
01D48:  BNZ   1D54
01D4A:  MOVF   xD5,F
01D4C:  BNZ   1D54
01D4E:  MOVLW  03
01D50:  MOVWF  01
01D52:  BRA    1DDC
.................... 			config.pi_offtime_seconds=value; 
01D54:  MOVFF  2D5,41
01D58:  MOVFF  2D4,40
.................... 			break; 
01D5C:  BRA    1DD8
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01D5E:  MOVLB  2
01D60:  MOVF   xD5,F
01D62:  BNZ   1D6A
01D64:  MOVF   xD4,W
01D66:  SUBLW  01
01D68:  BC    1D70
01D6A:  MOVLW  03
01D6C:  MOVWF  01
01D6E:  BRA    1DDC
.................... 			config.power_startup=value; 
01D70:  MOVFF  2D4,42
.................... 			break; 
01D74:  BRA    1DD8
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01D76:  MOVLB  2
01D78:  DECFSZ xD4,W
01D7A:  BRA    1D80
01D7C:  MOVF   xD5,F
01D7E:  BZ    1D86
01D80:  MOVLW  03
01D82:  MOVWF  01
01D84:  BRA    1DDC
.................... 			write_default_param_file(); 
01D86:  MOVLB  0
01D88:  CALL   0CDA
.................... 			break; 
01D8C:  MOVLB  2
01D8E:  BRA    1DD8
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01D90:  MOVLB  2
01D92:  DECFSZ xD4,W
01D94:  BRA    1D9A
01D96:  MOVF   xD5,F
01D98:  BZ    1DA0
01D9A:  MOVLW  03
01D9C:  MOVWF  01
01D9E:  BRA    1DDC
.................... 			write_param_file(); 
01DA0:  MOVLB  0
01DA2:  CALL   0C86
.................... 			break; 
01DA6:  MOVLB  2
01DA8:  BRA    1DD8
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01DAA:  MOVLB  2
01DAC:  MOVF   xD4,W
01DAE:  SUBLW  0A
01DB0:  BNZ   1DB8
01DB2:  MOVF   xD5,W
01DB4:  SUBLW  07
01DB6:  BZ    1DC4
.................... 				current.factory_unlocked=0; 
01DB8:  MOVLB  1
01DBA:  CLRF   x8E
.................... 				return ILLEGAL_DATA_VALUE; 
01DBC:  MOVLW  03
01DBE:  MOVWF  01
01DC0:  MOVLB  2
01DC2:  BRA    1DDC
.................... 			} 
.................... 			current.factory_unlocked=1; 
01DC4:  MOVLW  01
01DC6:  MOVLB  1
01DC8:  MOVWF  x8E
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01DCA:  MOVLW  C8
01DCC:  MOVWF  xAA
.................... 			break; 
01DCE:  MOVLB  2
01DD0:  BRA    1DD8
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01DD2:  MOVLW  02
01DD4:  MOVWF  01
01DD6:  BRA    1DDC
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01DD8:  MOVLW  00
01DDA:  MOVWF  01
.................... } 
01DDC:  MOVLB  0
01DDE:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
01E70:  GOTO   110A
01E74:  MOVF   01,F
01E76:  BTFSC  FD8.2
01E78:  BRA    20A0
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( 255==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
01E7A:  INCFSZ 36,W
01E7C:  BRA    1E80
01E7E:  BRA    1E8C
01E80:  MOVF   36,W
01E82:  MOVLB  1
01E84:  SUBWF  xB4,W
01E86:  BTFSS  FD8.2
01E88:  BRA    208C
01E8A:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
01E8C:  MOVLB  1
01E8E:  INCFSZ x82,W
01E90:  BRA    1E98
01E92:  INCFSZ x83,W
01E94:  BRA    1E98
01E96:  BRA    1E9E
.................... 				current.modbus_our_packets++; 
01E98:  INCF   x82,F
01E9A:  BTFSC  FD8.2
01E9C:  INCF   x83,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
01E9E:  MOVLW  14
01EA0:  MOVWF  xAA
....................  
.................... 			switch(modbus_rx.func) { 
01EA2:  MOVF   xB6,W
01EA4:  XORLW  03
01EA6:  MOVLB  0
01EA8:  BZ    1EBA
01EAA:  XORLW  07
01EAC:  BZ    1EBA
01EAE:  XORLW  02
01EB0:  BZ    1F32
01EB2:  XORLW  16
01EB4:  BTFSC  FD8.2
01EB6:  BRA    1FA4
01EB8:  BRA    2066
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01EBA:  MOVFF  1B8,2C7
01EBE:  MOVFF  1B9,2C6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01EC2:  MOVFF  1BA,2C9
01EC6:  MOVFF  1BB,2C8
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
01ECA:  MOVLB  2
01ECC:  MOVF   xC8,W
01ECE:  ADDWF  xC6,W
01ED0:  MOVWF  xCC
01ED2:  MOVF   xC9,W
01ED4:  ADDWFC xC7,W
01ED6:  MOVWF  xCD
01ED8:  MOVFF  2C7,2CF
01EDC:  MOVFF  2C6,2CE
01EE0:  MOVWF  xD1
01EE2:  MOVFF  2CC,2D0
01EE6:  MOVLB  0
01EE8:  GOTO   1130
01EEC:  MOVF   01,F
01EEE:  BNZ   1F14
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
01EF0:  MOVFF  1B4,2CC
01EF4:  MOVLB  2
01EF6:  CLRF   xCE
01EF8:  MOVFF  1B6,2CD
01EFC:  MOVLW  02
01EFE:  MOVWF  xCF
01F00:  MOVLB  0
01F02:  CALL   1228
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
01F06:  MOVLB  1
01F08:  CLRF   x87
01F0A:  MOVLW  02
01F0C:  MOVWF  x86
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
01F0E:  CLRF   xAA
.................... 					} else { 
01F10:  BRA    1F30
01F12:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
01F14:  MOVFF  1B6,2CC
01F18:  MOVFF  1B4,2CD
01F1C:  MOVFF  2C7,2CF
01F20:  MOVFF  2C6,2CE
01F24:  MOVFF  2C9,2D1
01F28:  MOVFF  2C8,2D0
01F2C:  BRA    1B92
01F2E:  MOVLB  1
.................... 					} 
.................... 					break; 
01F30:  BRA    2086
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01F32:  MOVFF  1B8,2C7
01F36:  MOVFF  1B9,2C6
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
01F3A:  MOVFF  1BA,2CD
01F3E:  MOVFF  1BB,2CC
01F42:  MOVFF  2C7,2D3
01F46:  MOVFF  2C6,2D2
01F4A:  MOVFF  1BA,2D5
01F4E:  MOVFF  1BB,2D4
01F52:  RCALL  1C14
01F54:  MOVFF  01,2CA
....................  
.................... 					if ( result ) { 
01F58:  MOVLB  2
01F5A:  MOVF   xCA,F
01F5C:  BZ    1F80
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
01F5E:  MOVFF  1B4,2CC
01F62:  CLRF   xCE
01F64:  MOVFF  1B6,2CD
01F68:  MOVFF  2CA,2CF
01F6C:  MOVLB  0
01F6E:  CALL   1228
.................... 						current.modbus_last_error=result; 
01F72:  MOVLB  1
01F74:  CLRF   x87
01F76:  MOVFF  2CA,186
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
01F7A:  CLRF   xAA
.................... 					}  else { 
01F7C:  BRA    1FA2
01F7E:  MOVLB  2
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
01F80:  MOVFF  1BA,2CD
01F84:  MOVFF  1BB,2CC
01F88:  MOVFF  1B4,2CE
01F8C:  MOVFF  2C7,2D0
01F90:  MOVFF  2C6,2CF
01F94:  MOVFF  1BA,2D2
01F98:  MOVFF  1BB,2D1
01F9C:  MOVLB  0
01F9E:  BRA    1DE0
01FA0:  MOVLB  1
.................... 					} 
.................... 					break; 
01FA2:  BRA    2086
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01FA4:  MOVFF  1B8,2C7
01FA8:  MOVFF  1B9,2C6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01FAC:  MOVFF  1BA,2C9
01FB0:  MOVFF  1BB,2C8
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
01FB4:  MOVLB  2
01FB6:  CLRF   xCB
01FB8:  MOVF   xC9,F
01FBA:  BNZ   1FC2
01FBC:  MOVF   xC8,W
01FBE:  SUBWF  xCB,W
01FC0:  BC    2046
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
01FC2:  MOVF   xCB,W
01FC4:  ADDWF  xC6,W
01FC6:  MOVWF  xCC
01FC8:  MOVLW  00
01FCA:  ADDWFC xC7,W
01FCC:  MOVWF  xCD
01FCE:  BCF    FD8.0
01FD0:  RLCF   xCB,W
01FD2:  ADDLW  05
01FD4:  ADDLW  B8
01FD6:  MOVWF  FE9
01FD8:  MOVLW  01
01FDA:  MOVWF  FEA
01FDC:  BTFSC  FD8.0
01FDE:  INCF   FEA,F
01FE0:  MOVFF  FEF,2CE
01FE4:  BCF    FD8.0
01FE6:  RLCF   xCB,W
01FE8:  ADDLW  06
01FEA:  ADDLW  B8
01FEC:  MOVWF  FE9
01FEE:  MOVLW  01
01FF0:  MOVWF  FEA
01FF2:  BTFSC  FD8.0
01FF4:  INCF   FEA,F
01FF6:  MOVFF  FEF,2CF
01FFA:  MOVFF  2CE,2D1
01FFE:  MOVFF  2CF,2D0
02002:  MOVFF  2CD,2D3
02006:  MOVFF  2CC,2D2
0200A:  MOVFF  2CE,2D5
0200E:  MOVFF  2CF,2D4
02012:  MOVLB  0
02014:  RCALL  1C14
02016:  MOVFF  01,2CA
....................  
.................... 						if ( result ) { 
0201A:  MOVLB  2
0201C:  MOVF   xCA,F
0201E:  BZ    2042
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02020:  MOVFF  1B4,2CC
02024:  CLRF   xCE
02026:  MOVFF  1B6,2CD
0202A:  MOVFF  2CA,2CF
0202E:  MOVLB  0
02030:  CALL   1228
.................... 							current.modbus_last_error=result; 
02034:  MOVLB  1
02036:  CLRF   x87
02038:  MOVFF  2CA,186
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
0203C:  CLRF   xAA
.................... 			 
.................... 							break; 
0203E:  MOVLB  2
02040:  BRA    2046
.................... 						} 
.................... 					} 
02042:  INCF   xCB,F
02044:  BRA    1FB8
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02046:  MOVF   xCA,F
02048:  BNZ   2062
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
0204A:  MOVFF  1B4,2CC
0204E:  MOVFF  2C7,2CE
02052:  MOVFF  2C6,2CD
02056:  MOVFF  2C9,2D0
0205A:  MOVFF  2C8,2CF
0205E:  MOVLB  0
02060:  BRA    1E28
.................... 					} 
....................  
.................... 					break;   
02062:  MOVLB  1
02064:  BRA    2086
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02066:  MOVFF  1B4,2CC
0206A:  MOVLB  2
0206C:  CLRF   xCE
0206E:  MOVFF  1B6,2CD
02072:  MOVLW  01
02074:  MOVWF  xCF
02076:  MOVLB  0
02078:  CALL   1228
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
0207C:  MOVLB  1
0207E:  CLRF   x87
02080:  MOVLW  01
02082:  MOVWF  x86
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02084:  CLRF   xAA
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02086:  CLRF   x91
02088:  CLRF   x90
....................  
.................... 		} else { 
0208A:  BRA    20A0
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
0208C:  INCFSZ x84,W
0208E:  BRA    2096
02090:  INCFSZ x85,W
02092:  BRA    2096
02094:  BRA    209C
.................... 				current.modbus_other_packets++; 
02096:  INCF   x84,F
02098:  BTFSC  FD8.2
0209A:  INCF   x85,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
0209C:  MOVLW  14
0209E:  MOVWF  xAA
020A0:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
020A2:  GOTO   2358 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00480:  MOVLB  2
00482:  BTFSS  xE8.0
00484:  BRA    049E
00486:  MOVLB  1
00488:  INCFSZ x99,W
0048A:  BRA    0496
0048C:  INCFSZ x9A,W
0048E:  BRA    0496
00490:  MOVLB  2
00492:  BRA    049E
00494:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00496:  INCF   x99,F
00498:  BTFSC  FD8.2
0049A:  INCF   x9A,F
0049C:  MOVLB  2
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0049E:  BTFSS  xE8.2
004A0:  BRA    04BA
004A2:  MOVLB  1
004A4:  INCFSZ x9B,W
004A6:  BRA    04B2
004A8:  INCFSZ x9C,W
004AA:  BRA    04B2
004AC:  MOVLB  2
004AE:  BRA    04BA
004B0:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
004B2:  INCF   x9B,F
004B4:  BTFSC  FD8.2
004B6:  INCF   x9C,F
004B8:  MOVLB  2
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
004BA:  BTFSS  xE8.4
004BC:  BRA    04D6
004BE:  MOVLB  1
004C0:  INCFSZ x9D,W
004C2:  BRA    04CE
004C4:  INCFSZ x9E,W
004C6:  BRA    04CE
004C8:  MOVLB  2
004CA:  BRA    04D6
004CC:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
004CE:  INCF   x9D,F
004D0:  BTFSC  FD8.2
004D2:  INCF   x9E,F
004D4:  MOVLB  2
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
004D6:  BCF    xE8.1
004D8:  BTFSC  F81.0
004DA:  BSF    xE8.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
004DC:  BTFSC  xE8.1
004DE:  BRA    0564
004E0:  MOVLB  1
004E2:  BTFSC  xB0.1
004E4:  BRA    04EA
004E6:  MOVLB  2
004E8:  BRA    0564
.................... 		current.pulse_count[0]++; 
004EA:  INCF   5F,F
004EC:  BTFSS  FD8.2
004EE:  BRA    04F6
004F0:  MOVLB  0
004F2:  INCF   x60,F
004F4:  MOVLB  1
.................... 		current.pulse_sum[0]++; 
004F6:  MOVLW  01
004F8:  MOVLB  0
004FA:  ADDWF  x65,F
004FC:  BTFSC  FD8.0
004FE:  INCF   x66,F
00500:  BTFSC  FD8.2
00502:  INCF   x67,F
00504:  BTFSC  FD8.2
00506:  INCF   x68,F
.................... 		if ( 1 == ext0_state ) { 
00508:  MOVLB  1
0050A:  BTFSS  xB0.2
0050C:  BRA    0554
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0050E:  MOVLB  2
00510:  BCF    xE8.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
00512:  MOVFF  19A,4E
00516:  MOVFF  199,4D
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
0051A:  MOVF   4E,W
0051C:  SUBWF  54,W
0051E:  BNC   0530
00520:  BNZ   0528
00522:  MOVF   53,W
00524:  SUBWF  4D,W
00526:  BC    0530
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00528:  MOVFF  4E,54
0052C:  MOVFF  4D,53
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
00530:  MOVF   5A,W
00532:  SUBWF  4E,W
00534:  BNC   0550
00536:  BNZ   053E
00538:  MOVF   4D,W
0053A:  SUBWF  59,W
0053C:  BC    0550
0053E:  INCFSZ 4D,W
00540:  BRA    0548
00542:  INCFSZ 4E,W
00544:  BRA    0548
00546:  BRA    0550
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00548:  MOVFF  4E,5A
0054C:  MOVFF  4D,59
.................... 			} 
.................... 			ext0_state=0; 
00550:  MOVLB  1
00552:  BCF    xB0.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00554:  BTFSC  xB0.2
00556:  BRA    0564
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00558:  CLRF   x9A
0055A:  CLRF   x99
.................... 			ext0_count=1; 
0055C:  MOVLB  2
0055E:  BSF    xE8.0
.................... 			ext0_state=1; 
00560:  MOVLB  1
00562:  BSF    xB0.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00564:  MOVLB  1
00566:  BCF    xB0.1
00568:  MOVLB  2
0056A:  BTFSS  xE8.1
0056C:  BRA    0574
0056E:  MOVLB  1
00570:  BSF    xB0.1
00572:  MOVLB  2
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00574:  BCF    xE8.3
00576:  BTFSC  F81.1
00578:  BSF    xE8.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0057A:  BTFSC  xE8.3
0057C:  BRA    05FC
0057E:  MOVLB  1
00580:  BTFSC  xB0.3
00582:  BRA    0588
00584:  MOVLB  2
00586:  BRA    05FC
.................... 		current.pulse_count[1]++; 
00588:  MOVLB  0
0058A:  INCF   x61,F
0058C:  BTFSC  FD8.2
0058E:  INCF   x62,F
.................... 		current.pulse_sum[1]++; 
00590:  MOVLW  01
00592:  ADDWF  x69,F
00594:  BTFSC  FD8.0
00596:  INCF   x6A,F
00598:  BTFSC  FD8.2
0059A:  INCF   x6B,F
0059C:  BTFSC  FD8.2
0059E:  INCF   x6C,F
.................... 		if ( 1 == ext1_state ) { 
005A0:  MOVLB  1
005A2:  BTFSS  xB0.4
005A4:  BRA    05EC
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
005A6:  MOVLB  2
005A8:  BCF    xE8.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
005AA:  MOVFF  19C,50
005AE:  MOVFF  19B,4F
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
005B2:  MOVF   50,W
005B4:  SUBWF  56,W
005B6:  BNC   05C8
005B8:  BNZ   05C0
005BA:  MOVF   55,W
005BC:  SUBWF  4F,W
005BE:  BC    05C8
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
005C0:  MOVFF  50,56
005C4:  MOVFF  4F,55
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
005C8:  MOVF   5C,W
005CA:  SUBWF  50,W
005CC:  BNC   05E8
005CE:  BNZ   05D6
005D0:  MOVF   4F,W
005D2:  SUBWF  5B,W
005D4:  BC    05E8
005D6:  INCFSZ 4F,W
005D8:  BRA    05E0
005DA:  INCFSZ 50,W
005DC:  BRA    05E0
005DE:  BRA    05E8
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005E0:  MOVFF  50,5C
005E4:  MOVFF  4F,5B
.................... 			} 
.................... 			ext1_state=0; 
005E8:  MOVLB  1
005EA:  BCF    xB0.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005EC:  BTFSC  xB0.4
005EE:  BRA    05FC
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005F0:  CLRF   x9C
005F2:  CLRF   x9B
.................... 			ext1_count=1; 
005F4:  MOVLB  2
005F6:  BSF    xE8.2
.................... 			ext1_state=1; 
005F8:  MOVLB  1
005FA:  BSF    xB0.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005FC:  MOVLB  1
005FE:  BCF    xB0.3
00600:  MOVLB  2
00602:  BTFSS  xE8.3
00604:  BRA    060C
00606:  MOVLB  1
00608:  BSF    xB0.3
0060A:  MOVLB  2
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0060C:  BCF    xE8.5
0060E:  BTFSC  F81.2
00610:  BSF    xE8.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00612:  BTFSC  xE8.5
00614:  BRA    0694
00616:  MOVLB  1
00618:  BTFSC  xB0.5
0061A:  BRA    0620
0061C:  MOVLB  2
0061E:  BRA    0694
.................... 		current.pulse_count[2]++; 
00620:  MOVLB  0
00622:  INCF   x63,F
00624:  BTFSC  FD8.2
00626:  INCF   x64,F
.................... 		current.pulse_sum[2]++; 
00628:  MOVLW  01
0062A:  ADDWF  x6D,F
0062C:  BTFSC  FD8.0
0062E:  INCF   x6E,F
00630:  BTFSC  FD8.2
00632:  INCF   x6F,F
00634:  BTFSC  FD8.2
00636:  INCF   x70,F
.................... 		if ( 1 == ext2_state ) { 
00638:  MOVLB  1
0063A:  BTFSS  xB0.6
0063C:  BRA    0684
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0063E:  MOVLB  2
00640:  BCF    xE8.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00642:  MOVFF  19E,52
00646:  MOVFF  19D,51
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0064A:  MOVF   52,W
0064C:  SUBWF  58,W
0064E:  BNC   0660
00650:  BNZ   0658
00652:  MOVF   57,W
00654:  SUBWF  51,W
00656:  BC    0660
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
00658:  MOVFF  52,58
0065C:  MOVFF  51,57
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00660:  MOVF   5E,W
00662:  SUBWF  52,W
00664:  BNC   0680
00666:  BNZ   066E
00668:  MOVF   51,W
0066A:  SUBWF  5D,W
0066C:  BC    0680
0066E:  INCFSZ 51,W
00670:  BRA    0678
00672:  INCFSZ 52,W
00674:  BRA    0678
00676:  BRA    0680
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
00678:  MOVFF  52,5E
0067C:  MOVFF  51,5D
.................... 			} 
.................... 			ext2_state=0; 
00680:  MOVLB  1
00682:  BCF    xB0.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
00684:  BTFSC  xB0.6
00686:  BRA    0694
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
00688:  CLRF   x9E
0068A:  CLRF   x9D
.................... 			ext2_count=1; 
0068C:  MOVLB  2
0068E:  BSF    xE8.4
.................... 			ext2_state=1; 
00690:  MOVLB  1
00692:  BSF    xB0.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
00694:  MOVLB  1
00696:  BCF    xB0.5
00698:  MOVLB  2
0069A:  BTFSS  xE8.5
0069C:  BRA    06A4
0069E:  MOVLB  1
006A0:  BSF    xB0.5
006A2:  MOVLB  2
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
006A4:  INCF   xBB,F
.................... 	if ( 10 == tick ) { 
006A6:  MOVF   xBB,W
006A8:  SUBLW  0A
006AA:  BNZ   06B4
.................... 		tick=0; 
006AC:  CLRF   xBB
.................... 		timers.now_millisecond=1; 
006AE:  MOVLB  1
006B0:  BSF    xAD.2
006B2:  MOVLB  2
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
006B4:  BCF    F9E.1
006B6:  MOVLB  0
006B8:  GOTO   0122
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(MODBUS_SERIAL); 
*
00706:  RCALL  06BC
00708:  MOVFF  01,2E5
....................  
.................... 	if ( current.bridged_uarts ) { 
0070C:  MOVLB  1
0070E:  BTFSS  x8F.0
00710:  BRA    071E
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,DEBUG); 
00712:  MOVLB  2
00714:  MOVF   xE5,W
00716:  MOVLB  0
00718:  RCALL  06D2
.................... 		return; 
0071A:  BRA    0776
0071C:  MOVLB  1
.................... 	}  
....................  
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
0071E:  BTFSC  xB0.0
00720:  BRA    0778
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00722:  MOVF   xB1,F
00724:  BNZ   0736
.................... 			modbus_serial_crc.d = 0xFFFF; 
00726:  SETF   xB3
00728:  SETF   xB2
.................... 			modbus_rx.address = c; 
0072A:  MOVFF  2E5,1B4
.................... 			modbus_serial_state++; 
0072E:  INCF   xB1,F
.................... 			modbus_rx.len = 0; 
00730:  CLRF   xB5
.................... 			modbus_rx.error=0; 
00732:  CLRF   xB7
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00734:  BRA    0764
00736:  DECFSZ xB1,W
00738:  BRA    0742
.................... 			modbus_rx.func = c; 
0073A:  MOVFF  2E5,1B6
.................... 			modbus_serial_state++; 
0073E:  INCF   xB1,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00740:  BRA    0764
00742:  MOVF   xB1,W
00744:  SUBLW  02
00746:  BNZ   0764
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
00748:  INCFSZ xB5,W
0074A:  BRA    0750
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0074C:  MOVLW  FE
0074E:  MOVWF  xB5
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
00750:  MOVLW  B8
00752:  ADDWF  xB5,W
00754:  MOVWF  FE9
00756:  MOVLW  01
00758:  MOVWF  FEA
0075A:  BTFSC  FD8.0
0075C:  INCF   FEA,F
0075E:  MOVFF  2E5,FEF
.................... 			modbus_rx.len++; 
00762:  INCF   xB5,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00764:  MOVFF  2E5,2E6
00768:  MOVLB  0
0076A:  RCALL  06DA
.................... 		modbus_enable_timeout(TRUE); 
0076C:  MOVLW  01
0076E:  MOVLB  2
00770:  MOVWF  xE6
00772:  MOVLB  0
00774:  RCALL  043A
00776:  MOVLB  1
.................... 	} 
.................... } 
....................  
....................  
....................  
00778:  BCF    F9E.5
0077A:  MOVLB  0
0077C:  GOTO   007C
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
008EE:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
008F0:  MOVLW  08
008F2:  MOVWF  F61
008F4:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
008F6:  MOVLW  00
008F8:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
008FA:  MOVLW  FF
008FC:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
008FE:  MOVLW  92
00900:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00902:  MOVLW  80
00904:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00906:  BCF    F96.0
00908:  BCF    F96.1
0090A:  BCF    F96.2
0090C:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
0090E:  MOVLB  1
00910:  CLRF   xAA
.................... 	timers.load_off_seconds=2; 
00912:  CLRF   xAC
00914:  MOVLW  02
00916:  MOVWF  xAB
.................... 	timers.now_adc_sample=0; 
00918:  BCF    xAD.0
.................... 	timers.now_adc_reset_count=0; 
0091A:  BCF    xAD.1
.................... 	timers.now_millisecond=0; 
0091C:  BCF    xAD.2
.................... 	timers.port_b=0b11111111; 
0091E:  SETF   xAE
.................... 	timers.port_c=0b11111111; 
00920:  SETF   xAF
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
00922:  MOVLB  2
00924:  CLRF   xC6
00926:  MOVF   xC6,W
00928:  SUBLW  02
0092A:  BNC   09D8
.................... 		current.pulse_period[i]=0; 
0092C:  CLRF   03
0092E:  MOVFF  2C6,02
00932:  BCF    FD8.0
00934:  RLCF   02,F
00936:  RLCF   03,F
00938:  MOVF   02,W
0093A:  ADDLW  4D
0093C:  MOVWF  FE9
0093E:  MOVLW  00
00940:  ADDWFC 03,W
00942:  MOVWF  FEA
00944:  CLRF   FEC
00946:  MOVF   FED,F
00948:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
0094A:  CLRF   03
0094C:  MOVFF  2C6,02
00950:  BCF    FD8.0
00952:  RLCF   02,F
00954:  RLCF   03,F
00956:  MOVF   02,W
00958:  ADDLW  53
0095A:  MOVWF  FE9
0095C:  MOVLW  00
0095E:  ADDWFC 03,W
00960:  MOVWF  FEA
00962:  SETF   FEC
00964:  MOVF   FED,F
00966:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00968:  CLRF   03
0096A:  MOVFF  2C6,02
0096E:  BCF    FD8.0
00970:  RLCF   02,F
00972:  RLCF   03,F
00974:  MOVF   02,W
00976:  ADDLW  59
00978:  MOVWF  FE9
0097A:  MOVLW  00
0097C:  ADDWFC 03,W
0097E:  MOVWF  FEA
00980:  CLRF   FEC
00982:  MOVF   FED,F
00984:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00986:  CLRF   03
00988:  MOVFF  2C6,02
0098C:  BCF    FD8.0
0098E:  RLCF   02,F
00990:  RLCF   03,F
00992:  MOVF   02,W
00994:  ADDLW  5F
00996:  MOVWF  FE9
00998:  MOVLW  00
0099A:  ADDWFC 03,W
0099C:  MOVWF  FEA
0099E:  CLRF   FEC
009A0:  MOVF   FED,F
009A2:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
009A4:  CLRF   xE1
009A6:  MOVFF  2C6,2E0
009AA:  CLRF   xE3
009AC:  MOVLW  04
009AE:  MOVWF  xE2
009B0:  MOVLB  0
009B2:  RCALL  08CC
009B4:  MOVF   01,W
009B6:  ADDLW  65
009B8:  MOVWF  FE9
009BA:  MOVLW  00
009BC:  ADDWFC 02,W
009BE:  MOVWF  FEA
009C0:  MOVF   FEE,F
009C2:  MOVF   FEE,F
009C4:  CLRF   FEC
009C6:  MOVF   FED,F
009C8:  CLRF   FEF
009CA:  MOVF   FED,F
009CC:  CLRF   FEF
009CE:  MOVF   FED,F
009D0:  CLRF   FEF
.................... 	} 
009D2:  MOVLB  2
009D4:  INCF   xC6,F
009D6:  BRA    0926
....................  
.................... 	current.modbus_our_packets=0; 
009D8:  MOVLB  1
009DA:  CLRF   x83
009DC:  CLRF   x82
.................... 	current.modbus_other_packets=0; 
009DE:  CLRF   x85
009E0:  CLRF   x84
.................... 	current.modbus_last_error=0; 
009E2:  CLRF   x87
009E4:  CLRF   x86
.................... 	current.sequence_number=0; 
009E6:  CLRF   x89
009E8:  CLRF   x88
.................... 	current.uptime_minutes=0; 
009EA:  CLRF   x8B
009EC:  CLRF   x8A
.................... 	current.interval_milliseconds=0; 
009EE:  CLRF   x8D
009F0:  CLRF   x8C
.................... 	current.adc_buffer_index=0; 
009F2:  CLRF   x81
.................... 	current.factory_unlocked=0; 
009F4:  CLRF   x8E
.................... 	current.bridged_uarts=0; 
009F6:  BCF    x8F.0
.................... 	current.watchdog_seconds=0; 
009F8:  CLRF   x91
009FA:  CLRF   x90
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
009FC:  MOVFF  4A,194
00A00:  MOVFF  49,193
.................... 	current.power_off_delay=config.power_off_below_delay; 
00A04:  MOVFF  46,196
00A08:  MOVFF  45,195
.................... 	current.power_override_timeout=0; 
00A0C:  CLRF   x98
00A0E:  CLRF   x97
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
00A10:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
00A12:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
00A14:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00A16:  MOVLW  00
00A18:  IORLW  05
00A1A:  MOVWF  FBA
00A1C:  MOVLW  4A
00A1E:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00A20:  BSF    F9D.1
.................... //	enable_interrupts(INT_RDA2); /* debug cable */ 
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00A22:  MOVLB  0
00A24:  GOTO   2146 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00FAA:  MOVLB  1
00FAC:  BCF    xAD.2
....................  
.................... //	fputc('.',DEBUG); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(DEBUG,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00FAE:  BCF    FD8.0
00FB0:  MOVLB  2
00FB2:  RLCF   xC1,W
00FB4:  MOVWF  xC6
00FB6:  RLCF   xC2,W
00FB8:  MOVWF  xC7
00FBA:  MOVLW  00
00FBC:  MOVLB  1
00FBE:  BTFSS  xAF.5
00FC0:  MOVLW  01
00FC2:  MOVLB  2
00FC4:  IORWF  xC6,F
00FC6:  MOVFF  2C6,2C1
00FCA:  MOVF   xC7,W
00FCC:  IORLW  E0
00FCE:  MOVWF  xC2
.................... 	if ( b2_state==0xf000) { 
00FD0:  MOVF   xC1,F
00FD2:  BNZ   0FDA
00FD4:  MOVF   xC2,W
00FD6:  SUBLW  F0
00FD8:  BNZ   0FDA
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00FDA:  MOVLB  1
00FDC:  INCFSZ x99,W
00FDE:  BRA    0FE8
00FE0:  INCFSZ x9A,W
00FE2:  BRA    0FE8
.................... 				current.pulse_period[0]=0; 
00FE4:  CLRF   4E
00FE6:  CLRF   4D
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00FE8:  INCFSZ x9B,W
00FEA:  BRA    0FF4
00FEC:  INCFSZ x9C,W
00FEE:  BRA    0FF4
.................... 				current.pulse_period[1]=0; 
00FF0:  CLRF   50
00FF2:  CLRF   4F
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00FF4:  INCFSZ x9D,W
00FF6:  BRA    1000
00FF8:  INCFSZ x9E,W
00FFA:  BRA    1000
.................... 				current.pulse_period[2]=0; 
00FFC:  CLRF   52
00FFE:  CLRF   51
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
01000:  MOVFF  F81,1AE
.................... 	timers.port_c=port_c; 
01004:  MOVFF  F82,1AF
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
01008:  BTFSS  x8F.0
0100A:  BRA    1010
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
0100C:  BSF    F89.3
.................... 	} else { 
0100E:  BRA    101C
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
01010:  MOVF   xAA,F
01012:  BNZ   1018
.................... 			output_low(LED_GREEN); 
01014:  BCF    F89.3
.................... 		} else { 
01016:  BRA    101C
.................... 			output_high(LED_GREEN); 
01018:  BSF    F89.3
.................... 			timers.led_on_green--; 
0101A:  DECF   xAA,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
0101C:  INCFSZ x8C,W
0101E:  BRA    1026
01020:  INCFSZ x8D,W
01022:  BRA    1026
01024:  BRA    102C
.................... 		current.interval_milliseconds++; 
01026:  INCF   x8C,F
01028:  BTFSC  FD8.2
0102A:  INCF   x8D,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
0102C:  MOVLB  2
0102E:  INCF   xBF,F
01030:  BTFSC  FD8.2
01032:  INCF   xC0,F
.................... 	if ( 1000 == ticks ) { 
01034:  MOVF   xBF,W
01036:  SUBLW  E8
01038:  BNZ   10BE
0103A:  MOVF   xC0,W
0103C:  SUBLW  03
0103E:  BNZ   10BE
.................... 		ticks=0; 
01040:  CLRF   xC0
01042:  CLRF   xBF
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
01044:  MOVLB  1
01046:  INCFSZ x90,W
01048:  BRA    1050
0104A:  INCFSZ x91,W
0104C:  BRA    1050
0104E:  BRA    1056
.................... 			current.watchdog_seconds++; 
01050:  INCF   x90,F
01052:  BTFSC  FD8.2
01054:  INCF   x91,F
.................... 		} 
....................  
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
01056:  MOVF   3E,F
01058:  BNZ   105E
0105A:  MOVF   3F,F
0105C:  BZ    107C
0105E:  MOVF   3F,W
01060:  SUBWF  x91,W
01062:  BNC   107C
01064:  BNZ   106C
01066:  MOVF   x90,W
01068:  SUBWF  3E,W
0106A:  BC    107C
0106C:  MOVF   xAB,F
0106E:  BNZ   107C
01070:  MOVF   xAC,F
01072:  BNZ   107C
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
01074:  MOVFF  41,1AC
01078:  MOVFF  40,1AB
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
0107C:  MOVF   xAB,F
0107E:  BNZ   1088
01080:  MOVF   xAC,F
01082:  BNZ   1088
.................... 			output_high(PI_POWER_EN); 
01084:  BSF    F8B.0
.................... 		} else { 
01086:  BRA    109E
.................... 			output_low(PI_POWER_EN); 
01088:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
0108A:  MOVF   xAB,W
0108C:  BTFSC  FD8.2
0108E:  DECF   xAC,F
01090:  DECF   xAB,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
01092:  MOVF   xAB,F
01094:  BNZ   109E
01096:  MOVF   xAC,F
01098:  BNZ   109E
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
0109A:  CLRF   x91
0109C:  CLRF   x90
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
0109E:  MOVLB  2
010A0:  INCF   xBC,F
.................... 		if ( 60 == uptimeTicks ) { 
010A2:  MOVF   xBC,W
010A4:  SUBLW  3C
010A6:  BNZ   10BE
.................... 			uptimeTicks=0; 
010A8:  CLRF   xBC
.................... 			if ( current.uptime_minutes < 65535 )  
010AA:  MOVLB  1
010AC:  INCFSZ x8A,W
010AE:  BRA    10B6
010B0:  INCFSZ x8B,W
010B2:  BRA    10B6
010B4:  BRA    10BC
.................... 				current.uptime_minutes++; 
010B6:  INCF   x8A,F
010B8:  BTFSC  FD8.2
010BA:  INCF   x8B,F
010BC:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
010BE:  INCFSZ xC3,W
010C0:  BRA    10D4
010C2:  INCFSZ xC4,W
010C4:  BRA    10D4
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
010C6:  CLRF   xDA
010C8:  MOVLB  0
010CA:  RCALL  0F22
010CC:  MOVFF  02,2C4
010D0:  MOVFF  01,2C3
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
010D4:  MOVLB  1
010D6:  BTFSS  xAD.1
010D8:  BRA    10E2
.................... 		timers.now_adc_reset_count=0; 
010DA:  BCF    xAD.1
.................... 		adcTicks=0; 
010DC:  MOVLB  2
010DE:  CLRF   xBE
010E0:  CLRF   xBD
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
010E2:  MOVLB  2
010E4:  INCF   xBD,F
010E6:  BTFSC  FD8.2
010E8:  INCF   xBE,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
010EA:  MOVF   3B,W
010EC:  SUBWF  xBD,W
010EE:  BNZ   1104
010F0:  MOVF   3C,W
010F2:  SUBWF  xBE,W
010F4:  BNZ   1104
.................... 		adcTicks=0; 
010F6:  CLRF   xBE
010F8:  CLRF   xBD
.................... 		timers.now_adc_sample=1; 
010FA:  MOVLB  1
010FC:  BSF    xAD.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
010FE:  MOVLB  2
01100:  SETF   xC4
01102:  SETF   xC3
.................... 	} 
....................  
....................  
.................... #if 0 
.................... 	/* raspberry pi power control */ 
.................... 	if ( current.power_override_timeout > 0 ) { 
.................... 		current.power_override_timeout--; 
.................... //		continue; what is this doing? 
.................... 	} 
.................... #endif 
....................  
....................  
.................... } 
01104:  MOVLB  0
01106:  GOTO   2346 (RETURN)
....................  
....................  
.................... void main(void) { 
*
020A6:  CLRF   FF8
020A8:  BCF    FF1.2
020AA:  BSF    F9F.1
020AC:  BCF    F9F.5
020AE:  BSF    FD0.7
020B0:  BSF    07.7
020B2:  CLRF   FEA
020B4:  CLRF   FE9
020B6:  CLRF   35
020B8:  BCF    FB8.3
020BA:  MOVLW  0C
020BC:  MOVWF  FAF
020BE:  MOVLW  A6
020C0:  MOVWF  FAC
020C2:  MOVLW  90
020C4:  MOVWF  FAB
020C6:  BCF    F70.3
020C8:  MOVLW  4D
020CA:  MOVWF  F75
020CC:  MOVLW  A6
020CE:  MOVWF  F72
020D0:  MOVLW  90
020D2:  MOVWF  F71
020D4:  MOVLB  1
020D6:  BCF    xB0.0
020D8:  CLRF   xB1
020DA:  MOVLB  2
020DC:  CLRF   xBB
020DE:  MOVLB  1
020E0:  BCF    xB0.1
020E2:  BCF    xB0.2
020E4:  BCF    xB0.3
020E6:  BCF    xB0.4
020E8:  BCF    xB0.5
020EA:  BCF    xB0.6
020EC:  MOVLB  2
020EE:  CLRF   xBC
020F0:  CLRF   xBE
020F2:  CLRF   xBD
020F4:  CLRF   xC0
020F6:  CLRF   xBF
020F8:  CLRF   xC2
020FA:  CLRF   xC1
020FC:  MOVF   FC1,W
020FE:  ANDLW  F0
02100:  MOVWF  FC1
02102:  MOVLW  00
02104:  MOVLB  F
02106:  MOVWF  x38
02108:  MOVWF  x3C
0210A:  MOVWF  x39
0210C:  MOVWF  x3A
0210E:  MOVWF  x3B
02110:  MOVLB  1
02112:  CLRF   x88
02114:  CLRF   F77
02116:  CLRF   F78
02118:  CLRF   F79
0211A:  CLRF   2F
0211C:  CLRF   30
0211E:  MOVLB  2
02120:  CLRF   xB7
02122:  CLRF   xB8
02124:  CLRF   xB9
02126:  CLRF   xBA
02128:  CLRF   xC3
0212A:  CLRF   xC4
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
0212C:  MOVF   FD0,W
0212E:  ANDLW  0F
02130:  BTFSS  FD0.4
02132:  MOVLW  00
02134:  BSF    FD0.0
02136:  BSF    FD0.1
02138:  BSF    FD0.4
0213A:  BSF    FD8.3
0213C:  BSF    FD8.4
0213E:  MOVWF  xC5
....................  
.................... 	init(); 
02140:  MOVLB  0
02142:  GOTO   08EE
....................  
.................... #if 0 
.................... 	output_high(LED_GREEN); 
.................... 	output_high(PI_POWER_EN); 
.................... 	delay_ms(1000); 
.................... 	output_low(LED_GREEN); 
.................... 	output_low(PI_POWER_EN); 
.................... 	delay_ms(1000); 
.................... 	output_high(LED_GREEN); 
.................... 	output_high(PI_POWER_EN); 
.................... #endif 
....................  
.................... 	output_high(RS485_DE); 
02146:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
02148:  BSF    F8C.0
.................... 	delay_ms(1); 
0214A:  MOVLW  01
0214C:  MOVLB  2
0214E:  MOVWF  xC6
02150:  MOVLB  0
02152:  GOTO   0A28
.................... 	fprintf(DEBUG,"# pcwx %s\r\n",__DATE__); 
02156:  MOVLW  80
02158:  MOVWF  FF6
0215A:  MOVLW  07
0215C:  MOVWF  FF7
0215E:  MOVLW  07
02160:  MOVLB  2
02162:  MOVWF  xC7
02164:  MOVLB  0
02166:  CALL   0A58
0216A:  MOVLW  8C
0216C:  MOVWF  FF6
0216E:  MOVLW  07
02170:  MOVWF  FF7
02172:  CALL   0A82
02176:  MOVLW  0D
02178:  BTFSS  FA4.4
0217A:  BRA    2178
0217C:  MOVWF  F73
0217E:  MOVLW  0A
02180:  BTFSS  FA4.4
02182:  BRA    2180
02184:  MOVWF  F73
.................... 	fprintf(DEBUG,"# restart_cause()=%u ",i); 
02186:  MOVLW  96
02188:  MOVWF  FF6
0218A:  MOVLW  07
0218C:  MOVWF  FF7
0218E:  MOVLW  12
02190:  MOVLB  2
02192:  MOVWF  xC7
02194:  MOVLB  0
02196:  CALL   0A58
0219A:  MOVFF  2C5,2C7
0219E:  MOVLW  1B
021A0:  MOVLB  2
021A2:  MOVWF  xC8
021A4:  MOVLB  0
021A6:  CALL   0AD0
021AA:  MOVLW  20
021AC:  BTFSS  FA4.4
021AE:  BRA    21AC
021B0:  MOVWF  F73
.................... 	switch ( i ) { 
021B2:  MOVLB  2
021B4:  MOVF   xC5,W
021B6:  XORLW  07
021B8:  MOVLB  0
021BA:  BZ    21D6
021BC:  XORLW  0C
021BE:  BZ    21E4
021C0:  XORLW  04
021C2:  BZ    21F2
021C4:  XORLW  03
021C6:  BZ    2200
021C8:  XORLW  02
021CA:  BZ    220E
021CC:  XORLW  0D
021CE:  BZ    221C
021D0:  XORLW  03
021D2:  BZ    222A
021D4:  BRA    2238
.................... 		case WDT_TIMEOUT: fprintf(DEBUG,"WDT_TIMEOUT"); break; 
021D6:  MOVLW  AC
021D8:  MOVWF  FF6
021DA:  MOVLW  07
021DC:  MOVWF  FF7
021DE:  CALL   0A82
021E2:  BRA    2244
.................... 		case MCLR_FROM_SLEEP: fprintf(DEBUG,"MCLR_FROM_SLEEP"); break; 
021E4:  MOVLW  B8
021E6:  MOVWF  FF6
021E8:  MOVLW  07
021EA:  MOVWF  FF7
021EC:  CALL   0A82
021F0:  BRA    2244
.................... 		case MCLR_FROM_RUN: fprintf(DEBUG,"MCLR_FROM_RUN"); break; 
021F2:  MOVLW  C8
021F4:  MOVWF  FF6
021F6:  MOVLW  07
021F8:  MOVWF  FF7
021FA:  CALL   0A82
021FE:  BRA    2244
.................... 		case NORMAL_POWER_UP: fprintf(DEBUG,"NORMAL_POWER_UP"); break; 
02200:  MOVLW  D6
02202:  MOVWF  FF6
02204:  MOVLW  07
02206:  MOVWF  FF7
02208:  CALL   0A82
0220C:  BRA    2244
.................... 		case BROWNOUT_RESTART: fprintf(DEBUG,"BROWNOUT_RESTART"); break; 
0220E:  MOVLW  E6
02210:  MOVWF  FF6
02212:  MOVLW  07
02214:  MOVWF  FF7
02216:  CALL   0A82
0221A:  BRA    2244
.................... 		case WDT_FROM_SLEEP: fprintf(DEBUG,"WDT_FROM_SLEEP"); break; 
0221C:  MOVLW  F8
0221E:  MOVWF  FF6
02220:  MOVLW  07
02222:  MOVWF  FF7
02224:  CALL   0A82
02228:  BRA    2244
.................... 		case RESET_INSTRUCTION: fprintf(DEBUG,"RESET_INSTRUCTION"); break; 
0222A:  MOVLW  08
0222C:  MOVWF  FF6
0222E:  MOVLW  08
02230:  MOVWF  FF7
02232:  CALL   0A82
02236:  BRA    2244
.................... 		default: fprintf(DEBUG,"unknown!"); 
02238:  MOVLW  1A
0223A:  MOVWF  FF6
0223C:  MOVLW  08
0223E:  MOVWF  FF7
02240:  CALL   0A82
.................... 	} 
.................... 	fprintf(DEBUG,"\r\n"); 
02244:  MOVLW  24
02246:  MOVWF  FF6
02248:  MOVLW  08
0224A:  MOVWF  FF7
0224C:  CALL   0A82
....................  
.................... 	fprintf(DEBUG,"# read_param_file() starting ..."); 
02250:  MOVLW  28
02252:  MOVWF  FF6
02254:  MOVLW  08
02256:  MOVWF  FF7
02258:  CALL   0A82
.................... 	read_param_file(); 
0225C:  GOTO   0D0C
.................... 	fprintf(DEBUG," complete\r\n"); 
02260:  MOVLW  4A
02262:  MOVWF  FF6
02264:  MOVLW  08
02266:  MOVWF  FF7
02268:  CALL   0A82
....................  
.................... 	/* wait for message to finish transmitting */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
0226C:  BTFSS  F72.1
0226E:  BRA    226C
....................  
.................... 	output_low(RS485_DE); 
02270:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02272:  BCF    F8C.0
....................  
.................... 	 
.................... 	for ( ; ; ) { 
.................... 		if ( kbhit(DEBUG) ) { 
02274:  BTFSS  FA4.5
02276:  BRA    2296
.................... 			i=fgetc(DEBUG); 
02278:  GOTO   0D5E
0227C:  MOVFF  01,2C5
....................  
.................... 	 
.................... 			output_high(RS485_DE); 
02280:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02282:  BSF    F8C.0
....................  
.................... 			fputc(i,DEBUG); 
02284:  MOVLB  2
02286:  MOVF   xC5,W
02288:  MOVLB  0
0228A:  CALL   06D2
.................... 			while ( ! TRMT2 ) 
.................... 				; 
0228E:  BTFSS  F72.1
02290:  BRA    228E
.................... 	 
.................... 			output_low(RS485_DE); 
02292:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02294:  BCF    F8C.0
.................... 		} 
.................... 	} 
02296:  BRA    2274
....................  
....................  
....................  
.................... 	if ( config.modbus_address != 255 && config.modbus_address > 127 ) { 
02298:  INCFSZ 36,W
0229A:  BRA    229E
0229C:  BRA    22C0
0229E:  MOVF   36,W
022A0:  SUBLW  7F
022A2:  BC    22C0
.................... 		fprintf(DEBUG,"# write_default_param_file() starting ..."); 
022A4:  MOVLW  56
022A6:  MOVWF  FF6
022A8:  MOVLW  08
022AA:  MOVWF  FF7
022AC:  CALL   0A82
.................... 		write_default_param_file(); 
022B0:  CALL   0CDA
.................... 		fprintf(DEBUG," complete\r\n"); 
022B4:  MOVLW  80
022B6:  MOVWF  FF6
022B8:  MOVLW  08
022BA:  MOVWF  FF7
022BC:  CALL   0A82
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
022C0:  BSF    FAB.7
022C2:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	fprintf(DEBUG,"# modbus_init() starting ..."); 
022C4:  MOVLW  8C
022C6:  MOVWF  FF6
022C8:  MOVLW  08
022CA:  MOVWF  FF7
022CC:  CALL   0A82
.................... 	modbus_init(); 
022D0:  GOTO   0D96
.................... 	fprintf(DEBUG," complete\r\n"); 
022D4:  MOVLW  AA
022D6:  MOVWF  FF6
022D8:  MOVLW  08
022DA:  MOVWF  FF7
022DC:  CALL   0A82
....................  
.................... 	fprintf(DEBUG,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
022E0:  MOVLW  00
022E2:  MOVLB  1
022E4:  BTFSC  x8F.0
022E6:  MOVLW  01
022E8:  MOVLB  2
022EA:  MOVWF  xC6
022EC:  MOVLW  B6
022EE:  MOVWF  FF6
022F0:  MOVLW  08
022F2:  MOVWF  FF7
022F4:  MOVLW  10
022F6:  MOVWF  xC7
022F8:  MOVLB  0
022FA:  CALL   0A58
022FE:  MOVFF  2C6,2C7
02302:  MOVLW  1B
02304:  MOVLB  2
02306:  MOVWF  xC8
02308:  MOVLB  0
0230A:  CALL   0AD0
0230E:  MOVLW  0D
02310:  BTFSS  FA4.4
02312:  BRA    2310
02314:  MOVWF  F73
02316:  MOVLW  0A
02318:  BTFSS  FA4.4
0231A:  BRA    2318
0231C:  MOVWF  F73
....................  
.................... //	enable_interrupts(INT_RDA); 
.................... //	enable_interrupts(GLOBAL); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
0231E:  MOVLB  2
02320:  CLRF   xC5
02322:  MOVF   xC5,W
02324:  SUBLW  1D
02326:  BNC   2334
.................... 		adc_update(); 
02328:  MOVLB  0
0232A:  CALL   0E7C
.................... 	} 
0232E:  MOVLB  2
02330:  INCF   xC5,F
02332:  BRA    2322
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02334:  MOVFF  42,192
....................  
....................  
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02338:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(DEBUG) ) { 
.................... 				fputc(fgetc(DEBUG),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
0233A:  MOVLB  1
0233C:  BTFSS  xAD.2
0233E:  BRA    2348
.................... 			periodic_millisecond(); 
02340:  MOVLB  0
02342:  GOTO   0FAA
02346:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02348:  BTFSS  xAD.0
0234A:  BRA    2354
.................... 			timers.now_adc_sample=0; 
0234C:  BCF    xAD.0
.................... 			adc_update(); 
0234E:  MOVLB  0
02350:  CALL   0E7C
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
02354:  MOVLB  0
02356:  BRA    1E70
.................... //		} 
....................  
.................... 	} 
02358:  MOVLB  2
0235A:  BRA    2338
.................... } 
0235C:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
