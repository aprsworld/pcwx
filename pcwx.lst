CCS PCH C Compiler, Version 4.135, 4375               20-Nov-15 15:06

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 8942 bytes (14%)
                         Largest free fragment is 56590
               RAM used: 1930 (50%) at main() level
                         2194 (56%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   21BE
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03B0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   06B2
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   0638
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   03E2
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
00EA8:  MOVLW  05
00EAA:  MOVLB  7
00EAC:  SUBWF  x91,F
00EAE:  BNC   0EC4
00EB0:  MOVLW  07
00EB2:  MOVWF  FEA
00EB4:  MOVLW  91
00EB6:  MOVWF  FE9
00EB8:  MOVF   FEF,W
00EBA:  BZ    0EC4
00EBC:  BRA    0EC0
00EBE:  CLRWDT
00EC0:  DECFSZ FEF,F
00EC2:  BRA    0EBE
00EC4:  MOVLB  0
00EC6:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00668:  BTFSS  F9E.5
0066A:  BRA    0668
0066C:  MOVFF  FAB,35
00670:  MOVFF  FAE,01
00674:  BTFSS  35.1
00676:  BRA    067C
00678:  BCF    FAB.4
0067A:  BSF    FAB.4
0067C:  RETURN 0
*
00F4A:  BTFSS  F9E.4
00F4C:  BRA    0F4A
00F4E:  MOVWF  FAD
00F50:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00620:  BTFSS  FA4.5
00622:  BRA    0620
00624:  MOVFF  F71,35
00628:  MOVFF  F74,01
0062C:  BTFSS  35.1
0062E:  BRA    0634
00630:  BCF    F71.4
00632:  BSF    F71.4
00634:  GOTO   063A (RETURN)
*
0067E:  BTFSS  FA4.4
00680:  BRA    067E
00682:  MOVWF  F73
00684:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
.................... #define N_NMEA0183_SENTENCES 12 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00B7A:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00ADA:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00ADC:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00ADE:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00AE0:  MOVLB  7
00AE2:  MOVF   x8D,F
00AE4:  BNZ   0AEC
.................... 		c=0b00011; 
00AE6:  MOVLW  03
00AE8:  MOVWF  x91
.................... 	else if ( 1 == ch )  
00AEA:  BRA    0B36
00AEC:  DECFSZ x8D,W
00AEE:  BRA    0AF6
.................... 		c=0b10011; 
00AF0:  MOVLW  13
00AF2:  MOVWF  x91
.................... 	else if ( 2 == ch )  
00AF4:  BRA    0B36
00AF6:  MOVF   x8D,W
00AF8:  SUBLW  02
00AFA:  BNZ   0B02
.................... 		c=0b01011; 
00AFC:  MOVLW  0B
00AFE:  MOVWF  x91
.................... 	else if ( 3 == ch )  
00B00:  BRA    0B36
00B02:  MOVF   x8D,W
00B04:  SUBLW  03
00B06:  BNZ   0B0E
.................... 		c=0b11011; 
00B08:  MOVLW  1B
00B0A:  MOVWF  x91
.................... 	else if ( 4 == ch ) 
00B0C:  BRA    0B36
00B0E:  MOVF   x8D,W
00B10:  SUBLW  04
00B12:  BNZ   0B1A
.................... 		c=0b00111; 
00B14:  MOVLW  07
00B16:  MOVWF  x91
.................... 	else if ( 5 == ch )  
00B18:  BRA    0B36
00B1A:  MOVF   x8D,W
00B1C:  SUBLW  05
00B1E:  BNZ   0B26
.................... 		c=0b10111; 
00B20:  MOVLW  17
00B22:  MOVWF  x91
.................... 	else if ( 6 == ch ) 
00B24:  BRA    0B36
00B26:  MOVF   x8D,W
00B28:  SUBLW  06
00B2A:  BNZ   0B32
.................... 		c=0b01111; 
00B2C:  MOVLW  0F
00B2E:  MOVWF  x91
.................... 	else 
00B30:  BRA    0B36
.................... 		c=0b11111; 
00B32:  MOVLW  1F
00B34:  MOVWF  x91
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00B36:  CLRF   x90
00B38:  MOVF   x90,W
00B3A:  SUBLW  04
00B3C:  BNC   0B54
.................... 		output_low(MCP3208_CLK); 
00B3E:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00B40:  BTFSC  x91.0
00B42:  BRA    0B48
00B44:  BCF    F8B.5
00B46:  BRA    0B4A
00B48:  BSF    F8B.5
.................... 		c=c>>1; 
00B4A:  BCF    FD8.0
00B4C:  RRCF   x91,F
.................... 		output_high(MCP3208_CLK); 
00B4E:  BSF    F8B.3
.................... 	} 
00B50:  INCF   x90,F
00B52:  BRA    0B38
....................  
....................  
.................... 	value=0; 
00B54:  CLRF   x8F
00B56:  CLRF   x8E
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00B58:  CLRF   x90
00B5A:  MOVF   x90,W
00B5C:  SUBLW  0D
00B5E:  BNC   0B76
.................... 		output_low(MCP3208_CLK); 
00B60:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00B62:  BTFSC  F82.4
00B64:  BRA    0B6A
00B66:  BCF    FD8.0
00B68:  BRA    0B6C
00B6A:  BSF    FD8.0
00B6C:  RLCF   x8E,F
00B6E:  RLCF   x8F,F
.................... 		output_high(MCP3208_CLK); 
00B70:  BSF    F8B.3
.................... 	} 
00B72:  INCF   x90,F
00B74:  BRA    0B5A
....................  
.................... 	bit_clear(value,13); 
00B76:  BCF    x8F.5
.................... 	bit_clear(value,12); 
00B78:  BCF    x8F.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00B7C:  MOVFF  78E,01
00B80:  MOVFF  78F,02
.................... } 
00B84:  MOVLB  0
00B86:  GOTO   0BF6 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00C80:  MOVLB  7
00C82:  CLRF   xA5
00C84:  MOVFF  79E,7A4
00C88:  CLRF   xA7
00C8A:  MOVLW  20
00C8C:  MOVWF  xA6
00C8E:  MOVLB  0
00C90:  RCALL  0742
00C92:  MOVFF  02,03
00C96:  MOVF   01,W
00C98:  ADDLW  82
00C9A:  MOVWF  01
00C9C:  MOVLW  00
00C9E:  ADDWFC 03,F
00CA0:  MOVFF  01,7A2
00CA4:  MOVLB  7
00CA6:  MOVFF  03,7A3
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00CAA:  CLRF   xA0
00CAC:  CLRF   x9F
.................... 	for( i = 0; i < 16 ; i++ ) { 
00CAE:  CLRF   xA1
00CB0:  MOVF   xA1,W
00CB2:  SUBLW  0F
00CB4:  BNC   0CD8
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00CB6:  BCF    FD8.0
00CB8:  RLCF   xA1,W
00CBA:  CLRF   03
00CBC:  ADDWF  xA2,W
00CBE:  MOVWF  FE9
00CC0:  MOVF   xA3,W
00CC2:  ADDWFC 03,W
00CC4:  MOVWF  FEA
00CC6:  MOVFF  FEC,03
00CCA:  MOVF   FED,F
00CCC:  MOVF   FEF,W
00CCE:  ADDWF  x9F,F
00CD0:  MOVF   03,W
00CD2:  ADDWFC xA0,F
.................... 	} 
00CD4:  INCF   xA1,F
00CD6:  BRA    0CB0
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00CD8:  MOVLW  08
00CDA:  ADDWF  x9F,W
00CDC:  MOVWF  xA4
00CDE:  MOVLW  00
00CE0:  ADDWFC xA0,W
00CE2:  MOVWF  xA5
00CE4:  RRCF   xA5,W
00CE6:  MOVWF  03
00CE8:  RRCF   xA4,W
00CEA:  MOVWF  02
00CEC:  RRCF   03,F
00CEE:  RRCF   02,F
00CF0:  RRCF   03,F
00CF2:  RRCF   02,F
00CF4:  RRCF   03,F
00CF6:  RRCF   02,F
00CF8:  MOVLW  0F
00CFA:  ANDWF  03,F
00CFC:  MOVFF  02,01
00D00:  MOVFF  03,02
.................... } 
00D04:  MOVLB  0
00D06:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00B8A:  MOVLB  1
00B8C:  INCF   x82,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00B8E:  MOVF   x82,W
00B90:  SUBLW  0F
00B92:  BC    0B96
.................... 		current.adc_buffer_index=0; 
00B94:  CLRF   x82
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00B96:  MOVLB  7
00B98:  CLRF   x8A
00B9A:  MOVF   x8A,W
00B9C:  SUBLW  07
00B9E:  BNC   0C2C
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00BA0:  CLRF   xA5
00BA2:  MOVFF  78A,7A4
00BA6:  CLRF   xA7
00BA8:  MOVLW  20
00BAA:  MOVWF  xA6
00BAC:  MOVLB  0
00BAE:  RCALL  0742
00BB0:  MOVFF  02,03
00BB4:  MOVF   01,W
00BB6:  ADDLW  34
00BB8:  MOVLB  7
00BBA:  MOVWF  x8B
00BBC:  MOVLW  00
00BBE:  ADDWFC 02,W
00BC0:  MOVWF  x8C
00BC2:  CLRF   03
00BC4:  MOVLB  1
00BC6:  MOVFF  182,02
00BCA:  BCF    FD8.0
00BCC:  RLCF   02,F
00BCE:  RLCF   03,F
00BD0:  MOVF   02,W
00BD2:  MOVLB  7
00BD4:  ADDWF  x8B,W
00BD6:  MOVWF  01
00BD8:  MOVF   x8C,W
00BDA:  ADDWFC 03,F
00BDC:  MOVF   01,W
00BDE:  ADDLW  4E
00BE0:  MOVWF  01
00BE2:  MOVLW  00
00BE4:  ADDWFC 03,F
00BE6:  MOVFF  01,78B
00BEA:  MOVFF  03,78C
00BEE:  MOVFF  78A,78D
00BF2:  MOVLB  0
00BF4:  BRA    0ADA
00BF6:  MOVFF  78C,FEA
00BFA:  MOVFF  78B,FE9
00BFE:  MOVFF  02,FEC
00C02:  MOVF   FED,F
00C04:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00C08:  CLRF   03
00C0A:  MOVLB  7
00C0C:  MOVFF  78A,02
00C10:  BCF    FD8.0
00C12:  RLCF   02,F
00C14:  RLCF   03,F
00C16:  MOVF   02,W
00C18:  ADDLW  72
00C1A:  MOVWF  FE9
00C1C:  MOVLW  00
00C1E:  ADDWFC 03,W
00C20:  MOVWF  FEA
00C22:  CLRF   FEC
00C24:  MOVF   FED,F
00C26:  CLRF   FEF
....................  
.................... 	} 
00C28:  INCF   x8A,F
00C2A:  BRA    0B9A
.................... } 
00C2C:  MOVLB  0
00C2E:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00920:  MOVF   xA5,W
00922:  XORWF  xA6,W
00924:  MOVWF  01
*
00972:  MOVF   xA5,W
00974:  XORWF  xA6,W
00976:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
008AA:  MOVLB  7
008AC:  CLRF   x93
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
008AE:  MOVFF  792,03
008B2:  MOVF   x91,W
008B4:  BTFSC  FD8.2
008B6:  DECF   x92,F
008B8:  DECF   x91,F
008BA:  MOVWF  x94
008BC:  MOVFF  03,795
008C0:  MOVF   x94,F
008C2:  BNZ   08C8
008C4:  MOVF   x95,F
008C6:  BZ    0932
.................... 		*data = read_eeprom( address++ ); 
008C8:  MOVFF  790,03
008CC:  MOVF   x8F,W
008CE:  MOVWF  FE9
008D0:  MOVFF  03,FEA
008D4:  MOVF   x8E,W
008D6:  MOVWF  03
008D8:  MOVF   x8D,W
008DA:  INCF   x8D,F
008DC:  BTFSC  FD8.2
008DE:  INCF   x8E,F
008E0:  MOVWF  x96
008E2:  MOVFF  03,797
008E6:  MOVFF  FF2,798
008EA:  BCF    FF2.6
008EC:  BCF    FF2.7
008EE:  MOVFF  797,FAA
008F2:  MOVFF  796,FA9
008F6:  BCF    FA6.6
008F8:  BCF    FA6.7
008FA:  BSF    FA6.0
008FC:  MOVF   FA8,W
008FE:  BTFSC  x98.6
00900:  BSF    FF2.6
00902:  BTFSC  x98.7
00904:  BSF    FF2.7
00906:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00908:  MOVFF  790,03
0090C:  MOVF   x8F,W
0090E:  MOVWF  FE9
00910:  MOVFF  03,FEA
00914:  MOVFF  FEF,794
00918:  MOVFF  793,7A5
0091C:  MOVFF  794,7A6
*
00926:  MOVFF  01,793
.................... 		data++; 
0092A:  INCF   x8F,F
0092C:  BTFSC  FD8.2
0092E:  INCF   x90,F
.................... 	} 
00930:  BRA    08AE
.................... 	return crc; 
00932:  MOVFF  793,01
.................... } 
00936:  MOVLB  0
00938:  GOTO   0A8E (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
0093C:  MOVLB  7
0093E:  CLRF   xA3
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00940:  MOVFF  7A2,03
00944:  MOVF   xA1,W
00946:  BTFSC  FD8.2
00948:  DECF   xA2,F
0094A:  DECF   xA1,F
0094C:  MOVWF  xA4
0094E:  MOVFF  03,7A5
00952:  MOVF   xA4,F
00954:  BNZ   095A
00956:  MOVF   xA5,F
00958:  BZ    09D8
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
0095A:  MOVFF  7A0,03
0095E:  MOVF   x9F,W
00960:  MOVWF  FE9
00962:  MOVFF  03,FEA
00966:  MOVFF  FEF,7A4
0096A:  MOVFF  7A3,7A5
0096E:  MOVFF  7A4,7A6
*
00978:  MOVFF  01,7A3
.................... 		write_eeprom( address++, *data++ ); 
0097C:  MOVF   x9E,W
0097E:  MOVWF  03
00980:  MOVF   x9D,W
00982:  INCF   x9D,F
00984:  BTFSC  FD8.2
00986:  INCF   x9E,F
00988:  MOVWF  xA4
0098A:  MOVFF  03,7A5
0098E:  MOVF   xA0,W
00990:  MOVWF  03
00992:  MOVF   x9F,W
00994:  INCF   x9F,F
00996:  BTFSC  FD8.2
00998:  INCF   xA0,F
0099A:  MOVWF  FE9
0099C:  MOVFF  03,FEA
009A0:  MOVFF  FEF,7A6
009A4:  MOVFF  7A5,FAA
009A8:  MOVFF  7A4,FA9
009AC:  MOVFF  7A6,FA8
009B0:  BCF    FA6.6
009B2:  BCF    FA6.7
009B4:  BSF    FA6.2
009B6:  MOVF   FF2,W
009B8:  MOVWF  00
009BA:  BCF    FF2.6
009BC:  BCF    FF2.7
009BE:  MOVLB  F
009C0:  MOVLW  55
009C2:  MOVWF  FA7
009C4:  MOVLW  AA
009C6:  MOVWF  FA7
009C8:  BSF    FA6.1
009CA:  BTFSC  FA6.1
009CC:  BRA    09CA
009CE:  BCF    FA6.2
009D0:  MOVF   00,W
009D2:  IORWF  FF2,F
.................... 	} 
009D4:  MOVLB  7
009D6:  BRA    0940
....................  
.................... 	return crc; 
009D8:  MOVFF  7A3,01
.................... } 
009DC:  MOVLB  0
009DE:  GOTO   0A02 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
009E2:  MOVLB  7
009E4:  CLRF   x9C
009E6:  MOVLW  36
009E8:  MOVWF  x9B
009EA:  CLRF   x9E
009EC:  MOVLW  02
009EE:  MOVWF  x9D
009F0:  MOVFF  79C,7A0
009F4:  MOVFF  79B,79F
009F8:  CLRF   xA2
009FA:  MOVLW  18
009FC:  MOVWF  xA1
009FE:  MOVLB  0
00A00:  BRA    093C
00A02:  MOVFF  01,79A
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00A06:  CLRF   FAA
00A08:  CLRF   FA9
00A0A:  MOVFF  79A,FA8
00A0E:  BCF    FA6.6
00A10:  BCF    FA6.7
00A12:  BSF    FA6.2
00A14:  MOVF   FF2,W
00A16:  MOVWF  00
00A18:  BCF    FF2.6
00A1A:  BCF    FF2.7
00A1C:  MOVLB  F
00A1E:  MOVLW  55
00A20:  MOVWF  FA7
00A22:  MOVLW  AA
00A24:  MOVWF  FA7
00A26:  BSF    FA6.1
00A28:  BTFSC  FA6.1
00A2A:  BRA    0A28
00A2C:  BCF    FA6.2
00A2E:  MOVF   00,W
00A30:  IORWF  FF2,F
.................... } 
00A32:  MOVLB  0
00A34:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00A36:  MOVLW  96
00A38:  MOVLB  1
00A3A:  MOVWF  xAB
....................  
.................... 	config.modbus_address=38; 
00A3C:  MOVLW  26
00A3E:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_MODBUS_BRIDGE; 
00A40:  MOVLW  01
00A42:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00A44:  MOVLW  50
00A46:  MOVWF  39
.................... 	config.serial_number=9876; 
00A48:  MOVLW  26
00A4A:  MOVWF  3B
00A4C:  MOVLW  94
00A4E:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00A50:  CLRF   3D
00A52:  MOVLW  14
00A54:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00A56:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00A58:  MOVLW  02
00A5A:  MOVWF  40
00A5C:  MOVLW  76
00A5E:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00A60:  CLRF   42
00A62:  MOVLW  02
00A64:  MOVWF  41
.................... 	config.power_startup=0; 
00A66:  CLRF   43
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00A68:  MOVLB  0
00A6A:  RCALL  09E2
....................  
.................... } 
00A6C:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00A6E:  MOVLB  7
00A70:  CLRF   x8C
00A72:  MOVLW  36
00A74:  MOVWF  x8B
00A76:  CLRF   x8E
00A78:  MOVLW  02
00A7A:  MOVWF  x8D
00A7C:  MOVFF  78C,790
00A80:  MOVFF  78B,78F
00A84:  CLRF   x92
00A86:  MOVLW  18
00A88:  MOVWF  x91
00A8A:  MOVLB  0
00A8C:  BRA    08AA
00A8E:  MOVFF  01,78A
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00A92:  MOVFF  FF2,78B
00A96:  BCF    FF2.6
00A98:  BCF    FF2.7
00A9A:  CLRF   FAA
00A9C:  CLRF   FA9
00A9E:  BCF    FA6.6
00AA0:  BCF    FA6.7
00AA2:  BSF    FA6.0
00AA4:  MOVF   FA8,W
00AA6:  MOVLB  7
00AA8:  BTFSC  x8B.6
00AAA:  BSF    FF2.6
00AAC:  BTFSC  x8B.7
00AAE:  BSF    FF2.7
00AB0:  SUBWF  x8A,W
00AB2:  BZ    0ABA
.................... 		write_default_param_file(); 
00AB4:  MOVLB  0
00AB6:  RCALL  0A36
00AB8:  MOVLB  7
.................... 	} 
.................... } 
00ABA:  MOVLB  0
00ABC:  GOTO   2264 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
00FAC:  BTFSS  FAC.1
00FAE:  BRA    0FAC
.................... } 
00FB0:  GOTO   0FCA (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00AC0:  BTFSS  F9E.5
00AC2:  BRA    0AC8
.................... 		fgetc(STREAM_PI); 
00AC4:  RCALL  0668
.................... 	} 
00AC6:  BRA    0AC0
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00AC8:  BSF    F9D.5
.................... } 
00ACA:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00ACC:  RCALL  0AC0
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00ACE:  MOVLW  C6
00AD0:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00AD2:  MOVLW  C0
00AD4:  IORWF  FF2,F
.................... } 
00AD6:  GOTO   2276 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0039C:  BCF    FF2.5
.................... 	if (enable) { 
0039E:  MOVLB  8
003A0:  MOVF   x8F,F
003A2:  BZ    03AC
.................... 		set_timer0(0); 
003A4:  CLRF   FD7
003A6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003A8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003AA:  BSF    FF2.5
.................... 	} 
.................... } 
003AC:  MOVLB  0
003AE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003B0:  MOVLB  6
003B2:  MOVF   x75,W
003B4:  SUBLW  02
003B6:  BNZ   03CC
003B8:  MOVF   x76,F
003BA:  BNZ   03CC
003BC:  MOVF   x77,F
003BE:  BNZ   03CC
003C0:  BTFSC  x74.0
003C2:  BRA    03CC
....................    { 
....................       modbus_rx.len-=2; 
003C4:  MOVLW  02
003C6:  SUBWF  x79,F
....................       modbus_serial_new=TRUE; 
003C8:  BSF    x74.0
....................    } 
....................    else 
003CA:  BRA    03CE
....................       modbus_serial_new=FALSE; 
003CC:  BCF    x74.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003CE:  SETF   x77
003D0:  SETF   x76
....................    modbus_serial_state=MODBUS_GETADDY; 
003D2:  CLRF   x75
....................    modbus_enable_timeout(FALSE); 
003D4:  MOVLB  8
003D6:  CLRF   x8F
003D8:  MOVLB  0
003DA:  RCALL  039C
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003DC:  BCF    FF2.2
003DE:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00686:  MOVLB  6
00688:  MOVF   x77,W
0068A:  MOVLB  8
0068C:  XORWF  x8F,W
0068E:  MOVWF  x90
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00690:  CLRF   03
00692:  MOVF   x90,W
00694:  MOVLB  0
00696:  RCALL  017C
00698:  MOVWF  01
0069A:  MOVLB  6
0069C:  MOVF   x76,W
0069E:  XORWF  01,W
006A0:  MOVWF  x77
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006A2:  CLRF   03
006A4:  MOVLB  8
006A6:  MOVF   x90,W
006A8:  MOVLB  0
006AA:  RCALL  028C
006AC:  MOVFF  FE8,676
.................... } 
006B0:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
00F52:  MOVLB  7
00F54:  MOVF   x9C,W
00F56:  MOVLB  0
00F58:  RCALL  0F4A
00F5A:  CLRF   19
00F5C:  BTFSC  FF2.6
00F5E:  BSF    19.6
00F60:  BCF    FF2.6
00F62:  BTFSC  FF2.7
00F64:  BSF    19.7
00F66:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
00F68:  MOVFF  79C,88F
00F6C:  CALL   0686
00F70:  BTFSC  19.6
00F72:  BSF    FF2.6
00F74:  BTFSC  19.7
00F76:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
00F78:  CLRWDT
00F7A:  MOVLW  08
00F7C:  MOVWF  00
00F7E:  DECFSZ 00,F
00F80:  BRA    0F7E
00F82:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
00F84:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
00F86:  MOVLB  6
00F88:  SETF   x77
00F8A:  SETF   x76
....................    modbus_serial_new=FALSE; 
00F8C:  BCF    x74.0
....................  
....................    RCV_OFF(); 
00F8E:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
00F90:  CLRWDT
00F92:  MOVLW  3C
00F94:  MOVWF  00
00F96:  DECFSZ 00,F
00F98:  BRA    0F96
00F9A:  NOP   
....................  
....................    modbus_serial_putc(to); 
00F9C:  MOVFF  79A,79C
00FA0:  MOVLB  0
00FA2:  RCALL  0F52
....................    modbus_serial_putc(func); 
00FA4:  MOVFF  79B,79C
00FA8:  RCALL  0F52
.................... } 
00FAA:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
00FB4:  MOVFF  677,79B
....................    crc_low=modbus_serial_crc.b[0]; 
00FB8:  MOVFF  676,79A
....................  
....................    modbus_serial_putc(crc_high); 
00FBC:  MOVFF  79B,79C
00FC0:  RCALL  0F52
....................    modbus_serial_putc(crc_low); 
00FC2:  MOVFF  79A,79C
00FC6:  RCALL  0F52
....................  
....................    WAIT_FOR_HW_BUFFER(); 
00FC8:  BRA    0FAC
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
00FCA:  CLRWDT
00FCC:  MOVLW  3C
00FCE:  MOVWF  00
00FD0:  DECFSZ 00,F
00FD2:  BRA    0FD0
00FD4:  NOP   
....................  
....................  
....................    RCV_ON(); 
00FD6:  RCALL  0AC0
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
00FD8:  MOVLB  6
00FDA:  SETF   x77
00FDC:  SETF   x76
.................... } 
00FDE:  MOVLB  0
00FE0:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00E82:  MOVLB  6
00E84:  BTFSC  x74.0
00E86:  BRA    0E90
....................       return FALSE; 
00E88:  MOVLW  00
00E8A:  MOVWF  01
00E8C:  BRA    0EA2
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00E8E:  BRA    0E9C
00E90:  BTFSS  x7A.7
00E92:  BRA    0E9C
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00E94:  MOVFF  67C,67B
....................       modbus_rx.len = 1; 
00E98:  MOVLW  01
00E9A:  MOVWF  x79
....................    } 
....................    modbus_serial_new=FALSE; 
00E9C:  BCF    x74.0
....................    return TRUE; 
00E9E:  MOVLW  01
00EA0:  MOVWF  01
.................... } 
00EA2:  MOVLB  0
00EA4:  GOTO   1E5A (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01DC6:  MOVFF  792,79A
01DCA:  MOVLW  06
01DCC:  MOVLB  7
01DCE:  MOVWF  x9B
01DD0:  MOVLB  0
01DD2:  CALL   0F86
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01DD6:  MOVFF  794,797
01DDA:  MOVFF  794,79C
01DDE:  CALL   0F52
....................    modbus_serial_putc(make8(reg_address,0)); 
01DE2:  MOVFF  793,797
01DE6:  MOVFF  793,79C
01DEA:  CALL   0F52
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01DEE:  MOVFF  796,797
01DF2:  MOVFF  796,79C
01DF6:  CALL   0F52
....................    modbus_serial_putc(make8(reg_value,0)); 
01DFA:  MOVFF  795,797
01DFE:  MOVFF  795,79C
01E02:  CALL   0F52
....................  
....................    modbus_serial_send_stop(); 
01E06:  CALL   0FB4
.................... } 
01E0A:  GOTO   203E (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01E0E:  MOVFF  790,79A
01E12:  MOVLW  10
01E14:  MOVLB  7
01E16:  MOVWF  x9B
01E18:  MOVLB  0
01E1A:  CALL   0F86
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01E1E:  MOVFF  792,795
01E22:  MOVFF  792,79C
01E26:  CALL   0F52
....................    modbus_serial_putc(make8(start_address,0)); 
01E2A:  MOVFF  791,795
01E2E:  MOVFF  791,79C
01E32:  CALL   0F52
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01E36:  MOVFF  794,795
01E3A:  MOVFF  794,79C
01E3E:  CALL   0F52
....................    modbus_serial_putc(make8(quantity,0)); 
01E42:  MOVFF  793,795
01E46:  MOVFF  793,79C
01E4A:  CALL   0F52
....................  
....................    modbus_serial_send_stop(); 
01E4E:  CALL   0FB4
.................... } 
01E52:  GOTO   2100 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
00FE2:  MOVLB  7
00FE4:  MOVF   x91,W
00FE6:  IORLW  80
00FE8:  MOVWF  x94
00FEA:  MOVFF  792,795
00FEE:  MOVFF  790,79A
00FF2:  MOVWF  x9B
00FF4:  MOVLB  0
00FF6:  RCALL  0F86
....................    modbus_serial_putc(error); 
00FF8:  MOVFF  793,79C
00FFC:  RCALL  0F52
....................    modbus_serial_send_stop(); 
00FFE:  RCALL  0FB4
.................... } 
01000:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1012 
....................  
.................... #define MIN_EE_REGISTER      2000 
.................... #define MAX_EE_REGISTER      MIN_EE_REGISTER + 512 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
010C8:  MOVLB  1
010CA:  CLRF   x84
010CC:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
010CE:  CLRF   x86
010D0:  CLRF   x85
.................... 	current.modbus_last_error=0; 
010D2:  CLRF   x88
010D4:  CLRF   x87
.................... } 
010D6:  MOVLB  0
010D8:  GOTO   19FE (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
01064:  BCF    FF2.6
01066:  BCF    FF2.7
01068:  BTFSC  FF2.7
0106A:  BRA    1066
....................  
.................... 	current.pulse_count[0]=0; 
0106C:  CLRF   x61
0106E:  CLRF   x60
.................... 	current.pulse_count[1]=0; 
01070:  CLRF   x63
01072:  CLRF   x62
.................... 	current.pulse_count[2]=0; 
01074:  CLRF   x65
01076:  CLRF   x64
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
01078:  SETF   55
0107A:  SETF   54
.................... 	current.pulse_min_period[1]=65535; 
0107C:  SETF   57
0107E:  SETF   56
.................... 	current.pulse_min_period[2]=65535; 
01080:  SETF   59
01082:  SETF   58
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
01084:  CLRF   5B
01086:  CLRF   5A
.................... 	current.pulse_max_period[1]=0; 
01088:  CLRF   5D
0108A:  CLRF   5C
.................... 	current.pulse_max_period[2]=0; 
0108C:  CLRF   5F
0108E:  CLRF   5E
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01090:  MOVLB  1
01092:  CLRF   x8E
01094:  CLRF   x8D
....................  
.................... 	enable_interrupts(GLOBAL); 
01096:  MOVLW  C0
01098:  IORWF  FF2,F
.................... } 
0109A:  MOVLB  0
0109C:  GOTO   19AE (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
010A0:  BCF    FF2.6
010A2:  BCF    FF2.7
010A4:  BTFSC  FF2.7
010A6:  BRA    10A2
.................... 	current.pulse_sum[0]=0; 
010A8:  CLRF   x69
010AA:  CLRF   x68
010AC:  CLRF   x67
010AE:  CLRF   x66
.................... 	current.pulse_sum[1]=0; 
010B0:  CLRF   x6D
010B2:  CLRF   x6C
010B4:  CLRF   x6B
010B6:  CLRF   x6A
.................... 	current.pulse_sum[2]=0; 
010B8:  CLRF   x71
010BA:  CLRF   x70
010BC:  CLRF   x6F
010BE:  CLRF   x6E
.................... 	enable_interrupts(GLOBAL); 
010C0:  MOVLW  C0
010C2:  IORWF  FF2,F
.................... } 
010C4:  GOTO   19BE (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01002:  BCF    FF2.6
01004:  BCF    FF2.7
01006:  BTFSC  FF2.7
01008:  BRA    1004
.................... 	l=current.pulse_sum[ch]; 
0100A:  MOVLB  7
0100C:  CLRF   xA5
0100E:  MOVFF  79E,7A4
01012:  CLRF   xA7
01014:  MOVLW  04
01016:  MOVWF  xA6
01018:  MOVLB  0
0101A:  CALL   0742
0101E:  MOVFF  02,03
01022:  MOVF   01,W
01024:  ADDLW  66
01026:  MOVWF  FE9
01028:  MOVLW  00
0102A:  ADDWFC 02,W
0102C:  MOVWF  FEA
0102E:  MOVFF  FEF,00
01032:  MOVFF  FEC,01
01036:  MOVFF  FEC,02
0103A:  MOVFF  FEC,03
0103E:  MOVFF  03,7A2
01042:  MOVFF  02,7A1
01046:  MOVFF  01,7A0
0104A:  MOVFF  00,79F
.................... 	enable_interrupts(GLOBAL); 
0104E:  MOVLW  C0
01050:  IORWF  FF2,F
....................  
.................... 	return l; 
01052:  MOVFF  79F,00
01056:  MOVFF  7A0,01
0105A:  MOVFF  7A1,02
0105E:  MOVFF  7A2,03
.................... } 
01062:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
010DC:  MOVLB  7
010DE:  MOVF   x9D,W
010E0:  SUBLW  06
010E2:  BC    1138
010E4:  XORLW  FF
010E6:  BNZ   10EE
010E8:  MOVF   x9C,W
010EA:  SUBLW  CF
010EC:  BC    1138
010EE:  MOVF   x9D,W
010F0:  SUBLW  09
010F2:  BNC   1138
010F4:  BNZ   10FC
010F6:  MOVF   x9C,W
010F8:  SUBLW  CF
010FA:  BNC   1138
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
010FC:  MOVLW  D0
010FE:  SUBWF  x9C,W
01100:  MOVWF  x9E
01102:  MOVLW  07
01104:  SUBWFB x9D,W
01106:  MOVWF  x9F
01108:  MOVLW  02
0110A:  ADDWF  x9F,F
0110C:  MOVFF  FF2,7A0
01110:  BCF    FF2.6
01112:  BCF    FF2.7
01114:  MOVFF  79F,FAA
01118:  MOVFF  79E,FA9
0111C:  BCF    FA6.6
0111E:  BCF    FA6.7
01120:  BSF    FA6.0
01122:  MOVF   FA8,W
01124:  BTFSC  xA0.6
01126:  BSF    FF2.6
01128:  BTFSC  xA0.7
0112A:  BSF    FF2.7
0112C:  CLRF   03
0112E:  MOVWF  01
01130:  MOVF   03,W
01132:  MOVWF  02
01134:  GOTO   1AD0
.................... 	} 
....................  
.................... 	switch ( addr ) { 
01138:  MOVF   x9C,W
0113A:  MOVWF  00
0113C:  MOVF   x9D,W
0113E:  MOVWF  03
01140:  MOVF   03,W
01142:  BNZ   114E
01144:  MOVF   00,F
01146:  MOVLB  0
01148:  BTFSC  FD8.2
0114A:  BRA    156A
0114C:  MOVLB  7
0114E:  MOVF   03,W
01150:  BNZ   115E
01152:  MOVLW  01
01154:  SUBWF  00,W
01156:  MOVLB  0
01158:  BTFSC  FD8.2
0115A:  BRA    1578
0115C:  MOVLB  7
0115E:  MOVF   03,W
01160:  BNZ   116E
01162:  MOVLW  02
01164:  SUBWF  00,W
01166:  MOVLB  0
01168:  BTFSC  FD8.2
0116A:  BRA    1586
0116C:  MOVLB  7
0116E:  MOVF   03,W
01170:  BNZ   117E
01172:  MOVLW  03
01174:  SUBWF  00,W
01176:  MOVLB  0
01178:  BTFSC  FD8.2
0117A:  BRA    1594
0117C:  MOVLB  7
0117E:  MOVF   03,W
01180:  BNZ   118E
01182:  MOVLW  04
01184:  SUBWF  00,W
01186:  MOVLB  0
01188:  BTFSC  FD8.2
0118A:  BRA    15A2
0118C:  MOVLB  7
0118E:  MOVF   03,W
01190:  BNZ   119E
01192:  MOVLW  05
01194:  SUBWF  00,W
01196:  MOVLB  0
01198:  BTFSC  FD8.2
0119A:  BRA    15C8
0119C:  MOVLB  7
0119E:  MOVF   03,W
011A0:  BNZ   11AE
011A2:  MOVLW  06
011A4:  SUBWF  00,W
011A6:  MOVLB  0
011A8:  BTFSC  FD8.2
011AA:  BRA    15D6
011AC:  MOVLB  7
011AE:  MOVF   03,W
011B0:  BNZ   11BE
011B2:  MOVLW  07
011B4:  SUBWF  00,W
011B6:  MOVLB  0
011B8:  BTFSC  FD8.2
011BA:  BRA    15E4
011BC:  MOVLB  7
011BE:  MOVF   03,W
011C0:  BNZ   11CE
011C2:  MOVLW  08
011C4:  SUBWF  00,W
011C6:  MOVLB  0
011C8:  BTFSC  FD8.2
011CA:  BRA    15F2
011CC:  MOVLB  7
011CE:  MOVF   03,W
011D0:  BNZ   11DE
011D2:  MOVLW  09
011D4:  SUBWF  00,W
011D6:  MOVLB  0
011D8:  BTFSC  FD8.2
011DA:  BRA    1600
011DC:  MOVLB  7
011DE:  MOVF   03,W
011E0:  BNZ   11EE
011E2:  MOVLW  0A
011E4:  SUBWF  00,W
011E6:  MOVLB  0
011E8:  BTFSC  FD8.2
011EA:  BRA    160E
011EC:  MOVLB  7
011EE:  MOVF   03,W
011F0:  BNZ   11FE
011F2:  MOVLW  0B
011F4:  SUBWF  00,W
011F6:  MOVLB  0
011F8:  BTFSC  FD8.2
011FA:  BRA    1636
011FC:  MOVLB  7
011FE:  MOVF   03,W
01200:  BNZ   120E
01202:  MOVLW  0C
01204:  SUBWF  00,W
01206:  MOVLB  0
01208:  BTFSC  FD8.2
0120A:  BRA    1644
0120C:  MOVLB  7
0120E:  MOVF   03,W
01210:  BNZ   121E
01212:  MOVLW  0D
01214:  SUBWF  00,W
01216:  MOVLB  0
01218:  BTFSC  FD8.2
0121A:  BRA    1652
0121C:  MOVLB  7
0121E:  MOVF   03,W
01220:  BNZ   122E
01222:  MOVLW  0E
01224:  SUBWF  00,W
01226:  MOVLB  0
01228:  BTFSC  FD8.2
0122A:  BRA    1660
0122C:  MOVLB  7
0122E:  MOVF   03,W
01230:  BNZ   123E
01232:  MOVLW  0F
01234:  SUBWF  00,W
01236:  MOVLB  0
01238:  BTFSC  FD8.2
0123A:  BRA    166E
0123C:  MOVLB  7
0123E:  MOVF   03,W
01240:  BNZ   124E
01242:  MOVLW  10
01244:  SUBWF  00,W
01246:  MOVLB  0
01248:  BTFSC  FD8.2
0124A:  BRA    167C
0124C:  MOVLB  7
0124E:  MOVF   03,W
01250:  BNZ   125E
01252:  MOVLW  11
01254:  SUBWF  00,W
01256:  MOVLB  0
01258:  BTFSC  FD8.2
0125A:  BRA    16A4
0125C:  MOVLB  7
0125E:  MOVF   03,W
01260:  BNZ   126E
01262:  MOVLW  12
01264:  SUBWF  00,W
01266:  MOVLB  0
01268:  BTFSC  FD8.2
0126A:  BRA    16B2
0126C:  MOVLB  7
0126E:  MOVF   03,W
01270:  BNZ   127E
01272:  MOVLW  13
01274:  SUBWF  00,W
01276:  MOVLB  0
01278:  BTFSC  FD8.2
0127A:  BRA    16E0
0127C:  MOVLB  7
0127E:  MOVF   03,W
01280:  BNZ   128E
01282:  MOVLW  14
01284:  SUBWF  00,W
01286:  MOVLB  0
01288:  BTFSC  FD8.2
0128A:  BRA    16F8
0128C:  MOVLB  7
0128E:  MOVF   03,W
01290:  BNZ   129E
01292:  MOVLW  15
01294:  SUBWF  00,W
01296:  MOVLB  0
01298:  BTFSC  FD8.2
0129A:  BRA    1706
0129C:  MOVLB  7
0129E:  MOVF   03,W
012A0:  BNZ   12AE
012A2:  MOVLW  16
012A4:  SUBWF  00,W
012A6:  MOVLB  0
012A8:  BTFSC  FD8.2
012AA:  BRA    1734
012AC:  MOVLB  7
012AE:  MOVF   03,W
012B0:  BNZ   12BE
012B2:  MOVLW  17
012B4:  SUBWF  00,W
012B6:  MOVLB  0
012B8:  BTFSC  FD8.2
012BA:  BRA    174E
012BC:  MOVLB  7
012BE:  MOVF   03,W
012C0:  BNZ   12CE
012C2:  MOVLW  18
012C4:  SUBWF  00,W
012C6:  MOVLB  0
012C8:  BTFSC  FD8.2
012CA:  BRA    175C
012CC:  MOVLB  7
012CE:  MOVF   03,W
012D0:  BNZ   12DE
012D2:  MOVLW  19
012D4:  SUBWF  00,W
012D6:  MOVLB  0
012D8:  BTFSC  FD8.2
012DA:  BRA    178A
012DC:  MOVLB  7
012DE:  MOVF   03,W
012E0:  BNZ   12EE
012E2:  MOVLW  1A
012E4:  SUBWF  00,W
012E6:  MOVLB  0
012E8:  BTFSC  FD8.2
012EA:  BRA    17A4
012EC:  MOVLB  7
012EE:  MOVF   03,W
012F0:  BNZ   12FE
012F2:  MOVLW  1B
012F4:  SUBWF  00,W
012F6:  MOVLB  0
012F8:  BTFSC  FD8.2
012FA:  BRA    17B2
012FC:  MOVLB  7
012FE:  MOVF   03,W
01300:  BNZ   130E
01302:  MOVLW  1C
01304:  SUBWF  00,W
01306:  MOVLB  0
01308:  BTFSC  FD8.2
0130A:  BRA    17E0
0130C:  MOVLB  7
0130E:  MOVF   03,W
01310:  BNZ   131E
01312:  MOVLW  1D
01314:  SUBWF  00,W
01316:  MOVLB  0
01318:  BTFSC  FD8.2
0131A:  BRA    17FA
0131C:  MOVLB  7
0131E:  MOVF   03,W
01320:  BNZ   132E
01322:  MOVLW  1E
01324:  SUBWF  00,W
01326:  MOVLB  0
01328:  BTFSC  FD8.2
0132A:  BRA    1808
0132C:  MOVLB  7
0132E:  MOVF   03,W
01330:  BNZ   133E
01332:  MOVLW  1F
01334:  SUBWF  00,W
01336:  MOVLB  0
01338:  BTFSC  FD8.2
0133A:  BRA    1836
0133C:  MOVLB  7
0133E:  MOVF   03,W
01340:  BNZ   134E
01342:  MOVLW  20
01344:  SUBWF  00,W
01346:  MOVLB  0
01348:  BTFSC  FD8.2
0134A:  BRA    1850
0134C:  MOVLB  7
0134E:  MOVF   03,W
01350:  BNZ   135E
01352:  MOVLW  21
01354:  SUBWF  00,W
01356:  MOVLB  0
01358:  BTFSC  FD8.2
0135A:  BRA    185E
0135C:  MOVLB  7
0135E:  MOVF   03,W
01360:  BNZ   136E
01362:  MOVLW  22
01364:  SUBWF  00,W
01366:  MOVLB  0
01368:  BTFSC  FD8.2
0136A:  BRA    188C
0136C:  MOVLB  7
0136E:  MOVF   03,W
01370:  BNZ   137E
01372:  MOVLW  23
01374:  SUBWF  00,W
01376:  MOVLB  0
01378:  BTFSC  FD8.2
0137A:  BRA    18A6
0137C:  MOVLB  7
0137E:  MOVF   03,W
01380:  BNZ   138E
01382:  MOVLW  24
01384:  SUBWF  00,W
01386:  MOVLB  0
01388:  BTFSC  FD8.2
0138A:  BRA    18B4
0138C:  MOVLB  7
0138E:  MOVF   03,W
01390:  BNZ   139E
01392:  MOVLW  25
01394:  SUBWF  00,W
01396:  MOVLB  0
01398:  BTFSC  FD8.2
0139A:  BRA    18E2
0139C:  MOVLB  7
0139E:  MOVF   03,W
013A0:  BNZ   13AE
013A2:  MOVLW  26
013A4:  SUBWF  00,W
013A6:  MOVLB  0
013A8:  BTFSC  FD8.2
013AA:  BRA    18FC
013AC:  MOVLB  7
013AE:  MOVF   03,W
013B0:  BNZ   13BE
013B2:  MOVLW  27
013B4:  SUBWF  00,W
013B6:  MOVLB  0
013B8:  BTFSC  FD8.2
013BA:  BRA    190A
013BC:  MOVLB  7
013BE:  MOVF   03,W
013C0:  BNZ   13CE
013C2:  MOVLW  28
013C4:  SUBWF  00,W
013C6:  MOVLB  0
013C8:  BTFSC  FD8.2
013CA:  BRA    1938
013CC:  MOVLB  7
013CE:  MOVF   03,W
013D0:  BNZ   13DE
013D2:  MOVLW  29
013D4:  SUBWF  00,W
013D6:  MOVLB  0
013D8:  BTFSC  FD8.2
013DA:  BRA    1952
013DC:  MOVLB  7
013DE:  MOVF   03,W
013E0:  BNZ   13EE
013E2:  MOVLW  2A
013E4:  SUBWF  00,W
013E6:  MOVLB  0
013E8:  BTFSC  FD8.2
013EA:  BRA    1960
013EC:  MOVLB  7
013EE:  MOVF   03,W
013F0:  BNZ   13FE
013F2:  MOVLW  2B
013F4:  SUBWF  00,W
013F6:  MOVLB  0
013F8:  BTFSC  FD8.2
013FA:  BRA    197A
013FC:  MOVLB  7
013FE:  MOVF   03,W
01400:  BNZ   140E
01402:  MOVLW  2C
01404:  SUBWF  00,W
01406:  MOVLB  0
01408:  BTFSC  FD8.2
0140A:  BRA    198A
0140C:  MOVLB  7
0140E:  MOVF   03,W
01410:  BNZ   141E
01412:  MOVLW  2D
01414:  SUBWF  00,W
01416:  MOVLB  0
01418:  BTFSC  FD8.2
0141A:  BRA    199A
0141C:  MOVLB  7
0141E:  MOVF   03,W
01420:  BNZ   142E
01422:  MOVLW  2E
01424:  SUBWF  00,W
01426:  MOVLB  0
01428:  BTFSC  FD8.2
0142A:  BRA    19AA
0142C:  MOVLB  7
0142E:  MOVF   03,W
01430:  BNZ   143E
01432:  MOVLW  2F
01434:  SUBWF  00,W
01436:  MOVLB  0
01438:  BTFSC  FD8.2
0143A:  BRA    19BA
0143C:  MOVLB  7
0143E:  MOVF   03,W
01440:  BNZ   144E
01442:  MOVLW  30
01444:  SUBWF  00,W
01446:  MOVLB  0
01448:  BTFSC  FD8.2
0144A:  BRA    19CA
0144C:  MOVLB  7
0144E:  MOVF   03,W
01450:  BNZ   145E
01452:  MOVLW  31
01454:  SUBWF  00,W
01456:  MOVLB  0
01458:  BTFSC  FD8.2
0145A:  BRA    19DA
0145C:  MOVLB  7
0145E:  MOVF   03,W
01460:  BNZ   146E
01462:  MOVLW  32
01464:  SUBWF  00,W
01466:  MOVLB  0
01468:  BTFSC  FD8.2
0146A:  BRA    19EA
0146C:  MOVLB  7
0146E:  MOVF   03,W
01470:  BNZ   147E
01472:  MOVLW  33
01474:  SUBWF  00,W
01476:  MOVLB  0
01478:  BTFSC  FD8.2
0147A:  BRA    19FA
0147C:  MOVLB  7
0147E:  MOVLW  03
01480:  SUBWF  03,W
01482:  BNZ   1490
01484:  MOVLW  E8
01486:  SUBWF  00,W
01488:  MOVLB  0
0148A:  BTFSC  FD8.2
0148C:  BRA    1A0A
0148E:  MOVLB  7
01490:  MOVLW  03
01492:  SUBWF  03,W
01494:  BNZ   14A2
01496:  MOVLW  E9
01498:  SUBWF  00,W
0149A:  MOVLB  0
0149C:  BTFSC  FD8.2
0149E:  BRA    1A1A
014A0:  MOVLB  7
014A2:  MOVLW  03
014A4:  SUBWF  03,W
014A6:  BNZ   14B4
014A8:  MOVLW  EA
014AA:  SUBWF  00,W
014AC:  MOVLB  0
014AE:  BTFSC  FD8.2
014B0:  BRA    1A28
014B2:  MOVLB  7
014B4:  MOVLW  03
014B6:  SUBWF  03,W
014B8:  BNZ   14C6
014BA:  MOVLW  EB
014BC:  SUBWF  00,W
014BE:  MOVLB  0
014C0:  BTFSC  FD8.2
014C2:  BRA    1A36
014C4:  MOVLB  7
014C6:  MOVLW  03
014C8:  SUBWF  03,W
014CA:  BNZ   14D8
014CC:  MOVLW  EC
014CE:  SUBWF  00,W
014D0:  MOVLB  0
014D2:  BTFSC  FD8.2
014D4:  BRA    1A44
014D6:  MOVLB  7
014D8:  MOVLW  03
014DA:  SUBWF  03,W
014DC:  BNZ   14EA
014DE:  MOVLW  ED
014E0:  SUBWF  00,W
014E2:  MOVLB  0
014E4:  BTFSC  FD8.2
014E6:  BRA    1A52
014E8:  MOVLB  7
014EA:  MOVLW  03
014EC:  SUBWF  03,W
014EE:  BNZ   14FC
014F0:  MOVLW  EE
014F2:  SUBWF  00,W
014F4:  MOVLB  0
014F6:  BTFSC  FD8.2
014F8:  BRA    1A60
014FA:  MOVLB  7
014FC:  MOVLW  03
014FE:  SUBWF  03,W
01500:  BNZ   150E
01502:  MOVLW  EF
01504:  SUBWF  00,W
01506:  MOVLB  0
01508:  BTFSC  FD8.2
0150A:  BRA    1A70
0150C:  MOVLB  7
0150E:  MOVLW  03
01510:  SUBWF  03,W
01512:  BNZ   1520
01514:  MOVLW  F0
01516:  SUBWF  00,W
01518:  MOVLB  0
0151A:  BTFSC  FD8.2
0151C:  BRA    1A7E
0151E:  MOVLB  7
01520:  MOVLW  03
01522:  SUBWF  03,W
01524:  BNZ   1532
01526:  MOVLW  F1
01528:  SUBWF  00,W
0152A:  MOVLB  0
0152C:  BTFSC  FD8.2
0152E:  BRA    1A8E
01530:  MOVLB  7
01532:  MOVLW  03
01534:  SUBWF  03,W
01536:  BNZ   1544
01538:  MOVLW  F2
0153A:  SUBWF  00,W
0153C:  MOVLB  0
0153E:  BTFSC  FD8.2
01540:  BRA    1A9C
01542:  MOVLB  7
01544:  MOVLW  03
01546:  SUBWF  03,W
01548:  BNZ   1556
0154A:  MOVLW  F3
0154C:  SUBWF  00,W
0154E:  MOVLB  0
01550:  BTFSC  FD8.2
01552:  BRA    1AAA
01554:  MOVLB  7
01556:  MOVLW  03
01558:  SUBWF  03,W
0155A:  BNZ   1568
0155C:  MOVLW  F4
0155E:  SUBWF  00,W
01560:  MOVLB  0
01562:  BTFSC  FD8.2
01564:  BRA    1ABA
01566:  MOVLB  7
01568:  BRA    1AC8
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
0156A:  MOVFF  60,01
0156E:  MOVFF  61,02
01572:  MOVLB  7
01574:  BRA    1AD0
01576:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01578:  MOVF   4E,W
0157A:  MOVWF  01
0157C:  MOVF   4F,W
0157E:  MOVWF  02
01580:  MOVLB  7
01582:  BRA    1AD0
01584:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01586:  MOVF   54,W
01588:  MOVWF  01
0158A:  MOVF   55,W
0158C:  MOVWF  02
0158E:  MOVLB  7
01590:  BRA    1AD0
01592:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01594:  MOVF   5A,W
01596:  MOVWF  01
01598:  MOVF   5B,W
0159A:  MOVWF  02
0159C:  MOVLB  7
0159E:  BRA    1AD0
015A0:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
015A2:  MOVLB  7
015A4:  CLRF   x9E
015A6:  MOVLB  0
015A8:  RCALL  1002
015AA:  MOVFF  03,77E
015AE:  MOVFF  02,77D
015B2:  MOVFF  01,77C
015B6:  MOVFF  00,77B
015BA:  MOVLB  7
015BC:  MOVF   x7B,W
015BE:  MOVWF  01
015C0:  MOVF   x7C,W
015C2:  MOVWF  02
015C4:  BRA    1AD0
015C6:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
015C8:  MOVLB  7
015CA:  MOVF   x7D,W
015CC:  MOVWF  01
015CE:  MOVF   x7E,W
015D0:  MOVWF  02
015D2:  BRA    1AD0
015D4:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
015D6:  MOVF   x62,W
015D8:  MOVWF  01
015DA:  MOVF   x63,W
015DC:  MOVWF  02
015DE:  MOVLB  7
015E0:  BRA    1AD0
015E2:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
015E4:  MOVF   50,W
015E6:  MOVWF  01
015E8:  MOVF   51,W
015EA:  MOVWF  02
015EC:  MOVLB  7
015EE:  BRA    1AD0
015F0:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
015F2:  MOVF   56,W
015F4:  MOVWF  01
015F6:  MOVF   57,W
015F8:  MOVWF  02
015FA:  MOVLB  7
015FC:  BRA    1AD0
015FE:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01600:  MOVF   5C,W
01602:  MOVWF  01
01604:  MOVF   5D,W
01606:  MOVWF  02
01608:  MOVLB  7
0160A:  BRA    1AD0
0160C:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
0160E:  MOVLW  01
01610:  MOVLB  7
01612:  MOVWF  x9E
01614:  MOVLB  0
01616:  RCALL  1002
01618:  MOVFF  03,77E
0161C:  MOVFF  02,77D
01620:  MOVFF  01,77C
01624:  MOVFF  00,77B
01628:  MOVLB  7
0162A:  MOVF   x7B,W
0162C:  MOVWF  01
0162E:  MOVF   x7C,W
01630:  MOVWF  02
01632:  BRA    1AD0
01634:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01636:  MOVLB  7
01638:  MOVF   x7D,W
0163A:  MOVWF  01
0163C:  MOVF   x7E,W
0163E:  MOVWF  02
01640:  BRA    1AD0
01642:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01644:  MOVF   x64,W
01646:  MOVWF  01
01648:  MOVF   x65,W
0164A:  MOVWF  02
0164C:  MOVLB  7
0164E:  BRA    1AD0
01650:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01652:  MOVF   52,W
01654:  MOVWF  01
01656:  MOVF   53,W
01658:  MOVWF  02
0165A:  MOVLB  7
0165C:  BRA    1AD0
0165E:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01660:  MOVF   58,W
01662:  MOVWF  01
01664:  MOVF   59,W
01666:  MOVWF  02
01668:  MOVLB  7
0166A:  BRA    1AD0
0166C:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
0166E:  MOVF   5E,W
01670:  MOVWF  01
01672:  MOVF   5F,W
01674:  MOVWF  02
01676:  MOVLB  7
01678:  BRA    1AD0
0167A:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
0167C:  MOVLW  02
0167E:  MOVLB  7
01680:  MOVWF  x9E
01682:  MOVLB  0
01684:  RCALL  1002
01686:  MOVFF  03,77E
0168A:  MOVFF  02,77D
0168E:  MOVFF  01,77C
01692:  MOVFF  00,77B
01696:  MOVLB  7
01698:  MOVF   x7B,W
0169A:  MOVWF  01
0169C:  MOVF   x7C,W
0169E:  MOVWF  02
016A0:  BRA    1AD0
016A2:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
016A4:  MOVLB  7
016A6:  MOVF   x7D,W
016A8:  MOVWF  01
016AA:  MOVF   x7E,W
016AC:  MOVWF  02
016AE:  BRA    1AD0
016B0:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
016B2:  CLRF   03
016B4:  MOVLB  1
016B6:  MOVF   x82,W
016B8:  MOVWF  02
016BA:  BCF    FD8.0
016BC:  RLCF   02,F
016BE:  RLCF   03,F
016C0:  MOVF   02,W
016C2:  ADDLW  82
016C4:  MOVWF  FE9
016C6:  MOVLW  00
016C8:  ADDWFC 03,W
016CA:  MOVWF  FEA
016CC:  MOVFF  FEC,03
016D0:  MOVF   FED,F
016D2:  MOVF   FEF,W
016D4:  MOVWF  01
016D6:  MOVF   03,W
016D8:  MOVWF  02
016DA:  MOVLB  7
016DC:  BRA    1AD0
016DE:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
016E0:  MOVLB  7
016E2:  CLRF   x9E
016E4:  MOVLB  0
016E6:  CALL   0C80
016EA:  MOVF   01,W
016EC:  MOVWF  01
016EE:  MOVF   02,W
016F0:  MOVWF  02
016F2:  MOVLB  7
016F4:  BRA    1AD0
016F6:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
016F8:  MOVF   x72,W
016FA:  MOVWF  01
016FC:  MOVF   x73,W
016FE:  MOVWF  02
01700:  MOVLB  7
01702:  BRA    1AD0
01704:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01706:  CLRF   03
01708:  MOVLB  1
0170A:  MOVF   x82,W
0170C:  MOVWF  02
0170E:  BCF    FD8.0
01710:  RLCF   02,F
01712:  RLCF   03,F
01714:  MOVF   02,W
01716:  ADDLW  A2
01718:  MOVWF  FE9
0171A:  MOVLW  00
0171C:  ADDWFC 03,W
0171E:  MOVWF  FEA
01720:  MOVFF  FEC,03
01724:  MOVF   FED,F
01726:  MOVF   FEF,W
01728:  MOVWF  01
0172A:  MOVF   03,W
0172C:  MOVWF  02
0172E:  MOVLB  7
01730:  BRA    1AD0
01732:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01734:  MOVLW  01
01736:  MOVLB  7
01738:  MOVWF  x9E
0173A:  MOVLB  0
0173C:  CALL   0C80
01740:  MOVF   01,W
01742:  MOVWF  01
01744:  MOVF   02,W
01746:  MOVWF  02
01748:  MOVLB  7
0174A:  BRA    1AD0
0174C:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0174E:  MOVF   x74,W
01750:  MOVWF  01
01752:  MOVF   x75,W
01754:  MOVWF  02
01756:  MOVLB  7
01758:  BRA    1AD0
0175A:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0175C:  CLRF   03
0175E:  MOVLB  1
01760:  MOVF   x82,W
01762:  MOVWF  02
01764:  BCF    FD8.0
01766:  RLCF   02,F
01768:  RLCF   03,F
0176A:  MOVF   02,W
0176C:  ADDLW  C2
0176E:  MOVWF  FE9
01770:  MOVLW  00
01772:  ADDWFC 03,W
01774:  MOVWF  FEA
01776:  MOVFF  FEC,03
0177A:  MOVF   FED,F
0177C:  MOVF   FEF,W
0177E:  MOVWF  01
01780:  MOVF   03,W
01782:  MOVWF  02
01784:  MOVLB  7
01786:  BRA    1AD0
01788:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
0178A:  MOVLW  02
0178C:  MOVLB  7
0178E:  MOVWF  x9E
01790:  MOVLB  0
01792:  CALL   0C80
01796:  MOVF   01,W
01798:  MOVWF  01
0179A:  MOVF   02,W
0179C:  MOVWF  02
0179E:  MOVLB  7
017A0:  BRA    1AD0
017A2:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
017A4:  MOVF   x76,W
017A6:  MOVWF  01
017A8:  MOVF   x77,W
017AA:  MOVWF  02
017AC:  MOVLB  7
017AE:  BRA    1AD0
017B0:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
017B2:  CLRF   03
017B4:  MOVLB  1
017B6:  MOVF   x82,W
017B8:  MOVWF  02
017BA:  BCF    FD8.0
017BC:  RLCF   02,F
017BE:  RLCF   03,F
017C0:  MOVF   02,W
017C2:  ADDLW  E2
017C4:  MOVWF  FE9
017C6:  MOVLW  00
017C8:  ADDWFC 03,W
017CA:  MOVWF  FEA
017CC:  MOVFF  FEC,03
017D0:  MOVF   FED,F
017D2:  MOVF   FEF,W
017D4:  MOVWF  01
017D6:  MOVF   03,W
017D8:  MOVWF  02
017DA:  MOVLB  7
017DC:  BRA    1AD0
017DE:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
017E0:  MOVLW  03
017E2:  MOVLB  7
017E4:  MOVWF  x9E
017E6:  MOVLB  0
017E8:  CALL   0C80
017EC:  MOVF   01,W
017EE:  MOVWF  01
017F0:  MOVF   02,W
017F2:  MOVWF  02
017F4:  MOVLB  7
017F6:  BRA    1AD0
017F8:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
017FA:  MOVF   x78,W
017FC:  MOVWF  01
017FE:  MOVF   x79,W
01800:  MOVWF  02
01802:  MOVLB  7
01804:  BRA    1AD0
01806:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01808:  CLRF   03
0180A:  MOVLB  1
0180C:  MOVF   x82,W
0180E:  MOVWF  02
01810:  BCF    FD8.0
01812:  RLCF   02,F
01814:  RLCF   03,F
01816:  MOVF   02,W
01818:  ADDLW  02
0181A:  MOVWF  FE9
0181C:  MOVLW  01
0181E:  ADDWFC 03,W
01820:  MOVWF  FEA
01822:  MOVFF  FEC,03
01826:  MOVF   FED,F
01828:  MOVF   FEF,W
0182A:  MOVWF  01
0182C:  MOVF   03,W
0182E:  MOVWF  02
01830:  MOVLB  7
01832:  BRA    1AD0
01834:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01836:  MOVLW  04
01838:  MOVLB  7
0183A:  MOVWF  x9E
0183C:  MOVLB  0
0183E:  CALL   0C80
01842:  MOVF   01,W
01844:  MOVWF  01
01846:  MOVF   02,W
01848:  MOVWF  02
0184A:  MOVLB  7
0184C:  BRA    1AD0
0184E:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01850:  MOVF   x7A,W
01852:  MOVWF  01
01854:  MOVF   x7B,W
01856:  MOVWF  02
01858:  MOVLB  7
0185A:  BRA    1AD0
0185C:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
0185E:  CLRF   03
01860:  MOVLB  1
01862:  MOVF   x82,W
01864:  MOVWF  02
01866:  BCF    FD8.0
01868:  RLCF   02,F
0186A:  RLCF   03,F
0186C:  MOVF   02,W
0186E:  ADDLW  22
01870:  MOVWF  FE9
01872:  MOVLW  01
01874:  ADDWFC 03,W
01876:  MOVWF  FEA
01878:  MOVFF  FEC,03
0187C:  MOVF   FED,F
0187E:  MOVF   FEF,W
01880:  MOVWF  01
01882:  MOVF   03,W
01884:  MOVWF  02
01886:  MOVLB  7
01888:  BRA    1AD0
0188A:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
0188C:  MOVLW  05
0188E:  MOVLB  7
01890:  MOVWF  x9E
01892:  MOVLB  0
01894:  CALL   0C80
01898:  MOVF   01,W
0189A:  MOVWF  01
0189C:  MOVF   02,W
0189E:  MOVWF  02
018A0:  MOVLB  7
018A2:  BRA    1AD0
018A4:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
018A6:  MOVF   x7C,W
018A8:  MOVWF  01
018AA:  MOVF   x7D,W
018AC:  MOVWF  02
018AE:  MOVLB  7
018B0:  BRA    1AD0
018B2:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
018B4:  CLRF   03
018B6:  MOVLB  1
018B8:  MOVF   x82,W
018BA:  MOVWF  02
018BC:  BCF    FD8.0
018BE:  RLCF   02,F
018C0:  RLCF   03,F
018C2:  MOVF   02,W
018C4:  ADDLW  42
018C6:  MOVWF  FE9
018C8:  MOVLW  01
018CA:  ADDWFC 03,W
018CC:  MOVWF  FEA
018CE:  MOVFF  FEC,03
018D2:  MOVF   FED,F
018D4:  MOVF   FEF,W
018D6:  MOVWF  01
018D8:  MOVF   03,W
018DA:  MOVWF  02
018DC:  MOVLB  7
018DE:  BRA    1AD0
018E0:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
018E2:  MOVLW  06
018E4:  MOVLB  7
018E6:  MOVWF  x9E
018E8:  MOVLB  0
018EA:  CALL   0C80
018EE:  MOVF   01,W
018F0:  MOVWF  01
018F2:  MOVF   02,W
018F4:  MOVWF  02
018F6:  MOVLB  7
018F8:  BRA    1AD0
018FA:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
018FC:  MOVF   x7E,W
018FE:  MOVWF  01
01900:  MOVF   x7F,W
01902:  MOVWF  02
01904:  MOVLB  7
01906:  BRA    1AD0
01908:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
0190A:  CLRF   03
0190C:  MOVLB  1
0190E:  MOVF   x82,W
01910:  MOVWF  02
01912:  BCF    FD8.0
01914:  RLCF   02,F
01916:  RLCF   03,F
01918:  MOVF   02,W
0191A:  ADDLW  62
0191C:  MOVWF  FE9
0191E:  MOVLW  01
01920:  ADDWFC 03,W
01922:  MOVWF  FEA
01924:  MOVFF  FEC,03
01928:  MOVF   FED,F
0192A:  MOVF   FEF,W
0192C:  MOVWF  01
0192E:  MOVF   03,W
01930:  MOVWF  02
01932:  MOVLB  7
01934:  BRA    1AD0
01936:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01938:  MOVLW  07
0193A:  MOVLB  7
0193C:  MOVWF  x9E
0193E:  MOVLB  0
01940:  CALL   0C80
01944:  MOVF   01,W
01946:  MOVWF  01
01948:  MOVF   02,W
0194A:  MOVWF  02
0194C:  MOVLB  7
0194E:  BRA    1AD0
01950:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01952:  MOVF   x80,W
01954:  MOVWF  01
01956:  MOVF   x81,W
01958:  MOVWF  02
0195A:  MOVLB  7
0195C:  BRA    1AD0
0195E:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01960:  MOVLB  1
01962:  MOVF   x8A,W
01964:  MOVWF  03
01966:  MOVF   x89,W
01968:  INCF   x89,F
0196A:  BTFSC  FD8.2
0196C:  INCF   x8A,F
0196E:  MOVWF  01
01970:  MOVF   03,W
01972:  MOVWF  02
01974:  MOVLB  7
01976:  BRA    1AD0
01978:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
0197A:  MOVLB  1
0197C:  MOVF   x8D,W
0197E:  MOVWF  01
01980:  MOVF   x8E,W
01982:  MOVWF  02
01984:  MOVLB  7
01986:  BRA    1AD0
01988:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
0198A:  MOVLB  1
0198C:  MOVF   x8B,W
0198E:  MOVWF  01
01990:  MOVF   x8C,W
01992:  MOVWF  02
01994:  MOVLB  7
01996:  BRA    1AD0
01998:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
0199A:  MOVLB  1
0199C:  MOVF   x91,W
0199E:  MOVWF  01
019A0:  MOVF   x92,W
019A2:  MOVWF  02
019A4:  MOVLB  7
019A6:  BRA    1AD0
019A8:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
019AA:  GOTO   1064
019AE:  MOVLW  00
019B0:  MOVWF  01
019B2:  MOVWF  02
019B4:  MOVLB  7
019B6:  BRA    1AD0
019B8:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
019BA:  GOTO   10A0
019BE:  MOVLW  00
019C0:  MOVWF  01
019C2:  MOVWF  02
019C4:  MOVLB  7
019C6:  BRA    1AD0
019C8:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
019CA:  MOVLB  1
019CC:  MOVF   x83,W
019CE:  MOVWF  01
019D0:  MOVF   x84,W
019D2:  MOVWF  02
019D4:  MOVLB  7
019D6:  BRA    1AD0
019D8:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
019DA:  MOVLB  1
019DC:  MOVF   x85,W
019DE:  MOVWF  01
019E0:  MOVF   x86,W
019E2:  MOVWF  02
019E4:  MOVLB  7
019E6:  BRA    1AD0
019E8:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
019EA:  MOVLB  1
019EC:  MOVF   x87,W
019EE:  MOVWF  01
019F0:  MOVF   x88,W
019F2:  MOVWF  02
019F4:  MOVLB  7
019F6:  BRA    1AD0
019F8:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
019FA:  GOTO   10C8
019FE:  MOVLW  00
01A00:  MOVWF  01
01A02:  MOVWF  02
01A04:  MOVLB  7
01A06:  BRA    1AD0
01A08:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01A0A:  CLRF   03
01A0C:  MOVF   39,W
01A0E:  MOVWF  01
01A10:  MOVF   03,W
01A12:  MOVWF  02
01A14:  MOVLB  7
01A16:  BRA    1AD0
01A18:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01A1A:  MOVF   3A,W
01A1C:  MOVWF  01
01A1E:  MOVF   3B,W
01A20:  MOVWF  02
01A22:  MOVLB  7
01A24:  BRA    1AD0
01A26:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01A28:  MOVLW  50
01A2A:  MOVWF  01
01A2C:  MOVLW  00
01A2E:  MOVWF  02
01A30:  MOVLB  7
01A32:  BRA    1AD0
01A34:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01A36:  MOVLW  57
01A38:  MOVWF  01
01A3A:  MOVLW  00
01A3C:  MOVWF  02
01A3E:  MOVLB  7
01A40:  BRA    1AD0
01A42:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01A44:  MOVLW  58
01A46:  MOVWF  01
01A48:  MOVLW  00
01A4A:  MOVWF  02
01A4C:  MOVLB  7
01A4E:  BRA    1AD0
01A50:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01A52:  MOVLW  01
01A54:  MOVWF  01
01A56:  MOVLW  00
01A58:  MOVWF  02
01A5A:  MOVLB  7
01A5C:  BRA    1AD0
01A5E:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01A60:  CLRF   03
01A62:  MOVF   36,W
01A64:  MOVWF  01
01A66:  MOVF   03,W
01A68:  MOVWF  02
01A6A:  MOVLB  7
01A6C:  BRA    1AD0
01A6E:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01A70:  MOVF   3C,W
01A72:  MOVWF  01
01A74:  MOVF   3D,W
01A76:  MOVWF  02
01A78:  MOVLB  7
01A7A:  BRA    1AD0
01A7C:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01A7E:  CLRF   03
01A80:  MOVF   3E,W
01A82:  MOVWF  01
01A84:  MOVF   03,W
01A86:  MOVWF  02
01A88:  MOVLB  7
01A8A:  BRA    1AD0
01A8C:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01A8E:  MOVF   3F,W
01A90:  MOVWF  01
01A92:  MOVF   40,W
01A94:  MOVWF  02
01A96:  MOVLB  7
01A98:  BRA    1AD0
01A9A:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01A9C:  MOVF   41,W
01A9E:  MOVWF  01
01AA0:  MOVF   42,W
01AA2:  MOVWF  02
01AA4:  MOVLB  7
01AA6:  BRA    1AD0
01AA8:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01AAA:  CLRF   03
01AAC:  MOVF   43,W
01AAE:  MOVWF  01
01AB0:  MOVF   03,W
01AB2:  MOVWF  02
01AB4:  MOVLB  7
01AB6:  BRA    1AD0
01AB8:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01ABA:  CLRF   03
01ABC:  MOVF   38,W
01ABE:  MOVWF  01
01AC0:  MOVF   03,W
01AC2:  MOVWF  02
01AC4:  MOVLB  7
01AC6:  BRA    1AD0
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01AC8:  MOVLW  FF
01ACA:  MOVWF  01
01ACC:  MOVWF  02
01ACE:  BRA    1AD0
.................... 	} 
....................  
.................... } 
01AD0:  MOVLB  0
01AD2:  GOTO   1B24 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
00EC8:  MOVLB  7
00ECA:  MOVF   x92,W
00ECC:  SUBLW  1F
00ECE:  BNZ   0EE8
00ED0:  MOVF   x93,W
00ED2:  SUBLW  4E
00ED4:  BNZ   0EE8
00ED6:  MOVF   x94,W
00ED8:  SUBLW  20
00EDA:  BNZ   0EE8
00EDC:  MOVF   x95,W
00EDE:  SUBLW  4E
00EE0:  BNZ   0EE8
.................... 		return 1; 
00EE2:  MOVLW  01
00EE4:  MOVWF  01
00EE6:  BRA    0F44
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
00EE8:  MOVF   x93,W
00EEA:  SUBLW  02
00EEC:  BC    0F0C
00EEE:  XORLW  FF
00EF0:  BNZ   0EF8
00EF2:  MOVF   x92,W
00EF4:  SUBLW  E7
00EF6:  BC    0F0C
00EF8:  MOVF   x95,W
00EFA:  SUBLW  03
00EFC:  BNC   0F0C
00EFE:  BNZ   0F06
00F00:  MOVF   x94,W
00F02:  SUBLW  F5
00F04:  BNC   0F0C
.................... 		return 1; 
00F06:  MOVLW  01
00F08:  MOVWF  01
00F0A:  BRA    0F44
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
00F0C:  MOVF   x93,W
00F0E:  SUBLW  06
00F10:  BC    0F30
00F12:  XORLW  FF
00F14:  BNZ   0F1C
00F16:  MOVF   x92,W
00F18:  SUBLW  CF
00F1A:  BC    0F30
00F1C:  MOVF   x95,W
00F1E:  SUBLW  09
00F20:  BNC   0F30
00F22:  BNZ   0F2A
00F24:  MOVF   x94,W
00F26:  SUBLW  D1
00F28:  BNC   0F30
.................... 		return 1; 
00F2A:  MOVLW  01
00F2C:  MOVWF  01
00F2E:  BRA    0F44
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
00F30:  MOVF   x95,F
00F32:  BNZ   0F40
00F34:  MOVF   x94,W
00F36:  SUBLW  34
00F38:  BNC   0F40
.................... 		return 1; 
00F3A:  MOVLW  01
00F3C:  MOVWF  01
00F3E:  BRA    0F44
....................  
.................... 	return 0; 
00F40:  MOVLW  00
00F42:  MOVWF  01
.................... } 
00F44:  MOVLB  0
00F46:  GOTO   1F8A (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01AD6:  MOVFF  791,79A
01ADA:  MOVFF  790,79B
01ADE:  CALL   0F86
.................... 	modbus_serial_putc(register_count*2); 
01AE2:  BCF    FD8.0
01AE4:  MOVLB  7
01AE6:  RLCF   x94,W
01AE8:  MOVWF  x9A
01AEA:  RLCF   x95,W
01AEC:  MOVWF  x9B
01AEE:  MOVFF  79A,79C
01AF2:  MOVLB  0
01AF4:  CALL   0F52
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01AF8:  MOVLB  7
01AFA:  CLRF   x97
01AFC:  CLRF   x96
01AFE:  MOVF   x97,W
01B00:  SUBWF  x95,W
01B02:  BNC   1B4E
01B04:  BNZ   1B0C
01B06:  MOVF   x94,W
01B08:  SUBWF  x96,W
01B0A:  BC    1B4E
.................... 		l=map_modbus(start_address+i); 
01B0C:  MOVF   x96,W
01B0E:  ADDWF  x92,W
01B10:  MOVWF  x9A
01B12:  MOVF   x97,W
01B14:  ADDWFC x93,W
01B16:  MOVWF  x9B
01B18:  MOVWF  x9D
01B1A:  MOVFF  79A,79C
01B1E:  MOVLB  0
01B20:  GOTO   10DC
01B24:  MOVFF  02,799
01B28:  MOVFF  01,798
.................... 		modbus_serial_putc(make8(l,1)); 
01B2C:  MOVFF  799,79A
01B30:  MOVFF  799,79C
01B34:  CALL   0F52
....................   		modbus_serial_putc(make8(l,0)); 
01B38:  MOVFF  798,79A
01B3C:  MOVFF  798,79C
01B40:  CALL   0F52
.................... 	} 
01B44:  MOVLB  7
01B46:  INCF   x96,F
01B48:  BTFSC  FD8.2
01B4A:  INCF   x97,F
01B4C:  BRA    1AFE
....................  
.................... 	modbus_serial_send_stop(); 
01B4E:  MOVLB  0
01B50:  CALL   0FB4
.................... } 
01B54:  GOTO   1FCC (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01B58:  MOVLB  7
01B5A:  MOVF   x97,W
01B5C:  SUBLW  06
01B5E:  BC    1BD6
01B60:  XORLW  FF
01B62:  BNZ   1B6A
01B64:  MOVF   x96,W
01B66:  SUBLW  CF
01B68:  BC    1BD6
01B6A:  MOVF   x97,W
01B6C:  SUBLW  09
01B6E:  BNC   1BD6
01B70:  BNZ   1B78
01B72:  MOVF   x96,W
01B74:  SUBLW  CF
01B76:  BNC   1BD6
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01B78:  MOVF   x99,W
01B7A:  SUBLW  00
01B7C:  BC    1B8E
01B7E:  XORLW  FF
01B80:  BNZ   1B88
01B82:  MOVF   x98,W
01B84:  SUBLW  00
01B86:  BC    1B8E
01B88:  MOVLW  03
01B8A:  MOVWF  01
01B8C:  BRA    1DC2
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01B8E:  MOVLW  D0
01B90:  SUBWF  x96,W
01B92:  MOVWF  x9A
01B94:  MOVLW  07
01B96:  SUBWFB x97,W
01B98:  MOVWF  x9B
01B9A:  MOVLW  02
01B9C:  ADDWF  x9B,F
01B9E:  MOVFF  79B,FAA
01BA2:  MOVFF  79A,FA9
01BA6:  MOVFF  798,FA8
01BAA:  BCF    FA6.6
01BAC:  BCF    FA6.7
01BAE:  BSF    FA6.2
01BB0:  MOVF   FF2,W
01BB2:  MOVWF  00
01BB4:  BCF    FF2.6
01BB6:  BCF    FF2.7
01BB8:  MOVLB  F
01BBA:  MOVLW  55
01BBC:  MOVWF  FA7
01BBE:  MOVLW  AA
01BC0:  MOVWF  FA7
01BC2:  BSF    FA6.1
01BC4:  BTFSC  FA6.1
01BC6:  BRA    1BC4
01BC8:  BCF    FA6.2
01BCA:  MOVF   00,W
01BCC:  IORWF  FF2,F
.................... 		return 0; 
01BCE:  MOVLW  00
01BD0:  MOVWF  01
01BD2:  MOVLB  7
01BD4:  BRA    1DC2
.................... 	} 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01BD6:  MOVLB  1
01BD8:  MOVF   x8F,F
01BDA:  BZ    1C12
.................... 		if ( 1000 == address ) { 
01BDC:  MOVLB  7
01BDE:  MOVF   x96,W
01BE0:  SUBLW  E8
01BE2:  BNZ   1BF6
01BE4:  MOVF   x97,W
01BE6:  SUBLW  03
01BE8:  BNZ   1BF6
.................... 			config.serial_prefix=value; 
01BEA:  MOVFF  798,39
.................... 			return 0; 
01BEE:  MOVLW  00
01BF0:  MOVWF  01
01BF2:  BRA    1DC2
.................... 		} else if ( 1001 == address ) { 
01BF4:  BRA    1C10
01BF6:  MOVF   x96,W
01BF8:  SUBLW  E9
01BFA:  BNZ   1C10
01BFC:  MOVF   x97,W
01BFE:  SUBLW  03
01C00:  BNZ   1C10
.................... 			config.serial_number=value; 
01C02:  MOVFF  799,3B
01C06:  MOVFF  798,3A
.................... 			return 0; 
01C0A:  MOVLW  00
01C0C:  MOVWF  01
01C0E:  BRA    1DC2
01C10:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01C12:  MOVLB  7
01C14:  MOVF   x96,W
01C16:  MOVWF  00
01C18:  MOVF   x97,W
01C1A:  MOVWF  03
01C1C:  MOVLW  03
01C1E:  SUBWF  03,W
01C20:  BNZ   1C2C
01C22:  MOVLW  EE
01C24:  SUBWF  00,W
01C26:  MOVLB  0
01C28:  BZ    1CC6
01C2A:  MOVLB  7
01C2C:  MOVLW  03
01C2E:  SUBWF  03,W
01C30:  BNZ   1C3C
01C32:  MOVLW  EF
01C34:  SUBWF  00,W
01C36:  MOVLB  0
01C38:  BZ    1CDE
01C3A:  MOVLB  7
01C3C:  MOVLW  03
01C3E:  SUBWF  03,W
01C40:  BNZ   1C4C
01C42:  MOVLW  F0
01C44:  SUBWF  00,W
01C46:  MOVLB  0
01C48:  BZ    1CEE
01C4A:  MOVLB  7
01C4C:  MOVLW  03
01C4E:  SUBWF  03,W
01C50:  BNZ   1C5C
01C52:  MOVLW  F1
01C54:  SUBWF  00,W
01C56:  MOVLB  0
01C58:  BZ    1D06
01C5A:  MOVLB  7
01C5C:  MOVLW  03
01C5E:  SUBWF  03,W
01C60:  BNZ   1C6C
01C62:  MOVLW  F2
01C64:  SUBWF  00,W
01C66:  MOVLB  0
01C68:  BZ    1D12
01C6A:  MOVLB  7
01C6C:  MOVLW  03
01C6E:  SUBWF  03,W
01C70:  BNZ   1C7C
01C72:  MOVLW  F3
01C74:  SUBWF  00,W
01C76:  MOVLB  0
01C78:  BZ    1D2C
01C7A:  MOVLB  7
01C7C:  MOVLW  03
01C7E:  SUBWF  03,W
01C80:  BNZ   1C8E
01C82:  MOVLW  F4
01C84:  SUBWF  00,W
01C86:  MOVLB  0
01C88:  BTFSC  FD8.2
01C8A:  BRA    1D44
01C8C:  MOVLB  7
01C8E:  MOVLW  07
01C90:  SUBWF  03,W
01C92:  BNZ   1CA0
01C94:  MOVLW  CE
01C96:  SUBWF  00,W
01C98:  MOVLB  0
01C9A:  BTFSC  FD8.2
01C9C:  BRA    1D5C
01C9E:  MOVLB  7
01CA0:  MOVLW  07
01CA2:  SUBWF  03,W
01CA4:  BNZ   1CB2
01CA6:  MOVLW  CF
01CA8:  SUBWF  00,W
01CAA:  MOVLB  0
01CAC:  BTFSC  FD8.2
01CAE:  BRA    1D76
01CB0:  MOVLB  7
01CB2:  MOVLW  4E
01CB4:  SUBWF  03,W
01CB6:  BNZ   1CC4
01CB8:  MOVLW  1F
01CBA:  SUBWF  00,W
01CBC:  MOVLB  0
01CBE:  BTFSC  FD8.2
01CC0:  BRA    1D90
01CC2:  MOVLB  7
01CC4:  BRA    1DB8
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01CC6:  MOVLB  7
01CC8:  MOVF   x99,F
01CCA:  BNZ   1CD2
01CCC:  MOVF   x98,W
01CCE:  SUBLW  80
01CD0:  BC    1CD8
01CD2:  MOVLW  03
01CD4:  MOVWF  01
01CD6:  BRA    1DC2
.................... 			config.modbus_address=value; 
01CD8:  MOVFF  798,36
.................... 			break; 
01CDC:  BRA    1DBE
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01CDE:  MOVLB  1
01CE0:  BSF    xAE.1
.................... 			config.adc_sample_ticks=value; 
01CE2:  MOVFF  799,3D
01CE6:  MOVFF  798,3C
.................... 			break; 
01CEA:  MOVLB  7
01CEC:  BRA    1DBE
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01CEE:  MOVLB  7
01CF0:  MOVF   x99,F
01CF2:  BNZ   1CFA
01CF4:  MOVF   x98,W
01CF6:  SUBLW  01
01CF8:  BC    1D00
01CFA:  MOVLW  03
01CFC:  MOVWF  01
01CFE:  BRA    1DC2
.................... 			config.allow_bootload_request=value; 
01D00:  MOVFF  798,3E
.................... 			break; 
01D04:  BRA    1DBE
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01D06:  MOVFF  799,40
01D0A:  MOVFF  798,3F
.................... 			break; 
01D0E:  MOVLB  7
01D10:  BRA    1DBE
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01D12:  MOVLB  7
01D14:  MOVF   x98,F
01D16:  BNZ   1D22
01D18:  MOVF   x99,F
01D1A:  BNZ   1D22
01D1C:  MOVLW  03
01D1E:  MOVWF  01
01D20:  BRA    1DC2
.................... 			config.pi_offtime_seconds=value; 
01D22:  MOVFF  799,42
01D26:  MOVFF  798,41
.................... 			break; 
01D2A:  BRA    1DBE
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01D2C:  MOVLB  7
01D2E:  MOVF   x99,F
01D30:  BNZ   1D38
01D32:  MOVF   x98,W
01D34:  SUBLW  01
01D36:  BC    1D3E
01D38:  MOVLW  03
01D3A:  MOVWF  01
01D3C:  BRA    1DC2
.................... 			config.power_startup=value; 
01D3E:  MOVFF  798,43
.................... 			break; 
01D42:  BRA    1DBE
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
01D44:  MOVLB  7
01D46:  MOVF   x99,F
01D48:  BNZ   1D50
01D4A:  MOVF   x98,W
01D4C:  SUBLW  02
01D4E:  BC    1D56
01D50:  MOVLW  03
01D52:  MOVWF  01
01D54:  BRA    1DC2
.................... 			config.rs485_port_mode=value; 
01D56:  MOVFF  798,38
.................... 			break; 
01D5A:  BRA    1DBE
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01D5C:  MOVLB  7
01D5E:  DECFSZ x98,W
01D60:  BRA    1D66
01D62:  MOVF   x99,F
01D64:  BZ    1D6C
01D66:  MOVLW  03
01D68:  MOVWF  01
01D6A:  BRA    1DC2
.................... 			write_default_param_file(); 
01D6C:  MOVLB  0
01D6E:  CALL   0A36
.................... 			break; 
01D72:  MOVLB  7
01D74:  BRA    1DBE
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01D76:  MOVLB  7
01D78:  DECFSZ x98,W
01D7A:  BRA    1D80
01D7C:  MOVF   x99,F
01D7E:  BZ    1D86
01D80:  MOVLW  03
01D82:  MOVWF  01
01D84:  BRA    1DC2
.................... 			write_param_file(); 
01D86:  MOVLB  0
01D88:  CALL   09E2
.................... 			break; 
01D8C:  MOVLB  7
01D8E:  BRA    1DBE
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01D90:  MOVLB  7
01D92:  MOVF   x98,W
01D94:  SUBLW  0A
01D96:  BNZ   1D9E
01D98:  MOVF   x99,W
01D9A:  SUBLW  07
01D9C:  BZ    1DAA
.................... 				current.factory_unlocked=0; 
01D9E:  MOVLB  1
01DA0:  CLRF   x8F
.................... 				return ILLEGAL_DATA_VALUE; 
01DA2:  MOVLW  03
01DA4:  MOVWF  01
01DA6:  MOVLB  7
01DA8:  BRA    1DC2
.................... 			} 
.................... 			current.factory_unlocked=1; 
01DAA:  MOVLW  01
01DAC:  MOVLB  1
01DAE:  MOVWF  x8F
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01DB0:  MOVLW  C8
01DB2:  MOVWF  xAB
.................... 			break; 
01DB4:  MOVLB  7
01DB6:  BRA    1DBE
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01DB8:  MOVLW  02
01DBA:  MOVWF  01
01DBC:  BRA    1DC2
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01DBE:  MOVLW  00
01DC0:  MOVWF  01
.................... } 
01DC2:  MOVLB  0
01DC4:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
01E56:  GOTO   0E82
01E5A:  MOVF   01,F
01E5C:  BTFSC  FD8.2
01E5E:  BRA    2142
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
01E60:  DECFSZ 38,W
01E62:  BRA    1F16
01E64:  MOVF   36,W
01E66:  MOVLB  6
01E68:  SUBWF  x78,W
01E6A:  BTFSS  FD8.2
01E6C:  BRA    1E72
01E6E:  MOVLB  0
01E70:  BRA    1F16
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
01E72:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
01E74:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
01E76:  CLRWDT
01E78:  MOVLW  02
01E7A:  MOVLB  7
01E7C:  MOVWF  x90
01E7E:  MOVLW  B5
01E80:  MOVWF  x91
01E82:  MOVLB  0
01E84:  CALL   0EA8
01E88:  MOVLB  7
01E8A:  DECFSZ x90,F
01E8C:  BRA    1E7E
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
01E8E:  MOVLB  6
01E90:  MOVF   x78,W
01E92:  MOVLB  0
01E94:  CALL   067E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
01E98:  CLRWDT
01E9A:  MOVLW  67
01E9C:  MOVWF  00
01E9E:  DECFSZ 00,F
01EA0:  BRA    1E9E
01EA2:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
01EA4:  MOVLB  6
01EA6:  MOVF   x7A,W
01EA8:  MOVLB  0
01EAA:  CALL   067E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
01EAE:  CLRWDT
01EB0:  MOVLW  67
01EB2:  MOVWF  00
01EB4:  DECFSZ 00,F
01EB6:  BRA    1EB4
01EB8:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
01EBA:  MOVLB  7
01EBC:  CLRF   x8F
01EBE:  MOVLW  02
01EC0:  MOVLB  6
01EC2:  ADDWF  x79,W
01EC4:  MOVLB  7
01EC6:  SUBWF  x8F,W
01EC8:  BC    1EF6
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
01ECA:  MOVLW  7C
01ECC:  ADDWF  x8F,W
01ECE:  MOVWF  FE9
01ED0:  MOVLW  06
01ED2:  MOVWF  FEA
01ED4:  BTFSC  FD8.0
01ED6:  INCF   FEA,F
01ED8:  MOVFF  FEF,790
01EDC:  MOVF   x90,W
01EDE:  MOVLB  0
01EE0:  CALL   067E
.................... 				delay_us(104); //one stop bit @ 9600 baud 
01EE4:  CLRWDT
01EE6:  MOVLW  67
01EE8:  MOVWF  00
01EEA:  DECFSZ 00,F
01EEC:  BRA    1EEA
01EEE:  NOP   
.................... 			} 
01EF0:  MOVLB  7
01EF2:  INCF   x8F,F
01EF4:  BRA    1EBE
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
01EF6:  BTFSS  F72.1
01EF8:  BRA    1EF6
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
01EFA:  CLRWDT
01EFC:  MOVLW  02
01EFE:  MOVWF  x90
01F00:  MOVLW  B5
01F02:  MOVWF  x91
01F04:  MOVLB  0
01F06:  CALL   0EA8
01F0A:  MOVLB  7
01F0C:  DECFSZ x90,F
01F0E:  BRA    1F00
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
01F10:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
01F12:  BCF    F8C.0
01F14:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
01F16:  MOVF   36,W
01F18:  SUBLW  80
01F1A:  BZ    1F28
01F1C:  MOVF   36,W
01F1E:  MOVLB  6
01F20:  SUBWF  x78,W
01F22:  BTFSS  FD8.2
01F24:  BRA    212C
01F26:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
01F28:  MOVLB  1
01F2A:  INCFSZ x83,W
01F2C:  BRA    1F34
01F2E:  INCFSZ x84,W
01F30:  BRA    1F34
01F32:  BRA    1F3A
.................... 				current.modbus_our_packets++; 
01F34:  INCF   x83,F
01F36:  BTFSC  FD8.2
01F38:  INCF   x84,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
01F3A:  MOVLW  14
01F3C:  MOVWF  xAB
....................  
.................... 			switch(modbus_rx.func) { 
01F3E:  MOVLB  6
01F40:  MOVF   x7A,W
01F42:  XORLW  03
01F44:  MOVLB  0
01F46:  BZ    1F58
01F48:  XORLW  07
01F4A:  BZ    1F58
01F4C:  XORLW  02
01F4E:  BZ    1FD0
01F50:  XORLW  16
01F52:  BTFSC  FD8.2
01F54:  BRA    2042
01F56:  BRA    2104
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01F58:  MOVFF  67C,78B
01F5C:  MOVFF  67D,78A
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01F60:  MOVFF  67E,78D
01F64:  MOVFF  67F,78C
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
01F68:  MOVLB  7
01F6A:  MOVF   x8C,W
01F6C:  ADDWF  x8A,W
01F6E:  MOVWF  x90
01F70:  MOVF   x8D,W
01F72:  ADDWFC x8B,W
01F74:  MOVWF  x91
01F76:  MOVFF  78B,793
01F7A:  MOVFF  78A,792
01F7E:  MOVWF  x95
01F80:  MOVFF  790,794
01F84:  MOVLB  0
01F86:  GOTO   0EC8
01F8A:  MOVF   01,F
01F8C:  BNZ   1FB2
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
01F8E:  MOVFF  678,790
01F92:  MOVLB  7
01F94:  CLRF   x92
01F96:  MOVFF  67A,791
01F9A:  MOVLW  02
01F9C:  MOVWF  x93
01F9E:  MOVLB  0
01FA0:  CALL   0FE2
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
01FA4:  MOVLB  1
01FA6:  CLRF   x88
01FA8:  MOVLW  02
01FAA:  MOVWF  x87
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
01FAC:  CLRF   xAB
.................... 					} else { 
01FAE:  BRA    1FCE
01FB0:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
01FB2:  MOVFF  67A,790
01FB6:  MOVFF  678,791
01FBA:  MOVFF  78B,793
01FBE:  MOVFF  78A,792
01FC2:  MOVFF  78D,795
01FC6:  MOVFF  78C,794
01FCA:  BRA    1AD6
01FCC:  MOVLB  1
.................... 					} 
.................... 					break; 
01FCE:  BRA    2124
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01FD0:  MOVFF  67C,78B
01FD4:  MOVFF  67D,78A
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
01FD8:  MOVFF  67E,791
01FDC:  MOVFF  67F,790
01FE0:  MOVFF  78B,797
01FE4:  MOVFF  78A,796
01FE8:  MOVFF  67E,799
01FEC:  MOVFF  67F,798
01FF0:  RCALL  1B58
01FF2:  MOVFF  01,78E
....................  
.................... 					if ( result ) { 
01FF6:  MOVLB  7
01FF8:  MOVF   x8E,F
01FFA:  BZ    201E
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
01FFC:  MOVFF  678,790
02000:  CLRF   x92
02002:  MOVFF  67A,791
02006:  MOVFF  78E,793
0200A:  MOVLB  0
0200C:  CALL   0FE2
.................... 						current.modbus_last_error=result; 
02010:  MOVLB  1
02012:  CLRF   x88
02014:  MOVFF  78E,187
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02018:  CLRF   xAB
.................... 					}  else { 
0201A:  BRA    2040
0201C:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
0201E:  MOVFF  67E,791
02022:  MOVFF  67F,790
02026:  MOVFF  678,792
0202A:  MOVFF  78B,794
0202E:  MOVFF  78A,793
02032:  MOVFF  67E,796
02036:  MOVFF  67F,795
0203A:  MOVLB  0
0203C:  BRA    1DC6
0203E:  MOVLB  1
.................... 					} 
.................... 					break; 
02040:  BRA    2124
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02042:  MOVFF  67C,78B
02046:  MOVFF  67D,78A
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
0204A:  MOVFF  67E,78D
0204E:  MOVFF  67F,78C
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02052:  MOVLB  7
02054:  CLRF   x8F
02056:  MOVF   x8D,F
02058:  BNZ   2060
0205A:  MOVF   x8C,W
0205C:  SUBWF  x8F,W
0205E:  BC    20E4
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02060:  MOVF   x8F,W
02062:  ADDWF  x8A,W
02064:  MOVWF  x90
02066:  MOVLW  00
02068:  ADDWFC x8B,W
0206A:  MOVWF  x91
0206C:  BCF    FD8.0
0206E:  RLCF   x8F,W
02070:  ADDLW  05
02072:  ADDLW  7C
02074:  MOVWF  FE9
02076:  MOVLW  06
02078:  MOVWF  FEA
0207A:  BTFSC  FD8.0
0207C:  INCF   FEA,F
0207E:  MOVFF  FEF,792
02082:  BCF    FD8.0
02084:  RLCF   x8F,W
02086:  ADDLW  06
02088:  ADDLW  7C
0208A:  MOVWF  FE9
0208C:  MOVLW  06
0208E:  MOVWF  FEA
02090:  BTFSC  FD8.0
02092:  INCF   FEA,F
02094:  MOVFF  FEF,793
02098:  MOVFF  792,795
0209C:  MOVFF  793,794
020A0:  MOVFF  791,797
020A4:  MOVFF  790,796
020A8:  MOVFF  792,799
020AC:  MOVFF  793,798
020B0:  MOVLB  0
020B2:  RCALL  1B58
020B4:  MOVFF  01,78E
....................  
.................... 						if ( result ) { 
020B8:  MOVLB  7
020BA:  MOVF   x8E,F
020BC:  BZ    20E0
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
020BE:  MOVFF  678,790
020C2:  CLRF   x92
020C4:  MOVFF  67A,791
020C8:  MOVFF  78E,793
020CC:  MOVLB  0
020CE:  CALL   0FE2
.................... 							current.modbus_last_error=result; 
020D2:  MOVLB  1
020D4:  CLRF   x88
020D6:  MOVFF  78E,187
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
020DA:  CLRF   xAB
.................... 			 
.................... 							break; 
020DC:  MOVLB  7
020DE:  BRA    20E4
.................... 						} 
.................... 					} 
020E0:  INCF   x8F,F
020E2:  BRA    2056
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
020E4:  MOVF   x8E,F
020E6:  BNZ   2100
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
020E8:  MOVFF  678,790
020EC:  MOVFF  78B,792
020F0:  MOVFF  78A,791
020F4:  MOVFF  78D,794
020F8:  MOVFF  78C,793
020FC:  MOVLB  0
020FE:  BRA    1E0E
.................... 					} 
....................  
.................... 					break;   
02100:  MOVLB  1
02102:  BRA    2124
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02104:  MOVFF  678,790
02108:  MOVLB  7
0210A:  CLRF   x92
0210C:  MOVFF  67A,791
02110:  MOVLW  01
02112:  MOVWF  x93
02114:  MOVLB  0
02116:  CALL   0FE2
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
0211A:  MOVLB  1
0211C:  CLRF   x88
0211E:  MOVLW  01
02120:  MOVWF  x87
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02122:  CLRF   xAB
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02124:  CLRF   x92
02126:  CLRF   x91
....................  
.................... 		} else { 
02128:  BRA    2142
0212A:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
0212C:  MOVLB  1
0212E:  INCFSZ x85,W
02130:  BRA    2138
02132:  INCFSZ x86,W
02134:  BRA    2138
02136:  BRA    213E
.................... 				current.modbus_other_packets++; 
02138:  INCF   x85,F
0213A:  BTFSC  FD8.2
0213C:  INCF   x86,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
0213E:  MOVLW  0A
02140:  MOVWF  xAB
02142:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02144:  GOTO   22DE (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003E2:  MOVLB  8
003E4:  BTFSS  x91.0
003E6:  BRA    0400
003E8:  MOVLB  1
003EA:  INCFSZ x9A,W
003EC:  BRA    03F8
003EE:  INCFSZ x9B,W
003F0:  BRA    03F8
003F2:  MOVLB  8
003F4:  BRA    0400
003F6:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
003F8:  INCF   x9A,F
003FA:  BTFSC  FD8.2
003FC:  INCF   x9B,F
003FE:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00400:  BTFSS  x91.2
00402:  BRA    041C
00404:  MOVLB  1
00406:  INCFSZ x9C,W
00408:  BRA    0414
0040A:  INCFSZ x9D,W
0040C:  BRA    0414
0040E:  MOVLB  8
00410:  BRA    041C
00412:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00414:  INCF   x9C,F
00416:  BTFSC  FD8.2
00418:  INCF   x9D,F
0041A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0041C:  BTFSS  x91.4
0041E:  BRA    0438
00420:  MOVLB  1
00422:  INCFSZ x9E,W
00424:  BRA    0430
00426:  INCFSZ x9F,W
00428:  BRA    0430
0042A:  MOVLB  8
0042C:  BRA    0438
0042E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00430:  INCF   x9E,F
00432:  BTFSC  FD8.2
00434:  INCF   x9F,F
00436:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00438:  BCF    x91.1
0043A:  BTFSC  F81.0
0043C:  BSF    x91.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0043E:  BTFSC  x91.1
00440:  BRA    04C2
00442:  MOVLB  6
00444:  BTFSC  x74.1
00446:  BRA    044C
00448:  MOVLB  8
0044A:  BRA    04C2
.................... 		current.pulse_count[0]++; 
0044C:  MOVLB  0
0044E:  INCF   x60,F
00450:  BTFSC  FD8.2
00452:  INCF   x61,F
.................... 		current.pulse_sum[0]++; 
00454:  MOVLW  01
00456:  ADDWF  x66,F
00458:  BTFSC  FD8.0
0045A:  INCF   x67,F
0045C:  BTFSC  FD8.2
0045E:  INCF   x68,F
00460:  BTFSC  FD8.2
00462:  INCF   x69,F
.................... 		if ( 1 == ext0_state ) { 
00464:  MOVLB  6
00466:  BTFSS  x74.2
00468:  BRA    04B0
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0046A:  MOVLB  8
0046C:  BCF    x91.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0046E:  MOVFF  19B,4F
00472:  MOVFF  19A,4E
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
00476:  MOVF   4F,W
00478:  SUBWF  55,W
0047A:  BNC   048C
0047C:  BNZ   0484
0047E:  MOVF   54,W
00480:  SUBWF  4E,W
00482:  BC    048C
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00484:  MOVFF  4F,55
00488:  MOVFF  4E,54
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0048C:  MOVF   5B,W
0048E:  SUBWF  4F,W
00490:  BNC   04AC
00492:  BNZ   049A
00494:  MOVF   4E,W
00496:  SUBWF  5A,W
00498:  BC    04AC
0049A:  INCFSZ 4E,W
0049C:  BRA    04A4
0049E:  INCFSZ 4F,W
004A0:  BRA    04A4
004A2:  BRA    04AC
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004A4:  MOVFF  4F,5B
004A8:  MOVFF  4E,5A
.................... 			} 
.................... 			ext0_state=0; 
004AC:  MOVLB  6
004AE:  BCF    x74.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004B0:  BTFSC  x74.2
004B2:  BRA    04C2
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004B4:  MOVLB  1
004B6:  CLRF   x9B
004B8:  CLRF   x9A
.................... 			ext0_count=1; 
004BA:  MOVLB  8
004BC:  BSF    x91.0
.................... 			ext0_state=1; 
004BE:  MOVLB  6
004C0:  BSF    x74.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004C2:  MOVLB  6
004C4:  BCF    x74.1
004C6:  MOVLB  8
004C8:  BTFSS  x91.1
004CA:  BRA    04D2
004CC:  MOVLB  6
004CE:  BSF    x74.1
004D0:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004D2:  BCF    x91.3
004D4:  BTFSC  F81.1
004D6:  BSF    x91.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004D8:  BTFSC  x91.3
004DA:  BRA    055C
004DC:  MOVLB  6
004DE:  BTFSC  x74.3
004E0:  BRA    04E6
004E2:  MOVLB  8
004E4:  BRA    055C
.................... 		current.pulse_count[1]++; 
004E6:  MOVLB  0
004E8:  INCF   x62,F
004EA:  BTFSC  FD8.2
004EC:  INCF   x63,F
.................... 		current.pulse_sum[1]++; 
004EE:  MOVLW  01
004F0:  ADDWF  x6A,F
004F2:  BTFSC  FD8.0
004F4:  INCF   x6B,F
004F6:  BTFSC  FD8.2
004F8:  INCF   x6C,F
004FA:  BTFSC  FD8.2
004FC:  INCF   x6D,F
.................... 		if ( 1 == ext1_state ) { 
004FE:  MOVLB  6
00500:  BTFSS  x74.4
00502:  BRA    054A
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00504:  MOVLB  8
00506:  BCF    x91.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00508:  MOVFF  19D,51
0050C:  MOVFF  19C,50
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00510:  MOVF   51,W
00512:  SUBWF  57,W
00514:  BNC   0526
00516:  BNZ   051E
00518:  MOVF   56,W
0051A:  SUBWF  50,W
0051C:  BC    0526
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0051E:  MOVFF  51,57
00522:  MOVFF  50,56
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00526:  MOVF   5D,W
00528:  SUBWF  51,W
0052A:  BNC   0546
0052C:  BNZ   0534
0052E:  MOVF   50,W
00530:  SUBWF  5C,W
00532:  BC    0546
00534:  INCFSZ 50,W
00536:  BRA    053E
00538:  INCFSZ 51,W
0053A:  BRA    053E
0053C:  BRA    0546
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
0053E:  MOVFF  51,5D
00542:  MOVFF  50,5C
.................... 			} 
.................... 			ext1_state=0; 
00546:  MOVLB  6
00548:  BCF    x74.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0054A:  BTFSC  x74.4
0054C:  BRA    055C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
0054E:  MOVLB  1
00550:  CLRF   x9D
00552:  CLRF   x9C
.................... 			ext1_count=1; 
00554:  MOVLB  8
00556:  BSF    x91.2
.................... 			ext1_state=1; 
00558:  MOVLB  6
0055A:  BSF    x74.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
0055C:  MOVLB  6
0055E:  BCF    x74.3
00560:  MOVLB  8
00562:  BTFSS  x91.3
00564:  BRA    056C
00566:  MOVLB  6
00568:  BSF    x74.3
0056A:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0056C:  BCF    x91.5
0056E:  BTFSC  F81.2
00570:  BSF    x91.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00572:  BTFSC  x91.5
00574:  BRA    05F6
00576:  MOVLB  6
00578:  BTFSC  x74.5
0057A:  BRA    0580
0057C:  MOVLB  8
0057E:  BRA    05F6
.................... 		current.pulse_count[2]++; 
00580:  MOVLB  0
00582:  INCF   x64,F
00584:  BTFSC  FD8.2
00586:  INCF   x65,F
.................... 		current.pulse_sum[2]++; 
00588:  MOVLW  01
0058A:  ADDWF  x6E,F
0058C:  BTFSC  FD8.0
0058E:  INCF   x6F,F
00590:  BTFSC  FD8.2
00592:  INCF   x70,F
00594:  BTFSC  FD8.2
00596:  INCF   x71,F
.................... 		if ( 1 == ext2_state ) { 
00598:  MOVLB  6
0059A:  BTFSS  x74.6
0059C:  BRA    05E4
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0059E:  MOVLB  8
005A0:  BCF    x91.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005A2:  MOVFF  19F,53
005A6:  MOVFF  19E,52
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005AA:  MOVF   53,W
005AC:  SUBWF  59,W
005AE:  BNC   05C0
005B0:  BNZ   05B8
005B2:  MOVF   58,W
005B4:  SUBWF  52,W
005B6:  BC    05C0
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005B8:  MOVFF  53,59
005BC:  MOVFF  52,58
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005C0:  MOVF   5F,W
005C2:  SUBWF  53,W
005C4:  BNC   05E0
005C6:  BNZ   05CE
005C8:  MOVF   52,W
005CA:  SUBWF  5E,W
005CC:  BC    05E0
005CE:  INCFSZ 52,W
005D0:  BRA    05D8
005D2:  INCFSZ 53,W
005D4:  BRA    05D8
005D6:  BRA    05E0
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005D8:  MOVFF  53,5F
005DC:  MOVFF  52,5E
.................... 			} 
.................... 			ext2_state=0; 
005E0:  MOVLB  6
005E2:  BCF    x74.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005E4:  BTFSC  x74.6
005E6:  BRA    05F6
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005E8:  MOVLB  1
005EA:  CLRF   x9F
005EC:  CLRF   x9E
.................... 			ext2_count=1; 
005EE:  MOVLB  8
005F0:  BSF    x91.4
.................... 			ext2_state=1; 
005F2:  MOVLB  6
005F4:  BSF    x74.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
005F6:  MOVLB  6
005F8:  BCF    x74.5
005FA:  MOVLB  8
005FC:  BTFSS  x91.5
005FE:  BRA    0606
00600:  MOVLB  6
00602:  BSF    x74.5
00604:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00606:  MOVLB  7
00608:  INCF   x7F,F
.................... 	if ( 10 == tick ) { 
0060A:  MOVF   x7F,W
0060C:  SUBLW  0A
0060E:  BNZ   0618
.................... 		tick=0; 
00610:  CLRF   x7F
.................... 		timers.now_millisecond=1; 
00612:  MOVLB  1
00614:  BSF    xAE.2
00616:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
00618:  BCF    F9E.1
0061A:  MOVLB  0
0061C:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
00638:  BRA    0620
0063A:  MOVFF  01,88E
....................  
.................... 	if ( RS485_MODE_OFF != config.rs485_port_mode ) { 
0063E:  MOVF   38,F
00640:  BZ    0662
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
00642:  MOVLB  2
00644:  CLRF   xB3
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
00646:  INCFSZ xB2,W
00648:  BRA    064C
0064A:  BRA    0660
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
0064C:  MOVLW  B2
0064E:  ADDWF  xB2,W
00650:  MOVWF  FE9
00652:  MOVLW  01
00654:  MOVWF  FEA
00656:  BTFSC  FD8.0
00658:  INCF   FEA,F
0065A:  MOVFF  88E,FEF
.................... 			timers.rda2_buff_pos++; 
0065E:  INCF   xB2,F
00660:  MOVLB  0
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00662:  BCF    FA4.5
00664:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
006B2:  RCALL  0668
006B4:  MOVFF  01,88E
....................  
.................... 	if ( current.bridged_uarts ) { 
006B8:  MOVLB  1
006BA:  BTFSS  x90.0
006BC:  BRA    06C8
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,STREAM_RS485); 
006BE:  MOVLB  8
006C0:  MOVF   x8E,W
006C2:  MOVLB  0
006C4:  RCALL  067E
.................... 		return; 
006C6:  BRA    0722
.................... 	} 
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006C8:  MOVLB  6
006CA:  BTFSC  x74.0
006CC:  BRA    0724
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
006CE:  MOVF   x75,F
006D0:  BNZ   06E2
.................... 			modbus_serial_crc.d = 0xFFFF; 
006D2:  SETF   x77
006D4:  SETF   x76
.................... 			modbus_rx.address = c; 
006D6:  MOVFF  88E,678
.................... 			modbus_serial_state++; 
006DA:  INCF   x75,F
.................... 			modbus_rx.len = 0; 
006DC:  CLRF   x79
.................... 			modbus_rx.error=0; 
006DE:  CLRF   x7B
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
006E0:  BRA    0710
006E2:  DECFSZ x75,W
006E4:  BRA    06EE
.................... 			modbus_rx.func = c; 
006E6:  MOVFF  88E,67A
.................... 			modbus_serial_state++; 
006EA:  INCF   x75,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
006EC:  BRA    0710
006EE:  MOVF   x75,W
006F0:  SUBLW  02
006F2:  BNZ   0710
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
006F4:  INCFSZ x79,W
006F6:  BRA    06FC
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
006F8:  MOVLW  FE
006FA:  MOVWF  x79
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
006FC:  MOVLW  7C
006FE:  ADDWF  x79,W
00700:  MOVWF  FE9
00702:  MOVLW  06
00704:  MOVWF  FEA
00706:  BTFSC  FD8.0
00708:  INCF   FEA,F
0070A:  MOVFF  88E,FEF
.................... 			modbus_rx.len++; 
0070E:  INCF   x79,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00710:  MOVFF  88E,88F
00714:  MOVLB  0
00716:  RCALL  0686
.................... 		modbus_enable_timeout(TRUE); 
00718:  MOVLW  01
0071A:  MOVLB  8
0071C:  MOVWF  x8F
0071E:  MOVLB  0
00720:  RCALL  039C
00722:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
....................  
00724:  BCF    F9E.5
00726:  MOVLB  0
00728:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00764:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00766:  MOVLW  08
00768:  MOVWF  F61
0076A:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
0076C:  MOVLW  00
0076E:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
00770:  MOVLW  FF
00772:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00774:  MOVLW  92
00776:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00778:  MOVLW  80
0077A:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
0077C:  BCF    F96.0
0077E:  BCF    F96.1
00780:  BCF    F96.2
00782:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00784:  MOVLB  1
00786:  CLRF   xAB
.................... 	timers.load_off_seconds=2; 
00788:  CLRF   xAD
0078A:  MOVLW  02
0078C:  MOVWF  xAC
.................... 	timers.now_adc_sample=0; 
0078E:  BCF    xAE.0
.................... 	timers.now_adc_reset_count=0; 
00790:  BCF    xAE.1
.................... 	timers.now_millisecond=0; 
00792:  BCF    xAE.2
.................... 	timers.port_b=0b11111111; 
00794:  SETF   xAF
.................... 	timers.port_c=0b11111111; 
00796:  SETF   xB0
....................  
.................... 	timers.rda2_buff_pos=0; 
00798:  MOVLB  2
0079A:  CLRF   xB2
.................... 	timers.rda2_buff_gap=255; 
0079C:  SETF   xB3
.................... 	timers.now_parse_rda2=0; 
0079E:  MOVLB  1
007A0:  BCF    xB1.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
007A2:  MOVLB  7
007A4:  CLRF   x8A
007A6:  MOVF   x8A,W
007A8:  SUBLW  02
007AA:  BNC   0858
.................... 		current.pulse_period[i]=0; 
007AC:  CLRF   03
007AE:  MOVFF  78A,02
007B2:  BCF    FD8.0
007B4:  RLCF   02,F
007B6:  RLCF   03,F
007B8:  MOVF   02,W
007BA:  ADDLW  4E
007BC:  MOVWF  FE9
007BE:  MOVLW  00
007C0:  ADDWFC 03,W
007C2:  MOVWF  FEA
007C4:  CLRF   FEC
007C6:  MOVF   FED,F
007C8:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
007CA:  CLRF   03
007CC:  MOVFF  78A,02
007D0:  BCF    FD8.0
007D2:  RLCF   02,F
007D4:  RLCF   03,F
007D6:  MOVF   02,W
007D8:  ADDLW  54
007DA:  MOVWF  FE9
007DC:  MOVLW  00
007DE:  ADDWFC 03,W
007E0:  MOVWF  FEA
007E2:  SETF   FEC
007E4:  MOVF   FED,F
007E6:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
007E8:  CLRF   03
007EA:  MOVFF  78A,02
007EE:  BCF    FD8.0
007F0:  RLCF   02,F
007F2:  RLCF   03,F
007F4:  MOVF   02,W
007F6:  ADDLW  5A
007F8:  MOVWF  FE9
007FA:  MOVLW  00
007FC:  ADDWFC 03,W
007FE:  MOVWF  FEA
00800:  CLRF   FEC
00802:  MOVF   FED,F
00804:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00806:  CLRF   03
00808:  MOVFF  78A,02
0080C:  BCF    FD8.0
0080E:  RLCF   02,F
00810:  RLCF   03,F
00812:  MOVF   02,W
00814:  ADDLW  60
00816:  MOVWF  FE9
00818:  MOVLW  00
0081A:  ADDWFC 03,W
0081C:  MOVWF  FEA
0081E:  CLRF   FEC
00820:  MOVF   FED,F
00822:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00824:  CLRF   xA5
00826:  MOVFF  78A,7A4
0082A:  CLRF   xA7
0082C:  MOVLW  04
0082E:  MOVWF  xA6
00830:  MOVLB  0
00832:  RCALL  0742
00834:  MOVF   01,W
00836:  ADDLW  66
00838:  MOVWF  FE9
0083A:  MOVLW  00
0083C:  ADDWFC 02,W
0083E:  MOVWF  FEA
00840:  MOVF   FEE,F
00842:  MOVF   FEE,F
00844:  CLRF   FEC
00846:  MOVF   FED,F
00848:  CLRF   FEF
0084A:  MOVF   FED,F
0084C:  CLRF   FEF
0084E:  MOVF   FED,F
00850:  CLRF   FEF
.................... 	} 
00852:  MOVLB  7
00854:  INCF   x8A,F
00856:  BRA    07A6
....................  
.................... 	current.modbus_our_packets=0; 
00858:  MOVLB  1
0085A:  CLRF   x84
0085C:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
0085E:  CLRF   x86
00860:  CLRF   x85
.................... 	current.modbus_last_error=0; 
00862:  CLRF   x88
00864:  CLRF   x87
.................... 	current.sequence_number=0; 
00866:  CLRF   x8A
00868:  CLRF   x89
.................... 	current.uptime_minutes=0; 
0086A:  CLRF   x8C
0086C:  CLRF   x8B
.................... 	current.interval_milliseconds=0; 
0086E:  CLRF   x8E
00870:  CLRF   x8D
.................... 	current.adc_buffer_index=0; 
00872:  CLRF   x82
.................... 	current.factory_unlocked=0; 
00874:  CLRF   x8F
.................... 	current.bridged_uarts=0; 
00876:  BCF    x90.0
.................... 	current.watchdog_seconds=0; 
00878:  CLRF   x92
0087A:  CLRF   x91
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
0087C:  MOVFF  4B,195
00880:  MOVFF  4A,194
.................... 	current.power_off_delay=config.power_off_below_delay; 
00884:  MOVFF  47,197
00888:  MOVFF  46,196
.................... 	current.power_override_timeout=0; 
0088C:  CLRF   x99
0088E:  CLRF   x98
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
00890:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
00892:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
00894:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00896:  MOVLW  00
00898:  IORLW  05
0089A:  MOVWF  FBA
0089C:  MOVLW  4A
0089E:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
008A0:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
008A2:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
008A4:  MOVLB  0
008A6:  GOTO   2260 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00D08:  MOVLB  1
00D0A:  BCF    xAE.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00D0C:  BCF    FD8.0
00D0E:  MOVLB  7
00D10:  RLCF   x85,W
00D12:  MOVWF  x8A
00D14:  RLCF   x86,W
00D16:  MOVWF  x8B
00D18:  MOVLW  00
00D1A:  MOVLB  1
00D1C:  BTFSS  xB0.5
00D1E:  MOVLW  01
00D20:  MOVLB  7
00D22:  IORWF  x8A,F
00D24:  MOVFF  78A,785
00D28:  MOVF   x8B,W
00D2A:  IORLW  E0
00D2C:  MOVWF  x86
.................... 	if ( b2_state==0xf000) { 
00D2E:  MOVF   x85,F
00D30:  BNZ   0D38
00D32:  MOVF   x86,W
00D34:  SUBLW  F0
00D36:  BNZ   0D38
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00D38:  MOVLB  1
00D3A:  INCFSZ x9A,W
00D3C:  BRA    0D46
00D3E:  INCFSZ x9B,W
00D40:  BRA    0D46
.................... 				current.pulse_period[0]=0; 
00D42:  CLRF   4F
00D44:  CLRF   4E
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00D46:  INCFSZ x9C,W
00D48:  BRA    0D52
00D4A:  INCFSZ x9D,W
00D4C:  BRA    0D52
.................... 				current.pulse_period[1]=0; 
00D4E:  CLRF   51
00D50:  CLRF   50
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00D52:  INCFSZ x9E,W
00D54:  BRA    0D5E
00D56:  INCFSZ x9F,W
00D58:  BRA    0D5E
.................... 				current.pulse_period[2]=0; 
00D5A:  CLRF   53
00D5C:  CLRF   52
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00D5E:  MOVFF  F81,1AF
.................... 	timers.port_c=port_c; 
00D62:  MOVFF  F82,1B0
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00D66:  BTFSS  x90.0
00D68:  BRA    0D6E
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00D6A:  BSF    F89.3
.................... 	} else { 
00D6C:  BRA    0D7A
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00D6E:  MOVF   xAB,F
00D70:  BNZ   0D76
.................... 			output_low(LED_GREEN); 
00D72:  BCF    F89.3
.................... 		} else { 
00D74:  BRA    0D7A
.................... 			output_high(LED_GREEN); 
00D76:  BSF    F89.3
.................... 			timers.led_on_green--; 
00D78:  DECF   xAB,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00D7A:  INCFSZ x8D,W
00D7C:  BRA    0D84
00D7E:  INCFSZ x8E,W
00D80:  BRA    0D84
00D82:  BRA    0D8A
.................... 		current.interval_milliseconds++; 
00D84:  INCF   x8D,F
00D86:  BTFSC  FD8.2
00D88:  INCF   x8E,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00D8A:  MOVLB  7
00D8C:  INCF   x83,F
00D8E:  BTFSC  FD8.2
00D90:  INCF   x84,F
.................... 	if ( 1000 == ticks ) { 
00D92:  MOVF   x83,W
00D94:  SUBLW  E8
00D96:  BNZ   0E1C
00D98:  MOVF   x84,W
00D9A:  SUBLW  03
00D9C:  BNZ   0E1C
.................... 		ticks=0; 
00D9E:  CLRF   x84
00DA0:  CLRF   x83
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00DA2:  MOVLB  1
00DA4:  INCFSZ x91,W
00DA6:  BRA    0DAE
00DA8:  INCFSZ x92,W
00DAA:  BRA    0DAE
00DAC:  BRA    0DB4
.................... 			current.watchdog_seconds++; 
00DAE:  INCF   x91,F
00DB0:  BTFSC  FD8.2
00DB2:  INCF   x92,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00DB4:  MOVF   3F,F
00DB6:  BNZ   0DBC
00DB8:  MOVF   40,F
00DBA:  BZ    0DDA
00DBC:  MOVF   40,W
00DBE:  SUBWF  x92,W
00DC0:  BNC   0DDA
00DC2:  BNZ   0DCA
00DC4:  MOVF   x91,W
00DC6:  SUBWF  3F,W
00DC8:  BC    0DDA
00DCA:  MOVF   xAC,F
00DCC:  BNZ   0DDA
00DCE:  MOVF   xAD,F
00DD0:  BNZ   0DDA
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00DD2:  MOVFF  42,1AD
00DD6:  MOVFF  41,1AC
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00DDA:  MOVF   xAC,F
00DDC:  BNZ   0DE6
00DDE:  MOVF   xAD,F
00DE0:  BNZ   0DE6
.................... 			output_high(PI_POWER_EN); 
00DE2:  BSF    F8B.0
.................... 		} else { 
00DE4:  BRA    0DFC
.................... 			output_low(PI_POWER_EN); 
00DE6:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00DE8:  MOVF   xAC,W
00DEA:  BTFSC  FD8.2
00DEC:  DECF   xAD,F
00DEE:  DECF   xAC,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00DF0:  MOVF   xAC,F
00DF2:  BNZ   0DFC
00DF4:  MOVF   xAD,F
00DF6:  BNZ   0DFC
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00DF8:  CLRF   x92
00DFA:  CLRF   x91
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00DFC:  MOVLB  7
00DFE:  INCF   x80,F
.................... 		if ( 60 == uptimeTicks ) { 
00E00:  MOVF   x80,W
00E02:  SUBLW  3C
00E04:  BNZ   0E1C
.................... 			uptimeTicks=0; 
00E06:  CLRF   x80
.................... 			if ( current.uptime_minutes < 65535 )  
00E08:  MOVLB  1
00E0A:  INCFSZ x8B,W
00E0C:  BRA    0E14
00E0E:  INCFSZ x8C,W
00E10:  BRA    0E14
00E12:  BRA    0E1A
.................... 				current.uptime_minutes++; 
00E14:  INCF   x8B,F
00E16:  BTFSC  FD8.2
00E18:  INCF   x8C,F
00E1A:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00E1C:  INCFSZ x87,W
00E1E:  BRA    0E32
00E20:  INCFSZ x88,W
00E22:  BRA    0E32
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00E24:  CLRF   x9E
00E26:  MOVLB  0
00E28:  RCALL  0C80
00E2A:  MOVFF  02,788
00E2E:  MOVFF  01,787
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00E32:  MOVLB  1
00E34:  BTFSS  xAE.1
00E36:  BRA    0E40
.................... 		timers.now_adc_reset_count=0; 
00E38:  BCF    xAE.1
.................... 		adcTicks=0; 
00E3A:  MOVLB  7
00E3C:  CLRF   x82
00E3E:  CLRF   x81
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00E40:  MOVLB  7
00E42:  INCF   x81,F
00E44:  BTFSC  FD8.2
00E46:  INCF   x82,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00E48:  MOVF   3C,W
00E4A:  SUBWF  x81,W
00E4C:  BNZ   0E62
00E4E:  MOVF   3D,W
00E50:  SUBWF  x82,W
00E52:  BNZ   0E62
.................... 		adcTicks=0; 
00E54:  CLRF   x82
00E56:  CLRF   x81
.................... 		timers.now_adc_sample=1; 
00E58:  MOVLB  1
00E5A:  BSF    xAE.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00E5C:  MOVLB  7
00E5E:  SETF   x88
00E60:  SETF   x87
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
00E62:  MOVLB  2
00E64:  INCFSZ xB3,W
00E66:  BRA    0E6A
00E68:  BRA    0E6C
.................... 		timers.rda2_buff_gap++; 
00E6A:  INCF   xB3,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
00E6C:  MOVF   xB3,W
00E6E:  SUBLW  09
00E70:  BC    0E7C
00E72:  MOVF   xB2,F
00E74:  BZ    0E7C
.................... 		timers.now_parse_rda2=1;	 
00E76:  MOVLB  1
00E78:  BSF    xB1.0
00E7A:  MOVLB  2
.................... 	} 
.................... } 
00E7C:  MOVLB  0
00E7E:  GOTO   22CC (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02148:  MOVFF  2B2,88A
.................... 	timers.rda2_buff_pos=255; /* stop getting more data for a second */ 
0214C:  MOVLB  2
0214E:  SETF   xB2
.................... 	memcpy(buff,timers.rda2_buff,length); 
02150:  MOVLW  07
02152:  MOVWF  FEA
02154:  MOVLW  8A
02156:  MOVWF  FE9
02158:  MOVLW  01
0215A:  MOVWF  FE2
0215C:  MOVLW  B2
0215E:  MOVWF  FE1
02160:  MOVLB  8
02162:  MOVF   x8A,W
02164:  MOVWF  01
02166:  BZ    2170
02168:  MOVFF  FE6,FEE
0216C:  DECFSZ 01,F
0216E:  BRA    2168
.................... 	timers.rda2_buff_gap=0; 
02170:  MOVLB  2
02172:  CLRF   xB3
.................... 	timers.rda2_buff_pos=0; 
02174:  CLRF   xB2
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02176:  DECFSZ 38,W
02178:  BRA    21B0
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
0217A:  MOVLB  8
0217C:  CLRF   x8C
0217E:  CLRF   x8B
02180:  MOVF   x8C,F
02182:  BNZ   21AC
02184:  MOVF   x8A,W
02186:  SUBWF  x8B,W
02188:  BC    21AC
.................... 			fputc(buff[l],STREAM_PI); 
0218A:  MOVLW  8A
0218C:  ADDWF  x8B,W
0218E:  MOVWF  FE9
02190:  MOVLW  07
02192:  ADDWFC x8C,W
02194:  MOVWF  FEA
02196:  MOVFF  FEF,88D
0219A:  MOVF   x8D,W
0219C:  MOVLB  0
0219E:  CALL   0F4A
.................... 		} 
021A2:  MOVLB  8
021A4:  INCF   x8B,F
021A6:  BTFSC  FD8.2
021A8:  INCF   x8C,F
021AA:  BRA    2180
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
021AC:  BRA    21B8
021AE:  MOVLB  2
021B0:  MOVF   38,W
021B2:  SUBLW  02
021B4:  BNZ   21B6
021B6:  MOVLB  8
.................... 		/* do something */ 
.................... 	} 
.................... } 
021B8:  MOVLB  0
021BA:  GOTO   22EA (RETURN)
....................  
....................  
.................... void main(void) { 
021BE:  CLRF   FF8
021C0:  BCF    FF1.2
021C2:  BSF    F9F.1
021C4:  BCF    F9F.5
021C6:  BCF    FA5.5
021C8:  BSF    FD0.7
021CA:  BSF    07.7
021CC:  CLRF   FEA
021CE:  CLRF   FE9
021D0:  CLRF   35
021D2:  BCF    FB8.3
021D4:  MOVLW  0C
021D6:  MOVWF  FAF
021D8:  MOVLW  A6
021DA:  MOVWF  FAC
021DC:  MOVLW  90
021DE:  MOVWF  FAB
021E0:  BCF    F70.3
021E2:  MOVLW  4D
021E4:  MOVWF  F75
021E6:  MOVLW  A6
021E8:  MOVWF  F72
021EA:  MOVLW  90
021EC:  MOVWF  F71
021EE:  MOVLB  6
021F0:  BCF    x74.0
021F2:  CLRF   x75
021F4:  MOVLB  7
021F6:  CLRF   x7F
021F8:  MOVLB  6
021FA:  BCF    x74.1
021FC:  BCF    x74.2
021FE:  BCF    x74.3
02200:  BCF    x74.4
02202:  BCF    x74.5
02204:  BCF    x74.6
02206:  MOVLB  7
02208:  CLRF   x80
0220A:  CLRF   x82
0220C:  CLRF   x81
0220E:  CLRF   x84
02210:  CLRF   x83
02212:  CLRF   x86
02214:  CLRF   x85
02216:  MOVF   FC1,W
02218:  ANDLW  F0
0221A:  MOVWF  FC1
0221C:  MOVLW  00
0221E:  MOVLB  F
02220:  MOVWF  x38
02222:  MOVWF  x3C
02224:  MOVWF  x39
02226:  MOVWF  x3A
02228:  MOVWF  x3B
0222A:  MOVLB  1
0222C:  CLRF   x88
0222E:  CLRF   F77
02230:  CLRF   F78
02232:  CLRF   F79
02234:  CLRF   2F
02236:  CLRF   30
02238:  MOVLB  7
0223A:  CLRF   x7B
0223C:  CLRF   x7C
0223E:  CLRF   x7D
02240:  CLRF   x7E
02242:  CLRF   x87
02244:  CLRF   x88
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02246:  MOVF   FD0,W
02248:  ANDLW  0F
0224A:  BTFSS  FD0.4
0224C:  MOVLW  00
0224E:  BSF    FD0.0
02250:  BSF    FD0.1
02252:  BSF    FD0.4
02254:  BSF    FD8.3
02256:  BSF    FD8.4
02258:  MOVWF  x89
....................  
.................... 	init(); 
0225A:  MOVLB  0
0225C:  GOTO   0764
....................  
....................  
.................... #if 0 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
.................... 	output_high(RS485_NRE); 
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
....................  
.................... 	switch ( i ) { 
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02260:  GOTO   0A6E
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02264:  MOVF   36,W
02266:  SUBLW  80
02268:  BC    226E
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
0226A:  CALL   0A36
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
0226E:  BSF    FAB.7
02270:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02272:  GOTO   0ACC
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02276:  MOVLB  7
02278:  CLRF   x89
0227A:  MOVF   x89,W
0227C:  SUBLW  1D
0227E:  BNC   228C
.................... 		adc_update(); 
02280:  MOVLB  0
02282:  CALL   0B8A
.................... 	} 
02286:  MOVLB  7
02288:  INCF   x89,F
0228A:  BRA    227A
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
0228C:  MOVFF  43,193
....................  
....................  
.................... #if 0 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
.................... 	output_low(RS485_DE); 
.................... 	output_low(RS485_NRE); 
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02290:  MOVLW  2C
02292:  MOVWF  FF6
02294:  MOVLW  07
02296:  MOVWF  FF7
02298:  MOVLW  07
0229A:  MOVWF  x8A
0229C:  MOVLB  0
0229E:  GOTO   0C30
022A2:  MOVLW  38
022A4:  MOVWF  FF6
022A6:  MOVLW  07
022A8:  MOVWF  FF7
022AA:  GOTO   0C5C
022AE:  MOVLW  0D
022B0:  BTFSS  F9E.4
022B2:  BRA    22B0
022B4:  MOVWF  FAD
022B6:  MOVLW  0A
022B8:  BTFSS  F9E.4
022BA:  BRA    22B8
022BC:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
022BE:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(STREAM_RS485) ) { 
.................... 				fputc(fgetc(STREAM_RS485),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
022C0:  MOVLB  1
022C2:  BTFSS  xAE.2
022C4:  BRA    22CE
.................... 			periodic_millisecond(); 
022C6:  MOVLB  0
022C8:  GOTO   0D08
022CC:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
022CE:  BTFSS  xAE.0
022D0:  BRA    22DA
.................... 			timers.now_adc_sample=0; 
022D2:  BCF    xAE.0
.................... 			adc_update(); 
022D4:  MOVLB  0
022D6:  CALL   0B8A
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
022DA:  MOVLB  0
022DC:  BRA    1E56
.................... //		} 
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
022DE:  MOVLB  1
022E0:  BTFSS  xB1.0
022E2:  BRA    22EC
.................... 			timers.now_parse_rda2=0; 
022E4:  BCF    xB1.0
.................... 			rs485_to_host(); 
022E6:  MOVLB  0
022E8:  BRA    2148
022EA:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
022EC:  MOVLB  0
022EE:  BRA    22BE
.................... } 
022F0:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
