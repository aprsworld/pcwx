CCS PCH C Compiler, Version 4.135, 4375               20-Nov-15 17:52

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 10286 bytes (16%)
                         Largest free fragment is 55246
               RAM used: 2002 (51%) at main() level
                         2279 (58%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   26FE
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03E0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   06E8
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   066E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0412
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
02460:  MOVFF  8D9,8DF
02464:  MOVFF  8D8,8DE
02468:  MOVLB  8
0246A:  MOVF   xDC,F
0246C:  BNZ   2472
0246E:  MOVF   xDD,F
02470:  BZ    24C0
02472:  MOVFF  8DB,03
02476:  MOVFF  8DA,FE9
0247A:  MOVFF  8DB,FEA
0247E:  MOVF   FEF,F
02480:  BZ    24C0
....................      *s++ = *s2++; 
02482:  MOVFF  8DF,03
02486:  MOVF   xDE,W
02488:  INCF   xDE,F
0248A:  BTFSC  FD8.2
0248C:  INCF   xDF,F
0248E:  MOVWF  xE0
02490:  MOVFF  03,8E1
02494:  MOVFF  8DB,03
02498:  MOVF   xDA,W
0249A:  INCF   xDA,F
0249C:  BTFSC  FD8.2
0249E:  INCF   xDB,F
024A0:  MOVWF  FE9
024A2:  MOVFF  03,FEA
024A6:  MOVFF  FEF,8E2
024AA:  MOVFF  8E1,FEA
024AE:  MOVFF  8E0,FE9
024B2:  MOVFF  8E2,FEF
024B6:  MOVF   xDC,W
024B8:  BTFSC  FD8.2
024BA:  DECF   xDD,F
024BC:  DECF   xDC,F
024BE:  BRA    246A
....................   for (; n > 0; n--) 
024C0:  MOVF   xDC,F
024C2:  BNZ   24C8
024C4:  MOVF   xDD,F
024C6:  BZ    24E6
....................      *s++ = '\0'; 
024C8:  MOVFF  8DF,03
024CC:  MOVF   xDE,W
024CE:  INCF   xDE,F
024D0:  BTFSC  FD8.2
024D2:  INCF   xDF,F
024D4:  MOVWF  FE9
024D6:  MOVFF  03,FEA
024DA:  CLRF   FEF
024DC:  MOVF   xDC,W
024DE:  BTFSC  FD8.2
024E0:  DECF   xDD,F
024E2:  DECF   xDC,F
024E4:  BRA    24C0
....................  
....................   return(s1); 
024E6:  MOVFF  8D8,01
024EA:  MOVFF  8D9,02
.................... } 
024EE:  MOVLB  0
024F0:  RETURN 0
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
024F2:  MOVLB  8
024F4:  MOVF   xDC,F
024F6:  BNZ   24FC
024F8:  MOVF   xDD,F
024FA:  BZ    2580
....................       if (*s1 != *s2) 
024FC:  MOVFF  8D8,FE9
02500:  MOVFF  8D9,FEA
02504:  MOVFF  FEF,8DE
02508:  MOVFF  8DB,03
0250C:  MOVFF  8DA,FE9
02510:  MOVFF  8DB,FEA
02514:  MOVF   FEF,W
02516:  SUBWF  xDE,W
02518:  BZ    2548
....................          return((*s1 <*s2) ? -1: 1); 
0251A:  MOVFF  8D9,03
0251E:  MOVFF  8D8,FE9
02522:  MOVFF  8D9,FEA
02526:  MOVFF  FEF,8DE
0252A:  MOVFF  8DB,03
0252E:  MOVFF  8DA,FE9
02532:  MOVFF  8DB,FEA
02536:  MOVF   FEF,W
02538:  SUBWF  xDE,W
0253A:  BC    2540
0253C:  MOVLW  FF
0253E:  BRA    2542
02540:  MOVLW  01
02542:  MOVWF  01
02544:  BRA    2584
....................       else if (*s1 == '\0') 
02546:  BRA    255E
02548:  MOVFF  8D9,03
0254C:  MOVFF  8D8,FE9
02550:  MOVFF  8D9,FEA
02554:  MOVF   FEF,F
02556:  BNZ   255E
....................          return(0); 
02558:  MOVLW  00
0255A:  MOVWF  01
0255C:  BRA    2584
0255E:  MOVFF  8D9,03
02562:  MOVF   xD8,W
02564:  INCF   xD8,F
02566:  BTFSC  FD8.2
02568:  INCF   xD9,F
0256A:  MOVFF  8DB,03
0256E:  MOVF   xDA,W
02570:  INCF   xDA,F
02572:  BTFSC  FD8.2
02574:  INCF   xDB,F
02576:  MOVF   xDC,W
02578:  BTFSC  FD8.2
0257A:  DECF   xDD,F
0257C:  DECF   xDC,F
0257E:  BRA    24F4
....................    return(0); 
02580:  MOVLW  00
02582:  MOVWF  01
.................... } 
02584:  MOVLB  0
02586:  GOTO   266E (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
00F5A:  MOVLW  05
00F5C:  MOVLB  7
00F5E:  SUBWF  xD9,F
00F60:  BNC   0F76
00F62:  MOVLW  07
00F64:  MOVWF  FEA
00F66:  MOVLW  D9
00F68:  MOVWF  FE9
00F6A:  MOVF   FEF,W
00F6C:  BZ    0F76
00F6E:  BRA    0F72
00F70:  CLRWDT
00F72:  DECFSZ FEF,F
00F74:  BRA    0F70
00F76:  MOVLB  0
00F78:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0069E:  BTFSS  F9E.5
006A0:  BRA    069E
006A2:  MOVFF  FAB,35
006A6:  MOVFF  FAE,01
006AA:  BTFSS  35.1
006AC:  BRA    06B2
006AE:  BCF    FAB.4
006B0:  BSF    FAB.4
006B2:  RETURN 0
*
01068:  BTFSS  F9E.4
0106A:  BRA    1068
0106C:  MOVWF  FAD
0106E:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00656:  BTFSS  FA4.5
00658:  BRA    0656
0065A:  MOVFF  F71,35
0065E:  MOVFF  F74,01
00662:  BTFSS  35.1
00664:  BRA    066A
00666:  BCF    F71.4
00668:  BSF    F71.4
0066A:  GOTO   0670 (RETURN)
*
006B4:  BTFSS  FA4.4
006B6:  BRA    06B4
006B8:  MOVWF  F73
006BA:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00C1E:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00B7E:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00B80:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00B82:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00B84:  MOVLB  7
00B86:  MOVF   xD5,F
00B88:  BNZ   0B90
.................... 		c=0b00011; 
00B8A:  MOVLW  03
00B8C:  MOVWF  xD9
.................... 	else if ( 1 == ch )  
00B8E:  BRA    0BDA
00B90:  DECFSZ xD5,W
00B92:  BRA    0B9A
.................... 		c=0b10011; 
00B94:  MOVLW  13
00B96:  MOVWF  xD9
.................... 	else if ( 2 == ch )  
00B98:  BRA    0BDA
00B9A:  MOVF   xD5,W
00B9C:  SUBLW  02
00B9E:  BNZ   0BA6
.................... 		c=0b01011; 
00BA0:  MOVLW  0B
00BA2:  MOVWF  xD9
.................... 	else if ( 3 == ch )  
00BA4:  BRA    0BDA
00BA6:  MOVF   xD5,W
00BA8:  SUBLW  03
00BAA:  BNZ   0BB2
.................... 		c=0b11011; 
00BAC:  MOVLW  1B
00BAE:  MOVWF  xD9
.................... 	else if ( 4 == ch ) 
00BB0:  BRA    0BDA
00BB2:  MOVF   xD5,W
00BB4:  SUBLW  04
00BB6:  BNZ   0BBE
.................... 		c=0b00111; 
00BB8:  MOVLW  07
00BBA:  MOVWF  xD9
.................... 	else if ( 5 == ch )  
00BBC:  BRA    0BDA
00BBE:  MOVF   xD5,W
00BC0:  SUBLW  05
00BC2:  BNZ   0BCA
.................... 		c=0b10111; 
00BC4:  MOVLW  17
00BC6:  MOVWF  xD9
.................... 	else if ( 6 == ch ) 
00BC8:  BRA    0BDA
00BCA:  MOVF   xD5,W
00BCC:  SUBLW  06
00BCE:  BNZ   0BD6
.................... 		c=0b01111; 
00BD0:  MOVLW  0F
00BD2:  MOVWF  xD9
.................... 	else 
00BD4:  BRA    0BDA
.................... 		c=0b11111; 
00BD6:  MOVLW  1F
00BD8:  MOVWF  xD9
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00BDA:  CLRF   xD8
00BDC:  MOVF   xD8,W
00BDE:  SUBLW  04
00BE0:  BNC   0BF8
.................... 		output_low(MCP3208_CLK); 
00BE2:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00BE4:  BTFSC  xD9.0
00BE6:  BRA    0BEC
00BE8:  BCF    F8B.5
00BEA:  BRA    0BEE
00BEC:  BSF    F8B.5
.................... 		c=c>>1; 
00BEE:  BCF    FD8.0
00BF0:  RRCF   xD9,F
.................... 		output_high(MCP3208_CLK); 
00BF2:  BSF    F8B.3
.................... 	} 
00BF4:  INCF   xD8,F
00BF6:  BRA    0BDC
....................  
....................  
.................... 	value=0; 
00BF8:  CLRF   xD7
00BFA:  CLRF   xD6
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00BFC:  CLRF   xD8
00BFE:  MOVF   xD8,W
00C00:  SUBLW  0D
00C02:  BNC   0C1A
.................... 		output_low(MCP3208_CLK); 
00C04:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00C06:  BTFSC  F82.4
00C08:  BRA    0C0E
00C0A:  BCF    FD8.0
00C0C:  BRA    0C10
00C0E:  BSF    FD8.0
00C10:  RLCF   xD6,F
00C12:  RLCF   xD7,F
.................... 		output_high(MCP3208_CLK); 
00C14:  BSF    F8B.3
.................... 	} 
00C16:  INCF   xD8,F
00C18:  BRA    0BFE
....................  
.................... 	bit_clear(value,13); 
00C1A:  BCF    xD7.5
.................... 	bit_clear(value,12); 
00C1C:  BCF    xD7.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00C20:  MOVFF  7D6,01
00C24:  MOVFF  7D7,02
.................... } 
00C28:  MOVLB  0
00C2A:  GOTO   0C9C (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00D26:  MOVLB  8
00D28:  CLRF   xD7
00D2A:  MOVFF  7EA,8D6
00D2E:  CLRF   xD9
00D30:  MOVLW  20
00D32:  MOVWF  xD8
00D34:  MOVLB  0
00D36:  RCALL  0778
00D38:  MOVFF  02,03
00D3C:  MOVF   01,W
00D3E:  ADDLW  CA
00D40:  MOVWF  01
00D42:  MOVLW  00
00D44:  ADDWFC 03,F
00D46:  MOVFF  01,7EE
00D4A:  MOVLB  7
00D4C:  MOVFF  03,7EF
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00D50:  CLRF   xEC
00D52:  CLRF   xEB
.................... 	for( i = 0; i < 16 ; i++ ) { 
00D54:  CLRF   xED
00D56:  MOVF   xED,W
00D58:  SUBLW  0F
00D5A:  BNC   0D7E
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00D5C:  BCF    FD8.0
00D5E:  RLCF   xED,W
00D60:  CLRF   03
00D62:  ADDWF  xEE,W
00D64:  MOVWF  FE9
00D66:  MOVF   xEF,W
00D68:  ADDWFC 03,W
00D6A:  MOVWF  FEA
00D6C:  MOVFF  FEC,03
00D70:  MOVF   FED,F
00D72:  MOVF   FEF,W
00D74:  ADDWF  xEB,F
00D76:  MOVF   03,W
00D78:  ADDWFC xEC,F
.................... 	} 
00D7A:  INCF   xED,F
00D7C:  BRA    0D56
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00D7E:  MOVLW  08
00D80:  ADDWF  xEB,W
00D82:  MOVWF  xF0
00D84:  MOVLW  00
00D86:  ADDWFC xEC,W
00D88:  MOVWF  xF1
00D8A:  RRCF   xF1,W
00D8C:  MOVWF  03
00D8E:  RRCF   xF0,W
00D90:  MOVWF  02
00D92:  RRCF   03,F
00D94:  RRCF   02,F
00D96:  RRCF   03,F
00D98:  RRCF   02,F
00D9A:  RRCF   03,F
00D9C:  RRCF   02,F
00D9E:  MOVLW  0F
00DA0:  ANDWF  03,F
00DA2:  MOVFF  02,01
00DA6:  MOVFF  03,02
.................... } 
00DAA:  MOVLB  0
00DAC:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00C2E:  MOVLB  1
00C30:  INCF   xCA,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00C32:  MOVF   xCA,W
00C34:  SUBLW  0F
00C36:  BC    0C3A
.................... 		current.adc_buffer_index=0; 
00C38:  CLRF   xCA
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00C3A:  MOVLB  7
00C3C:  CLRF   xD2
00C3E:  MOVF   xD2,W
00C40:  SUBLW  07
00C42:  BNC   0CD2
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00C44:  MOVLB  8
00C46:  CLRF   xD7
00C48:  MOVFF  7D2,8D6
00C4C:  CLRF   xD9
00C4E:  MOVLW  20
00C50:  MOVWF  xD8
00C52:  MOVLB  0
00C54:  RCALL  0778
00C56:  MOVFF  02,03
00C5A:  MOVF   01,W
00C5C:  ADDLW  34
00C5E:  MOVLB  7
00C60:  MOVWF  xD3
00C62:  MOVLW  00
00C64:  ADDWFC 02,W
00C66:  MOVWF  xD4
00C68:  CLRF   03
00C6A:  MOVLB  1
00C6C:  MOVFF  1CA,02
00C70:  BCF    FD8.0
00C72:  RLCF   02,F
00C74:  RLCF   03,F
00C76:  MOVF   02,W
00C78:  MOVLB  7
00C7A:  ADDWF  xD3,W
00C7C:  MOVWF  01
00C7E:  MOVF   xD4,W
00C80:  ADDWFC 03,F
00C82:  MOVF   01,W
00C84:  ADDLW  96
00C86:  MOVWF  01
00C88:  MOVLW  00
00C8A:  ADDWFC 03,F
00C8C:  MOVFF  01,7D3
00C90:  MOVFF  03,7D4
00C94:  MOVFF  7D2,7D5
00C98:  MOVLB  0
00C9A:  BRA    0B7E
00C9C:  MOVFF  7D4,FEA
00CA0:  MOVFF  7D3,FE9
00CA4:  MOVFF  02,FEC
00CA8:  MOVF   FED,F
00CAA:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00CAE:  CLRF   03
00CB0:  MOVLB  7
00CB2:  MOVFF  7D2,02
00CB6:  BCF    FD8.0
00CB8:  RLCF   02,F
00CBA:  RLCF   03,F
00CBC:  MOVF   02,W
00CBE:  ADDLW  BA
00CC0:  MOVWF  FE9
00CC2:  MOVLW  00
00CC4:  ADDWFC 03,W
00CC6:  MOVWF  FEA
00CC8:  CLRF   FEC
00CCA:  MOVF   FED,F
00CCC:  CLRF   FEF
....................  
.................... 	} 
00CCE:  INCF   xD2,F
00CD0:  BRA    0C3E
.................... } 
00CD2:  MOVLB  0
00CD4:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00984:  MOVF   xEF,W
00986:  XORWF  xF0,W
00988:  MOVWF  01
*
009D6:  MOVF   xEF,W
009D8:  XORWF  xF0,W
009DA:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
0090E:  MOVLB  7
00910:  CLRF   xDB
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00912:  MOVFF  7DA,03
00916:  MOVF   xD9,W
00918:  BTFSC  FD8.2
0091A:  DECF   xDA,F
0091C:  DECF   xD9,F
0091E:  MOVWF  xDC
00920:  MOVFF  03,7DD
00924:  MOVF   xDC,F
00926:  BNZ   092C
00928:  MOVF   xDD,F
0092A:  BZ    0996
.................... 		*data = read_eeprom( address++ ); 
0092C:  MOVFF  7D8,03
00930:  MOVF   xD7,W
00932:  MOVWF  FE9
00934:  MOVFF  03,FEA
00938:  MOVF   xD6,W
0093A:  MOVWF  03
0093C:  MOVF   xD5,W
0093E:  INCF   xD5,F
00940:  BTFSC  FD8.2
00942:  INCF   xD6,F
00944:  MOVWF  xDE
00946:  MOVFF  03,7DF
0094A:  MOVFF  FF2,7E0
0094E:  BCF    FF2.6
00950:  BCF    FF2.7
00952:  MOVFF  7DF,FAA
00956:  MOVFF  7DE,FA9
0095A:  BCF    FA6.6
0095C:  BCF    FA6.7
0095E:  BSF    FA6.0
00960:  MOVF   FA8,W
00962:  BTFSC  xE0.6
00964:  BSF    FF2.6
00966:  BTFSC  xE0.7
00968:  BSF    FF2.7
0096A:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
0096C:  MOVFF  7D8,03
00970:  MOVF   xD7,W
00972:  MOVWF  FE9
00974:  MOVFF  03,FEA
00978:  MOVFF  FEF,7DC
0097C:  MOVFF  7DB,7EF
00980:  MOVFF  7DC,7F0
*
0098A:  MOVFF  01,7DB
.................... 		data++; 
0098E:  INCF   xD7,F
00990:  BTFSC  FD8.2
00992:  INCF   xD8,F
.................... 	} 
00994:  BRA    0912
.................... 	return crc; 
00996:  MOVFF  7DB,01
.................... } 
0099A:  MOVLB  0
0099C:  GOTO   0B32 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
009A0:  MOVLB  7
009A2:  CLRF   xED
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
009A4:  MOVFF  7EC,03
009A8:  MOVF   xEB,W
009AA:  BTFSC  FD8.2
009AC:  DECF   xEC,F
009AE:  DECF   xEB,F
009B0:  MOVWF  xEE
009B2:  MOVFF  03,7EF
009B6:  MOVF   xEE,F
009B8:  BNZ   09BE
009BA:  MOVF   xEF,F
009BC:  BZ    0A3C
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
009BE:  MOVFF  7EA,03
009C2:  MOVF   xE9,W
009C4:  MOVWF  FE9
009C6:  MOVFF  03,FEA
009CA:  MOVFF  FEF,7EE
009CE:  MOVFF  7ED,7EF
009D2:  MOVFF  7EE,7F0
*
009DC:  MOVFF  01,7ED
.................... 		write_eeprom( address++, *data++ ); 
009E0:  MOVF   xE8,W
009E2:  MOVWF  03
009E4:  MOVF   xE7,W
009E6:  INCF   xE7,F
009E8:  BTFSC  FD8.2
009EA:  INCF   xE8,F
009EC:  MOVWF  xEE
009EE:  MOVFF  03,7EF
009F2:  MOVF   xEA,W
009F4:  MOVWF  03
009F6:  MOVF   xE9,W
009F8:  INCF   xE9,F
009FA:  BTFSC  FD8.2
009FC:  INCF   xEA,F
009FE:  MOVWF  FE9
00A00:  MOVFF  03,FEA
00A04:  MOVFF  FEF,7F0
00A08:  MOVFF  7EF,FAA
00A0C:  MOVFF  7EE,FA9
00A10:  MOVFF  7F0,FA8
00A14:  BCF    FA6.6
00A16:  BCF    FA6.7
00A18:  BSF    FA6.2
00A1A:  MOVF   FF2,W
00A1C:  MOVWF  00
00A1E:  BCF    FF2.6
00A20:  BCF    FF2.7
00A22:  MOVLB  F
00A24:  MOVLW  55
00A26:  MOVWF  FA7
00A28:  MOVLW  AA
00A2A:  MOVWF  FA7
00A2C:  BSF    FA6.1
00A2E:  BTFSC  FA6.1
00A30:  BRA    0A2E
00A32:  BCF    FA6.2
00A34:  MOVF   00,W
00A36:  IORWF  FF2,F
.................... 	} 
00A38:  MOVLB  7
00A3A:  BRA    09A4
....................  
.................... 	return crc; 
00A3C:  MOVFF  7ED,01
.................... } 
00A40:  MOVLB  0
00A42:  GOTO   0A66 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00A46:  MOVLB  7
00A48:  CLRF   xE6
00A4A:  MOVLW  36
00A4C:  MOVWF  xE5
00A4E:  CLRF   xE8
00A50:  MOVLW  02
00A52:  MOVWF  xE7
00A54:  MOVFF  7E6,7EA
00A58:  MOVFF  7E5,7E9
00A5C:  CLRF   xEC
00A5E:  MOVLW  60
00A60:  MOVWF  xEB
00A62:  MOVLB  0
00A64:  BRA    09A0
00A66:  MOVFF  01,7E4
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00A6A:  CLRF   FAA
00A6C:  CLRF   FA9
00A6E:  MOVFF  7E4,FA8
00A72:  BCF    FA6.6
00A74:  BCF    FA6.7
00A76:  BSF    FA6.2
00A78:  MOVF   FF2,W
00A7A:  MOVWF  00
00A7C:  BCF    FF2.6
00A7E:  BCF    FF2.7
00A80:  MOVLB  F
00A82:  MOVLW  55
00A84:  MOVWF  FA7
00A86:  MOVLW  AA
00A88:  MOVWF  FA7
00A8A:  BSF    FA6.1
00A8C:  BTFSC  FA6.1
00A8E:  BRA    0A8C
00A90:  BCF    FA6.2
00A92:  MOVF   00,W
00A94:  IORWF  FF2,F
.................... } 
00A96:  MOVLB  0
00A98:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00A9A:  MOVLW  96
00A9C:  MOVLB  1
00A9E:  MOVWF  xF3
....................  
.................... 	config.modbus_address=38; 
00AA0:  MOVLW  26
00AA2:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_MODBUS_BRIDGE; 
00AA4:  MOVLW  01
00AA6:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00AA8:  MOVLW  50
00AAA:  MOVWF  39
.................... 	config.serial_number=9876; 
00AAC:  MOVLW  26
00AAE:  MOVWF  3B
00AB0:  MOVLW  94
00AB2:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00AB4:  CLRF   3D
00AB6:  MOVLW  14
00AB8:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00ABA:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00ABC:  MOVLW  02
00ABE:  MOVWF  40
00AC0:  MOVLW  76
00AC2:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00AC4:  CLRF   42
00AC6:  MOVLW  02
00AC8:  MOVWF  41
.................... 	config.power_startup=0; 
00ACA:  CLRF   43
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00ACC:  CLRF   FEA
00ACE:  MOVLW  4E
00AD0:  MOVWF  FE9
00AD2:  CLRF   00
00AD4:  CLRF   02
00AD6:  MOVLW  48
00AD8:  MOVWF  01
00ADA:  MOVLB  0
00ADC:  RCALL  079A
.................... 	/* set defaults. Can set the first 11 this way. Have to do them in order. 
.................... 	 12th would overrun end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00ADE:  CLRF   FEA
00AE0:  MOVLW  4E
00AE2:  MOVWF  FE9
00AE4:  MOVLW  00
00AE6:  CALL   017C
00AEA:  TBLRD*-
00AEC:  TBLRD*+
00AEE:  MOVF   FF5,W
00AF0:  MOVWF  FEE
00AF2:  IORLW  00
00AF4:  BNZ   0AEC
.................... 	strcpy(config.nmea0183_sentence[1],"$WIMDA"); 
00AF6:  CLRF   FEA
00AF8:  MOVLW  54
00AFA:  MOVWF  FE9
00AFC:  MOVLW  00
00AFE:  CALL   0194
00B02:  TBLRD*-
00B04:  TBLRD*+
00B06:  MOVF   FF5,W
00B08:  MOVWF  FEE
00B0A:  IORLW  00
00B0C:  BNZ   0B04
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00B0E:  RCALL  0A46
....................  
.................... } 
00B10:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00B12:  MOVLB  7
00B14:  CLRF   xD4
00B16:  MOVLW  36
00B18:  MOVWF  xD3
00B1A:  CLRF   xD6
00B1C:  MOVLW  02
00B1E:  MOVWF  xD5
00B20:  MOVFF  7D4,7D8
00B24:  MOVFF  7D3,7D7
00B28:  CLRF   xDA
00B2A:  MOVLW  60
00B2C:  MOVWF  xD9
00B2E:  MOVLB  0
00B30:  BRA    090E
00B32:  MOVFF  01,7D2
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00B36:  MOVFF  FF2,7D3
00B3A:  BCF    FF2.6
00B3C:  BCF    FF2.7
00B3E:  CLRF   FAA
00B40:  CLRF   FA9
00B42:  BCF    FA6.6
00B44:  BCF    FA6.7
00B46:  BSF    FA6.0
00B48:  MOVF   FA8,W
00B4A:  MOVLB  7
00B4C:  BTFSC  xD3.6
00B4E:  BSF    FF2.6
00B50:  BTFSC  xD3.7
00B52:  BSF    FF2.7
00B54:  SUBWF  xD2,W
00B56:  BZ    0B5E
.................... 		write_default_param_file(); 
00B58:  MOVLB  0
00B5A:  RCALL  0A9A
00B5C:  MOVLB  7
.................... 	} 
.................... } 
00B5E:  MOVLB  0
00B60:  GOTO   27A4 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
010CA:  BTFSS  FAC.1
010CC:  BRA    10CA
.................... } 
010CE:  GOTO   10E8 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00B64:  BTFSS  F9E.5
00B66:  BRA    0B6C
.................... 		fgetc(STREAM_PI); 
00B68:  RCALL  069E
.................... 	} 
00B6A:  BRA    0B64
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00B6C:  BSF    F9D.5
.................... } 
00B6E:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00B70:  RCALL  0B64
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00B72:  MOVLW  C6
00B74:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00B76:  MOVLW  C0
00B78:  IORWF  FF2,F
.................... } 
00B7A:  GOTO   27B6 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003CC:  BCF    FF2.5
.................... 	if (enable) { 
003CE:  MOVLB  8
003D0:  MOVF   xE4,F
003D2:  BZ    03DC
.................... 		set_timer0(0); 
003D4:  CLRF   FD7
003D6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003D8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003DA:  BSF    FF2.5
.................... 	} 
.................... } 
003DC:  MOVLB  0
003DE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003E0:  MOVLB  6
003E2:  MOVF   xBD,W
003E4:  SUBLW  02
003E6:  BNZ   03FC
003E8:  MOVF   xBE,F
003EA:  BNZ   03FC
003EC:  MOVF   xBF,F
003EE:  BNZ   03FC
003F0:  BTFSC  xBC.0
003F2:  BRA    03FC
....................    { 
....................       modbus_rx.len-=2; 
003F4:  MOVLW  02
003F6:  SUBWF  xC1,F
....................       modbus_serial_new=TRUE; 
003F8:  BSF    xBC.0
....................    } 
....................    else 
003FA:  BRA    03FE
....................       modbus_serial_new=FALSE; 
003FC:  BCF    xBC.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003FE:  SETF   xBF
00400:  SETF   xBE
....................    modbus_serial_state=MODBUS_GETADDY; 
00402:  CLRF   xBD
....................    modbus_enable_timeout(FALSE); 
00404:  MOVLB  8
00406:  CLRF   xE4
00408:  MOVLB  0
0040A:  RCALL  03CC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0040C:  BCF    FF2.2
0040E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
006BC:  MOVLB  6
006BE:  MOVF   xBF,W
006C0:  MOVLB  8
006C2:  XORWF  xE4,W
006C4:  MOVWF  xE5
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
006C6:  CLRF   03
006C8:  MOVF   xE5,W
006CA:  MOVLB  0
006CC:  RCALL  01AC
006CE:  MOVWF  01
006D0:  MOVLB  6
006D2:  MOVF   xBE,W
006D4:  XORWF  01,W
006D6:  MOVWF  xBF
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006D8:  CLRF   03
006DA:  MOVLB  8
006DC:  MOVF   xE5,W
006DE:  MOVLB  0
006E0:  RCALL  02BC
006E2:  MOVFF  FE8,6BE
.................... } 
006E6:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
01070:  MOVLB  7
01072:  MOVF   xE4,W
01074:  MOVLB  0
01076:  RCALL  1068
01078:  CLRF   19
0107A:  BTFSC  FF2.6
0107C:  BSF    19.6
0107E:  BCF    FF2.6
01080:  BTFSC  FF2.7
01082:  BSF    19.7
01084:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
01086:  MOVFF  7E4,8E4
0108A:  CALL   06BC
0108E:  BTFSC  19.6
01090:  BSF    FF2.6
01092:  BTFSC  19.7
01094:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
01096:  CLRWDT
01098:  MOVLW  08
0109A:  MOVWF  00
0109C:  DECFSZ 00,F
0109E:  BRA    109C
010A0:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
010A2:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
010A4:  MOVLB  6
010A6:  SETF   xBF
010A8:  SETF   xBE
....................    modbus_serial_new=FALSE; 
010AA:  BCF    xBC.0
....................  
....................    RCV_OFF(); 
010AC:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
010AE:  CLRWDT
010B0:  MOVLW  3C
010B2:  MOVWF  00
010B4:  DECFSZ 00,F
010B6:  BRA    10B4
010B8:  NOP   
....................  
....................    modbus_serial_putc(to); 
010BA:  MOVFF  7E2,7E4
010BE:  MOVLB  0
010C0:  RCALL  1070
....................    modbus_serial_putc(func); 
010C2:  MOVFF  7E3,7E4
010C6:  RCALL  1070
.................... } 
010C8:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
010D2:  MOVFF  6BF,7E3
....................    crc_low=modbus_serial_crc.b[0]; 
010D6:  MOVFF  6BE,7E2
....................  
....................    modbus_serial_putc(crc_high); 
010DA:  MOVFF  7E3,7E4
010DE:  RCALL  1070
....................    modbus_serial_putc(crc_low); 
010E0:  MOVFF  7E2,7E4
010E4:  RCALL  1070
....................  
....................    WAIT_FOR_HW_BUFFER(); 
010E6:  BRA    10CA
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
010E8:  CLRWDT
010EA:  MOVLW  3C
010EC:  MOVWF  00
010EE:  DECFSZ 00,F
010F0:  BRA    10EE
010F2:  NOP   
....................  
....................  
....................    RCV_ON(); 
010F4:  RCALL  0B64
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
010F6:  MOVLB  6
010F8:  SETF   xBF
010FA:  SETF   xBE
.................... } 
010FC:  MOVLB  0
010FE:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00F34:  MOVLB  6
00F36:  BTFSC  xBC.0
00F38:  BRA    0F42
....................       return FALSE; 
00F3A:  MOVLW  00
00F3C:  MOVWF  01
00F3E:  BRA    0F54
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00F40:  BRA    0F4E
00F42:  BTFSS  xC2.7
00F44:  BRA    0F4E
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00F46:  MOVFF  6C4,6C3
....................       modbus_rx.len = 1; 
00F4A:  MOVLW  01
00F4C:  MOVWF  xC1
....................    } 
....................    modbus_serial_new=FALSE; 
00F4E:  BCF    xBC.0
....................    return TRUE; 
00F50:  MOVLW  01
00F52:  MOVWF  01
.................... } 
00F54:  MOVLB  0
00F56:  GOTO   2172 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
020DE:  MOVFF  7DA,7E2
020E2:  MOVLW  06
020E4:  MOVLB  7
020E6:  MOVWF  xE3
020E8:  MOVLB  0
020EA:  CALL   10A4
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
020EE:  MOVFF  7DC,7DF
020F2:  MOVFF  7DC,7E4
020F6:  CALL   1070
....................    modbus_serial_putc(make8(reg_address,0)); 
020FA:  MOVFF  7DB,7DF
020FE:  MOVFF  7DB,7E4
02102:  CALL   1070
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02106:  MOVFF  7DE,7DF
0210A:  MOVFF  7DE,7E4
0210E:  CALL   1070
....................    modbus_serial_putc(make8(reg_value,0)); 
02112:  MOVFF  7DD,7DF
02116:  MOVFF  7DD,7E4
0211A:  CALL   1070
....................  
....................    modbus_serial_send_stop(); 
0211E:  CALL   10D2
.................... } 
02122:  GOTO   2356 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02126:  MOVFF  7D8,7E2
0212A:  MOVLW  10
0212C:  MOVLB  7
0212E:  MOVWF  xE3
02130:  MOVLB  0
02132:  CALL   10A4
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02136:  MOVFF  7DA,7DD
0213A:  MOVFF  7DA,7E4
0213E:  CALL   1070
....................    modbus_serial_putc(make8(start_address,0)); 
02142:  MOVFF  7D9,7DD
02146:  MOVFF  7D9,7E4
0214A:  CALL   1070
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0214E:  MOVFF  7DC,7DD
02152:  MOVFF  7DC,7E4
02156:  CALL   1070
....................    modbus_serial_putc(make8(quantity,0)); 
0215A:  MOVFF  7DB,7DD
0215E:  MOVFF  7DB,7E4
02162:  CALL   1070
....................  
....................    modbus_serial_send_stop(); 
02166:  CALL   10D2
.................... } 
0216A:  GOTO   2418 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01100:  MOVLB  7
01102:  MOVF   xD9,W
01104:  IORLW  80
01106:  MOVWF  xDC
01108:  MOVFF  7DA,7DD
0110C:  MOVFF  7D8,7E2
01110:  MOVWF  xE3
01112:  MOVLB  0
01114:  RCALL  10A4
....................    modbus_serial_putc(error); 
01116:  MOVFF  7DB,7E4
0111A:  RCALL  1070
....................    modbus_serial_send_stop(); 
0111C:  RCALL  10D2
.................... } 
0111E:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          51 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1012 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
01212:  MOVLB  1
01214:  CLRF   xCC
01216:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
01218:  CLRF   xCE
0121A:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
0121C:  CLRF   xD0
0121E:  CLRF   xCF
.................... } 
01220:  MOVLB  0
01222:  GOTO   1C80 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
011AE:  BCF    FF2.6
011B0:  BCF    FF2.7
011B2:  BTFSC  FF2.7
011B4:  BRA    11B0
....................  
.................... 	current.pulse_count[0]=0; 
011B6:  CLRF   xA9
011B8:  CLRF   xA8
.................... 	current.pulse_count[1]=0; 
011BA:  CLRF   xAB
011BC:  CLRF   xAA
.................... 	current.pulse_count[2]=0; 
011BE:  CLRF   xAD
011C0:  CLRF   xAC
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
011C2:  SETF   x9D
011C4:  SETF   x9C
.................... 	current.pulse_min_period[1]=65535; 
011C6:  SETF   x9F
011C8:  SETF   x9E
.................... 	current.pulse_min_period[2]=65535; 
011CA:  SETF   xA1
011CC:  SETF   xA0
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
011CE:  CLRF   xA3
011D0:  CLRF   xA2
.................... 	current.pulse_max_period[1]=0; 
011D2:  CLRF   xA5
011D4:  CLRF   xA4
.................... 	current.pulse_max_period[2]=0; 
011D6:  CLRF   xA7
011D8:  CLRF   xA6
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
011DA:  MOVLB  1
011DC:  CLRF   xD6
011DE:  CLRF   xD5
....................  
.................... 	enable_interrupts(GLOBAL); 
011E0:  MOVLW  C0
011E2:  IORWF  FF2,F
.................... } 
011E4:  MOVLB  0
011E6:  GOTO   1C30 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
011EA:  BCF    FF2.6
011EC:  BCF    FF2.7
011EE:  BTFSC  FF2.7
011F0:  BRA    11EC
.................... 	current.pulse_sum[0]=0; 
011F2:  CLRF   xB1
011F4:  CLRF   xB0
011F6:  CLRF   xAF
011F8:  CLRF   xAE
.................... 	current.pulse_sum[1]=0; 
011FA:  CLRF   xB5
011FC:  CLRF   xB4
011FE:  CLRF   xB3
01200:  CLRF   xB2
.................... 	current.pulse_sum[2]=0; 
01202:  CLRF   xB9
01204:  CLRF   xB8
01206:  CLRF   xB7
01208:  CLRF   xB6
.................... 	enable_interrupts(GLOBAL); 
0120A:  MOVLW  C0
0120C:  IORWF  FF2,F
.................... } 
0120E:  GOTO   1C40 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
0114C:  BCF    FF2.6
0114E:  BCF    FF2.7
01150:  BTFSC  FF2.7
01152:  BRA    114E
.................... 	l=current.pulse_sum[ch]; 
01154:  MOVLB  8
01156:  CLRF   xD7
01158:  MOVFF  7EA,8D6
0115C:  CLRF   xD9
0115E:  MOVLW  04
01160:  MOVWF  xD8
01162:  MOVLB  0
01164:  CALL   0778
01168:  MOVFF  02,03
0116C:  MOVF   01,W
0116E:  ADDLW  AE
01170:  MOVWF  FE9
01172:  MOVLW  00
01174:  ADDWFC 02,W
01176:  MOVWF  FEA
01178:  MOVFF  FEF,00
0117C:  MOVFF  FEC,01
01180:  MOVFF  FEC,02
01184:  MOVFF  FEC,03
01188:  MOVFF  03,7EE
0118C:  MOVFF  02,7ED
01190:  MOVFF  01,7EC
01194:  MOVFF  00,7EB
.................... 	enable_interrupts(GLOBAL); 
01198:  MOVLW  C0
0119A:  IORWF  FF2,F
....................  
.................... 	return l; 
0119C:  MOVFF  7EB,00
011A0:  MOVFF  7EC,01
011A4:  MOVFF  7ED,02
011A8:  MOVFF  7EE,03
.................... } 
011AC:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01226:  MOVLB  7
01228:  MOVF   xE5,W
0122A:  SUBLW  06
0122C:  BC    1282
0122E:  XORLW  FF
01230:  BNZ   1238
01232:  MOVF   xE4,W
01234:  SUBLW  CF
01236:  BC    1282
01238:  MOVF   xE5,W
0123A:  SUBLW  09
0123C:  BNC   1282
0123E:  BNZ   1246
01240:  MOVF   xE4,W
01242:  SUBLW  CF
01244:  BNC   1282
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01246:  MOVLW  D0
01248:  SUBWF  xE4,W
0124A:  MOVWF  xEA
0124C:  MOVLW  07
0124E:  SUBWFB xE5,W
01250:  MOVWF  xEB
01252:  MOVLW  02
01254:  ADDWF  xEB,F
01256:  MOVFF  FF2,7EC
0125A:  BCF    FF2.6
0125C:  BCF    FF2.7
0125E:  MOVFF  7EB,FAA
01262:  MOVFF  7EA,FA9
01266:  BCF    FA6.6
01268:  BCF    FA6.7
0126A:  BSF    FA6.0
0126C:  MOVF   FA8,W
0126E:  BTFSC  xEC.6
01270:  BSF    FF2.6
01272:  BTFSC  xEC.7
01274:  BSF    FF2.7
01276:  CLRF   03
01278:  MOVWF  01
0127A:  MOVF   03,W
0127C:  MOVWF  02
0127E:  GOTO   1D52
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
01282:  MOVF   xE5,W
01284:  SUBLW  03
01286:  BC    1302
01288:  XORLW  FF
0128A:  BNZ   1292
0128C:  MOVF   xE4,W
0128E:  SUBLW  4B
01290:  BC    1302
01292:  MOVF   xE5,W
01294:  SUBLW  04
01296:  BNC   1302
01298:  BNZ   12A0
0129A:  MOVF   xE4,W
0129C:  SUBLW  93
0129E:  BNC   1302
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
012A0:  MOVLW  4C
012A2:  SUBWF  xE4,W
012A4:  MOVWF  xE6
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
012A6:  MOVFF  7E6,7EA
012AA:  MOVLW  06
012AC:  MOVWF  xEB
012AE:  MOVLB  0
012B0:  RCALL  1120
012B2:  MOVFF  00,7E7
.................... 		n = n / 6; /* number of sentence */ 
012B6:  MOVFF  7E6,7EA
012BA:  MOVLW  06
012BC:  MOVLB  7
012BE:  MOVWF  xEB
012C0:  MOVLB  0
012C2:  RCALL  1120
012C4:  MOVFF  01,7E6
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
012C8:  MOVLB  7
012CA:  MOVF   xE6,W
012CC:  MULLW  06
012CE:  MOVF   FF3,W
012D0:  CLRF   03
012D2:  ADDLW  18
012D4:  MOVWF  xEA
012D6:  MOVLW  00
012D8:  ADDWFC 03,W
012DA:  MOVWF  xEB
012DC:  CLRF   03
012DE:  MOVF   xE7,W
012E0:  ADDWF  xEA,W
012E2:  MOVWF  01
012E4:  MOVF   xEB,W
012E6:  ADDWFC 03,F
012E8:  MOVF   01,W
012EA:  ADDLW  36
012EC:  MOVWF  FE9
012EE:  MOVLW  00
012F0:  ADDWFC 03,W
012F2:  MOVWF  FEA
012F4:  MOVF   FEF,W
012F6:  CLRF   03
012F8:  MOVWF  01
012FA:  MOVFF  03,02
012FE:  GOTO   1D52
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
01302:  MOVF   xE5,W
01304:  SUBLW  12
01306:  BC    134A
01308:  XORLW  FF
0130A:  BNZ   1312
0130C:  MOVF   xE4,W
0130E:  SUBLW  87
01310:  BC    134A
01312:  MOVF   xE5,W
01314:  SUBLW  17
01316:  BNC   134A
01318:  BNZ   1320
0131A:  MOVF   xE4,W
0131C:  SUBLW  47
0131E:  BNC   134A
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
01320:  MOVLW  88
01322:  SUBWF  xE4,F
01324:  MOVLW  13
01326:  SUBWFB xE5,F
....................  
....................  		p  = nmea.sentence[0]; 
01328:  MOVLW  02
0132A:  MOVWF  xE9
0132C:  MOVLW  FC
0132E:  MOVWF  xE8
.................... 		return (int16) p[addr]; 
01330:  MOVF   xE8,W
01332:  ADDWF  xE4,W
01334:  MOVWF  FE9
01336:  MOVF   xE9,W
01338:  ADDWFC xE5,W
0133A:  MOVWF  FEA
0133C:  MOVF   FEF,W
0133E:  CLRF   03
01340:  MOVWF  01
01342:  MOVFF  03,02
01346:  GOTO   1D52
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
0134A:  MOVF   xE5,W
0134C:  SUBLW  16
0134E:  BC    13BA
01350:  XORLW  FF
01352:  BNZ   135A
01354:  MOVF   xE4,W
01356:  SUBLW  6F
01358:  BC    13BA
0135A:  MOVF   xE5,W
0135C:  SUBLW  19
0135E:  BNC   13BA
01360:  BNZ   1368
01362:  MOVF   xE4,W
01364:  SUBLW  4F
01366:  BNC   13BA
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01368:  MOVLW  70
0136A:  SUBWF  xE4,F
0136C:  MOVLW  17
0136E:  SUBWFB xE5,F
.................... 		addr = addr * 2; 
01370:  BCF    FD8.0
01372:  RLCF   xE4,F
01374:  RLCF   xE5,F
....................  
....................  		p  = nmea.sentence[0]; 
01376:  MOVLW  02
01378:  MOVWF  xE9
0137A:  MOVLW  FC
0137C:  MOVWF  xE8
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0137E:  MOVF   xE8,W
01380:  ADDWF  xE4,W
01382:  MOVWF  FE9
01384:  MOVF   xE9,W
01386:  ADDWFC xE5,W
01388:  MOVWF  FEA
0138A:  MOVFF  FEF,7EA
0138E:  MOVLW  01
01390:  ADDWF  xE4,W
01392:  MOVWF  xEB
01394:  MOVLW  00
01396:  ADDWFC xE5,W
01398:  MOVWF  xEC
0139A:  MOVF   xE8,W
0139C:  ADDWF  xEB,W
0139E:  MOVWF  FE9
013A0:  MOVF   xE9,W
013A2:  ADDWFC xEC,W
013A4:  MOVWF  FEA
013A6:  MOVFF  FEF,7ED
013AA:  MOVFF  7EA,03
013AE:  MOVFF  7ED,01
013B2:  MOVFF  7EA,02
013B6:  GOTO   1D52
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
013BA:  MOVF   xE4,W
013BC:  MOVWF  00
013BE:  MOVF   xE5,W
013C0:  MOVWF  03
013C2:  MOVF   03,W
013C4:  BNZ   13D0
013C6:  MOVF   00,F
013C8:  MOVLB  0
013CA:  BTFSC  FD8.2
013CC:  BRA    17EC
013CE:  MOVLB  7
013D0:  MOVF   03,W
013D2:  BNZ   13E0
013D4:  MOVLW  01
013D6:  SUBWF  00,W
013D8:  MOVLB  0
013DA:  BTFSC  FD8.2
013DC:  BRA    17FA
013DE:  MOVLB  7
013E0:  MOVF   03,W
013E2:  BNZ   13F0
013E4:  MOVLW  02
013E6:  SUBWF  00,W
013E8:  MOVLB  0
013EA:  BTFSC  FD8.2
013EC:  BRA    1808
013EE:  MOVLB  7
013F0:  MOVF   03,W
013F2:  BNZ   1400
013F4:  MOVLW  03
013F6:  SUBWF  00,W
013F8:  MOVLB  0
013FA:  BTFSC  FD8.2
013FC:  BRA    1816
013FE:  MOVLB  7
01400:  MOVF   03,W
01402:  BNZ   1410
01404:  MOVLW  04
01406:  SUBWF  00,W
01408:  MOVLB  0
0140A:  BTFSC  FD8.2
0140C:  BRA    1824
0140E:  MOVLB  7
01410:  MOVF   03,W
01412:  BNZ   1420
01414:  MOVLW  05
01416:  SUBWF  00,W
01418:  MOVLB  0
0141A:  BTFSC  FD8.2
0141C:  BRA    184A
0141E:  MOVLB  7
01420:  MOVF   03,W
01422:  BNZ   1430
01424:  MOVLW  06
01426:  SUBWF  00,W
01428:  MOVLB  0
0142A:  BTFSC  FD8.2
0142C:  BRA    1858
0142E:  MOVLB  7
01430:  MOVF   03,W
01432:  BNZ   1440
01434:  MOVLW  07
01436:  SUBWF  00,W
01438:  MOVLB  0
0143A:  BTFSC  FD8.2
0143C:  BRA    1866
0143E:  MOVLB  7
01440:  MOVF   03,W
01442:  BNZ   1450
01444:  MOVLW  08
01446:  SUBWF  00,W
01448:  MOVLB  0
0144A:  BTFSC  FD8.2
0144C:  BRA    1874
0144E:  MOVLB  7
01450:  MOVF   03,W
01452:  BNZ   1460
01454:  MOVLW  09
01456:  SUBWF  00,W
01458:  MOVLB  0
0145A:  BTFSC  FD8.2
0145C:  BRA    1882
0145E:  MOVLB  7
01460:  MOVF   03,W
01462:  BNZ   1470
01464:  MOVLW  0A
01466:  SUBWF  00,W
01468:  MOVLB  0
0146A:  BTFSC  FD8.2
0146C:  BRA    1890
0146E:  MOVLB  7
01470:  MOVF   03,W
01472:  BNZ   1480
01474:  MOVLW  0B
01476:  SUBWF  00,W
01478:  MOVLB  0
0147A:  BTFSC  FD8.2
0147C:  BRA    18B8
0147E:  MOVLB  7
01480:  MOVF   03,W
01482:  BNZ   1490
01484:  MOVLW  0C
01486:  SUBWF  00,W
01488:  MOVLB  0
0148A:  BTFSC  FD8.2
0148C:  BRA    18C6
0148E:  MOVLB  7
01490:  MOVF   03,W
01492:  BNZ   14A0
01494:  MOVLW  0D
01496:  SUBWF  00,W
01498:  MOVLB  0
0149A:  BTFSC  FD8.2
0149C:  BRA    18D4
0149E:  MOVLB  7
014A0:  MOVF   03,W
014A2:  BNZ   14B0
014A4:  MOVLW  0E
014A6:  SUBWF  00,W
014A8:  MOVLB  0
014AA:  BTFSC  FD8.2
014AC:  BRA    18E2
014AE:  MOVLB  7
014B0:  MOVF   03,W
014B2:  BNZ   14C0
014B4:  MOVLW  0F
014B6:  SUBWF  00,W
014B8:  MOVLB  0
014BA:  BTFSC  FD8.2
014BC:  BRA    18F0
014BE:  MOVLB  7
014C0:  MOVF   03,W
014C2:  BNZ   14D0
014C4:  MOVLW  10
014C6:  SUBWF  00,W
014C8:  MOVLB  0
014CA:  BTFSC  FD8.2
014CC:  BRA    18FE
014CE:  MOVLB  7
014D0:  MOVF   03,W
014D2:  BNZ   14E0
014D4:  MOVLW  11
014D6:  SUBWF  00,W
014D8:  MOVLB  0
014DA:  BTFSC  FD8.2
014DC:  BRA    1926
014DE:  MOVLB  7
014E0:  MOVF   03,W
014E2:  BNZ   14F0
014E4:  MOVLW  12
014E6:  SUBWF  00,W
014E8:  MOVLB  0
014EA:  BTFSC  FD8.2
014EC:  BRA    1934
014EE:  MOVLB  7
014F0:  MOVF   03,W
014F2:  BNZ   1500
014F4:  MOVLW  13
014F6:  SUBWF  00,W
014F8:  MOVLB  0
014FA:  BTFSC  FD8.2
014FC:  BRA    1962
014FE:  MOVLB  7
01500:  MOVF   03,W
01502:  BNZ   1510
01504:  MOVLW  14
01506:  SUBWF  00,W
01508:  MOVLB  0
0150A:  BTFSC  FD8.2
0150C:  BRA    197A
0150E:  MOVLB  7
01510:  MOVF   03,W
01512:  BNZ   1520
01514:  MOVLW  15
01516:  SUBWF  00,W
01518:  MOVLB  0
0151A:  BTFSC  FD8.2
0151C:  BRA    1988
0151E:  MOVLB  7
01520:  MOVF   03,W
01522:  BNZ   1530
01524:  MOVLW  16
01526:  SUBWF  00,W
01528:  MOVLB  0
0152A:  BTFSC  FD8.2
0152C:  BRA    19B6
0152E:  MOVLB  7
01530:  MOVF   03,W
01532:  BNZ   1540
01534:  MOVLW  17
01536:  SUBWF  00,W
01538:  MOVLB  0
0153A:  BTFSC  FD8.2
0153C:  BRA    19D0
0153E:  MOVLB  7
01540:  MOVF   03,W
01542:  BNZ   1550
01544:  MOVLW  18
01546:  SUBWF  00,W
01548:  MOVLB  0
0154A:  BTFSC  FD8.2
0154C:  BRA    19DE
0154E:  MOVLB  7
01550:  MOVF   03,W
01552:  BNZ   1560
01554:  MOVLW  19
01556:  SUBWF  00,W
01558:  MOVLB  0
0155A:  BTFSC  FD8.2
0155C:  BRA    1A0C
0155E:  MOVLB  7
01560:  MOVF   03,W
01562:  BNZ   1570
01564:  MOVLW  1A
01566:  SUBWF  00,W
01568:  MOVLB  0
0156A:  BTFSC  FD8.2
0156C:  BRA    1A26
0156E:  MOVLB  7
01570:  MOVF   03,W
01572:  BNZ   1580
01574:  MOVLW  1B
01576:  SUBWF  00,W
01578:  MOVLB  0
0157A:  BTFSC  FD8.2
0157C:  BRA    1A34
0157E:  MOVLB  7
01580:  MOVF   03,W
01582:  BNZ   1590
01584:  MOVLW  1C
01586:  SUBWF  00,W
01588:  MOVLB  0
0158A:  BTFSC  FD8.2
0158C:  BRA    1A62
0158E:  MOVLB  7
01590:  MOVF   03,W
01592:  BNZ   15A0
01594:  MOVLW  1D
01596:  SUBWF  00,W
01598:  MOVLB  0
0159A:  BTFSC  FD8.2
0159C:  BRA    1A7C
0159E:  MOVLB  7
015A0:  MOVF   03,W
015A2:  BNZ   15B0
015A4:  MOVLW  1E
015A6:  SUBWF  00,W
015A8:  MOVLB  0
015AA:  BTFSC  FD8.2
015AC:  BRA    1A8A
015AE:  MOVLB  7
015B0:  MOVF   03,W
015B2:  BNZ   15C0
015B4:  MOVLW  1F
015B6:  SUBWF  00,W
015B8:  MOVLB  0
015BA:  BTFSC  FD8.2
015BC:  BRA    1AB8
015BE:  MOVLB  7
015C0:  MOVF   03,W
015C2:  BNZ   15D0
015C4:  MOVLW  20
015C6:  SUBWF  00,W
015C8:  MOVLB  0
015CA:  BTFSC  FD8.2
015CC:  BRA    1AD2
015CE:  MOVLB  7
015D0:  MOVF   03,W
015D2:  BNZ   15E0
015D4:  MOVLW  21
015D6:  SUBWF  00,W
015D8:  MOVLB  0
015DA:  BTFSC  FD8.2
015DC:  BRA    1AE0
015DE:  MOVLB  7
015E0:  MOVF   03,W
015E2:  BNZ   15F0
015E4:  MOVLW  22
015E6:  SUBWF  00,W
015E8:  MOVLB  0
015EA:  BTFSC  FD8.2
015EC:  BRA    1B0E
015EE:  MOVLB  7
015F0:  MOVF   03,W
015F2:  BNZ   1600
015F4:  MOVLW  23
015F6:  SUBWF  00,W
015F8:  MOVLB  0
015FA:  BTFSC  FD8.2
015FC:  BRA    1B28
015FE:  MOVLB  7
01600:  MOVF   03,W
01602:  BNZ   1610
01604:  MOVLW  24
01606:  SUBWF  00,W
01608:  MOVLB  0
0160A:  BTFSC  FD8.2
0160C:  BRA    1B36
0160E:  MOVLB  7
01610:  MOVF   03,W
01612:  BNZ   1620
01614:  MOVLW  25
01616:  SUBWF  00,W
01618:  MOVLB  0
0161A:  BTFSC  FD8.2
0161C:  BRA    1B64
0161E:  MOVLB  7
01620:  MOVF   03,W
01622:  BNZ   1630
01624:  MOVLW  26
01626:  SUBWF  00,W
01628:  MOVLB  0
0162A:  BTFSC  FD8.2
0162C:  BRA    1B7E
0162E:  MOVLB  7
01630:  MOVF   03,W
01632:  BNZ   1640
01634:  MOVLW  27
01636:  SUBWF  00,W
01638:  MOVLB  0
0163A:  BTFSC  FD8.2
0163C:  BRA    1B8C
0163E:  MOVLB  7
01640:  MOVF   03,W
01642:  BNZ   1650
01644:  MOVLW  28
01646:  SUBWF  00,W
01648:  MOVLB  0
0164A:  BTFSC  FD8.2
0164C:  BRA    1BBA
0164E:  MOVLB  7
01650:  MOVF   03,W
01652:  BNZ   1660
01654:  MOVLW  29
01656:  SUBWF  00,W
01658:  MOVLB  0
0165A:  BTFSC  FD8.2
0165C:  BRA    1BD4
0165E:  MOVLB  7
01660:  MOVF   03,W
01662:  BNZ   1670
01664:  MOVLW  2A
01666:  SUBWF  00,W
01668:  MOVLB  0
0166A:  BTFSC  FD8.2
0166C:  BRA    1BE2
0166E:  MOVLB  7
01670:  MOVF   03,W
01672:  BNZ   1680
01674:  MOVLW  2B
01676:  SUBWF  00,W
01678:  MOVLB  0
0167A:  BTFSC  FD8.2
0167C:  BRA    1BFC
0167E:  MOVLB  7
01680:  MOVF   03,W
01682:  BNZ   1690
01684:  MOVLW  2C
01686:  SUBWF  00,W
01688:  MOVLB  0
0168A:  BTFSC  FD8.2
0168C:  BRA    1C0C
0168E:  MOVLB  7
01690:  MOVF   03,W
01692:  BNZ   16A0
01694:  MOVLW  2D
01696:  SUBWF  00,W
01698:  MOVLB  0
0169A:  BTFSC  FD8.2
0169C:  BRA    1C1C
0169E:  MOVLB  7
016A0:  MOVF   03,W
016A2:  BNZ   16B0
016A4:  MOVLW  2E
016A6:  SUBWF  00,W
016A8:  MOVLB  0
016AA:  BTFSC  FD8.2
016AC:  BRA    1C2C
016AE:  MOVLB  7
016B0:  MOVF   03,W
016B2:  BNZ   16C0
016B4:  MOVLW  2F
016B6:  SUBWF  00,W
016B8:  MOVLB  0
016BA:  BTFSC  FD8.2
016BC:  BRA    1C3C
016BE:  MOVLB  7
016C0:  MOVF   03,W
016C2:  BNZ   16D0
016C4:  MOVLW  30
016C6:  SUBWF  00,W
016C8:  MOVLB  0
016CA:  BTFSC  FD8.2
016CC:  BRA    1C4C
016CE:  MOVLB  7
016D0:  MOVF   03,W
016D2:  BNZ   16E0
016D4:  MOVLW  31
016D6:  SUBWF  00,W
016D8:  MOVLB  0
016DA:  BTFSC  FD8.2
016DC:  BRA    1C5C
016DE:  MOVLB  7
016E0:  MOVF   03,W
016E2:  BNZ   16F0
016E4:  MOVLW  32
016E6:  SUBWF  00,W
016E8:  MOVLB  0
016EA:  BTFSC  FD8.2
016EC:  BRA    1C6C
016EE:  MOVLB  7
016F0:  MOVF   03,W
016F2:  BNZ   1700
016F4:  MOVLW  33
016F6:  SUBWF  00,W
016F8:  MOVLB  0
016FA:  BTFSC  FD8.2
016FC:  BRA    1C7C
016FE:  MOVLB  7
01700:  MOVLW  03
01702:  SUBWF  03,W
01704:  BNZ   1712
01706:  MOVLW  E8
01708:  SUBWF  00,W
0170A:  MOVLB  0
0170C:  BTFSC  FD8.2
0170E:  BRA    1C8C
01710:  MOVLB  7
01712:  MOVLW  03
01714:  SUBWF  03,W
01716:  BNZ   1724
01718:  MOVLW  E9
0171A:  SUBWF  00,W
0171C:  MOVLB  0
0171E:  BTFSC  FD8.2
01720:  BRA    1C9C
01722:  MOVLB  7
01724:  MOVLW  03
01726:  SUBWF  03,W
01728:  BNZ   1736
0172A:  MOVLW  EA
0172C:  SUBWF  00,W
0172E:  MOVLB  0
01730:  BTFSC  FD8.2
01732:  BRA    1CAA
01734:  MOVLB  7
01736:  MOVLW  03
01738:  SUBWF  03,W
0173A:  BNZ   1748
0173C:  MOVLW  EB
0173E:  SUBWF  00,W
01740:  MOVLB  0
01742:  BTFSC  FD8.2
01744:  BRA    1CB8
01746:  MOVLB  7
01748:  MOVLW  03
0174A:  SUBWF  03,W
0174C:  BNZ   175A
0174E:  MOVLW  EC
01750:  SUBWF  00,W
01752:  MOVLB  0
01754:  BTFSC  FD8.2
01756:  BRA    1CC6
01758:  MOVLB  7
0175A:  MOVLW  03
0175C:  SUBWF  03,W
0175E:  BNZ   176C
01760:  MOVLW  ED
01762:  SUBWF  00,W
01764:  MOVLB  0
01766:  BTFSC  FD8.2
01768:  BRA    1CD4
0176A:  MOVLB  7
0176C:  MOVLW  03
0176E:  SUBWF  03,W
01770:  BNZ   177E
01772:  MOVLW  EE
01774:  SUBWF  00,W
01776:  MOVLB  0
01778:  BTFSC  FD8.2
0177A:  BRA    1CE2
0177C:  MOVLB  7
0177E:  MOVLW  03
01780:  SUBWF  03,W
01782:  BNZ   1790
01784:  MOVLW  EF
01786:  SUBWF  00,W
01788:  MOVLB  0
0178A:  BTFSC  FD8.2
0178C:  BRA    1CF2
0178E:  MOVLB  7
01790:  MOVLW  03
01792:  SUBWF  03,W
01794:  BNZ   17A2
01796:  MOVLW  F0
01798:  SUBWF  00,W
0179A:  MOVLB  0
0179C:  BTFSC  FD8.2
0179E:  BRA    1D00
017A0:  MOVLB  7
017A2:  MOVLW  03
017A4:  SUBWF  03,W
017A6:  BNZ   17B4
017A8:  MOVLW  F1
017AA:  SUBWF  00,W
017AC:  MOVLB  0
017AE:  BTFSC  FD8.2
017B0:  BRA    1D10
017B2:  MOVLB  7
017B4:  MOVLW  03
017B6:  SUBWF  03,W
017B8:  BNZ   17C6
017BA:  MOVLW  F2
017BC:  SUBWF  00,W
017BE:  MOVLB  0
017C0:  BTFSC  FD8.2
017C2:  BRA    1D1E
017C4:  MOVLB  7
017C6:  MOVLW  03
017C8:  SUBWF  03,W
017CA:  BNZ   17D8
017CC:  MOVLW  F3
017CE:  SUBWF  00,W
017D0:  MOVLB  0
017D2:  BTFSC  FD8.2
017D4:  BRA    1D2C
017D6:  MOVLB  7
017D8:  MOVLW  03
017DA:  SUBWF  03,W
017DC:  BNZ   17EA
017DE:  MOVLW  F4
017E0:  SUBWF  00,W
017E2:  MOVLB  0
017E4:  BTFSC  FD8.2
017E6:  BRA    1D3C
017E8:  MOVLB  7
017EA:  BRA    1D4A
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
017EC:  MOVFF  A8,01
017F0:  MOVFF  A9,02
017F4:  MOVLB  7
017F6:  BRA    1D52
017F8:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
017FA:  MOVF   x96,W
017FC:  MOVWF  01
017FE:  MOVF   x97,W
01800:  MOVWF  02
01802:  MOVLB  7
01804:  BRA    1D52
01806:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01808:  MOVF   x9C,W
0180A:  MOVWF  01
0180C:  MOVF   x9D,W
0180E:  MOVWF  02
01810:  MOVLB  7
01812:  BRA    1D52
01814:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01816:  MOVF   xA2,W
01818:  MOVWF  01
0181A:  MOVF   xA3,W
0181C:  MOVWF  02
0181E:  MOVLB  7
01820:  BRA    1D52
01822:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01824:  MOVLB  7
01826:  CLRF   xEA
01828:  MOVLB  0
0182A:  RCALL  114C
0182C:  MOVFF  03,7C6
01830:  MOVFF  02,7C5
01834:  MOVFF  01,7C4
01838:  MOVFF  00,7C3
0183C:  MOVLB  7
0183E:  MOVF   xC3,W
01840:  MOVWF  01
01842:  MOVF   xC4,W
01844:  MOVWF  02
01846:  BRA    1D52
01848:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
0184A:  MOVLB  7
0184C:  MOVF   xC5,W
0184E:  MOVWF  01
01850:  MOVF   xC6,W
01852:  MOVWF  02
01854:  BRA    1D52
01856:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01858:  MOVF   xAA,W
0185A:  MOVWF  01
0185C:  MOVF   xAB,W
0185E:  MOVWF  02
01860:  MOVLB  7
01862:  BRA    1D52
01864:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01866:  MOVF   x98,W
01868:  MOVWF  01
0186A:  MOVF   x99,W
0186C:  MOVWF  02
0186E:  MOVLB  7
01870:  BRA    1D52
01872:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01874:  MOVF   x9E,W
01876:  MOVWF  01
01878:  MOVF   x9F,W
0187A:  MOVWF  02
0187C:  MOVLB  7
0187E:  BRA    1D52
01880:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01882:  MOVF   xA4,W
01884:  MOVWF  01
01886:  MOVF   xA5,W
01888:  MOVWF  02
0188A:  MOVLB  7
0188C:  BRA    1D52
0188E:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01890:  MOVLW  01
01892:  MOVLB  7
01894:  MOVWF  xEA
01896:  MOVLB  0
01898:  RCALL  114C
0189A:  MOVFF  03,7C6
0189E:  MOVFF  02,7C5
018A2:  MOVFF  01,7C4
018A6:  MOVFF  00,7C3
018AA:  MOVLB  7
018AC:  MOVF   xC3,W
018AE:  MOVWF  01
018B0:  MOVF   xC4,W
018B2:  MOVWF  02
018B4:  BRA    1D52
018B6:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
018B8:  MOVLB  7
018BA:  MOVF   xC5,W
018BC:  MOVWF  01
018BE:  MOVF   xC6,W
018C0:  MOVWF  02
018C2:  BRA    1D52
018C4:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
018C6:  MOVF   xAC,W
018C8:  MOVWF  01
018CA:  MOVF   xAD,W
018CC:  MOVWF  02
018CE:  MOVLB  7
018D0:  BRA    1D52
018D2:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
018D4:  MOVF   x9A,W
018D6:  MOVWF  01
018D8:  MOVF   x9B,W
018DA:  MOVWF  02
018DC:  MOVLB  7
018DE:  BRA    1D52
018E0:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
018E2:  MOVF   xA0,W
018E4:  MOVWF  01
018E6:  MOVF   xA1,W
018E8:  MOVWF  02
018EA:  MOVLB  7
018EC:  BRA    1D52
018EE:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
018F0:  MOVF   xA6,W
018F2:  MOVWF  01
018F4:  MOVF   xA7,W
018F6:  MOVWF  02
018F8:  MOVLB  7
018FA:  BRA    1D52
018FC:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
018FE:  MOVLW  02
01900:  MOVLB  7
01902:  MOVWF  xEA
01904:  MOVLB  0
01906:  RCALL  114C
01908:  MOVFF  03,7C6
0190C:  MOVFF  02,7C5
01910:  MOVFF  01,7C4
01914:  MOVFF  00,7C3
01918:  MOVLB  7
0191A:  MOVF   xC3,W
0191C:  MOVWF  01
0191E:  MOVF   xC4,W
01920:  MOVWF  02
01922:  BRA    1D52
01924:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01926:  MOVLB  7
01928:  MOVF   xC5,W
0192A:  MOVWF  01
0192C:  MOVF   xC6,W
0192E:  MOVWF  02
01930:  BRA    1D52
01932:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01934:  CLRF   03
01936:  MOVLB  1
01938:  MOVF   xCA,W
0193A:  MOVWF  02
0193C:  BCF    FD8.0
0193E:  RLCF   02,F
01940:  RLCF   03,F
01942:  MOVF   02,W
01944:  ADDLW  CA
01946:  MOVWF  FE9
01948:  MOVLW  00
0194A:  ADDWFC 03,W
0194C:  MOVWF  FEA
0194E:  MOVFF  FEC,03
01952:  MOVF   FED,F
01954:  MOVF   FEF,W
01956:  MOVWF  01
01958:  MOVF   03,W
0195A:  MOVWF  02
0195C:  MOVLB  7
0195E:  BRA    1D52
01960:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01962:  MOVLB  7
01964:  CLRF   xEA
01966:  MOVLB  0
01968:  CALL   0D26
0196C:  MOVF   01,W
0196E:  MOVWF  01
01970:  MOVF   02,W
01972:  MOVWF  02
01974:  MOVLB  7
01976:  BRA    1D52
01978:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
0197A:  MOVF   xBA,W
0197C:  MOVWF  01
0197E:  MOVF   xBB,W
01980:  MOVWF  02
01982:  MOVLB  7
01984:  BRA    1D52
01986:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01988:  CLRF   03
0198A:  MOVLB  1
0198C:  MOVF   xCA,W
0198E:  MOVWF  02
01990:  BCF    FD8.0
01992:  RLCF   02,F
01994:  RLCF   03,F
01996:  MOVF   02,W
01998:  ADDLW  EA
0199A:  MOVWF  FE9
0199C:  MOVLW  00
0199E:  ADDWFC 03,W
019A0:  MOVWF  FEA
019A2:  MOVFF  FEC,03
019A6:  MOVF   FED,F
019A8:  MOVF   FEF,W
019AA:  MOVWF  01
019AC:  MOVF   03,W
019AE:  MOVWF  02
019B0:  MOVLB  7
019B2:  BRA    1D52
019B4:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
019B6:  MOVLW  01
019B8:  MOVLB  7
019BA:  MOVWF  xEA
019BC:  MOVLB  0
019BE:  CALL   0D26
019C2:  MOVF   01,W
019C4:  MOVWF  01
019C6:  MOVF   02,W
019C8:  MOVWF  02
019CA:  MOVLB  7
019CC:  BRA    1D52
019CE:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
019D0:  MOVF   xBC,W
019D2:  MOVWF  01
019D4:  MOVF   xBD,W
019D6:  MOVWF  02
019D8:  MOVLB  7
019DA:  BRA    1D52
019DC:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
019DE:  CLRF   03
019E0:  MOVLB  1
019E2:  MOVF   xCA,W
019E4:  MOVWF  02
019E6:  BCF    FD8.0
019E8:  RLCF   02,F
019EA:  RLCF   03,F
019EC:  MOVF   02,W
019EE:  ADDLW  0A
019F0:  MOVWF  FE9
019F2:  MOVLW  01
019F4:  ADDWFC 03,W
019F6:  MOVWF  FEA
019F8:  MOVFF  FEC,03
019FC:  MOVF   FED,F
019FE:  MOVF   FEF,W
01A00:  MOVWF  01
01A02:  MOVF   03,W
01A04:  MOVWF  02
01A06:  MOVLB  7
01A08:  BRA    1D52
01A0A:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01A0C:  MOVLW  02
01A0E:  MOVLB  7
01A10:  MOVWF  xEA
01A12:  MOVLB  0
01A14:  CALL   0D26
01A18:  MOVF   01,W
01A1A:  MOVWF  01
01A1C:  MOVF   02,W
01A1E:  MOVWF  02
01A20:  MOVLB  7
01A22:  BRA    1D52
01A24:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01A26:  MOVF   xBE,W
01A28:  MOVWF  01
01A2A:  MOVF   xBF,W
01A2C:  MOVWF  02
01A2E:  MOVLB  7
01A30:  BRA    1D52
01A32:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01A34:  CLRF   03
01A36:  MOVLB  1
01A38:  MOVF   xCA,W
01A3A:  MOVWF  02
01A3C:  BCF    FD8.0
01A3E:  RLCF   02,F
01A40:  RLCF   03,F
01A42:  MOVF   02,W
01A44:  ADDLW  2A
01A46:  MOVWF  FE9
01A48:  MOVLW  01
01A4A:  ADDWFC 03,W
01A4C:  MOVWF  FEA
01A4E:  MOVFF  FEC,03
01A52:  MOVF   FED,F
01A54:  MOVF   FEF,W
01A56:  MOVWF  01
01A58:  MOVF   03,W
01A5A:  MOVWF  02
01A5C:  MOVLB  7
01A5E:  BRA    1D52
01A60:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01A62:  MOVLW  03
01A64:  MOVLB  7
01A66:  MOVWF  xEA
01A68:  MOVLB  0
01A6A:  CALL   0D26
01A6E:  MOVF   01,W
01A70:  MOVWF  01
01A72:  MOVF   02,W
01A74:  MOVWF  02
01A76:  MOVLB  7
01A78:  BRA    1D52
01A7A:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01A7C:  MOVF   xC0,W
01A7E:  MOVWF  01
01A80:  MOVF   xC1,W
01A82:  MOVWF  02
01A84:  MOVLB  7
01A86:  BRA    1D52
01A88:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01A8A:  CLRF   03
01A8C:  MOVLB  1
01A8E:  MOVF   xCA,W
01A90:  MOVWF  02
01A92:  BCF    FD8.0
01A94:  RLCF   02,F
01A96:  RLCF   03,F
01A98:  MOVF   02,W
01A9A:  ADDLW  4A
01A9C:  MOVWF  FE9
01A9E:  MOVLW  01
01AA0:  ADDWFC 03,W
01AA2:  MOVWF  FEA
01AA4:  MOVFF  FEC,03
01AA8:  MOVF   FED,F
01AAA:  MOVF   FEF,W
01AAC:  MOVWF  01
01AAE:  MOVF   03,W
01AB0:  MOVWF  02
01AB2:  MOVLB  7
01AB4:  BRA    1D52
01AB6:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01AB8:  MOVLW  04
01ABA:  MOVLB  7
01ABC:  MOVWF  xEA
01ABE:  MOVLB  0
01AC0:  CALL   0D26
01AC4:  MOVF   01,W
01AC6:  MOVWF  01
01AC8:  MOVF   02,W
01ACA:  MOVWF  02
01ACC:  MOVLB  7
01ACE:  BRA    1D52
01AD0:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01AD2:  MOVF   xC2,W
01AD4:  MOVWF  01
01AD6:  MOVF   xC3,W
01AD8:  MOVWF  02
01ADA:  MOVLB  7
01ADC:  BRA    1D52
01ADE:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01AE0:  CLRF   03
01AE2:  MOVLB  1
01AE4:  MOVF   xCA,W
01AE6:  MOVWF  02
01AE8:  BCF    FD8.0
01AEA:  RLCF   02,F
01AEC:  RLCF   03,F
01AEE:  MOVF   02,W
01AF0:  ADDLW  6A
01AF2:  MOVWF  FE9
01AF4:  MOVLW  01
01AF6:  ADDWFC 03,W
01AF8:  MOVWF  FEA
01AFA:  MOVFF  FEC,03
01AFE:  MOVF   FED,F
01B00:  MOVF   FEF,W
01B02:  MOVWF  01
01B04:  MOVF   03,W
01B06:  MOVWF  02
01B08:  MOVLB  7
01B0A:  BRA    1D52
01B0C:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01B0E:  MOVLW  05
01B10:  MOVLB  7
01B12:  MOVWF  xEA
01B14:  MOVLB  0
01B16:  CALL   0D26
01B1A:  MOVF   01,W
01B1C:  MOVWF  01
01B1E:  MOVF   02,W
01B20:  MOVWF  02
01B22:  MOVLB  7
01B24:  BRA    1D52
01B26:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01B28:  MOVF   xC4,W
01B2A:  MOVWF  01
01B2C:  MOVF   xC5,W
01B2E:  MOVWF  02
01B30:  MOVLB  7
01B32:  BRA    1D52
01B34:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01B36:  CLRF   03
01B38:  MOVLB  1
01B3A:  MOVF   xCA,W
01B3C:  MOVWF  02
01B3E:  BCF    FD8.0
01B40:  RLCF   02,F
01B42:  RLCF   03,F
01B44:  MOVF   02,W
01B46:  ADDLW  8A
01B48:  MOVWF  FE9
01B4A:  MOVLW  01
01B4C:  ADDWFC 03,W
01B4E:  MOVWF  FEA
01B50:  MOVFF  FEC,03
01B54:  MOVF   FED,F
01B56:  MOVF   FEF,W
01B58:  MOVWF  01
01B5A:  MOVF   03,W
01B5C:  MOVWF  02
01B5E:  MOVLB  7
01B60:  BRA    1D52
01B62:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01B64:  MOVLW  06
01B66:  MOVLB  7
01B68:  MOVWF  xEA
01B6A:  MOVLB  0
01B6C:  CALL   0D26
01B70:  MOVF   01,W
01B72:  MOVWF  01
01B74:  MOVF   02,W
01B76:  MOVWF  02
01B78:  MOVLB  7
01B7A:  BRA    1D52
01B7C:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01B7E:  MOVF   xC6,W
01B80:  MOVWF  01
01B82:  MOVF   xC7,W
01B84:  MOVWF  02
01B86:  MOVLB  7
01B88:  BRA    1D52
01B8A:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01B8C:  CLRF   03
01B8E:  MOVLB  1
01B90:  MOVF   xCA,W
01B92:  MOVWF  02
01B94:  BCF    FD8.0
01B96:  RLCF   02,F
01B98:  RLCF   03,F
01B9A:  MOVF   02,W
01B9C:  ADDLW  AA
01B9E:  MOVWF  FE9
01BA0:  MOVLW  01
01BA2:  ADDWFC 03,W
01BA4:  MOVWF  FEA
01BA6:  MOVFF  FEC,03
01BAA:  MOVF   FED,F
01BAC:  MOVF   FEF,W
01BAE:  MOVWF  01
01BB0:  MOVF   03,W
01BB2:  MOVWF  02
01BB4:  MOVLB  7
01BB6:  BRA    1D52
01BB8:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01BBA:  MOVLW  07
01BBC:  MOVLB  7
01BBE:  MOVWF  xEA
01BC0:  MOVLB  0
01BC2:  CALL   0D26
01BC6:  MOVF   01,W
01BC8:  MOVWF  01
01BCA:  MOVF   02,W
01BCC:  MOVWF  02
01BCE:  MOVLB  7
01BD0:  BRA    1D52
01BD2:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01BD4:  MOVF   xC8,W
01BD6:  MOVWF  01
01BD8:  MOVF   xC9,W
01BDA:  MOVWF  02
01BDC:  MOVLB  7
01BDE:  BRA    1D52
01BE0:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01BE2:  MOVLB  1
01BE4:  MOVF   xD2,W
01BE6:  MOVWF  03
01BE8:  MOVF   xD1,W
01BEA:  INCF   xD1,F
01BEC:  BTFSC  FD8.2
01BEE:  INCF   xD2,F
01BF0:  MOVWF  01
01BF2:  MOVF   03,W
01BF4:  MOVWF  02
01BF6:  MOVLB  7
01BF8:  BRA    1D52
01BFA:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01BFC:  MOVLB  1
01BFE:  MOVF   xD5,W
01C00:  MOVWF  01
01C02:  MOVF   xD6,W
01C04:  MOVWF  02
01C06:  MOVLB  7
01C08:  BRA    1D52
01C0A:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01C0C:  MOVLB  1
01C0E:  MOVF   xD3,W
01C10:  MOVWF  01
01C12:  MOVF   xD4,W
01C14:  MOVWF  02
01C16:  MOVLB  7
01C18:  BRA    1D52
01C1A:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01C1C:  MOVLB  1
01C1E:  MOVF   xD9,W
01C20:  MOVWF  01
01C22:  MOVF   xDA,W
01C24:  MOVWF  02
01C26:  MOVLB  7
01C28:  BRA    1D52
01C2A:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01C2C:  GOTO   11AE
01C30:  MOVLW  00
01C32:  MOVWF  01
01C34:  MOVWF  02
01C36:  MOVLB  7
01C38:  BRA    1D52
01C3A:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01C3C:  GOTO   11EA
01C40:  MOVLW  00
01C42:  MOVWF  01
01C44:  MOVWF  02
01C46:  MOVLB  7
01C48:  BRA    1D52
01C4A:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01C4C:  MOVLB  1
01C4E:  MOVF   xCB,W
01C50:  MOVWF  01
01C52:  MOVF   xCC,W
01C54:  MOVWF  02
01C56:  MOVLB  7
01C58:  BRA    1D52
01C5A:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01C5C:  MOVLB  1
01C5E:  MOVF   xCD,W
01C60:  MOVWF  01
01C62:  MOVF   xCE,W
01C64:  MOVWF  02
01C66:  MOVLB  7
01C68:  BRA    1D52
01C6A:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01C6C:  MOVLB  1
01C6E:  MOVF   xCF,W
01C70:  MOVWF  01
01C72:  MOVF   xD0,W
01C74:  MOVWF  02
01C76:  MOVLB  7
01C78:  BRA    1D52
01C7A:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01C7C:  GOTO   1212
01C80:  MOVLW  00
01C82:  MOVWF  01
01C84:  MOVWF  02
01C86:  MOVLB  7
01C88:  BRA    1D52
01C8A:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01C8C:  CLRF   03
01C8E:  MOVF   39,W
01C90:  MOVWF  01
01C92:  MOVF   03,W
01C94:  MOVWF  02
01C96:  MOVLB  7
01C98:  BRA    1D52
01C9A:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01C9C:  MOVF   3A,W
01C9E:  MOVWF  01
01CA0:  MOVF   3B,W
01CA2:  MOVWF  02
01CA4:  MOVLB  7
01CA6:  BRA    1D52
01CA8:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01CAA:  MOVLW  50
01CAC:  MOVWF  01
01CAE:  MOVLW  00
01CB0:  MOVWF  02
01CB2:  MOVLB  7
01CB4:  BRA    1D52
01CB6:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01CB8:  MOVLW  57
01CBA:  MOVWF  01
01CBC:  MOVLW  00
01CBE:  MOVWF  02
01CC0:  MOVLB  7
01CC2:  BRA    1D52
01CC4:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01CC6:  MOVLW  58
01CC8:  MOVWF  01
01CCA:  MOVLW  00
01CCC:  MOVWF  02
01CCE:  MOVLB  7
01CD0:  BRA    1D52
01CD2:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01CD4:  MOVLW  01
01CD6:  MOVWF  01
01CD8:  MOVLW  00
01CDA:  MOVWF  02
01CDC:  MOVLB  7
01CDE:  BRA    1D52
01CE0:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01CE2:  CLRF   03
01CE4:  MOVF   36,W
01CE6:  MOVWF  01
01CE8:  MOVF   03,W
01CEA:  MOVWF  02
01CEC:  MOVLB  7
01CEE:  BRA    1D52
01CF0:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01CF2:  MOVF   3C,W
01CF4:  MOVWF  01
01CF6:  MOVF   3D,W
01CF8:  MOVWF  02
01CFA:  MOVLB  7
01CFC:  BRA    1D52
01CFE:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01D00:  CLRF   03
01D02:  MOVF   3E,W
01D04:  MOVWF  01
01D06:  MOVF   03,W
01D08:  MOVWF  02
01D0A:  MOVLB  7
01D0C:  BRA    1D52
01D0E:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01D10:  MOVF   3F,W
01D12:  MOVWF  01
01D14:  MOVF   40,W
01D16:  MOVWF  02
01D18:  MOVLB  7
01D1A:  BRA    1D52
01D1C:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01D1E:  MOVF   41,W
01D20:  MOVWF  01
01D22:  MOVF   42,W
01D24:  MOVWF  02
01D26:  MOVLB  7
01D28:  BRA    1D52
01D2A:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01D2C:  CLRF   03
01D2E:  MOVF   43,W
01D30:  MOVWF  01
01D32:  MOVF   03,W
01D34:  MOVWF  02
01D36:  MOVLB  7
01D38:  BRA    1D52
01D3A:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01D3C:  CLRF   03
01D3E:  MOVF   38,W
01D40:  MOVWF  01
01D42:  MOVF   03,W
01D44:  MOVWF  02
01D46:  MOVLB  7
01D48:  BRA    1D52
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01D4A:  MOVLW  FF
01D4C:  MOVWF  01
01D4E:  MOVWF  02
01D50:  BRA    1D52
.................... 	} 
....................  
.................... } 
01D52:  MOVLB  0
01D54:  GOTO   1DA6 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
00F7A:  MOVLB  7
00F7C:  MOVF   xDA,W
00F7E:  SUBLW  1F
00F80:  BNZ   0F9A
00F82:  MOVF   xDB,W
00F84:  SUBLW  4E
00F86:  BNZ   0F9A
00F88:  MOVF   xDC,W
00F8A:  SUBLW  20
00F8C:  BNZ   0F9A
00F8E:  MOVF   xDD,W
00F90:  SUBLW  4E
00F92:  BNZ   0F9A
.................... 		return 1; 
00F94:  MOVLW  01
00F96:  MOVWF  01
00F98:  BRA    1062
....................  
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
00F9A:  MOVF   xDB,W
00F9C:  SUBLW  16
00F9E:  BC    0FBE
00FA0:  XORLW  FF
00FA2:  BNZ   0FAA
00FA4:  MOVF   xDA,W
00FA6:  SUBLW  6F
00FA8:  BC    0FBE
00FAA:  MOVF   xDD,W
00FAC:  SUBLW  19
00FAE:  BNC   0FBE
00FB0:  BNZ   0FB8
00FB2:  MOVF   xDC,W
00FB4:  SUBLW  50
00FB6:  BNC   0FBE
.................... 		return 1; 
00FB8:  MOVLW  01
00FBA:  MOVWF  01
00FBC:  BRA    1062
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
00FBE:  MOVF   xDB,W
00FC0:  SUBLW  12
00FC2:  BC    0FE2
00FC4:  XORLW  FF
00FC6:  BNZ   0FCE
00FC8:  MOVF   xDA,W
00FCA:  SUBLW  87
00FCC:  BC    0FE2
00FCE:  MOVF   xDD,W
00FD0:  SUBLW  17
00FD2:  BNC   0FE2
00FD4:  BNZ   0FDC
00FD6:  MOVF   xDC,W
00FD8:  SUBLW  48
00FDA:  BNC   0FE2
.................... 		return 1; 
00FDC:  MOVLW  01
00FDE:  MOVWF  01
00FE0:  BRA    1062
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
00FE2:  MOVF   xDB,W
00FE4:  SUBLW  03
00FE6:  BC    1006
00FE8:  XORLW  FF
00FEA:  BNZ   0FF2
00FEC:  MOVF   xDA,W
00FEE:  SUBLW  4B
00FF0:  BC    1006
00FF2:  MOVF   xDD,W
00FF4:  SUBLW  04
00FF6:  BNC   1006
00FF8:  BNZ   1000
00FFA:  MOVF   xDC,W
00FFC:  SUBLW  94
00FFE:  BNC   1006
.................... 		return 1; 
01000:  MOVLW  01
01002:  MOVWF  01
01004:  BRA    1062
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
01006:  MOVF   xDB,W
01008:  SUBLW  02
0100A:  BC    102A
0100C:  XORLW  FF
0100E:  BNZ   1016
01010:  MOVF   xDA,W
01012:  SUBLW  E7
01014:  BC    102A
01016:  MOVF   xDD,W
01018:  SUBLW  03
0101A:  BNC   102A
0101C:  BNZ   1024
0101E:  MOVF   xDC,W
01020:  SUBLW  F5
01022:  BNC   102A
.................... 		return 1; 
01024:  MOVLW  01
01026:  MOVWF  01
01028:  BRA    1062
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
0102A:  MOVF   xDB,W
0102C:  SUBLW  06
0102E:  BC    104E
01030:  XORLW  FF
01032:  BNZ   103A
01034:  MOVF   xDA,W
01036:  SUBLW  CF
01038:  BC    104E
0103A:  MOVF   xDD,W
0103C:  SUBLW  09
0103E:  BNC   104E
01040:  BNZ   1048
01042:  MOVF   xDC,W
01044:  SUBLW  D1
01046:  BNC   104E
.................... 		return 1; 
01048:  MOVLW  01
0104A:  MOVWF  01
0104C:  BRA    1062
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
0104E:  MOVF   xDD,F
01050:  BNZ   105E
01052:  MOVF   xDC,W
01054:  SUBLW  34
01056:  BNC   105E
.................... 		return 1; 
01058:  MOVLW  01
0105A:  MOVWF  01
0105C:  BRA    1062
....................  
.................... 	return 0; 
0105E:  MOVLW  00
01060:  MOVWF  01
.................... } 
01062:  MOVLB  0
01064:  GOTO   22A2 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01D58:  MOVFF  7D9,7E2
01D5C:  MOVFF  7D8,7E3
01D60:  CALL   10A4
.................... 	modbus_serial_putc(register_count*2); 
01D64:  BCF    FD8.0
01D66:  MOVLB  7
01D68:  RLCF   xDC,W
01D6A:  MOVWF  xE2
01D6C:  RLCF   xDD,W
01D6E:  MOVWF  xE3
01D70:  MOVFF  7E2,7E4
01D74:  MOVLB  0
01D76:  CALL   1070
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01D7A:  MOVLB  7
01D7C:  CLRF   xDF
01D7E:  CLRF   xDE
01D80:  MOVF   xDF,W
01D82:  SUBWF  xDD,W
01D84:  BNC   1DD0
01D86:  BNZ   1D8E
01D88:  MOVF   xDC,W
01D8A:  SUBWF  xDE,W
01D8C:  BC    1DD0
.................... 		l=map_modbus(start_address+i); 
01D8E:  MOVF   xDE,W
01D90:  ADDWF  xDA,W
01D92:  MOVWF  xE2
01D94:  MOVF   xDF,W
01D96:  ADDWFC xDB,W
01D98:  MOVWF  xE3
01D9A:  MOVWF  xE5
01D9C:  MOVFF  7E2,7E4
01DA0:  MOVLB  0
01DA2:  GOTO   1226
01DA6:  MOVFF  02,7E1
01DAA:  MOVFF  01,7E0
.................... 		modbus_serial_putc(make8(l,1)); 
01DAE:  MOVFF  7E1,7E2
01DB2:  MOVFF  7E1,7E4
01DB6:  CALL   1070
....................   		modbus_serial_putc(make8(l,0)); 
01DBA:  MOVFF  7E0,7E2
01DBE:  MOVFF  7E0,7E4
01DC2:  CALL   1070
.................... 	} 
01DC6:  MOVLB  7
01DC8:  INCF   xDE,F
01DCA:  BTFSC  FD8.2
01DCC:  INCF   xDF,F
01DCE:  BRA    1D80
....................  
.................... 	modbus_serial_send_stop(); 
01DD0:  MOVLB  0
01DD2:  CALL   10D2
.................... } 
01DD6:  GOTO   22E4 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01DDA:  MOVLB  7
01DDC:  MOVF   xDF,W
01DDE:  SUBLW  06
01DE0:  BC    1E58
01DE2:  XORLW  FF
01DE4:  BNZ   1DEC
01DE6:  MOVF   xDE,W
01DE8:  SUBLW  CF
01DEA:  BC    1E58
01DEC:  MOVF   xDF,W
01DEE:  SUBLW  09
01DF0:  BNC   1E58
01DF2:  BNZ   1DFA
01DF4:  MOVF   xDE,W
01DF6:  SUBLW  CF
01DF8:  BNC   1E58
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01DFA:  MOVF   xE1,W
01DFC:  SUBLW  00
01DFE:  BC    1E10
01E00:  XORLW  FF
01E02:  BNZ   1E0A
01E04:  MOVF   xE0,W
01E06:  SUBLW  00
01E08:  BC    1E10
01E0A:  MOVLW  03
01E0C:  MOVWF  01
01E0E:  BRA    20DA
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01E10:  MOVLW  D0
01E12:  SUBWF  xDE,W
01E14:  MOVWF  xE4
01E16:  MOVLW  07
01E18:  SUBWFB xDF,W
01E1A:  MOVWF  xE5
01E1C:  MOVLW  02
01E1E:  ADDWF  xE5,F
01E20:  MOVFF  7E5,FAA
01E24:  MOVFF  7E4,FA9
01E28:  MOVFF  7E0,FA8
01E2C:  BCF    FA6.6
01E2E:  BCF    FA6.7
01E30:  BSF    FA6.2
01E32:  MOVF   FF2,W
01E34:  MOVWF  00
01E36:  BCF    FF2.6
01E38:  BCF    FF2.7
01E3A:  MOVLB  F
01E3C:  MOVLW  55
01E3E:  MOVWF  FA7
01E40:  MOVLW  AA
01E42:  MOVWF  FA7
01E44:  BSF    FA6.1
01E46:  BTFSC  FA6.1
01E48:  BRA    1E46
01E4A:  BCF    FA6.2
01E4C:  MOVF   00,W
01E4E:  IORWF  FF2,F
.................... 		return 0; 
01E50:  MOVLW  00
01E52:  MOVWF  01
01E54:  MOVLB  7
01E56:  BRA    20DA
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
01E58:  MOVF   xDF,W
01E5A:  SUBLW  03
01E5C:  BC    1EEE
01E5E:  XORLW  FF
01E60:  BNZ   1E68
01E62:  MOVF   xDE,W
01E64:  SUBLW  4B
01E66:  BC    1EEE
01E68:  MOVF   xDF,W
01E6A:  SUBLW  04
01E6C:  BNC   1EEE
01E6E:  BNZ   1E76
01E70:  MOVF   xDE,W
01E72:  SUBLW  93
01E74:  BNC   1EEE
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01E76:  MOVF   xE1,W
01E78:  SUBLW  00
01E7A:  BC    1E8C
01E7C:  XORLW  FF
01E7E:  BNZ   1E86
01E80:  MOVF   xE0,W
01E82:  SUBLW  00
01E84:  BC    1E8C
01E86:  MOVLW  03
01E88:  MOVWF  01
01E8A:  BRA    20DA
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
01E8C:  MOVLW  4C
01E8E:  SUBWF  xDE,W
01E90:  MOVWF  xE2
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01E92:  MOVFF  7E2,7EA
01E96:  MOVLW  06
01E98:  MOVWF  xEB
01E9A:  MOVLB  0
01E9C:  CALL   1120
01EA0:  MOVFF  00,7E3
.................... 		n = n / 6; /* number of sentence */ 
01EA4:  MOVFF  7E2,7EA
01EA8:  MOVLW  06
01EAA:  MOVLB  7
01EAC:  MOVWF  xEB
01EAE:  MOVLB  0
01EB0:  CALL   1120
01EB4:  MOVFF  01,7E2
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
01EB8:  MOVLB  7
01EBA:  MOVF   xE2,W
01EBC:  MULLW  06
01EBE:  MOVF   FF3,W
01EC0:  CLRF   03
01EC2:  ADDLW  18
01EC4:  MOVWF  xE4
01EC6:  MOVLW  00
01EC8:  ADDWFC 03,W
01ECA:  MOVWF  xE5
01ECC:  CLRF   03
01ECE:  MOVF   xE3,W
01ED0:  ADDWF  xE4,W
01ED2:  MOVWF  01
01ED4:  MOVF   xE5,W
01ED6:  ADDWFC 03,F
01ED8:  MOVF   01,W
01EDA:  ADDLW  36
01EDC:  MOVWF  FE9
01EDE:  MOVLW  00
01EE0:  ADDWFC 03,W
01EE2:  MOVWF  FEA
01EE4:  MOVFF  7E0,FEF
.................... 		 
.................... 		return 0; 
01EE8:  MOVLW  00
01EEA:  MOVWF  01
01EEC:  BRA    20DA
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01EEE:  MOVLB  1
01EF0:  MOVF   xD7,F
01EF2:  BZ    1F2A
.................... 		if ( 1000 == address ) { 
01EF4:  MOVLB  7
01EF6:  MOVF   xDE,W
01EF8:  SUBLW  E8
01EFA:  BNZ   1F0E
01EFC:  MOVF   xDF,W
01EFE:  SUBLW  03
01F00:  BNZ   1F0E
.................... 			config.serial_prefix=value; 
01F02:  MOVFF  7E0,39
.................... 			return 0; 
01F06:  MOVLW  00
01F08:  MOVWF  01
01F0A:  BRA    20DA
.................... 		} else if ( 1001 == address ) { 
01F0C:  BRA    1F28
01F0E:  MOVF   xDE,W
01F10:  SUBLW  E9
01F12:  BNZ   1F28
01F14:  MOVF   xDF,W
01F16:  SUBLW  03
01F18:  BNZ   1F28
.................... 			config.serial_number=value; 
01F1A:  MOVFF  7E1,3B
01F1E:  MOVFF  7E0,3A
.................... 			return 0; 
01F22:  MOVLW  00
01F24:  MOVWF  01
01F26:  BRA    20DA
01F28:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01F2A:  MOVLB  7
01F2C:  MOVF   xDE,W
01F2E:  MOVWF  00
01F30:  MOVF   xDF,W
01F32:  MOVWF  03
01F34:  MOVLW  03
01F36:  SUBWF  03,W
01F38:  BNZ   1F44
01F3A:  MOVLW  EE
01F3C:  SUBWF  00,W
01F3E:  MOVLB  0
01F40:  BZ    1FDE
01F42:  MOVLB  7
01F44:  MOVLW  03
01F46:  SUBWF  03,W
01F48:  BNZ   1F54
01F4A:  MOVLW  EF
01F4C:  SUBWF  00,W
01F4E:  MOVLB  0
01F50:  BZ    1FF6
01F52:  MOVLB  7
01F54:  MOVLW  03
01F56:  SUBWF  03,W
01F58:  BNZ   1F64
01F5A:  MOVLW  F0
01F5C:  SUBWF  00,W
01F5E:  MOVLB  0
01F60:  BZ    2006
01F62:  MOVLB  7
01F64:  MOVLW  03
01F66:  SUBWF  03,W
01F68:  BNZ   1F74
01F6A:  MOVLW  F1
01F6C:  SUBWF  00,W
01F6E:  MOVLB  0
01F70:  BZ    201E
01F72:  MOVLB  7
01F74:  MOVLW  03
01F76:  SUBWF  03,W
01F78:  BNZ   1F84
01F7A:  MOVLW  F2
01F7C:  SUBWF  00,W
01F7E:  MOVLB  0
01F80:  BZ    202A
01F82:  MOVLB  7
01F84:  MOVLW  03
01F86:  SUBWF  03,W
01F88:  BNZ   1F94
01F8A:  MOVLW  F3
01F8C:  SUBWF  00,W
01F8E:  MOVLB  0
01F90:  BZ    2044
01F92:  MOVLB  7
01F94:  MOVLW  03
01F96:  SUBWF  03,W
01F98:  BNZ   1FA6
01F9A:  MOVLW  F4
01F9C:  SUBWF  00,W
01F9E:  MOVLB  0
01FA0:  BTFSC  FD8.2
01FA2:  BRA    205C
01FA4:  MOVLB  7
01FA6:  MOVLW  07
01FA8:  SUBWF  03,W
01FAA:  BNZ   1FB8
01FAC:  MOVLW  CE
01FAE:  SUBWF  00,W
01FB0:  MOVLB  0
01FB2:  BTFSC  FD8.2
01FB4:  BRA    2074
01FB6:  MOVLB  7
01FB8:  MOVLW  07
01FBA:  SUBWF  03,W
01FBC:  BNZ   1FCA
01FBE:  MOVLW  CF
01FC0:  SUBWF  00,W
01FC2:  MOVLB  0
01FC4:  BTFSC  FD8.2
01FC6:  BRA    208E
01FC8:  MOVLB  7
01FCA:  MOVLW  4E
01FCC:  SUBWF  03,W
01FCE:  BNZ   1FDC
01FD0:  MOVLW  1F
01FD2:  SUBWF  00,W
01FD4:  MOVLB  0
01FD6:  BTFSC  FD8.2
01FD8:  BRA    20A8
01FDA:  MOVLB  7
01FDC:  BRA    20D0
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01FDE:  MOVLB  7
01FE0:  MOVF   xE1,F
01FE2:  BNZ   1FEA
01FE4:  MOVF   xE0,W
01FE6:  SUBLW  80
01FE8:  BC    1FF0
01FEA:  MOVLW  03
01FEC:  MOVWF  01
01FEE:  BRA    20DA
.................... 			config.modbus_address=value; 
01FF0:  MOVFF  7E0,36
.................... 			break; 
01FF4:  BRA    20D6
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01FF6:  MOVLB  1
01FF8:  BSF    xF6.1
.................... 			config.adc_sample_ticks=value; 
01FFA:  MOVFF  7E1,3D
01FFE:  MOVFF  7E0,3C
.................... 			break; 
02002:  MOVLB  7
02004:  BRA    20D6
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02006:  MOVLB  7
02008:  MOVF   xE1,F
0200A:  BNZ   2012
0200C:  MOVF   xE0,W
0200E:  SUBLW  01
02010:  BC    2018
02012:  MOVLW  03
02014:  MOVWF  01
02016:  BRA    20DA
.................... 			config.allow_bootload_request=value; 
02018:  MOVFF  7E0,3E
.................... 			break; 
0201C:  BRA    20D6
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
0201E:  MOVFF  7E1,40
02022:  MOVFF  7E0,3F
.................... 			break; 
02026:  MOVLB  7
02028:  BRA    20D6
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
0202A:  MOVLB  7
0202C:  MOVF   xE0,F
0202E:  BNZ   203A
02030:  MOVF   xE1,F
02032:  BNZ   203A
02034:  MOVLW  03
02036:  MOVWF  01
02038:  BRA    20DA
.................... 			config.pi_offtime_seconds=value; 
0203A:  MOVFF  7E1,42
0203E:  MOVFF  7E0,41
.................... 			break; 
02042:  BRA    20D6
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02044:  MOVLB  7
02046:  MOVF   xE1,F
02048:  BNZ   2050
0204A:  MOVF   xE0,W
0204C:  SUBLW  01
0204E:  BC    2056
02050:  MOVLW  03
02052:  MOVWF  01
02054:  BRA    20DA
.................... 			config.power_startup=value; 
02056:  MOVFF  7E0,43
.................... 			break; 
0205A:  BRA    20D6
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
0205C:  MOVLB  7
0205E:  MOVF   xE1,F
02060:  BNZ   2068
02062:  MOVF   xE0,W
02064:  SUBLW  02
02066:  BC    206E
02068:  MOVLW  03
0206A:  MOVWF  01
0206C:  BRA    20DA
.................... 			config.rs485_port_mode=value; 
0206E:  MOVFF  7E0,38
.................... 			break; 
02072:  BRA    20D6
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02074:  MOVLB  7
02076:  DECFSZ xE0,W
02078:  BRA    207E
0207A:  MOVF   xE1,F
0207C:  BZ    2084
0207E:  MOVLW  03
02080:  MOVWF  01
02082:  BRA    20DA
.................... 			write_default_param_file(); 
02084:  MOVLB  0
02086:  CALL   0A9A
.................... 			break; 
0208A:  MOVLB  7
0208C:  BRA    20D6
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
0208E:  MOVLB  7
02090:  DECFSZ xE0,W
02092:  BRA    2098
02094:  MOVF   xE1,F
02096:  BZ    209E
02098:  MOVLW  03
0209A:  MOVWF  01
0209C:  BRA    20DA
.................... 			write_param_file(); 
0209E:  MOVLB  0
020A0:  CALL   0A46
.................... 			break; 
020A4:  MOVLB  7
020A6:  BRA    20D6
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
020A8:  MOVLB  7
020AA:  MOVF   xE0,W
020AC:  SUBLW  0A
020AE:  BNZ   20B6
020B0:  MOVF   xE1,W
020B2:  SUBLW  07
020B4:  BZ    20C2
.................... 				current.factory_unlocked=0; 
020B6:  MOVLB  1
020B8:  CLRF   xD7
.................... 				return ILLEGAL_DATA_VALUE; 
020BA:  MOVLW  03
020BC:  MOVWF  01
020BE:  MOVLB  7
020C0:  BRA    20DA
.................... 			} 
.................... 			current.factory_unlocked=1; 
020C2:  MOVLW  01
020C4:  MOVLB  1
020C6:  MOVWF  xD7
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
020C8:  MOVLW  C8
020CA:  MOVWF  xF3
.................... 			break; 
020CC:  MOVLB  7
020CE:  BRA    20D6
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
020D0:  MOVLW  02
020D2:  MOVWF  01
020D4:  BRA    20DA
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
020D6:  MOVLW  00
020D8:  MOVWF  01
.................... } 
020DA:  MOVLB  0
020DC:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
0216E:  GOTO   0F34
02172:  MOVF   01,F
02174:  BTFSC  FD8.2
02176:  BRA    245A
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02178:  DECFSZ 38,W
0217A:  BRA    222E
0217C:  MOVF   36,W
0217E:  MOVLB  6
02180:  SUBWF  xC0,W
02182:  BTFSS  FD8.2
02184:  BRA    218A
02186:  MOVLB  0
02188:  BRA    222E
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
0218A:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
0218C:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
0218E:  CLRWDT
02190:  MOVLW  02
02192:  MOVLB  7
02194:  MOVWF  xD8
02196:  MOVLW  B5
02198:  MOVWF  xD9
0219A:  MOVLB  0
0219C:  CALL   0F5A
021A0:  MOVLB  7
021A2:  DECFSZ xD8,F
021A4:  BRA    2196
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
021A6:  MOVLB  6
021A8:  MOVF   xC0,W
021AA:  MOVLB  0
021AC:  CALL   06B4
.................... 			delay_us(104); //one stop bit @ 9600 baud 
021B0:  CLRWDT
021B2:  MOVLW  67
021B4:  MOVWF  00
021B6:  DECFSZ 00,F
021B8:  BRA    21B6
021BA:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
021BC:  MOVLB  6
021BE:  MOVF   xC2,W
021C0:  MOVLB  0
021C2:  CALL   06B4
.................... 			delay_us(104); //one stop bit @ 9600 baud 
021C6:  CLRWDT
021C8:  MOVLW  67
021CA:  MOVWF  00
021CC:  DECFSZ 00,F
021CE:  BRA    21CC
021D0:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
021D2:  MOVLB  7
021D4:  CLRF   xD7
021D6:  MOVLW  02
021D8:  MOVLB  6
021DA:  ADDWF  xC1,W
021DC:  MOVLB  7
021DE:  SUBWF  xD7,W
021E0:  BC    220E
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
021E2:  MOVLW  C4
021E4:  ADDWF  xD7,W
021E6:  MOVWF  FE9
021E8:  MOVLW  06
021EA:  MOVWF  FEA
021EC:  BTFSC  FD8.0
021EE:  INCF   FEA,F
021F0:  MOVFF  FEF,7D8
021F4:  MOVF   xD8,W
021F6:  MOVLB  0
021F8:  CALL   06B4
.................... 				delay_us(104); //one stop bit @ 9600 baud 
021FC:  CLRWDT
021FE:  MOVLW  67
02200:  MOVWF  00
02202:  DECFSZ 00,F
02204:  BRA    2202
02206:  NOP   
.................... 			} 
02208:  MOVLB  7
0220A:  INCF   xD7,F
0220C:  BRA    21D6
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
0220E:  BTFSS  F72.1
02210:  BRA    220E
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02212:  CLRWDT
02214:  MOVLW  02
02216:  MOVWF  xD8
02218:  MOVLW  B5
0221A:  MOVWF  xD9
0221C:  MOVLB  0
0221E:  CALL   0F5A
02222:  MOVLB  7
02224:  DECFSZ xD8,F
02226:  BRA    2218
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02228:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
0222A:  BCF    F8C.0
0222C:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
0222E:  MOVF   36,W
02230:  SUBLW  80
02232:  BZ    2240
02234:  MOVF   36,W
02236:  MOVLB  6
02238:  SUBWF  xC0,W
0223A:  BTFSS  FD8.2
0223C:  BRA    2444
0223E:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02240:  MOVLB  1
02242:  INCFSZ xCB,W
02244:  BRA    224C
02246:  INCFSZ xCC,W
02248:  BRA    224C
0224A:  BRA    2252
.................... 				current.modbus_our_packets++; 
0224C:  INCF   xCB,F
0224E:  BTFSC  FD8.2
02250:  INCF   xCC,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02252:  MOVLW  14
02254:  MOVWF  xF3
....................  
.................... 			switch(modbus_rx.func) { 
02256:  MOVLB  6
02258:  MOVF   xC2,W
0225A:  XORLW  03
0225C:  MOVLB  0
0225E:  BZ    2270
02260:  XORLW  07
02262:  BZ    2270
02264:  XORLW  02
02266:  BZ    22E8
02268:  XORLW  16
0226A:  BTFSC  FD8.2
0226C:  BRA    235A
0226E:  BRA    241C
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02270:  MOVFF  6C4,7D3
02274:  MOVFF  6C5,7D2
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02278:  MOVFF  6C6,7D5
0227C:  MOVFF  6C7,7D4
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02280:  MOVLB  7
02282:  MOVF   xD4,W
02284:  ADDWF  xD2,W
02286:  MOVWF  xD8
02288:  MOVF   xD5,W
0228A:  ADDWFC xD3,W
0228C:  MOVWF  xD9
0228E:  MOVFF  7D3,7DB
02292:  MOVFF  7D2,7DA
02296:  MOVWF  xDD
02298:  MOVFF  7D8,7DC
0229C:  MOVLB  0
0229E:  GOTO   0F7A
022A2:  MOVF   01,F
022A4:  BNZ   22CA
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
022A6:  MOVFF  6C0,7D8
022AA:  MOVLB  7
022AC:  CLRF   xDA
022AE:  MOVFF  6C2,7D9
022B2:  MOVLW  02
022B4:  MOVWF  xDB
022B6:  MOVLB  0
022B8:  CALL   1100
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
022BC:  MOVLB  1
022BE:  CLRF   xD0
022C0:  MOVLW  02
022C2:  MOVWF  xCF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
022C4:  CLRF   xF3
.................... 					} else { 
022C6:  BRA    22E6
022C8:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
022CA:  MOVFF  6C2,7D8
022CE:  MOVFF  6C0,7D9
022D2:  MOVFF  7D3,7DB
022D6:  MOVFF  7D2,7DA
022DA:  MOVFF  7D5,7DD
022DE:  MOVFF  7D4,7DC
022E2:  BRA    1D58
022E4:  MOVLB  1
.................... 					} 
.................... 					break; 
022E6:  BRA    243C
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
022E8:  MOVFF  6C4,7D3
022EC:  MOVFF  6C5,7D2
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
022F0:  MOVFF  6C6,7D9
022F4:  MOVFF  6C7,7D8
022F8:  MOVFF  7D3,7DF
022FC:  MOVFF  7D2,7DE
02300:  MOVFF  6C6,7E1
02304:  MOVFF  6C7,7E0
02308:  RCALL  1DDA
0230A:  MOVFF  01,7D6
....................  
.................... 					if ( result ) { 
0230E:  MOVLB  7
02310:  MOVF   xD6,F
02312:  BZ    2336
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02314:  MOVFF  6C0,7D8
02318:  CLRF   xDA
0231A:  MOVFF  6C2,7D9
0231E:  MOVFF  7D6,7DB
02322:  MOVLB  0
02324:  CALL   1100
.................... 						current.modbus_last_error=result; 
02328:  MOVLB  1
0232A:  CLRF   xD0
0232C:  MOVFF  7D6,1CF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02330:  CLRF   xF3
.................... 					}  else { 
02332:  BRA    2358
02334:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02336:  MOVFF  6C6,7D9
0233A:  MOVFF  6C7,7D8
0233E:  MOVFF  6C0,7DA
02342:  MOVFF  7D3,7DC
02346:  MOVFF  7D2,7DB
0234A:  MOVFF  6C6,7DE
0234E:  MOVFF  6C7,7DD
02352:  MOVLB  0
02354:  BRA    20DE
02356:  MOVLB  1
.................... 					} 
.................... 					break; 
02358:  BRA    243C
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0235A:  MOVFF  6C4,7D3
0235E:  MOVFF  6C5,7D2
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02362:  MOVFF  6C6,7D5
02366:  MOVFF  6C7,7D4
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
0236A:  MOVLB  7
0236C:  CLRF   xD7
0236E:  MOVF   xD5,F
02370:  BNZ   2378
02372:  MOVF   xD4,W
02374:  SUBWF  xD7,W
02376:  BC    23FC
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02378:  MOVF   xD7,W
0237A:  ADDWF  xD2,W
0237C:  MOVWF  xD8
0237E:  MOVLW  00
02380:  ADDWFC xD3,W
02382:  MOVWF  xD9
02384:  BCF    FD8.0
02386:  RLCF   xD7,W
02388:  ADDLW  05
0238A:  ADDLW  C4
0238C:  MOVWF  FE9
0238E:  MOVLW  06
02390:  MOVWF  FEA
02392:  BTFSC  FD8.0
02394:  INCF   FEA,F
02396:  MOVFF  FEF,7DA
0239A:  BCF    FD8.0
0239C:  RLCF   xD7,W
0239E:  ADDLW  06
023A0:  ADDLW  C4
023A2:  MOVWF  FE9
023A4:  MOVLW  06
023A6:  MOVWF  FEA
023A8:  BTFSC  FD8.0
023AA:  INCF   FEA,F
023AC:  MOVFF  FEF,7DB
023B0:  MOVFF  7DA,7DD
023B4:  MOVFF  7DB,7DC
023B8:  MOVFF  7D9,7DF
023BC:  MOVFF  7D8,7DE
023C0:  MOVFF  7DA,7E1
023C4:  MOVFF  7DB,7E0
023C8:  MOVLB  0
023CA:  RCALL  1DDA
023CC:  MOVFF  01,7D6
....................  
.................... 						if ( result ) { 
023D0:  MOVLB  7
023D2:  MOVF   xD6,F
023D4:  BZ    23F8
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
023D6:  MOVFF  6C0,7D8
023DA:  CLRF   xDA
023DC:  MOVFF  6C2,7D9
023E0:  MOVFF  7D6,7DB
023E4:  MOVLB  0
023E6:  CALL   1100
.................... 							current.modbus_last_error=result; 
023EA:  MOVLB  1
023EC:  CLRF   xD0
023EE:  MOVFF  7D6,1CF
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
023F2:  CLRF   xF3
.................... 			 
.................... 							break; 
023F4:  MOVLB  7
023F6:  BRA    23FC
.................... 						} 
.................... 					} 
023F8:  INCF   xD7,F
023FA:  BRA    236E
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
023FC:  MOVF   xD6,F
023FE:  BNZ   2418
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02400:  MOVFF  6C0,7D8
02404:  MOVFF  7D3,7DA
02408:  MOVFF  7D2,7D9
0240C:  MOVFF  7D5,7DC
02410:  MOVFF  7D4,7DB
02414:  MOVLB  0
02416:  BRA    2126
.................... 					} 
....................  
.................... 					break;   
02418:  MOVLB  1
0241A:  BRA    243C
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
0241C:  MOVFF  6C0,7D8
02420:  MOVLB  7
02422:  CLRF   xDA
02424:  MOVFF  6C2,7D9
02428:  MOVLW  01
0242A:  MOVWF  xDB
0242C:  MOVLB  0
0242E:  CALL   1100
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02432:  MOVLB  1
02434:  CLRF   xD0
02436:  MOVLW  01
02438:  MOVWF  xCF
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
0243A:  CLRF   xF3
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
0243C:  CLRF   xDA
0243E:  CLRF   xD9
....................  
.................... 		} else { 
02440:  BRA    245A
02442:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02444:  MOVLB  1
02446:  INCFSZ xCD,W
02448:  BRA    2450
0244A:  INCFSZ xCE,W
0244C:  BRA    2450
0244E:  BRA    2456
.................... 				current.modbus_other_packets++; 
02450:  INCF   xCD,F
02452:  BTFSC  FD8.2
02454:  INCF   xCE,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02456:  MOVLW  0A
02458:  MOVWF  xF3
0245A:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
0245C:  GOTO   281E (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00412:  MOVLB  8
00414:  BTFSS  xE6.0
00416:  BRA    0430
00418:  MOVLB  1
0041A:  INCFSZ xE2,W
0041C:  BRA    0428
0041E:  INCFSZ xE3,W
00420:  BRA    0428
00422:  MOVLB  8
00424:  BRA    0430
00426:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00428:  INCF   xE2,F
0042A:  BTFSC  FD8.2
0042C:  INCF   xE3,F
0042E:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00430:  BTFSS  xE6.2
00432:  BRA    044C
00434:  MOVLB  1
00436:  INCFSZ xE4,W
00438:  BRA    0444
0043A:  INCFSZ xE5,W
0043C:  BRA    0444
0043E:  MOVLB  8
00440:  BRA    044C
00442:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00444:  INCF   xE4,F
00446:  BTFSC  FD8.2
00448:  INCF   xE5,F
0044A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0044C:  BTFSS  xE6.4
0044E:  BRA    0468
00450:  MOVLB  1
00452:  INCFSZ xE6,W
00454:  BRA    0460
00456:  INCFSZ xE7,W
00458:  BRA    0460
0045A:  MOVLB  8
0045C:  BRA    0468
0045E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00460:  INCF   xE6,F
00462:  BTFSC  FD8.2
00464:  INCF   xE7,F
00466:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00468:  BCF    xE6.1
0046A:  BTFSC  F81.0
0046C:  BSF    xE6.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0046E:  BTFSC  xE6.1
00470:  BRA    04F4
00472:  MOVLB  6
00474:  BTFSC  xBC.1
00476:  BRA    047C
00478:  MOVLB  8
0047A:  BRA    04F4
.................... 		current.pulse_count[0]++; 
0047C:  MOVLB  0
0047E:  INCF   xA8,F
00480:  BTFSC  FD8.2
00482:  INCF   xA9,F
.................... 		current.pulse_sum[0]++; 
00484:  MOVLW  01
00486:  ADDWF  xAE,F
00488:  BTFSC  FD8.0
0048A:  INCF   xAF,F
0048C:  BTFSC  FD8.2
0048E:  INCF   xB0,F
00490:  BTFSC  FD8.2
00492:  INCF   xB1,F
.................... 		if ( 1 == ext0_state ) { 
00494:  MOVLB  6
00496:  BTFSS  xBC.2
00498:  BRA    04E2
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0049A:  MOVLB  8
0049C:  BCF    xE6.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0049E:  MOVFF  1E3,97
004A2:  MOVFF  1E2,96
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004A6:  MOVLB  0
004A8:  MOVF   x97,W
004AA:  SUBWF  x9D,W
004AC:  BNC   04BE
004AE:  BNZ   04B6
004B0:  MOVF   x9C,W
004B2:  SUBWF  x96,W
004B4:  BC    04BE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004B6:  MOVFF  97,9D
004BA:  MOVFF  96,9C
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004BE:  MOVF   xA3,W
004C0:  SUBWF  x97,W
004C2:  BNC   04DE
004C4:  BNZ   04CC
004C6:  MOVF   x96,W
004C8:  SUBWF  xA2,W
004CA:  BC    04DE
004CC:  INCFSZ x96,W
004CE:  BRA    04D6
004D0:  INCFSZ x97,W
004D2:  BRA    04D6
004D4:  BRA    04DE
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004D6:  MOVFF  97,A3
004DA:  MOVFF  96,A2
.................... 			} 
.................... 			ext0_state=0; 
004DE:  MOVLB  6
004E0:  BCF    xBC.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004E2:  BTFSC  xBC.2
004E4:  BRA    04F4
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004E6:  MOVLB  1
004E8:  CLRF   xE3
004EA:  CLRF   xE2
.................... 			ext0_count=1; 
004EC:  MOVLB  8
004EE:  BSF    xE6.0
.................... 			ext0_state=1; 
004F0:  MOVLB  6
004F2:  BSF    xBC.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004F4:  MOVLB  6
004F6:  BCF    xBC.1
004F8:  MOVLB  8
004FA:  BTFSS  xE6.1
004FC:  BRA    0504
004FE:  MOVLB  6
00500:  BSF    xBC.1
00502:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00504:  BCF    xE6.3
00506:  BTFSC  F81.1
00508:  BSF    xE6.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0050A:  BTFSC  xE6.3
0050C:  BRA    0590
0050E:  MOVLB  6
00510:  BTFSC  xBC.3
00512:  BRA    0518
00514:  MOVLB  8
00516:  BRA    0590
.................... 		current.pulse_count[1]++; 
00518:  MOVLB  0
0051A:  INCF   xAA,F
0051C:  BTFSC  FD8.2
0051E:  INCF   xAB,F
.................... 		current.pulse_sum[1]++; 
00520:  MOVLW  01
00522:  ADDWF  xB2,F
00524:  BTFSC  FD8.0
00526:  INCF   xB3,F
00528:  BTFSC  FD8.2
0052A:  INCF   xB4,F
0052C:  BTFSC  FD8.2
0052E:  INCF   xB5,F
.................... 		if ( 1 == ext1_state ) { 
00530:  MOVLB  6
00532:  BTFSS  xBC.4
00534:  BRA    057E
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00536:  MOVLB  8
00538:  BCF    xE6.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0053A:  MOVFF  1E5,99
0053E:  MOVFF  1E4,98
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00542:  MOVLB  0
00544:  MOVF   x99,W
00546:  SUBWF  x9F,W
00548:  BNC   055A
0054A:  BNZ   0552
0054C:  MOVF   x9E,W
0054E:  SUBWF  x98,W
00550:  BC    055A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00552:  MOVFF  99,9F
00556:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0055A:  MOVF   xA5,W
0055C:  SUBWF  x99,W
0055E:  BNC   057A
00560:  BNZ   0568
00562:  MOVF   x98,W
00564:  SUBWF  xA4,W
00566:  BC    057A
00568:  INCFSZ x98,W
0056A:  BRA    0572
0056C:  INCFSZ x99,W
0056E:  BRA    0572
00570:  BRA    057A
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
00572:  MOVFF  99,A5
00576:  MOVFF  98,A4
.................... 			} 
.................... 			ext1_state=0; 
0057A:  MOVLB  6
0057C:  BCF    xBC.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0057E:  BTFSC  xBC.4
00580:  BRA    0590
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
00582:  MOVLB  1
00584:  CLRF   xE5
00586:  CLRF   xE4
.................... 			ext1_count=1; 
00588:  MOVLB  8
0058A:  BSF    xE6.2
.................... 			ext1_state=1; 
0058C:  MOVLB  6
0058E:  BSF    xBC.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
00590:  MOVLB  6
00592:  BCF    xBC.3
00594:  MOVLB  8
00596:  BTFSS  xE6.3
00598:  BRA    05A0
0059A:  MOVLB  6
0059C:  BSF    xBC.3
0059E:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005A0:  BCF    xE6.5
005A2:  BTFSC  F81.2
005A4:  BSF    xE6.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005A6:  BTFSC  xE6.5
005A8:  BRA    062C
005AA:  MOVLB  6
005AC:  BTFSC  xBC.5
005AE:  BRA    05B4
005B0:  MOVLB  8
005B2:  BRA    062C
.................... 		current.pulse_count[2]++; 
005B4:  MOVLB  0
005B6:  INCF   xAC,F
005B8:  BTFSC  FD8.2
005BA:  INCF   xAD,F
.................... 		current.pulse_sum[2]++; 
005BC:  MOVLW  01
005BE:  ADDWF  xB6,F
005C0:  BTFSC  FD8.0
005C2:  INCF   xB7,F
005C4:  BTFSC  FD8.2
005C6:  INCF   xB8,F
005C8:  BTFSC  FD8.2
005CA:  INCF   xB9,F
.................... 		if ( 1 == ext2_state ) { 
005CC:  MOVLB  6
005CE:  BTFSS  xBC.6
005D0:  BRA    061A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
005D2:  MOVLB  8
005D4:  BCF    xE6.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005D6:  MOVFF  1E7,9B
005DA:  MOVFF  1E6,9A
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005DE:  MOVLB  0
005E0:  MOVF   x9B,W
005E2:  SUBWF  xA1,W
005E4:  BNC   05F6
005E6:  BNZ   05EE
005E8:  MOVF   xA0,W
005EA:  SUBWF  x9A,W
005EC:  BC    05F6
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005EE:  MOVFF  9B,A1
005F2:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005F6:  MOVF   xA7,W
005F8:  SUBWF  x9B,W
005FA:  BNC   0616
005FC:  BNZ   0604
005FE:  MOVF   x9A,W
00600:  SUBWF  xA6,W
00602:  BC    0616
00604:  INCFSZ x9A,W
00606:  BRA    060E
00608:  INCFSZ x9B,W
0060A:  BRA    060E
0060C:  BRA    0616
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0060E:  MOVFF  9B,A7
00612:  MOVFF  9A,A6
.................... 			} 
.................... 			ext2_state=0; 
00616:  MOVLB  6
00618:  BCF    xBC.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0061A:  BTFSC  xBC.6
0061C:  BRA    062C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0061E:  MOVLB  1
00620:  CLRF   xE7
00622:  CLRF   xE6
.................... 			ext2_count=1; 
00624:  MOVLB  8
00626:  BSF    xE6.4
.................... 			ext2_state=1; 
00628:  MOVLB  6
0062A:  BSF    xBC.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0062C:  MOVLB  6
0062E:  BCF    xBC.5
00630:  MOVLB  8
00632:  BTFSS  xE6.5
00634:  BRA    063C
00636:  MOVLB  6
00638:  BSF    xBC.5
0063A:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0063C:  MOVLB  7
0063E:  INCF   xC7,F
.................... 	if ( 10 == tick ) { 
00640:  MOVF   xC7,W
00642:  SUBLW  0A
00644:  BNZ   064E
.................... 		tick=0; 
00646:  CLRF   xC7
.................... 		timers.now_millisecond=1; 
00648:  MOVLB  1
0064A:  BSF    xF6.2
0064C:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0064E:  BCF    F9E.1
00650:  MOVLB  0
00652:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0066E:  BRA    0656
00670:  MOVFF  01,8E3
....................  
.................... 	if ( RS485_MODE_OFF != config.rs485_port_mode ) { 
00674:  MOVF   38,F
00676:  BZ    0698
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
00678:  MOVLB  2
0067A:  CLRF   xFB
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
0067C:  INCFSZ xFA,W
0067E:  BRA    0682
00680:  BRA    0696
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
00682:  MOVLW  FA
00684:  ADDWF  xFA,W
00686:  MOVWF  FE9
00688:  MOVLW  01
0068A:  MOVWF  FEA
0068C:  BTFSC  FD8.0
0068E:  INCF   FEA,F
00690:  MOVFF  8E3,FEF
.................... 			timers.rda2_buff_pos++; 
00694:  INCF   xFA,F
00696:  MOVLB  0
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00698:  BCF    FA4.5
0069A:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
006E8:  RCALL  069E
006EA:  MOVFF  01,8E3
....................  
.................... 	if ( current.bridged_uarts ) { 
006EE:  MOVLB  1
006F0:  BTFSS  xD8.0
006F2:  BRA    06FE
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,STREAM_RS485); 
006F4:  MOVLB  8
006F6:  MOVF   xE3,W
006F8:  MOVLB  0
006FA:  RCALL  06B4
.................... 		return; 
006FC:  BRA    0758
.................... 	} 
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006FE:  MOVLB  6
00700:  BTFSC  xBC.0
00702:  BRA    075A
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00704:  MOVF   xBD,F
00706:  BNZ   0718
.................... 			modbus_serial_crc.d = 0xFFFF; 
00708:  SETF   xBF
0070A:  SETF   xBE
.................... 			modbus_rx.address = c; 
0070C:  MOVFF  8E3,6C0
.................... 			modbus_serial_state++; 
00710:  INCF   xBD,F
.................... 			modbus_rx.len = 0; 
00712:  CLRF   xC1
.................... 			modbus_rx.error=0; 
00714:  CLRF   xC3
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00716:  BRA    0746
00718:  DECFSZ xBD,W
0071A:  BRA    0724
.................... 			modbus_rx.func = c; 
0071C:  MOVFF  8E3,6C2
.................... 			modbus_serial_state++; 
00720:  INCF   xBD,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00722:  BRA    0746
00724:  MOVF   xBD,W
00726:  SUBLW  02
00728:  BNZ   0746
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0072A:  INCFSZ xC1,W
0072C:  BRA    0732
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0072E:  MOVLW  FE
00730:  MOVWF  xC1
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
00732:  MOVLW  C4
00734:  ADDWF  xC1,W
00736:  MOVWF  FE9
00738:  MOVLW  06
0073A:  MOVWF  FEA
0073C:  BTFSC  FD8.0
0073E:  INCF   FEA,F
00740:  MOVFF  8E3,FEF
.................... 			modbus_rx.len++; 
00744:  INCF   xC1,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00746:  MOVFF  8E3,8E4
0074A:  MOVLB  0
0074C:  RCALL  06BC
.................... 		modbus_enable_timeout(TRUE); 
0074E:  MOVLW  01
00750:  MOVLB  8
00752:  MOVWF  xE4
00754:  MOVLB  0
00756:  RCALL  03CC
00758:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
....................  
0075A:  BCF    F9E.5
0075C:  MOVLB  0
0075E:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
007B4:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
007B6:  MOVLW  08
007B8:  MOVWF  F61
007BA:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
007BC:  MOVLW  00
007BE:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
007C0:  MOVLW  FF
007C2:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
007C4:  MOVLW  92
007C6:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
007C8:  MOVLW  80
007CA:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
007CC:  BCF    F96.0
007CE:  BCF    F96.1
007D0:  BCF    F96.2
007D2:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
007D4:  MOVLB  1
007D6:  CLRF   xF3
.................... 	timers.load_off_seconds=2; 
007D8:  CLRF   xF5
007DA:  MOVLW  02
007DC:  MOVWF  xF4
.................... 	timers.now_adc_sample=0; 
007DE:  BCF    xF6.0
.................... 	timers.now_adc_reset_count=0; 
007E0:  BCF    xF6.1
.................... 	timers.now_millisecond=0; 
007E2:  BCF    xF6.2
.................... 	timers.port_b=0b11111111; 
007E4:  SETF   xF7
.................... 	timers.port_c=0b11111111; 
007E6:  SETF   xF8
....................  
.................... 	timers.rda2_buff_pos=0; 
007E8:  MOVLB  2
007EA:  CLRF   xFA
.................... 	timers.rda2_buff_gap=255; 
007EC:  SETF   xFB
.................... 	timers.now_parse_rda2=0; 
007EE:  MOVLB  1
007F0:  BCF    xF9.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
007F2:  MOVLB  7
007F4:  CLRF   xD2
007F6:  MOVF   xD2,W
007F8:  SUBLW  02
007FA:  BNC   08AA
.................... 		current.pulse_period[i]=0; 
007FC:  CLRF   03
007FE:  MOVFF  7D2,02
00802:  BCF    FD8.0
00804:  RLCF   02,F
00806:  RLCF   03,F
00808:  MOVF   02,W
0080A:  ADDLW  96
0080C:  MOVWF  FE9
0080E:  MOVLW  00
00810:  ADDWFC 03,W
00812:  MOVWF  FEA
00814:  CLRF   FEC
00816:  MOVF   FED,F
00818:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
0081A:  CLRF   03
0081C:  MOVFF  7D2,02
00820:  BCF    FD8.0
00822:  RLCF   02,F
00824:  RLCF   03,F
00826:  MOVF   02,W
00828:  ADDLW  9C
0082A:  MOVWF  FE9
0082C:  MOVLW  00
0082E:  ADDWFC 03,W
00830:  MOVWF  FEA
00832:  SETF   FEC
00834:  MOVF   FED,F
00836:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00838:  CLRF   03
0083A:  MOVFF  7D2,02
0083E:  BCF    FD8.0
00840:  RLCF   02,F
00842:  RLCF   03,F
00844:  MOVF   02,W
00846:  ADDLW  A2
00848:  MOVWF  FE9
0084A:  MOVLW  00
0084C:  ADDWFC 03,W
0084E:  MOVWF  FEA
00850:  CLRF   FEC
00852:  MOVF   FED,F
00854:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00856:  CLRF   03
00858:  MOVFF  7D2,02
0085C:  BCF    FD8.0
0085E:  RLCF   02,F
00860:  RLCF   03,F
00862:  MOVF   02,W
00864:  ADDLW  A8
00866:  MOVWF  FE9
00868:  MOVLW  00
0086A:  ADDWFC 03,W
0086C:  MOVWF  FEA
0086E:  CLRF   FEC
00870:  MOVF   FED,F
00872:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00874:  MOVLB  8
00876:  CLRF   xD7
00878:  MOVFF  7D2,8D6
0087C:  CLRF   xD9
0087E:  MOVLW  04
00880:  MOVWF  xD8
00882:  MOVLB  0
00884:  RCALL  0778
00886:  MOVF   01,W
00888:  ADDLW  AE
0088A:  MOVWF  FE9
0088C:  MOVLW  00
0088E:  ADDWFC 02,W
00890:  MOVWF  FEA
00892:  MOVF   FEE,F
00894:  MOVF   FEE,F
00896:  CLRF   FEC
00898:  MOVF   FED,F
0089A:  CLRF   FEF
0089C:  MOVF   FED,F
0089E:  CLRF   FEF
008A0:  MOVF   FED,F
008A2:  CLRF   FEF
.................... 	} 
008A4:  MOVLB  7
008A6:  INCF   xD2,F
008A8:  BRA    07F6
....................  
.................... 	current.modbus_our_packets=0; 
008AA:  MOVLB  1
008AC:  CLRF   xCC
008AE:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
008B0:  CLRF   xCE
008B2:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
008B4:  CLRF   xD0
008B6:  CLRF   xCF
.................... 	current.sequence_number=0; 
008B8:  CLRF   xD2
008BA:  CLRF   xD1
.................... 	current.uptime_minutes=0; 
008BC:  CLRF   xD4
008BE:  CLRF   xD3
.................... 	current.interval_milliseconds=0; 
008C0:  CLRF   xD6
008C2:  CLRF   xD5
.................... 	current.adc_buffer_index=0; 
008C4:  CLRF   xCA
.................... 	current.factory_unlocked=0; 
008C6:  CLRF   xD7
.................... 	current.bridged_uarts=0; 
008C8:  BCF    xD8.0
.................... 	current.watchdog_seconds=0; 
008CA:  CLRF   xDA
008CC:  CLRF   xD9
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
008CE:  MOVLW  02
008D0:  MOVWF  FEA
008D2:  MOVLW  FC
008D4:  MOVWF  FE9
008D6:  CLRF   00
008D8:  MOVLW  03
008DA:  MOVWF  02
008DC:  MOVLW  C0
008DE:  MOVWF  01
008E0:  MOVLB  0
008E2:  RCALL  079A
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
008E4:  MOVFF  4B,1DD
008E8:  MOVFF  4A,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
008EC:  MOVFF  47,1DF
008F0:  MOVFF  46,1DE
.................... 	current.power_override_timeout=0; 
008F4:  MOVLB  1
008F6:  CLRF   xE1
008F8:  CLRF   xE0
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
008FA:  MOVLW  00
008FC:  IORLW  05
008FE:  MOVWF  FBA
00900:  MOVLW  4A
00902:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00904:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00906:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00908:  MOVLB  0
0090A:  GOTO   27A0 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00DAE:  MOVLB  1
00DB0:  BCF    xF6.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00DB2:  BCF    FD8.0
00DB4:  MOVLB  7
00DB6:  RLCF   xCD,W
00DB8:  MOVWF  xD2
00DBA:  RLCF   xCE,W
00DBC:  MOVWF  xD3
00DBE:  MOVLW  00
00DC0:  MOVLB  1
00DC2:  BTFSS  xF8.5
00DC4:  MOVLW  01
00DC6:  MOVLB  7
00DC8:  IORWF  xD2,F
00DCA:  MOVFF  7D2,7CD
00DCE:  MOVF   xD3,W
00DD0:  IORLW  E0
00DD2:  MOVWF  xCE
.................... 	if ( b2_state==0xf000) { 
00DD4:  MOVF   xCD,F
00DD6:  BNZ   0DDE
00DD8:  MOVF   xCE,W
00DDA:  SUBLW  F0
00DDC:  BNZ   0DDE
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00DDE:  MOVLB  1
00DE0:  INCFSZ xE2,W
00DE2:  BRA    0DF0
00DE4:  INCFSZ xE3,W
00DE6:  BRA    0DF0
.................... 				current.pulse_period[0]=0; 
00DE8:  MOVLB  0
00DEA:  CLRF   x97
00DEC:  CLRF   x96
00DEE:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00DF0:  INCFSZ xE4,W
00DF2:  BRA    0E00
00DF4:  INCFSZ xE5,W
00DF6:  BRA    0E00
.................... 				current.pulse_period[1]=0; 
00DF8:  MOVLB  0
00DFA:  CLRF   x99
00DFC:  CLRF   x98
00DFE:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00E00:  INCFSZ xE6,W
00E02:  BRA    0E10
00E04:  INCFSZ xE7,W
00E06:  BRA    0E10
.................... 				current.pulse_period[2]=0; 
00E08:  MOVLB  0
00E0A:  CLRF   x9B
00E0C:  CLRF   x9A
00E0E:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00E10:  MOVFF  F81,1F7
.................... 	timers.port_c=port_c; 
00E14:  MOVFF  F82,1F8
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00E18:  BTFSS  xD8.0
00E1A:  BRA    0E20
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00E1C:  BSF    F89.3
.................... 	} else { 
00E1E:  BRA    0E2C
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00E20:  MOVF   xF3,F
00E22:  BNZ   0E28
.................... 			output_low(LED_GREEN); 
00E24:  BCF    F89.3
.................... 		} else { 
00E26:  BRA    0E2C
.................... 			output_high(LED_GREEN); 
00E28:  BSF    F89.3
.................... 			timers.led_on_green--; 
00E2A:  DECF   xF3,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00E2C:  INCFSZ xD5,W
00E2E:  BRA    0E36
00E30:  INCFSZ xD6,W
00E32:  BRA    0E36
00E34:  BRA    0E3C
.................... 		current.interval_milliseconds++; 
00E36:  INCF   xD5,F
00E38:  BTFSC  FD8.2
00E3A:  INCF   xD6,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00E3C:  MOVLB  7
00E3E:  INCF   xCB,F
00E40:  BTFSC  FD8.2
00E42:  INCF   xCC,F
.................... 	if ( 1000 == ticks ) { 
00E44:  MOVF   xCB,W
00E46:  SUBLW  E8
00E48:  BNZ   0ECE
00E4A:  MOVF   xCC,W
00E4C:  SUBLW  03
00E4E:  BNZ   0ECE
.................... 		ticks=0; 
00E50:  CLRF   xCC
00E52:  CLRF   xCB
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00E54:  MOVLB  1
00E56:  INCFSZ xD9,W
00E58:  BRA    0E60
00E5A:  INCFSZ xDA,W
00E5C:  BRA    0E60
00E5E:  BRA    0E66
.................... 			current.watchdog_seconds++; 
00E60:  INCF   xD9,F
00E62:  BTFSC  FD8.2
00E64:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00E66:  MOVF   3F,F
00E68:  BNZ   0E6E
00E6A:  MOVF   40,F
00E6C:  BZ    0E8C
00E6E:  MOVF   40,W
00E70:  SUBWF  xDA,W
00E72:  BNC   0E8C
00E74:  BNZ   0E7C
00E76:  MOVF   xD9,W
00E78:  SUBWF  3F,W
00E7A:  BC    0E8C
00E7C:  MOVF   xF4,F
00E7E:  BNZ   0E8C
00E80:  MOVF   xF5,F
00E82:  BNZ   0E8C
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00E84:  MOVFF  42,1F5
00E88:  MOVFF  41,1F4
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00E8C:  MOVF   xF4,F
00E8E:  BNZ   0E98
00E90:  MOVF   xF5,F
00E92:  BNZ   0E98
.................... 			output_high(PI_POWER_EN); 
00E94:  BSF    F8B.0
.................... 		} else { 
00E96:  BRA    0EAE
.................... 			output_low(PI_POWER_EN); 
00E98:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00E9A:  MOVF   xF4,W
00E9C:  BTFSC  FD8.2
00E9E:  DECF   xF5,F
00EA0:  DECF   xF4,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00EA2:  MOVF   xF4,F
00EA4:  BNZ   0EAE
00EA6:  MOVF   xF5,F
00EA8:  BNZ   0EAE
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00EAA:  CLRF   xDA
00EAC:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00EAE:  MOVLB  7
00EB0:  INCF   xC8,F
.................... 		if ( 60 == uptimeTicks ) { 
00EB2:  MOVF   xC8,W
00EB4:  SUBLW  3C
00EB6:  BNZ   0ECE
.................... 			uptimeTicks=0; 
00EB8:  CLRF   xC8
.................... 			if ( current.uptime_minutes < 65535 )  
00EBA:  MOVLB  1
00EBC:  INCFSZ xD3,W
00EBE:  BRA    0EC6
00EC0:  INCFSZ xD4,W
00EC2:  BRA    0EC6
00EC4:  BRA    0ECC
.................... 				current.uptime_minutes++; 
00EC6:  INCF   xD3,F
00EC8:  BTFSC  FD8.2
00ECA:  INCF   xD4,F
00ECC:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00ECE:  INCFSZ xCF,W
00ED0:  BRA    0EE4
00ED2:  INCFSZ xD0,W
00ED4:  BRA    0EE4
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00ED6:  CLRF   xEA
00ED8:  MOVLB  0
00EDA:  RCALL  0D26
00EDC:  MOVFF  02,7D0
00EE0:  MOVFF  01,7CF
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00EE4:  MOVLB  1
00EE6:  BTFSS  xF6.1
00EE8:  BRA    0EF2
.................... 		timers.now_adc_reset_count=0; 
00EEA:  BCF    xF6.1
.................... 		adcTicks=0; 
00EEC:  MOVLB  7
00EEE:  CLRF   xCA
00EF0:  CLRF   xC9
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00EF2:  MOVLB  7
00EF4:  INCF   xC9,F
00EF6:  BTFSC  FD8.2
00EF8:  INCF   xCA,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00EFA:  MOVF   3C,W
00EFC:  SUBWF  xC9,W
00EFE:  BNZ   0F14
00F00:  MOVF   3D,W
00F02:  SUBWF  xCA,W
00F04:  BNZ   0F14
.................... 		adcTicks=0; 
00F06:  CLRF   xCA
00F08:  CLRF   xC9
.................... 		timers.now_adc_sample=1; 
00F0A:  MOVLB  1
00F0C:  BSF    xF6.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00F0E:  MOVLB  7
00F10:  SETF   xD0
00F12:  SETF   xCF
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
00F14:  MOVLB  2
00F16:  INCFSZ xFB,W
00F18:  BRA    0F1C
00F1A:  BRA    0F1E
.................... 		timers.rda2_buff_gap++; 
00F1C:  INCF   xFB,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
00F1E:  MOVF   xFB,W
00F20:  SUBLW  09
00F22:  BC    0F2E
00F24:  MOVF   xFA,F
00F26:  BZ    0F2E
.................... 		timers.now_parse_rda2=1;	 
00F28:  MOVLB  1
00F2A:  BSF    xF9.0
00F2C:  MOVLB  2
.................... 	} 
.................... } 
00F2E:  MOVLB  0
00F30:  GOTO   280C (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
0258A:  MOVFF  2FA,8D2
.................... 	timers.rda2_buff_pos=255; /* stop getting more data for a second */ 
0258E:  MOVLB  2
02590:  SETF   xFA
.................... 	memcpy(buff,timers.rda2_buff,length); 
02592:  MOVLW  07
02594:  MOVWF  FEA
02596:  MOVLW  D2
02598:  MOVWF  FE9
0259A:  MOVLW  01
0259C:  MOVWF  FE2
0259E:  MOVLW  FA
025A0:  MOVWF  FE1
025A2:  MOVLB  8
025A4:  MOVF   xD2,W
025A6:  MOVWF  01
025A8:  BZ    25B2
025AA:  MOVFF  FE6,FEE
025AE:  DECFSZ 01,F
025B0:  BRA    25AA
.................... 	timers.rda2_buff_gap=0; 
025B2:  MOVLB  2
025B4:  CLRF   xFB
.................... 	timers.rda2_buff_pos=0; 
025B6:  CLRF   xFA
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
025B8:  DECFSZ 38,W
025BA:  BRA    25F2
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
025BC:  MOVLB  8
025BE:  CLRF   xD4
025C0:  CLRF   xD3
025C2:  MOVF   xD4,F
025C4:  BNZ   25EE
025C6:  MOVF   xD2,W
025C8:  SUBWF  xD3,W
025CA:  BC    25EE
.................... 			fputc(buff[l],STREAM_PI); 
025CC:  MOVLW  D2
025CE:  ADDWF  xD3,W
025D0:  MOVWF  FE9
025D2:  MOVLW  07
025D4:  ADDWFC xD4,W
025D6:  MOVWF  FEA
025D8:  MOVFF  FEF,8D6
025DC:  MOVF   xD6,W
025DE:  MOVLB  0
025E0:  CALL   1068
.................... 		} 
025E4:  MOVLB  8
025E6:  INCF   xD3,F
025E8:  BTFSC  FD8.2
025EA:  INCF   xD4,F
025EC:  BRA    25C2
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
025EE:  BRA    26F6
025F0:  MOVLB  2
025F2:  MOVF   38,W
025F4:  SUBLW  02
025F6:  BTFSS  FD8.2
025F8:  BRA    26F8
.................... 		/* do something */ 
.................... 		/* null terminate buff so we can treat it as a string */ 
.................... 		buff[length]='\0'; 
025FA:  CLRF   03
025FC:  MOVLB  8
025FE:  MOVF   xD2,W
02600:  ADDLW  D2
02602:  MOVWF  FE9
02604:  MOVLW  07
02606:  ADDWFC 03,W
02608:  MOVWF  FEA
0260A:  CLRF   FEF
....................  
.................... 		/* put copy in 11th slot no mater what ... for debugging */ 
.................... 		strncpy(nmea.sentence[11],buff,NMEA_SENTENCE_LENGTH-1); 
0260C:  MOVLW  06
0260E:  MOVWF  xD9
02610:  MOVLW  6C
02612:  MOVWF  xD8
02614:  MOVLW  07
02616:  MOVWF  xDB
02618:  MOVLW  D2
0261A:  MOVWF  xDA
0261C:  CLRF   xDD
0261E:  MOVLW  4F
02620:  MOVWF  xDC
02622:  MOVLB  0
02624:  RCALL  2460
.................... 		/* always null terminate final character */ 
.................... 		nmea.sentence[11][NMEA_SENTENCE_LENGTH-1]='\0'; 
02626:  MOVLB  6
02628:  CLRF   xBB
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
0262A:  MOVLB  8
0262C:  MOVF   xD2,W
0262E:  SUBLW  05
02630:  BNC   2634
.................... 			return; 
02632:  BRA    26F6
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
02634:  CLRF   xD5
02636:  MOVF   xD5,W
02638:  SUBLW  0B
0263A:  BNC   26F6
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
0263C:  MOVF   xD5,W
0263E:  MULLW  06
02640:  MOVF   FF3,W
02642:  CLRF   03
02644:  ADDLW  4E
02646:  MOVWF  01
02648:  MOVLW  00
0264A:  ADDWFC 03,F
0264C:  MOVFF  01,8D6
02650:  MOVFF  03,8D7
02654:  MOVLW  07
02656:  MOVWF  xD9
02658:  MOVLW  D2
0265A:  MOVWF  xD8
0265C:  MOVFF  03,8DB
02660:  MOVFF  01,8DA
02664:  CLRF   xDD
02666:  MOVLW  06
02668:  MOVWF  xDC
0266A:  MOVLB  0
0266C:  BRA    24F2
0266E:  MOVF   01,F
02670:  BZ    2674
.................... 				/* no match */ 
.................... 				continue; 
02672:  BRA    26F0
.................... 			} 
....................  
.................... 			/* put copy in 11th slot no mater what ... for debugging */ 
.................... 			strncpy(nmea.sentence[i],buff,NMEA_SENTENCE_LENGTH-1); 
02674:  MOVLB  8
02676:  CLRF   xD7
02678:  MOVFF  8D5,8D6
0267C:  CLRF   xD9
0267E:  MOVLW  50
02680:  MOVWF  xD8
02682:  MOVLB  0
02684:  CALL   0778
02688:  MOVFF  02,03
0268C:  MOVF   01,W
0268E:  ADDLW  FC
02690:  MOVWF  01
02692:  MOVLW  02
02694:  ADDWFC 03,F
02696:  MOVFF  01,8D6
0269A:  MOVLB  8
0269C:  MOVFF  03,8D7
026A0:  MOVFF  03,8D9
026A4:  MOVFF  01,8D8
026A8:  MOVLW  07
026AA:  MOVWF  xDB
026AC:  MOVLW  D2
026AE:  MOVWF  xDA
026B0:  CLRF   xDD
026B2:  MOVLW  4F
026B4:  MOVWF  xDC
026B6:  MOVLB  0
026B8:  RCALL  2460
.................... 			/* always null terminate final character */ 
.................... 			nmea.sentence[i][NMEA_SENTENCE_LENGTH-1]='\0'; 
026BA:  MOVLB  8
026BC:  CLRF   xD7
026BE:  MOVFF  8D5,8D6
026C2:  CLRF   xD9
026C4:  MOVLW  50
026C6:  MOVWF  xD8
026C8:  MOVLB  0
026CA:  CALL   0778
026CE:  MOVFF  01,8D6
026D2:  MOVLW  4F
026D4:  MOVLB  8
026D6:  ADDWF  01,W
026D8:  MOVWF  01
026DA:  MOVLW  00
026DC:  ADDWFC 02,W
026DE:  MOVWF  03
026E0:  MOVF   01,W
026E2:  ADDLW  FC
026E4:  MOVWF  FE9
026E6:  MOVLW  02
026E8:  ADDWFC 03,W
026EA:  MOVWF  FEA
026EC:  CLRF   FEF
026EE:  MOVLB  0
.................... 		} 
026F0:  MOVLB  8
026F2:  INCF   xD5,F
026F4:  BRA    2636
026F6:  MOVLB  2
.................... 	} 
.................... } 
026F8:  MOVLB  0
026FA:  GOTO   282A (RETURN)
....................  
....................  
.................... void main(void) { 
026FE:  CLRF   FF8
02700:  BCF    FF1.2
02702:  BSF    F9F.1
02704:  BCF    F9F.5
02706:  BCF    FA5.5
02708:  BSF    FD0.7
0270A:  BSF    07.7
0270C:  CLRF   FEA
0270E:  CLRF   FE9
02710:  CLRF   35
02712:  BCF    FB8.3
02714:  MOVLW  0C
02716:  MOVWF  FAF
02718:  MOVLW  A6
0271A:  MOVWF  FAC
0271C:  MOVLW  90
0271E:  MOVWF  FAB
02720:  BCF    F70.3
02722:  MOVLW  4D
02724:  MOVWF  F75
02726:  MOVLW  A6
02728:  MOVWF  F72
0272A:  MOVLW  90
0272C:  MOVWF  F71
0272E:  MOVLB  6
02730:  BCF    xBC.0
02732:  CLRF   xBD
02734:  MOVLB  7
02736:  CLRF   xC7
02738:  MOVLB  6
0273A:  BCF    xBC.1
0273C:  BCF    xBC.2
0273E:  BCF    xBC.3
02740:  BCF    xBC.4
02742:  BCF    xBC.5
02744:  BCF    xBC.6
02746:  MOVLB  7
02748:  CLRF   xC8
0274A:  CLRF   xCA
0274C:  CLRF   xC9
0274E:  CLRF   xCC
02750:  CLRF   xCB
02752:  CLRF   xCE
02754:  CLRF   xCD
02756:  MOVF   FC1,W
02758:  ANDLW  F0
0275A:  MOVWF  FC1
0275C:  MOVLW  00
0275E:  MOVLB  F
02760:  MOVWF  x38
02762:  MOVWF  x3C
02764:  MOVWF  x39
02766:  MOVWF  x3A
02768:  MOVWF  x3B
0276A:  MOVLB  1
0276C:  CLRF   x88
0276E:  CLRF   F77
02770:  CLRF   F78
02772:  CLRF   F79
02774:  CLRF   2F
02776:  CLRF   30
02778:  MOVLB  7
0277A:  CLRF   xC3
0277C:  CLRF   xC4
0277E:  CLRF   xC5
02780:  CLRF   xC6
02782:  CLRF   xCF
02784:  CLRF   xD0
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02786:  MOVF   FD0,W
02788:  ANDLW  0F
0278A:  BTFSS  FD0.4
0278C:  MOVLW  00
0278E:  BSF    FD0.0
02790:  BSF    FD0.1
02792:  BSF    FD0.4
02794:  BSF    FD8.3
02796:  BSF    FD8.4
02798:  MOVWF  xD1
....................  
.................... 	init(); 
0279A:  MOVLB  0
0279C:  GOTO   07B4
....................  
....................  
.................... #if 0 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
.................... 	output_high(RS485_NRE); 
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
....................  
.................... 	switch ( i ) { 
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
027A0:  GOTO   0B12
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
027A4:  MOVF   36,W
027A6:  SUBLW  80
027A8:  BC    27AE
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
027AA:  CALL   0A9A
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
027AE:  BSF    FAB.7
027B0:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
027B2:  GOTO   0B70
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
027B6:  MOVLB  7
027B8:  CLRF   xD1
027BA:  MOVF   xD1,W
027BC:  SUBLW  1D
027BE:  BNC   27CC
.................... 		adc_update(); 
027C0:  MOVLB  0
027C2:  CALL   0C2E
.................... 	} 
027C6:  MOVLB  7
027C8:  INCF   xD1,F
027CA:  BRA    27BA
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
027CC:  MOVFF  43,1DB
....................  
....................  
.................... #if 0 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
.................... 	output_low(RS485_DE); 
.................... 	output_low(RS485_NRE); 
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
027D0:  MOVLW  62
027D2:  MOVWF  FF6
027D4:  MOVLW  07
027D6:  MOVWF  FF7
027D8:  MOVLW  07
027DA:  MOVWF  xD2
027DC:  MOVLB  0
027DE:  GOTO   0CD6
027E2:  MOVLW  6E
027E4:  MOVWF  FF6
027E6:  MOVLW  07
027E8:  MOVWF  FF7
027EA:  GOTO   0D02
027EE:  MOVLW  0D
027F0:  BTFSS  F9E.4
027F2:  BRA    27F0
027F4:  MOVWF  FAD
027F6:  MOVLW  0A
027F8:  BTFSS  F9E.4
027FA:  BRA    27F8
027FC:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
027FE:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(STREAM_RS485) ) { 
.................... 				fputc(fgetc(STREAM_RS485),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
02800:  MOVLB  1
02802:  BTFSS  xF6.2
02804:  BRA    280E
.................... 			periodic_millisecond(); 
02806:  MOVLB  0
02808:  GOTO   0DAE
0280C:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
0280E:  BTFSS  xF6.0
02810:  BRA    281A
.................... 			timers.now_adc_sample=0; 
02812:  BCF    xF6.0
.................... 			adc_update(); 
02814:  MOVLB  0
02816:  CALL   0C2E
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
0281A:  MOVLB  0
0281C:  BRA    216E
.................... //		} 
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
0281E:  MOVLB  1
02820:  BTFSS  xF9.0
02822:  BRA    282C
.................... 			timers.now_parse_rda2=0; 
02824:  BCF    xF9.0
.................... 			rs485_to_host(); 
02826:  MOVLB  0
02828:  BRA    258A
0282A:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
0282C:  MOVLB  0
0282E:  BRA    27FE
.................... } 
02830:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
