CCS PCH C Compiler, Version 4.135, 4375               23-Nov-15 13:51

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 11630 bytes (18%)
                         Largest free fragment is 53902
               RAM used: 2006 (51%) at main() level
                         2282 (59%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   2B38
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   0410
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0760
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   069E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0442
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02978:  MOVLB  8
0297A:  MOVF   xE0,F
0297C:  BNZ   2982
0297E:  MOVF   xE1,F
02980:  BZ    2A06
....................       if (*s1 != *s2) 
02982:  MOVFF  8DC,FE9
02986:  MOVFF  8DD,FEA
0298A:  MOVFF  FEF,8E2
0298E:  MOVFF  8DF,03
02992:  MOVFF  8DE,FE9
02996:  MOVFF  8DF,FEA
0299A:  MOVF   FEF,W
0299C:  SUBWF  xE2,W
0299E:  BZ    29CE
....................          return((*s1 <*s2) ? -1: 1); 
029A0:  MOVFF  8DD,03
029A4:  MOVFF  8DC,FE9
029A8:  MOVFF  8DD,FEA
029AC:  MOVFF  FEF,8E2
029B0:  MOVFF  8DF,03
029B4:  MOVFF  8DE,FE9
029B8:  MOVFF  8DF,FEA
029BC:  MOVF   FEF,W
029BE:  SUBWF  xE2,W
029C0:  BC    29C6
029C2:  MOVLW  FF
029C4:  BRA    29C8
029C6:  MOVLW  01
029C8:  MOVWF  01
029CA:  BRA    2A0A
....................       else if (*s1 == '\0') 
029CC:  BRA    29E4
029CE:  MOVFF  8DD,03
029D2:  MOVFF  8DC,FE9
029D6:  MOVFF  8DD,FEA
029DA:  MOVF   FEF,F
029DC:  BNZ   29E4
....................          return(0); 
029DE:  MOVLW  00
029E0:  MOVWF  01
029E2:  BRA    2A0A
029E4:  MOVFF  8DD,03
029E8:  MOVF   xDC,W
029EA:  INCF   xDC,F
029EC:  BTFSC  FD8.2
029EE:  INCF   xDD,F
029F0:  MOVFF  8DF,03
029F4:  MOVF   xDE,W
029F6:  INCF   xDE,F
029F8:  BTFSC  FD8.2
029FA:  INCF   xDF,F
029FC:  MOVF   xE0,W
029FE:  BTFSC  FD8.2
02A00:  DECF   xE1,F
02A02:  DECF   xE0,F
02A04:  BRA    297A
....................    return(0); 
02A06:  MOVLW  00
02A08:  MOVWF  01
.................... } 
02A0A:  MOVLB  0
02A0C:  GOTO   2AE0 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
0121C:  MOVLW  05
0121E:  MOVLB  7
01220:  SUBWF  xDD,F
01222:  BNC   1238
01224:  MOVLW  07
01226:  MOVWF  FEA
01228:  MOVLW  DD
0122A:  MOVWF  FE9
0122C:  MOVF   FEF,W
0122E:  BZ    1238
01230:  BRA    1234
01232:  CLRWDT
01234:  DECFSZ FEF,F
01236:  BRA    1232
01238:  MOVLB  0
0123A:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0071E:  BTFSS  F9E.5
00720:  BRA    071E
00722:  MOVFF  FAB,35
00726:  MOVFF  FAE,01
0072A:  BTFSS  35.1
0072C:  BRA    0732
0072E:  BCF    FAB.4
00730:  BSF    FAB.4
00732:  RETURN 0
*
01332:  BTFSS  F9E.4
01334:  BRA    1332
01336:  MOVWF  FAD
01338:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00686:  BTFSS  FA4.5
00688:  BRA    0686
0068A:  MOVFF  F71,35
0068E:  MOVFF  F74,01
00692:  BTFSS  35.1
00694:  BRA    069A
00696:  BCF    F71.4
00698:  BSF    F71.4
0069A:  GOTO   06A0 (RETURN)
*
0123C:  BTFSS  FA4.4
0123E:  BRA    123C
01240:  MOVWF  F73
01242:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00EE8:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00E48:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00E4A:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00E4C:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00E4E:  MOVLB  7
00E50:  MOVF   xD9,F
00E52:  BNZ   0E5A
.................... 		c=0b00011; 
00E54:  MOVLW  03
00E56:  MOVWF  xDD
.................... 	else if ( 1 == ch )  
00E58:  BRA    0EA4
00E5A:  DECFSZ xD9,W
00E5C:  BRA    0E64
.................... 		c=0b10011; 
00E5E:  MOVLW  13
00E60:  MOVWF  xDD
.................... 	else if ( 2 == ch )  
00E62:  BRA    0EA4
00E64:  MOVF   xD9,W
00E66:  SUBLW  02
00E68:  BNZ   0E70
.................... 		c=0b01011; 
00E6A:  MOVLW  0B
00E6C:  MOVWF  xDD
.................... 	else if ( 3 == ch )  
00E6E:  BRA    0EA4
00E70:  MOVF   xD9,W
00E72:  SUBLW  03
00E74:  BNZ   0E7C
.................... 		c=0b11011; 
00E76:  MOVLW  1B
00E78:  MOVWF  xDD
.................... 	else if ( 4 == ch ) 
00E7A:  BRA    0EA4
00E7C:  MOVF   xD9,W
00E7E:  SUBLW  04
00E80:  BNZ   0E88
.................... 		c=0b00111; 
00E82:  MOVLW  07
00E84:  MOVWF  xDD
.................... 	else if ( 5 == ch )  
00E86:  BRA    0EA4
00E88:  MOVF   xD9,W
00E8A:  SUBLW  05
00E8C:  BNZ   0E94
.................... 		c=0b10111; 
00E8E:  MOVLW  17
00E90:  MOVWF  xDD
.................... 	else if ( 6 == ch ) 
00E92:  BRA    0EA4
00E94:  MOVF   xD9,W
00E96:  SUBLW  06
00E98:  BNZ   0EA0
.................... 		c=0b01111; 
00E9A:  MOVLW  0F
00E9C:  MOVWF  xDD
.................... 	else 
00E9E:  BRA    0EA4
.................... 		c=0b11111; 
00EA0:  MOVLW  1F
00EA2:  MOVWF  xDD
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00EA4:  CLRF   xDC
00EA6:  MOVF   xDC,W
00EA8:  SUBLW  04
00EAA:  BNC   0EC2
.................... 		output_low(MCP3208_CLK); 
00EAC:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00EAE:  BTFSC  xDD.0
00EB0:  BRA    0EB6
00EB2:  BCF    F8B.5
00EB4:  BRA    0EB8
00EB6:  BSF    F8B.5
.................... 		c=c>>1; 
00EB8:  BCF    FD8.0
00EBA:  RRCF   xDD,F
.................... 		output_high(MCP3208_CLK); 
00EBC:  BSF    F8B.3
.................... 	} 
00EBE:  INCF   xDC,F
00EC0:  BRA    0EA6
....................  
....................  
.................... 	value=0; 
00EC2:  CLRF   xDB
00EC4:  CLRF   xDA
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00EC6:  CLRF   xDC
00EC8:  MOVF   xDC,W
00ECA:  SUBLW  0D
00ECC:  BNC   0EE4
.................... 		output_low(MCP3208_CLK); 
00ECE:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00ED0:  BTFSC  F82.4
00ED2:  BRA    0ED8
00ED4:  BCF    FD8.0
00ED6:  BRA    0EDA
00ED8:  BSF    FD8.0
00EDA:  RLCF   xDA,F
00EDC:  RLCF   xDB,F
.................... 		output_high(MCP3208_CLK); 
00EDE:  BSF    F8B.3
.................... 	} 
00EE0:  INCF   xDC,F
00EE2:  BRA    0EC8
....................  
.................... 	bit_clear(value,13); 
00EE4:  BCF    xDB.5
.................... 	bit_clear(value,12); 
00EE6:  BCF    xDB.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00EEA:  MOVFF  7DA,01
00EEE:  MOVFF  7DB,02
.................... } 
00EF2:  MOVLB  0
00EF4:  GOTO   0F66 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00FF0:  MOVLB  8
00FF2:  CLRF   xDB
00FF4:  MOVFF  7EE,8DA
00FF8:  CLRF   xDD
00FFA:  MOVLW  20
00FFC:  MOVWF  xDC
00FFE:  MOVLB  0
01000:  RCALL  0890
01002:  MOVFF  02,03
01006:  MOVF   01,W
01008:  ADDLW  CB
0100A:  MOVWF  01
0100C:  MOVLW  00
0100E:  ADDWFC 03,F
01010:  MOVFF  01,7F2
01014:  MOVLB  7
01016:  MOVFF  03,7F3
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
0101A:  CLRF   xF0
0101C:  CLRF   xEF
.................... 	for( i = 0; i < 16 ; i++ ) { 
0101E:  CLRF   xF1
01020:  MOVF   xF1,W
01022:  SUBLW  0F
01024:  BNC   1048
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
01026:  BCF    FD8.0
01028:  RLCF   xF1,W
0102A:  CLRF   03
0102C:  ADDWF  xF2,W
0102E:  MOVWF  FE9
01030:  MOVF   xF3,W
01032:  ADDWFC 03,W
01034:  MOVWF  FEA
01036:  MOVFF  FEC,03
0103A:  MOVF   FED,F
0103C:  MOVF   FEF,W
0103E:  ADDWF  xEF,F
01040:  MOVF   03,W
01042:  ADDWFC xF0,F
.................... 	} 
01044:  INCF   xF1,F
01046:  BRA    1020
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
01048:  MOVLW  08
0104A:  ADDWF  xEF,W
0104C:  MOVWF  xF4
0104E:  MOVLW  00
01050:  ADDWFC xF0,W
01052:  MOVWF  xF5
01054:  RRCF   xF5,W
01056:  MOVWF  03
01058:  RRCF   xF4,W
0105A:  MOVWF  02
0105C:  RRCF   03,F
0105E:  RRCF   02,F
01060:  RRCF   03,F
01062:  RRCF   02,F
01064:  RRCF   03,F
01066:  RRCF   02,F
01068:  MOVLW  0F
0106A:  ANDWF  03,F
0106C:  MOVFF  02,01
01070:  MOVFF  03,02
.................... } 
01074:  MOVLB  0
01076:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00EF8:  MOVLB  1
00EFA:  INCF   xCB,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00EFC:  MOVF   xCB,W
00EFE:  SUBLW  0F
00F00:  BC    0F04
.................... 		current.adc_buffer_index=0; 
00F02:  CLRF   xCB
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00F04:  MOVLB  7
00F06:  CLRF   xD6
00F08:  MOVF   xD6,W
00F0A:  SUBLW  07
00F0C:  BNC   0F9C
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00F0E:  MOVLB  8
00F10:  CLRF   xDB
00F12:  MOVFF  7D6,8DA
00F16:  CLRF   xDD
00F18:  MOVLW  20
00F1A:  MOVWF  xDC
00F1C:  MOVLB  0
00F1E:  RCALL  0890
00F20:  MOVFF  02,03
00F24:  MOVF   01,W
00F26:  ADDLW  34
00F28:  MOVLB  7
00F2A:  MOVWF  xD7
00F2C:  MOVLW  00
00F2E:  ADDWFC 02,W
00F30:  MOVWF  xD8
00F32:  CLRF   03
00F34:  MOVLB  1
00F36:  MOVFF  1CB,02
00F3A:  BCF    FD8.0
00F3C:  RLCF   02,F
00F3E:  RLCF   03,F
00F40:  MOVF   02,W
00F42:  MOVLB  7
00F44:  ADDWF  xD7,W
00F46:  MOVWF  01
00F48:  MOVF   xD8,W
00F4A:  ADDWFC 03,F
00F4C:  MOVF   01,W
00F4E:  ADDLW  97
00F50:  MOVWF  01
00F52:  MOVLW  00
00F54:  ADDWFC 03,F
00F56:  MOVFF  01,7D7
00F5A:  MOVFF  03,7D8
00F5E:  MOVFF  7D6,7D9
00F62:  MOVLB  0
00F64:  BRA    0E48
00F66:  MOVFF  7D8,FEA
00F6A:  MOVFF  7D7,FE9
00F6E:  MOVFF  02,FEC
00F72:  MOVF   FED,F
00F74:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00F78:  CLRF   03
00F7A:  MOVLB  7
00F7C:  MOVFF  7D6,02
00F80:  BCF    FD8.0
00F82:  RLCF   02,F
00F84:  RLCF   03,F
00F86:  MOVF   02,W
00F88:  ADDLW  BB
00F8A:  MOVWF  FE9
00F8C:  MOVLW  00
00F8E:  ADDWFC 03,W
00F90:  MOVWF  FEA
00F92:  CLRF   FEC
00F94:  MOVF   FED,F
00F96:  CLRF   FEF
....................  
.................... 	} 
00F98:  INCF   xD6,F
00F9A:  BRA    0F08
.................... } 
00F9C:  MOVLB  0
00F9E:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00C1A:  MOVF   xF3,W
00C1C:  XORWF  xF4,W
00C1E:  MOVWF  01
*
00C6C:  MOVF   xF3,W
00C6E:  XORWF  xF4,W
00C70:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00BA4:  MOVLB  7
00BA6:  CLRF   xDF
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BA8:  MOVFF  7DE,03
00BAC:  MOVF   xDD,W
00BAE:  BTFSC  FD8.2
00BB0:  DECF   xDE,F
00BB2:  DECF   xDD,F
00BB4:  MOVWF  xE0
00BB6:  MOVFF  03,7E1
00BBA:  MOVF   xE0,F
00BBC:  BNZ   0BC2
00BBE:  MOVF   xE1,F
00BC0:  BZ    0C2C
.................... 		*data = read_eeprom( address++ ); 
00BC2:  MOVFF  7DC,03
00BC6:  MOVF   xDB,W
00BC8:  MOVWF  FE9
00BCA:  MOVFF  03,FEA
00BCE:  MOVF   xDA,W
00BD0:  MOVWF  03
00BD2:  MOVF   xD9,W
00BD4:  INCF   xD9,F
00BD6:  BTFSC  FD8.2
00BD8:  INCF   xDA,F
00BDA:  MOVWF  xE2
00BDC:  MOVFF  03,7E3
00BE0:  MOVFF  FF2,7E4
00BE4:  BCF    FF2.6
00BE6:  BCF    FF2.7
00BE8:  MOVFF  7E3,FAA
00BEC:  MOVFF  7E2,FA9
00BF0:  BCF    FA6.6
00BF2:  BCF    FA6.7
00BF4:  BSF    FA6.0
00BF6:  MOVF   FA8,W
00BF8:  BTFSC  xE4.6
00BFA:  BSF    FF2.6
00BFC:  BTFSC  xE4.7
00BFE:  BSF    FF2.7
00C00:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00C02:  MOVFF  7DC,03
00C06:  MOVF   xDB,W
00C08:  MOVWF  FE9
00C0A:  MOVFF  03,FEA
00C0E:  MOVFF  FEF,7E0
00C12:  MOVFF  7DF,7F3
00C16:  MOVFF  7E0,7F4
*
00C20:  MOVFF  01,7DF
.................... 		data++; 
00C24:  INCF   xDB,F
00C26:  BTFSC  FD8.2
00C28:  INCF   xDC,F
.................... 	} 
00C2A:  BRA    0BA8
.................... 	return crc; 
00C2C:  MOVFF  7DF,01
.................... } 
00C30:  MOVLB  0
00C32:  GOTO   0DFC (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00C36:  MOVLB  7
00C38:  CLRF   xF1
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00C3A:  MOVFF  7F0,03
00C3E:  MOVF   xEF,W
00C40:  BTFSC  FD8.2
00C42:  DECF   xF0,F
00C44:  DECF   xEF,F
00C46:  MOVWF  xF2
00C48:  MOVFF  03,7F3
00C4C:  MOVF   xF2,F
00C4E:  BNZ   0C54
00C50:  MOVF   xF3,F
00C52:  BZ    0CD2
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00C54:  MOVFF  7EE,03
00C58:  MOVF   xED,W
00C5A:  MOVWF  FE9
00C5C:  MOVFF  03,FEA
00C60:  MOVFF  FEF,7F2
00C64:  MOVFF  7F1,7F3
00C68:  MOVFF  7F2,7F4
*
00C72:  MOVFF  01,7F1
.................... 		write_eeprom( address++, *data++ ); 
00C76:  MOVF   xEC,W
00C78:  MOVWF  03
00C7A:  MOVF   xEB,W
00C7C:  INCF   xEB,F
00C7E:  BTFSC  FD8.2
00C80:  INCF   xEC,F
00C82:  MOVWF  xF2
00C84:  MOVFF  03,7F3
00C88:  MOVF   xEE,W
00C8A:  MOVWF  03
00C8C:  MOVF   xED,W
00C8E:  INCF   xED,F
00C90:  BTFSC  FD8.2
00C92:  INCF   xEE,F
00C94:  MOVWF  FE9
00C96:  MOVFF  03,FEA
00C9A:  MOVFF  FEF,7F4
00C9E:  MOVFF  7F3,FAA
00CA2:  MOVFF  7F2,FA9
00CA6:  MOVFF  7F4,FA8
00CAA:  BCF    FA6.6
00CAC:  BCF    FA6.7
00CAE:  BSF    FA6.2
00CB0:  MOVF   FF2,W
00CB2:  MOVWF  00
00CB4:  BCF    FF2.6
00CB6:  BCF    FF2.7
00CB8:  MOVLB  F
00CBA:  MOVLW  55
00CBC:  MOVWF  FA7
00CBE:  MOVLW  AA
00CC0:  MOVWF  FA7
00CC2:  BSF    FA6.1
00CC4:  BTFSC  FA6.1
00CC6:  BRA    0CC4
00CC8:  BCF    FA6.2
00CCA:  MOVF   00,W
00CCC:  IORWF  FF2,F
.................... 	} 
00CCE:  MOVLB  7
00CD0:  BRA    0C3A
....................  
.................... 	return crc; 
00CD2:  MOVFF  7F1,01
.................... } 
00CD6:  MOVLB  0
00CD8:  GOTO   0CFC (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00CDC:  MOVLB  7
00CDE:  CLRF   xEA
00CE0:  MOVLW  36
00CE2:  MOVWF  xE9
00CE4:  CLRF   xEC
00CE6:  MOVLW  02
00CE8:  MOVWF  xEB
00CEA:  MOVFF  7EA,7EE
00CEE:  MOVFF  7E9,7ED
00CF2:  CLRF   xF0
00CF4:  MOVLW  61
00CF6:  MOVWF  xEF
00CF8:  MOVLB  0
00CFA:  BRA    0C36
00CFC:  MOVFF  01,7E8
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00D00:  CLRF   FAA
00D02:  CLRF   FA9
00D04:  MOVFF  7E8,FA8
00D08:  BCF    FA6.6
00D0A:  BCF    FA6.7
00D0C:  BSF    FA6.2
00D0E:  MOVF   FF2,W
00D10:  MOVWF  00
00D12:  BCF    FF2.6
00D14:  BCF    FF2.7
00D16:  MOVLB  F
00D18:  MOVLW  55
00D1A:  MOVWF  FA7
00D1C:  MOVLW  AA
00D1E:  MOVWF  FA7
00D20:  BSF    FA6.1
00D22:  BTFSC  FA6.1
00D24:  BRA    0D22
00D26:  BCF    FA6.2
00D28:  MOVF   00,W
00D2A:  IORWF  FF2,F
.................... } 
00D2C:  MOVLB  0
00D2E:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00D30:  MOVLW  96
00D32:  MOVLB  1
00D34:  MOVWF  xF7
....................  
.................... 	config.modbus_address=38; 
00D36:  MOVLW  26
00D38:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00D3A:  MOVLW  03
00D3C:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00D3E:  MOVLW  02
00D40:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00D42:  MOVLW  50
00D44:  MOVWF  3A
.................... 	config.serial_number=9876; 
00D46:  MOVLW  26
00D48:  MOVWF  3C
00D4A:  MOVLW  94
00D4C:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00D4E:  CLRF   3E
00D50:  MOVLW  14
00D52:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00D54:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00D56:  MOVLW  02
00D58:  MOVWF  41
00D5A:  MOVLW  76
00D5C:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00D5E:  CLRF   43
00D60:  MOVLW  02
00D62:  MOVWF  42
.................... 	config.power_startup=0; 
00D64:  CLRF   44
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00D66:  CLRF   FEA
00D68:  MOVLW  4F
00D6A:  MOVWF  FE9
00D6C:  CLRF   00
00D6E:  CLRF   02
00D70:  MOVLW  48
00D72:  MOVWF  01
00D74:  MOVLB  0
00D76:  RCALL  08B2
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00D78:  CLRF   FEA
00D7A:  MOVLW  4F
00D7C:  MOVWF  FE9
00D7E:  MOVLW  00
00D80:  CALL   017C
00D84:  TBLRD*-
00D86:  TBLRD*+
00D88:  MOVF   FF5,W
00D8A:  MOVWF  FEE
00D8C:  IORLW  00
00D8E:  BNZ   0D86
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00D90:  CLRF   FEA
00D92:  MOVLW  55
00D94:  MOVWF  FE9
00D96:  MOVLW  00
00D98:  CALL   0194
00D9C:  TBLRD*-
00D9E:  TBLRD*+
00DA0:  MOVF   FF5,W
00DA2:  MOVWF  FEE
00DA4:  IORLW  00
00DA6:  BNZ   0D9E
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00DA8:  CLRF   FEA
00DAA:  MOVLW  5B
00DAC:  MOVWF  FE9
00DAE:  MOVLW  00
00DB0:  CALL   01AC
00DB4:  TBLRD*-
00DB6:  TBLRD*+
00DB8:  MOVF   FF5,W
00DBA:  MOVWF  FEE
00DBC:  IORLW  00
00DBE:  BNZ   0DB6
....................  
.................... 	strcpy(config.nmea0183_sentence[10],"$WIMDA"); 
00DC0:  CLRF   FEA
00DC2:  MOVLW  8B
00DC4:  MOVWF  FE9
00DC6:  MOVLW  00
00DC8:  CALL   01C4
00DCC:  TBLRD*-
00DCE:  TBLRD*+
00DD0:  MOVF   FF5,W
00DD2:  MOVWF  FEE
00DD4:  IORLW  00
00DD6:  BNZ   0DCE
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00DD8:  RCALL  0CDC
....................  
.................... } 
00DDA:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00DDC:  MOVLB  7
00DDE:  CLRF   xD8
00DE0:  MOVLW  36
00DE2:  MOVWF  xD7
00DE4:  CLRF   xDA
00DE6:  MOVLW  02
00DE8:  MOVWF  xD9
00DEA:  MOVFF  7D8,7DC
00DEE:  MOVFF  7D7,7DB
00DF2:  CLRF   xDE
00DF4:  MOVLW  61
00DF6:  MOVWF  xDD
00DF8:  MOVLB  0
00DFA:  BRA    0BA4
00DFC:  MOVFF  01,7D6
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00E00:  MOVFF  FF2,7D7
00E04:  BCF    FF2.6
00E06:  BCF    FF2.7
00E08:  CLRF   FAA
00E0A:  CLRF   FA9
00E0C:  BCF    FA6.6
00E0E:  BCF    FA6.7
00E10:  BSF    FA6.0
00E12:  MOVF   FA8,W
00E14:  MOVLB  7
00E16:  BTFSC  xD7.6
00E18:  BSF    FF2.6
00E1A:  BTFSC  xD7.7
00E1C:  BSF    FF2.7
00E1E:  SUBWF  xD6,W
00E20:  BZ    0E28
.................... 		write_default_param_file(); 
00E22:  MOVLB  0
00E24:  RCALL  0D30
00E26:  MOVLB  7
.................... 	} 
.................... } 
00E28:  MOVLB  0
00E2A:  GOTO   2CDC (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
01394:  BTFSS  FAC.1
01396:  BRA    1394
.................... } 
01398:  GOTO   13B2 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00E2E:  BTFSS  F9E.5
00E30:  BRA    0E36
.................... 		fgetc(STREAM_PI); 
00E32:  RCALL  071E
.................... 	} 
00E34:  BRA    0E2E
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00E36:  BSF    F9D.5
.................... } 
00E38:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00E3A:  RCALL  0E2E
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00E3C:  MOVLW  C6
00E3E:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00E40:  MOVLW  C0
00E42:  IORWF  FF2,F
.................... } 
00E44:  GOTO   2CEE (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003FC:  BCF    FF2.5
.................... 	if (enable) { 
003FE:  MOVLB  8
00400:  MOVF   xE7,F
00402:  BZ    040C
.................... 		set_timer0(0); 
00404:  CLRF   FD7
00406:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00408:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
0040A:  BSF    FF2.5
.................... 	} 
.................... } 
0040C:  MOVLB  0
0040E:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
00410:  MOVLB  6
00412:  MOVF   xC1,W
00414:  SUBLW  02
00416:  BNZ   042C
00418:  MOVF   xC2,F
0041A:  BNZ   042C
0041C:  MOVF   xC3,F
0041E:  BNZ   042C
00420:  BTFSC  xC0.0
00422:  BRA    042C
....................    { 
....................       modbus_rx.len-=2; 
00424:  MOVLW  02
00426:  SUBWF  xC5,F
....................       modbus_serial_new=TRUE; 
00428:  BSF    xC0.0
....................    } 
....................    else 
0042A:  BRA    042E
....................       modbus_serial_new=FALSE; 
0042C:  BCF    xC0.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0042E:  SETF   xC3
00430:  SETF   xC2
....................    modbus_serial_state=MODBUS_GETADDY; 
00432:  CLRF   xC1
....................    modbus_enable_timeout(FALSE); 
00434:  MOVLB  8
00436:  CLRF   xE7
00438:  MOVLB  0
0043A:  RCALL  03FC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0043C:  BCF    FF2.2
0043E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00734:  MOVLB  6
00736:  MOVF   xC3,W
00738:  MOVLB  8
0073A:  XORWF  xE7,W
0073C:  MOVWF  xE8
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0073E:  CLRF   03
00740:  MOVF   xE8,W
00742:  MOVLB  0
00744:  RCALL  01DC
00746:  MOVWF  01
00748:  MOVLB  6
0074A:  MOVF   xC2,W
0074C:  XORWF  01,W
0074E:  MOVWF  xC3
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00750:  CLRF   03
00752:  MOVLB  8
00754:  MOVF   xE8,W
00756:  MOVLB  0
00758:  RCALL  02EC
0075A:  MOVFF  FE8,6C2
.................... } 
0075E:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
0133A:  MOVLB  7
0133C:  MOVF   xE8,W
0133E:  MOVLB  0
01340:  RCALL  1332
01342:  CLRF   19
01344:  BTFSC  FF2.6
01346:  BSF    19.6
01348:  BCF    FF2.6
0134A:  BTFSC  FF2.7
0134C:  BSF    19.7
0134E:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
01350:  MOVFF  7E8,8E7
01354:  CALL   0734
01358:  BTFSC  19.6
0135A:  BSF    FF2.6
0135C:  BTFSC  19.7
0135E:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
01360:  CLRWDT
01362:  MOVLW  08
01364:  MOVWF  00
01366:  DECFSZ 00,F
01368:  BRA    1366
0136A:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
0136C:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
0136E:  MOVLB  6
01370:  SETF   xC3
01372:  SETF   xC2
....................    modbus_serial_new=FALSE; 
01374:  BCF    xC0.0
....................  
....................    RCV_OFF(); 
01376:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
01378:  CLRWDT
0137A:  MOVLW  3C
0137C:  MOVWF  00
0137E:  DECFSZ 00,F
01380:  BRA    137E
01382:  NOP   
....................  
....................    modbus_serial_putc(to); 
01384:  MOVFF  7E6,7E8
01388:  MOVLB  0
0138A:  RCALL  133A
....................    modbus_serial_putc(func); 
0138C:  MOVFF  7E7,7E8
01390:  RCALL  133A
.................... } 
01392:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
0139C:  MOVFF  6C3,7E7
....................    crc_low=modbus_serial_crc.b[0]; 
013A0:  MOVFF  6C2,7E6
....................  
....................    modbus_serial_putc(crc_high); 
013A4:  MOVFF  7E7,7E8
013A8:  RCALL  133A
....................    modbus_serial_putc(crc_low); 
013AA:  MOVFF  7E6,7E8
013AE:  RCALL  133A
....................  
....................    WAIT_FOR_HW_BUFFER(); 
013B0:  BRA    1394
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
013B2:  CLRWDT
013B4:  MOVLW  3C
013B6:  MOVWF  00
013B8:  DECFSZ 00,F
013BA:  BRA    13B8
013BC:  NOP   
....................  
....................  
....................    RCV_ON(); 
013BE:  RCALL  0E2E
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
013C0:  MOVLB  6
013C2:  SETF   xC3
013C4:  SETF   xC2
.................... } 
013C6:  MOVLB  0
013C8:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
011F6:  MOVLB  6
011F8:  BTFSC  xC0.0
011FA:  BRA    1204
....................       return FALSE; 
011FC:  MOVLW  00
011FE:  MOVWF  01
01200:  BRA    1216
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
01202:  BRA    1210
01204:  BTFSS  xC6.7
01206:  BRA    1210
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
01208:  MOVFF  6C8,6C7
....................       modbus_rx.len = 1; 
0120C:  MOVLW  01
0120E:  MOVWF  xC5
....................    } 
....................    modbus_serial_new=FALSE; 
01210:  BCF    xC0.0
....................    return TRUE; 
01212:  MOVLW  01
01214:  MOVWF  01
.................... } 
01216:  MOVLB  0
01218:  GOTO   25E4 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02550:  MOVFF  7DE,7E6
02554:  MOVLW  06
02556:  MOVLB  7
02558:  MOVWF  xE7
0255A:  MOVLB  0
0255C:  CALL   136E
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02560:  MOVFF  7E0,7E3
02564:  MOVFF  7E0,7E8
02568:  CALL   133A
....................    modbus_serial_putc(make8(reg_address,0)); 
0256C:  MOVFF  7DF,7E3
02570:  MOVFF  7DF,7E8
02574:  CALL   133A
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02578:  MOVFF  7E2,7E3
0257C:  MOVFF  7E2,7E8
02580:  CALL   133A
....................    modbus_serial_putc(make8(reg_value,0)); 
02584:  MOVFF  7E1,7E3
02588:  MOVFF  7E1,7E8
0258C:  CALL   133A
....................  
....................    modbus_serial_send_stop(); 
02590:  CALL   139C
.................... } 
02594:  GOTO   27C8 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02598:  MOVFF  7DC,7E6
0259C:  MOVLW  10
0259E:  MOVLB  7
025A0:  MOVWF  xE7
025A2:  MOVLB  0
025A4:  CALL   136E
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
025A8:  MOVFF  7DE,7E1
025AC:  MOVFF  7DE,7E8
025B0:  CALL   133A
....................    modbus_serial_putc(make8(start_address,0)); 
025B4:  MOVFF  7DD,7E1
025B8:  MOVFF  7DD,7E8
025BC:  CALL   133A
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
025C0:  MOVFF  7E0,7E1
025C4:  MOVFF  7E0,7E8
025C8:  CALL   133A
....................    modbus_serial_putc(make8(quantity,0)); 
025CC:  MOVFF  7DF,7E1
025D0:  MOVFF  7DF,7E8
025D4:  CALL   133A
....................  
....................    modbus_serial_send_stop(); 
025D8:  CALL   139C
.................... } 
025DC:  GOTO   288A (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
013CA:  MOVLB  7
013CC:  MOVF   xDD,W
013CE:  IORLW  80
013D0:  MOVWF  xE0
013D2:  MOVFF  7DE,7E1
013D6:  MOVFF  7DC,7E6
013DA:  MOVWF  xE7
013DC:  MOVLB  0
013DE:  RCALL  136E
....................    modbus_serial_putc(error); 
013E0:  MOVFF  7DF,7E8
013E4:  RCALL  133A
....................    modbus_serial_send_stop(); 
013E6:  RCALL  139C
.................... } 
013E8:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          53 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1013 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
014B0:  MOVLB  1
014B2:  CLRF   xCD
014B4:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
014B6:  CLRF   xCF
014B8:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
014BA:  CLRF   xD1
014BC:  CLRF   xD0
.................... } 
014BE:  MOVLB  0
014C0:  GOTO   1F50 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0144C:  BCF    FF2.6
0144E:  BCF    FF2.7
01450:  BTFSC  FF2.7
01452:  BRA    144E
....................  
.................... 	current.pulse_count[0]=0; 
01454:  CLRF   xAA
01456:  CLRF   xA9
.................... 	current.pulse_count[1]=0; 
01458:  CLRF   xAC
0145A:  CLRF   xAB
.................... 	current.pulse_count[2]=0; 
0145C:  CLRF   xAE
0145E:  CLRF   xAD
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
01460:  SETF   x9E
01462:  SETF   x9D
.................... 	current.pulse_min_period[1]=65535; 
01464:  SETF   xA0
01466:  SETF   x9F
.................... 	current.pulse_min_period[2]=65535; 
01468:  SETF   xA2
0146A:  SETF   xA1
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
0146C:  CLRF   xA4
0146E:  CLRF   xA3
.................... 	current.pulse_max_period[1]=0; 
01470:  CLRF   xA6
01472:  CLRF   xA5
.................... 	current.pulse_max_period[2]=0; 
01474:  CLRF   xA8
01476:  CLRF   xA7
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01478:  MOVLB  1
0147A:  CLRF   xD7
0147C:  CLRF   xD6
....................  
.................... 	enable_interrupts(GLOBAL); 
0147E:  MOVLW  C0
01480:  IORWF  FF2,F
.................... } 
01482:  MOVLB  0
01484:  GOTO   1F00 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
01488:  BCF    FF2.6
0148A:  BCF    FF2.7
0148C:  BTFSC  FF2.7
0148E:  BRA    148A
.................... 	current.pulse_sum[0]=0; 
01490:  CLRF   xB2
01492:  CLRF   xB1
01494:  CLRF   xB0
01496:  CLRF   xAF
.................... 	current.pulse_sum[1]=0; 
01498:  CLRF   xB6
0149A:  CLRF   xB5
0149C:  CLRF   xB4
0149E:  CLRF   xB3
.................... 	current.pulse_sum[2]=0; 
014A0:  CLRF   xBA
014A2:  CLRF   xB9
014A4:  CLRF   xB8
014A6:  CLRF   xB7
.................... 	enable_interrupts(GLOBAL); 
014A8:  MOVLW  C0
014AA:  IORWF  FF2,F
.................... } 
014AC:  GOTO   1F10 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
013EA:  BCF    FF2.6
013EC:  BCF    FF2.7
013EE:  BTFSC  FF2.7
013F0:  BRA    13EC
.................... 	l=current.pulse_sum[ch]; 
013F2:  MOVLB  8
013F4:  CLRF   xDB
013F6:  MOVFF  7EE,8DA
013FA:  CLRF   xDD
013FC:  MOVLW  04
013FE:  MOVWF  xDC
01400:  MOVLB  0
01402:  CALL   0890
01406:  MOVFF  02,03
0140A:  MOVF   01,W
0140C:  ADDLW  AF
0140E:  MOVWF  FE9
01410:  MOVLW  00
01412:  ADDWFC 02,W
01414:  MOVWF  FEA
01416:  MOVFF  FEF,00
0141A:  MOVFF  FEC,01
0141E:  MOVFF  FEC,02
01422:  MOVFF  FEC,03
01426:  MOVFF  03,7F2
0142A:  MOVFF  02,7F1
0142E:  MOVFF  01,7F0
01432:  MOVFF  00,7EF
.................... 	enable_interrupts(GLOBAL); 
01436:  MOVLW  C0
01438:  IORWF  FF2,F
....................  
.................... 	return l; 
0143A:  MOVFF  7EF,00
0143E:  MOVFF  7F0,01
01442:  MOVFF  7F1,02
01446:  MOVFF  7F2,03
.................... } 
0144A:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
014C4:  MOVLB  7
014C6:  MOVF   xE9,W
014C8:  SUBLW  06
014CA:  BC    1520
014CC:  XORLW  FF
014CE:  BNZ   14D6
014D0:  MOVF   xE8,W
014D2:  SUBLW  CF
014D4:  BC    1520
014D6:  MOVF   xE9,W
014D8:  SUBLW  09
014DA:  BNC   1520
014DC:  BNZ   14E4
014DE:  MOVF   xE8,W
014E0:  SUBLW  CF
014E2:  BNC   1520
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
014E4:  MOVLW  D0
014E6:  SUBWF  xE8,W
014E8:  MOVWF  xEE
014EA:  MOVLW  07
014EC:  SUBWFB xE9,W
014EE:  MOVWF  xEF
014F0:  MOVLW  02
014F2:  ADDWF  xEF,F
014F4:  MOVFF  FF2,7F0
014F8:  BCF    FF2.6
014FA:  BCF    FF2.7
014FC:  MOVFF  7EF,FAA
01500:  MOVFF  7EE,FA9
01504:  BCF    FA6.6
01506:  BCF    FA6.7
01508:  BSF    FA6.0
0150A:  MOVF   FA8,W
0150C:  BTFSC  xF0.6
0150E:  BSF    FF2.6
01510:  BTFSC  xF0.7
01512:  BSF    FF2.7
01514:  CLRF   03
01516:  MOVWF  01
01518:  MOVF   03,W
0151A:  MOVWF  02
0151C:  GOTO   20C4
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
01520:  MOVF   xE9,W
01522:  SUBLW  03
01524:  BC    15A4
01526:  XORLW  FF
01528:  BNZ   1530
0152A:  MOVF   xE8,W
0152C:  SUBLW  4B
0152E:  BC    15A4
01530:  MOVF   xE9,W
01532:  SUBLW  04
01534:  BNC   15A4
01536:  BNZ   153E
01538:  MOVF   xE8,W
0153A:  SUBLW  93
0153C:  BNC   15A4
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0153E:  MOVLW  4C
01540:  SUBWF  xE8,W
01542:  MOVWF  xEA
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01544:  MOVFF  7EA,7EE
01548:  MOVLW  06
0154A:  MOVWF  xEF
0154C:  MOVLB  0
0154E:  CALL   0AF8
01552:  MOVFF  00,7EB
.................... 		n = n / 6; /* number of sentence */ 
01556:  MOVFF  7EA,7EE
0155A:  MOVLW  06
0155C:  MOVLB  7
0155E:  MOVWF  xEF
01560:  MOVLB  0
01562:  CALL   0AF8
01566:  MOVFF  01,7EA
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
0156A:  MOVLB  7
0156C:  MOVF   xEA,W
0156E:  MULLW  06
01570:  MOVF   FF3,W
01572:  CLRF   03
01574:  ADDLW  19
01576:  MOVWF  xEE
01578:  MOVLW  00
0157A:  ADDWFC 03,W
0157C:  MOVWF  xEF
0157E:  CLRF   03
01580:  MOVF   xEB,W
01582:  ADDWF  xEE,W
01584:  MOVWF  01
01586:  MOVF   xEF,W
01588:  ADDWFC 03,F
0158A:  MOVF   01,W
0158C:  ADDLW  36
0158E:  MOVWF  FE9
01590:  MOVLW  00
01592:  ADDWFC 03,W
01594:  MOVWF  FEA
01596:  MOVF   FEF,W
01598:  CLRF   03
0159A:  MOVWF  01
0159C:  MOVFF  03,02
015A0:  GOTO   20C4
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
015A4:  MOVF   xE9,W
015A6:  SUBLW  12
015A8:  BC    15EA
015AA:  XORLW  FF
015AC:  BNZ   15B4
015AE:  MOVF   xE8,W
015B0:  SUBLW  87
015B2:  BC    15EA
015B4:  MOVF   xE9,W
015B6:  SUBLW  17
015B8:  BNC   15EA
015BA:  BNZ   15C2
015BC:  MOVF   xE8,W
015BE:  SUBLW  47
015C0:  BNC   15EA
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
015C2:  MOVLW  88
015C4:  SUBWF  xE8,F
015C6:  MOVLW  13
015C8:  SUBWFB xE9,F
....................  
....................  		p  = nmea.sentence[0]; 
015CA:  MOVLW  03
015CC:  MOVWF  xED
015CE:  CLRF   xEC
.................... 		return (int16) p[addr]; 
015D0:  MOVF   xEC,W
015D2:  ADDWF  xE8,W
015D4:  MOVWF  FE9
015D6:  MOVF   xED,W
015D8:  ADDWFC xE9,W
015DA:  MOVWF  FEA
015DC:  MOVF   FEF,W
015DE:  CLRF   03
015E0:  MOVWF  01
015E2:  MOVFF  03,02
015E6:  GOTO   20C4
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
015EA:  MOVF   xE9,W
015EC:  SUBLW  16
015EE:  BC    1658
015F0:  XORLW  FF
015F2:  BNZ   15FA
015F4:  MOVF   xE8,W
015F6:  SUBLW  6F
015F8:  BC    1658
015FA:  MOVF   xE9,W
015FC:  SUBLW  19
015FE:  BNC   1658
01600:  BNZ   1608
01602:  MOVF   xE8,W
01604:  SUBLW  4F
01606:  BNC   1658
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01608:  MOVLW  70
0160A:  SUBWF  xE8,F
0160C:  MOVLW  17
0160E:  SUBWFB xE9,F
.................... 		addr = addr * 2; 
01610:  BCF    FD8.0
01612:  RLCF   xE8,F
01614:  RLCF   xE9,F
....................  
....................  		p  = nmea.sentence[0]; 
01616:  MOVLW  03
01618:  MOVWF  xED
0161A:  CLRF   xEC
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0161C:  MOVF   xEC,W
0161E:  ADDWF  xE8,W
01620:  MOVWF  FE9
01622:  MOVF   xED,W
01624:  ADDWFC xE9,W
01626:  MOVWF  FEA
01628:  MOVFF  FEF,7EE
0162C:  MOVLW  01
0162E:  ADDWF  xE8,W
01630:  MOVWF  xEF
01632:  MOVLW  00
01634:  ADDWFC xE9,W
01636:  MOVWF  xF0
01638:  MOVF   xEC,W
0163A:  ADDWF  xEF,W
0163C:  MOVWF  FE9
0163E:  MOVF   xED,W
01640:  ADDWFC xF0,W
01642:  MOVWF  FEA
01644:  MOVFF  FEF,7F1
01648:  MOVFF  7EE,03
0164C:  MOVFF  7F1,01
01650:  MOVFF  7EE,02
01654:  GOTO   20C4
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
01658:  MOVF   xE8,W
0165A:  MOVWF  00
0165C:  MOVF   xE9,W
0165E:  MOVWF  03
01660:  MOVF   03,W
01662:  BNZ   166E
01664:  MOVF   00,F
01666:  MOVLB  0
01668:  BTFSC  FD8.2
0166A:  BRA    1ABC
0166C:  MOVLB  7
0166E:  MOVF   03,W
01670:  BNZ   167E
01672:  MOVLW  01
01674:  SUBWF  00,W
01676:  MOVLB  0
01678:  BTFSC  FD8.2
0167A:  BRA    1ACA
0167C:  MOVLB  7
0167E:  MOVF   03,W
01680:  BNZ   168E
01682:  MOVLW  02
01684:  SUBWF  00,W
01686:  MOVLB  0
01688:  BTFSC  FD8.2
0168A:  BRA    1AD8
0168C:  MOVLB  7
0168E:  MOVF   03,W
01690:  BNZ   169E
01692:  MOVLW  03
01694:  SUBWF  00,W
01696:  MOVLB  0
01698:  BTFSC  FD8.2
0169A:  BRA    1AE6
0169C:  MOVLB  7
0169E:  MOVF   03,W
016A0:  BNZ   16AE
016A2:  MOVLW  04
016A4:  SUBWF  00,W
016A6:  MOVLB  0
016A8:  BTFSC  FD8.2
016AA:  BRA    1AF4
016AC:  MOVLB  7
016AE:  MOVF   03,W
016B0:  BNZ   16BE
016B2:  MOVLW  05
016B4:  SUBWF  00,W
016B6:  MOVLB  0
016B8:  BTFSC  FD8.2
016BA:  BRA    1B1A
016BC:  MOVLB  7
016BE:  MOVF   03,W
016C0:  BNZ   16CE
016C2:  MOVLW  06
016C4:  SUBWF  00,W
016C6:  MOVLB  0
016C8:  BTFSC  FD8.2
016CA:  BRA    1B28
016CC:  MOVLB  7
016CE:  MOVF   03,W
016D0:  BNZ   16DE
016D2:  MOVLW  07
016D4:  SUBWF  00,W
016D6:  MOVLB  0
016D8:  BTFSC  FD8.2
016DA:  BRA    1B36
016DC:  MOVLB  7
016DE:  MOVF   03,W
016E0:  BNZ   16EE
016E2:  MOVLW  08
016E4:  SUBWF  00,W
016E6:  MOVLB  0
016E8:  BTFSC  FD8.2
016EA:  BRA    1B44
016EC:  MOVLB  7
016EE:  MOVF   03,W
016F0:  BNZ   16FE
016F2:  MOVLW  09
016F4:  SUBWF  00,W
016F6:  MOVLB  0
016F8:  BTFSC  FD8.2
016FA:  BRA    1B52
016FC:  MOVLB  7
016FE:  MOVF   03,W
01700:  BNZ   170E
01702:  MOVLW  0A
01704:  SUBWF  00,W
01706:  MOVLB  0
01708:  BTFSC  FD8.2
0170A:  BRA    1B60
0170C:  MOVLB  7
0170E:  MOVF   03,W
01710:  BNZ   171E
01712:  MOVLW  0B
01714:  SUBWF  00,W
01716:  MOVLB  0
01718:  BTFSC  FD8.2
0171A:  BRA    1B88
0171C:  MOVLB  7
0171E:  MOVF   03,W
01720:  BNZ   172E
01722:  MOVLW  0C
01724:  SUBWF  00,W
01726:  MOVLB  0
01728:  BTFSC  FD8.2
0172A:  BRA    1B96
0172C:  MOVLB  7
0172E:  MOVF   03,W
01730:  BNZ   173E
01732:  MOVLW  0D
01734:  SUBWF  00,W
01736:  MOVLB  0
01738:  BTFSC  FD8.2
0173A:  BRA    1BA4
0173C:  MOVLB  7
0173E:  MOVF   03,W
01740:  BNZ   174E
01742:  MOVLW  0E
01744:  SUBWF  00,W
01746:  MOVLB  0
01748:  BTFSC  FD8.2
0174A:  BRA    1BB2
0174C:  MOVLB  7
0174E:  MOVF   03,W
01750:  BNZ   175E
01752:  MOVLW  0F
01754:  SUBWF  00,W
01756:  MOVLB  0
01758:  BTFSC  FD8.2
0175A:  BRA    1BC0
0175C:  MOVLB  7
0175E:  MOVF   03,W
01760:  BNZ   176E
01762:  MOVLW  10
01764:  SUBWF  00,W
01766:  MOVLB  0
01768:  BTFSC  FD8.2
0176A:  BRA    1BCE
0176C:  MOVLB  7
0176E:  MOVF   03,W
01770:  BNZ   177E
01772:  MOVLW  11
01774:  SUBWF  00,W
01776:  MOVLB  0
01778:  BTFSC  FD8.2
0177A:  BRA    1BF6
0177C:  MOVLB  7
0177E:  MOVF   03,W
01780:  BNZ   178E
01782:  MOVLW  12
01784:  SUBWF  00,W
01786:  MOVLB  0
01788:  BTFSC  FD8.2
0178A:  BRA    1C04
0178C:  MOVLB  7
0178E:  MOVF   03,W
01790:  BNZ   179E
01792:  MOVLW  13
01794:  SUBWF  00,W
01796:  MOVLB  0
01798:  BTFSC  FD8.2
0179A:  BRA    1C32
0179C:  MOVLB  7
0179E:  MOVF   03,W
017A0:  BNZ   17AE
017A2:  MOVLW  14
017A4:  SUBWF  00,W
017A6:  MOVLB  0
017A8:  BTFSC  FD8.2
017AA:  BRA    1C4A
017AC:  MOVLB  7
017AE:  MOVF   03,W
017B0:  BNZ   17BE
017B2:  MOVLW  15
017B4:  SUBWF  00,W
017B6:  MOVLB  0
017B8:  BTFSC  FD8.2
017BA:  BRA    1C58
017BC:  MOVLB  7
017BE:  MOVF   03,W
017C0:  BNZ   17CE
017C2:  MOVLW  16
017C4:  SUBWF  00,W
017C6:  MOVLB  0
017C8:  BTFSC  FD8.2
017CA:  BRA    1C86
017CC:  MOVLB  7
017CE:  MOVF   03,W
017D0:  BNZ   17DE
017D2:  MOVLW  17
017D4:  SUBWF  00,W
017D6:  MOVLB  0
017D8:  BTFSC  FD8.2
017DA:  BRA    1CA0
017DC:  MOVLB  7
017DE:  MOVF   03,W
017E0:  BNZ   17EE
017E2:  MOVLW  18
017E4:  SUBWF  00,W
017E6:  MOVLB  0
017E8:  BTFSC  FD8.2
017EA:  BRA    1CAE
017EC:  MOVLB  7
017EE:  MOVF   03,W
017F0:  BNZ   17FE
017F2:  MOVLW  19
017F4:  SUBWF  00,W
017F6:  MOVLB  0
017F8:  BTFSC  FD8.2
017FA:  BRA    1CDC
017FC:  MOVLB  7
017FE:  MOVF   03,W
01800:  BNZ   180E
01802:  MOVLW  1A
01804:  SUBWF  00,W
01806:  MOVLB  0
01808:  BTFSC  FD8.2
0180A:  BRA    1CF6
0180C:  MOVLB  7
0180E:  MOVF   03,W
01810:  BNZ   181E
01812:  MOVLW  1B
01814:  SUBWF  00,W
01816:  MOVLB  0
01818:  BTFSC  FD8.2
0181A:  BRA    1D04
0181C:  MOVLB  7
0181E:  MOVF   03,W
01820:  BNZ   182E
01822:  MOVLW  1C
01824:  SUBWF  00,W
01826:  MOVLB  0
01828:  BTFSC  FD8.2
0182A:  BRA    1D32
0182C:  MOVLB  7
0182E:  MOVF   03,W
01830:  BNZ   183E
01832:  MOVLW  1D
01834:  SUBWF  00,W
01836:  MOVLB  0
01838:  BTFSC  FD8.2
0183A:  BRA    1D4C
0183C:  MOVLB  7
0183E:  MOVF   03,W
01840:  BNZ   184E
01842:  MOVLW  1E
01844:  SUBWF  00,W
01846:  MOVLB  0
01848:  BTFSC  FD8.2
0184A:  BRA    1D5A
0184C:  MOVLB  7
0184E:  MOVF   03,W
01850:  BNZ   185E
01852:  MOVLW  1F
01854:  SUBWF  00,W
01856:  MOVLB  0
01858:  BTFSC  FD8.2
0185A:  BRA    1D88
0185C:  MOVLB  7
0185E:  MOVF   03,W
01860:  BNZ   186E
01862:  MOVLW  20
01864:  SUBWF  00,W
01866:  MOVLB  0
01868:  BTFSC  FD8.2
0186A:  BRA    1DA2
0186C:  MOVLB  7
0186E:  MOVF   03,W
01870:  BNZ   187E
01872:  MOVLW  21
01874:  SUBWF  00,W
01876:  MOVLB  0
01878:  BTFSC  FD8.2
0187A:  BRA    1DB0
0187C:  MOVLB  7
0187E:  MOVF   03,W
01880:  BNZ   188E
01882:  MOVLW  22
01884:  SUBWF  00,W
01886:  MOVLB  0
01888:  BTFSC  FD8.2
0188A:  BRA    1DDE
0188C:  MOVLB  7
0188E:  MOVF   03,W
01890:  BNZ   189E
01892:  MOVLW  23
01894:  SUBWF  00,W
01896:  MOVLB  0
01898:  BTFSC  FD8.2
0189A:  BRA    1DF8
0189C:  MOVLB  7
0189E:  MOVF   03,W
018A0:  BNZ   18AE
018A2:  MOVLW  24
018A4:  SUBWF  00,W
018A6:  MOVLB  0
018A8:  BTFSC  FD8.2
018AA:  BRA    1E06
018AC:  MOVLB  7
018AE:  MOVF   03,W
018B0:  BNZ   18BE
018B2:  MOVLW  25
018B4:  SUBWF  00,W
018B6:  MOVLB  0
018B8:  BTFSC  FD8.2
018BA:  BRA    1E34
018BC:  MOVLB  7
018BE:  MOVF   03,W
018C0:  BNZ   18CE
018C2:  MOVLW  26
018C4:  SUBWF  00,W
018C6:  MOVLB  0
018C8:  BTFSC  FD8.2
018CA:  BRA    1E4E
018CC:  MOVLB  7
018CE:  MOVF   03,W
018D0:  BNZ   18DE
018D2:  MOVLW  27
018D4:  SUBWF  00,W
018D6:  MOVLB  0
018D8:  BTFSC  FD8.2
018DA:  BRA    1E5C
018DC:  MOVLB  7
018DE:  MOVF   03,W
018E0:  BNZ   18EE
018E2:  MOVLW  28
018E4:  SUBWF  00,W
018E6:  MOVLB  0
018E8:  BTFSC  FD8.2
018EA:  BRA    1E8A
018EC:  MOVLB  7
018EE:  MOVF   03,W
018F0:  BNZ   18FE
018F2:  MOVLW  29
018F4:  SUBWF  00,W
018F6:  MOVLB  0
018F8:  BTFSC  FD8.2
018FA:  BRA    1EA4
018FC:  MOVLB  7
018FE:  MOVF   03,W
01900:  BNZ   190E
01902:  MOVLW  2A
01904:  SUBWF  00,W
01906:  MOVLB  0
01908:  BTFSC  FD8.2
0190A:  BRA    1EB2
0190C:  MOVLB  7
0190E:  MOVF   03,W
01910:  BNZ   191E
01912:  MOVLW  2B
01914:  SUBWF  00,W
01916:  MOVLB  0
01918:  BTFSC  FD8.2
0191A:  BRA    1ECC
0191C:  MOVLB  7
0191E:  MOVF   03,W
01920:  BNZ   192E
01922:  MOVLW  2C
01924:  SUBWF  00,W
01926:  MOVLB  0
01928:  BTFSC  FD8.2
0192A:  BRA    1EDC
0192C:  MOVLB  7
0192E:  MOVF   03,W
01930:  BNZ   193E
01932:  MOVLW  2D
01934:  SUBWF  00,W
01936:  MOVLB  0
01938:  BTFSC  FD8.2
0193A:  BRA    1EEC
0193C:  MOVLB  7
0193E:  MOVF   03,W
01940:  BNZ   194E
01942:  MOVLW  2E
01944:  SUBWF  00,W
01946:  MOVLB  0
01948:  BTFSC  FD8.2
0194A:  BRA    1EFC
0194C:  MOVLB  7
0194E:  MOVF   03,W
01950:  BNZ   195E
01952:  MOVLW  2F
01954:  SUBWF  00,W
01956:  MOVLB  0
01958:  BTFSC  FD8.2
0195A:  BRA    1F0C
0195C:  MOVLB  7
0195E:  MOVF   03,W
01960:  BNZ   196E
01962:  MOVLW  30
01964:  SUBWF  00,W
01966:  MOVLB  0
01968:  BTFSC  FD8.2
0196A:  BRA    1F1C
0196C:  MOVLB  7
0196E:  MOVF   03,W
01970:  BNZ   197E
01972:  MOVLW  31
01974:  SUBWF  00,W
01976:  MOVLB  0
01978:  BTFSC  FD8.2
0197A:  BRA    1F2C
0197C:  MOVLB  7
0197E:  MOVF   03,W
01980:  BNZ   198E
01982:  MOVLW  32
01984:  SUBWF  00,W
01986:  MOVLB  0
01988:  BTFSC  FD8.2
0198A:  BRA    1F3C
0198C:  MOVLB  7
0198E:  MOVF   03,W
01990:  BNZ   199E
01992:  MOVLW  33
01994:  SUBWF  00,W
01996:  MOVLB  0
01998:  BTFSC  FD8.2
0199A:  BRA    1F4C
0199C:  MOVLB  7
0199E:  MOVF   03,W
019A0:  BNZ   19AE
019A2:  MOVLW  34
019A4:  SUBWF  00,W
019A6:  MOVLB  0
019A8:  BTFSC  FD8.2
019AA:  BRA    1F5C
019AC:  MOVLB  7
019AE:  MOVF   03,W
019B0:  BNZ   19BE
019B2:  MOVLW  35
019B4:  SUBWF  00,W
019B6:  MOVLB  0
019B8:  BTFSC  FD8.2
019BA:  BRA    1F6C
019BC:  MOVLB  7
019BE:  MOVLW  03
019C0:  SUBWF  03,W
019C2:  BNZ   19D0
019C4:  MOVLW  E8
019C6:  SUBWF  00,W
019C8:  MOVLB  0
019CA:  BTFSC  FD8.2
019CC:  BRA    1F7C
019CE:  MOVLB  7
019D0:  MOVLW  03
019D2:  SUBWF  03,W
019D4:  BNZ   19E2
019D6:  MOVLW  E9
019D8:  SUBWF  00,W
019DA:  MOVLB  0
019DC:  BTFSC  FD8.2
019DE:  BRA    1F8C
019E0:  MOVLB  7
019E2:  MOVLW  03
019E4:  SUBWF  03,W
019E6:  BNZ   19F4
019E8:  MOVLW  EA
019EA:  SUBWF  00,W
019EC:  MOVLB  0
019EE:  BTFSC  FD8.2
019F0:  BRA    1F9A
019F2:  MOVLB  7
019F4:  MOVLW  03
019F6:  SUBWF  03,W
019F8:  BNZ   1A06
019FA:  MOVLW  EB
019FC:  SUBWF  00,W
019FE:  MOVLB  0
01A00:  BTFSC  FD8.2
01A02:  BRA    1FA8
01A04:  MOVLB  7
01A06:  MOVLW  03
01A08:  SUBWF  03,W
01A0A:  BNZ   1A18
01A0C:  MOVLW  EC
01A0E:  SUBWF  00,W
01A10:  MOVLB  0
01A12:  BTFSC  FD8.2
01A14:  BRA    1FB6
01A16:  MOVLB  7
01A18:  MOVLW  03
01A1A:  SUBWF  03,W
01A1C:  BNZ   1A2A
01A1E:  MOVLW  ED
01A20:  SUBWF  00,W
01A22:  MOVLB  0
01A24:  BTFSC  FD8.2
01A26:  BRA    1FC4
01A28:  MOVLB  7
01A2A:  MOVLW  03
01A2C:  SUBWF  03,W
01A2E:  BNZ   1A3C
01A30:  MOVLW  EE
01A32:  SUBWF  00,W
01A34:  MOVLB  0
01A36:  BTFSC  FD8.2
01A38:  BRA    1FD2
01A3A:  MOVLB  7
01A3C:  MOVLW  03
01A3E:  SUBWF  03,W
01A40:  BNZ   1A4E
01A42:  MOVLW  EF
01A44:  SUBWF  00,W
01A46:  MOVLB  0
01A48:  BTFSC  FD8.2
01A4A:  BRA    1FE2
01A4C:  MOVLB  7
01A4E:  MOVLW  03
01A50:  SUBWF  03,W
01A52:  BNZ   1A60
01A54:  MOVLW  F0
01A56:  SUBWF  00,W
01A58:  MOVLB  0
01A5A:  BTFSC  FD8.2
01A5C:  BRA    1FF0
01A5E:  MOVLB  7
01A60:  MOVLW  03
01A62:  SUBWF  03,W
01A64:  BNZ   1A72
01A66:  MOVLW  F1
01A68:  SUBWF  00,W
01A6A:  MOVLB  0
01A6C:  BTFSC  FD8.2
01A6E:  BRA    2000
01A70:  MOVLB  7
01A72:  MOVLW  03
01A74:  SUBWF  03,W
01A76:  BNZ   1A84
01A78:  MOVLW  F2
01A7A:  SUBWF  00,W
01A7C:  MOVLB  0
01A7E:  BTFSC  FD8.2
01A80:  BRA    200E
01A82:  MOVLB  7
01A84:  MOVLW  03
01A86:  SUBWF  03,W
01A88:  BNZ   1A96
01A8A:  MOVLW  F3
01A8C:  SUBWF  00,W
01A8E:  MOVLB  0
01A90:  BTFSC  FD8.2
01A92:  BRA    201C
01A94:  MOVLB  7
01A96:  MOVLW  03
01A98:  SUBWF  03,W
01A9A:  BNZ   1AA8
01A9C:  MOVLW  F4
01A9E:  SUBWF  00,W
01AA0:  MOVLB  0
01AA2:  BTFSC  FD8.2
01AA4:  BRA    202C
01AA6:  MOVLB  7
01AA8:  MOVLW  03
01AAA:  SUBWF  03,W
01AAC:  BNZ   1ABA
01AAE:  MOVLW  F5
01AB0:  SUBWF  00,W
01AB2:  MOVLB  0
01AB4:  BTFSC  FD8.2
01AB6:  BRA    203C
01AB8:  MOVLB  7
01ABA:  BRA    20BC
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01ABC:  MOVFF  A9,01
01AC0:  MOVFF  AA,02
01AC4:  MOVLB  7
01AC6:  BRA    20C4
01AC8:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01ACA:  MOVF   x97,W
01ACC:  MOVWF  01
01ACE:  MOVF   x98,W
01AD0:  MOVWF  02
01AD2:  MOVLB  7
01AD4:  BRA    20C4
01AD6:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01AD8:  MOVF   x9D,W
01ADA:  MOVWF  01
01ADC:  MOVF   x9E,W
01ADE:  MOVWF  02
01AE0:  MOVLB  7
01AE2:  BRA    20C4
01AE4:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01AE6:  MOVF   xA3,W
01AE8:  MOVWF  01
01AEA:  MOVF   xA4,W
01AEC:  MOVWF  02
01AEE:  MOVLB  7
01AF0:  BRA    20C4
01AF2:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01AF4:  MOVLB  7
01AF6:  CLRF   xEE
01AF8:  MOVLB  0
01AFA:  RCALL  13EA
01AFC:  MOVFF  03,7CA
01B00:  MOVFF  02,7C9
01B04:  MOVFF  01,7C8
01B08:  MOVFF  00,7C7
01B0C:  MOVLB  7
01B0E:  MOVF   xC7,W
01B10:  MOVWF  01
01B12:  MOVF   xC8,W
01B14:  MOVWF  02
01B16:  BRA    20C4
01B18:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01B1A:  MOVLB  7
01B1C:  MOVF   xC9,W
01B1E:  MOVWF  01
01B20:  MOVF   xCA,W
01B22:  MOVWF  02
01B24:  BRA    20C4
01B26:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01B28:  MOVF   xAB,W
01B2A:  MOVWF  01
01B2C:  MOVF   xAC,W
01B2E:  MOVWF  02
01B30:  MOVLB  7
01B32:  BRA    20C4
01B34:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01B36:  MOVF   x99,W
01B38:  MOVWF  01
01B3A:  MOVF   x9A,W
01B3C:  MOVWF  02
01B3E:  MOVLB  7
01B40:  BRA    20C4
01B42:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01B44:  MOVF   x9F,W
01B46:  MOVWF  01
01B48:  MOVF   xA0,W
01B4A:  MOVWF  02
01B4C:  MOVLB  7
01B4E:  BRA    20C4
01B50:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01B52:  MOVF   xA5,W
01B54:  MOVWF  01
01B56:  MOVF   xA6,W
01B58:  MOVWF  02
01B5A:  MOVLB  7
01B5C:  BRA    20C4
01B5E:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01B60:  MOVLW  01
01B62:  MOVLB  7
01B64:  MOVWF  xEE
01B66:  MOVLB  0
01B68:  RCALL  13EA
01B6A:  MOVFF  03,7CA
01B6E:  MOVFF  02,7C9
01B72:  MOVFF  01,7C8
01B76:  MOVFF  00,7C7
01B7A:  MOVLB  7
01B7C:  MOVF   xC7,W
01B7E:  MOVWF  01
01B80:  MOVF   xC8,W
01B82:  MOVWF  02
01B84:  BRA    20C4
01B86:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01B88:  MOVLB  7
01B8A:  MOVF   xC9,W
01B8C:  MOVWF  01
01B8E:  MOVF   xCA,W
01B90:  MOVWF  02
01B92:  BRA    20C4
01B94:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01B96:  MOVF   xAD,W
01B98:  MOVWF  01
01B9A:  MOVF   xAE,W
01B9C:  MOVWF  02
01B9E:  MOVLB  7
01BA0:  BRA    20C4
01BA2:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01BA4:  MOVF   x9B,W
01BA6:  MOVWF  01
01BA8:  MOVF   x9C,W
01BAA:  MOVWF  02
01BAC:  MOVLB  7
01BAE:  BRA    20C4
01BB0:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01BB2:  MOVF   xA1,W
01BB4:  MOVWF  01
01BB6:  MOVF   xA2,W
01BB8:  MOVWF  02
01BBA:  MOVLB  7
01BBC:  BRA    20C4
01BBE:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01BC0:  MOVF   xA7,W
01BC2:  MOVWF  01
01BC4:  MOVF   xA8,W
01BC6:  MOVWF  02
01BC8:  MOVLB  7
01BCA:  BRA    20C4
01BCC:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01BCE:  MOVLW  02
01BD0:  MOVLB  7
01BD2:  MOVWF  xEE
01BD4:  MOVLB  0
01BD6:  RCALL  13EA
01BD8:  MOVFF  03,7CA
01BDC:  MOVFF  02,7C9
01BE0:  MOVFF  01,7C8
01BE4:  MOVFF  00,7C7
01BE8:  MOVLB  7
01BEA:  MOVF   xC7,W
01BEC:  MOVWF  01
01BEE:  MOVF   xC8,W
01BF0:  MOVWF  02
01BF2:  BRA    20C4
01BF4:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01BF6:  MOVLB  7
01BF8:  MOVF   xC9,W
01BFA:  MOVWF  01
01BFC:  MOVF   xCA,W
01BFE:  MOVWF  02
01C00:  BRA    20C4
01C02:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01C04:  CLRF   03
01C06:  MOVLB  1
01C08:  MOVF   xCB,W
01C0A:  MOVWF  02
01C0C:  BCF    FD8.0
01C0E:  RLCF   02,F
01C10:  RLCF   03,F
01C12:  MOVF   02,W
01C14:  ADDLW  CB
01C16:  MOVWF  FE9
01C18:  MOVLW  00
01C1A:  ADDWFC 03,W
01C1C:  MOVWF  FEA
01C1E:  MOVFF  FEC,03
01C22:  MOVF   FED,F
01C24:  MOVF   FEF,W
01C26:  MOVWF  01
01C28:  MOVF   03,W
01C2A:  MOVWF  02
01C2C:  MOVLB  7
01C2E:  BRA    20C4
01C30:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01C32:  MOVLB  7
01C34:  CLRF   xEE
01C36:  MOVLB  0
01C38:  CALL   0FF0
01C3C:  MOVF   01,W
01C3E:  MOVWF  01
01C40:  MOVF   02,W
01C42:  MOVWF  02
01C44:  MOVLB  7
01C46:  BRA    20C4
01C48:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01C4A:  MOVF   xBB,W
01C4C:  MOVWF  01
01C4E:  MOVF   xBC,W
01C50:  MOVWF  02
01C52:  MOVLB  7
01C54:  BRA    20C4
01C56:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01C58:  CLRF   03
01C5A:  MOVLB  1
01C5C:  MOVF   xCB,W
01C5E:  MOVWF  02
01C60:  BCF    FD8.0
01C62:  RLCF   02,F
01C64:  RLCF   03,F
01C66:  MOVF   02,W
01C68:  ADDLW  EB
01C6A:  MOVWF  FE9
01C6C:  MOVLW  00
01C6E:  ADDWFC 03,W
01C70:  MOVWF  FEA
01C72:  MOVFF  FEC,03
01C76:  MOVF   FED,F
01C78:  MOVF   FEF,W
01C7A:  MOVWF  01
01C7C:  MOVF   03,W
01C7E:  MOVWF  02
01C80:  MOVLB  7
01C82:  BRA    20C4
01C84:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01C86:  MOVLW  01
01C88:  MOVLB  7
01C8A:  MOVWF  xEE
01C8C:  MOVLB  0
01C8E:  CALL   0FF0
01C92:  MOVF   01,W
01C94:  MOVWF  01
01C96:  MOVF   02,W
01C98:  MOVWF  02
01C9A:  MOVLB  7
01C9C:  BRA    20C4
01C9E:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01CA0:  MOVF   xBD,W
01CA2:  MOVWF  01
01CA4:  MOVF   xBE,W
01CA6:  MOVWF  02
01CA8:  MOVLB  7
01CAA:  BRA    20C4
01CAC:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01CAE:  CLRF   03
01CB0:  MOVLB  1
01CB2:  MOVF   xCB,W
01CB4:  MOVWF  02
01CB6:  BCF    FD8.0
01CB8:  RLCF   02,F
01CBA:  RLCF   03,F
01CBC:  MOVF   02,W
01CBE:  ADDLW  0B
01CC0:  MOVWF  FE9
01CC2:  MOVLW  01
01CC4:  ADDWFC 03,W
01CC6:  MOVWF  FEA
01CC8:  MOVFF  FEC,03
01CCC:  MOVF   FED,F
01CCE:  MOVF   FEF,W
01CD0:  MOVWF  01
01CD2:  MOVF   03,W
01CD4:  MOVWF  02
01CD6:  MOVLB  7
01CD8:  BRA    20C4
01CDA:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01CDC:  MOVLW  02
01CDE:  MOVLB  7
01CE0:  MOVWF  xEE
01CE2:  MOVLB  0
01CE4:  CALL   0FF0
01CE8:  MOVF   01,W
01CEA:  MOVWF  01
01CEC:  MOVF   02,W
01CEE:  MOVWF  02
01CF0:  MOVLB  7
01CF2:  BRA    20C4
01CF4:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01CF6:  MOVF   xBF,W
01CF8:  MOVWF  01
01CFA:  MOVF   xC0,W
01CFC:  MOVWF  02
01CFE:  MOVLB  7
01D00:  BRA    20C4
01D02:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01D04:  CLRF   03
01D06:  MOVLB  1
01D08:  MOVF   xCB,W
01D0A:  MOVWF  02
01D0C:  BCF    FD8.0
01D0E:  RLCF   02,F
01D10:  RLCF   03,F
01D12:  MOVF   02,W
01D14:  ADDLW  2B
01D16:  MOVWF  FE9
01D18:  MOVLW  01
01D1A:  ADDWFC 03,W
01D1C:  MOVWF  FEA
01D1E:  MOVFF  FEC,03
01D22:  MOVF   FED,F
01D24:  MOVF   FEF,W
01D26:  MOVWF  01
01D28:  MOVF   03,W
01D2A:  MOVWF  02
01D2C:  MOVLB  7
01D2E:  BRA    20C4
01D30:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01D32:  MOVLW  03
01D34:  MOVLB  7
01D36:  MOVWF  xEE
01D38:  MOVLB  0
01D3A:  CALL   0FF0
01D3E:  MOVF   01,W
01D40:  MOVWF  01
01D42:  MOVF   02,W
01D44:  MOVWF  02
01D46:  MOVLB  7
01D48:  BRA    20C4
01D4A:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01D4C:  MOVF   xC1,W
01D4E:  MOVWF  01
01D50:  MOVF   xC2,W
01D52:  MOVWF  02
01D54:  MOVLB  7
01D56:  BRA    20C4
01D58:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01D5A:  CLRF   03
01D5C:  MOVLB  1
01D5E:  MOVF   xCB,W
01D60:  MOVWF  02
01D62:  BCF    FD8.0
01D64:  RLCF   02,F
01D66:  RLCF   03,F
01D68:  MOVF   02,W
01D6A:  ADDLW  4B
01D6C:  MOVWF  FE9
01D6E:  MOVLW  01
01D70:  ADDWFC 03,W
01D72:  MOVWF  FEA
01D74:  MOVFF  FEC,03
01D78:  MOVF   FED,F
01D7A:  MOVF   FEF,W
01D7C:  MOVWF  01
01D7E:  MOVF   03,W
01D80:  MOVWF  02
01D82:  MOVLB  7
01D84:  BRA    20C4
01D86:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01D88:  MOVLW  04
01D8A:  MOVLB  7
01D8C:  MOVWF  xEE
01D8E:  MOVLB  0
01D90:  CALL   0FF0
01D94:  MOVF   01,W
01D96:  MOVWF  01
01D98:  MOVF   02,W
01D9A:  MOVWF  02
01D9C:  MOVLB  7
01D9E:  BRA    20C4
01DA0:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01DA2:  MOVF   xC3,W
01DA4:  MOVWF  01
01DA6:  MOVF   xC4,W
01DA8:  MOVWF  02
01DAA:  MOVLB  7
01DAC:  BRA    20C4
01DAE:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01DB0:  CLRF   03
01DB2:  MOVLB  1
01DB4:  MOVF   xCB,W
01DB6:  MOVWF  02
01DB8:  BCF    FD8.0
01DBA:  RLCF   02,F
01DBC:  RLCF   03,F
01DBE:  MOVF   02,W
01DC0:  ADDLW  6B
01DC2:  MOVWF  FE9
01DC4:  MOVLW  01
01DC6:  ADDWFC 03,W
01DC8:  MOVWF  FEA
01DCA:  MOVFF  FEC,03
01DCE:  MOVF   FED,F
01DD0:  MOVF   FEF,W
01DD2:  MOVWF  01
01DD4:  MOVF   03,W
01DD6:  MOVWF  02
01DD8:  MOVLB  7
01DDA:  BRA    20C4
01DDC:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01DDE:  MOVLW  05
01DE0:  MOVLB  7
01DE2:  MOVWF  xEE
01DE4:  MOVLB  0
01DE6:  CALL   0FF0
01DEA:  MOVF   01,W
01DEC:  MOVWF  01
01DEE:  MOVF   02,W
01DF0:  MOVWF  02
01DF2:  MOVLB  7
01DF4:  BRA    20C4
01DF6:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01DF8:  MOVF   xC5,W
01DFA:  MOVWF  01
01DFC:  MOVF   xC6,W
01DFE:  MOVWF  02
01E00:  MOVLB  7
01E02:  BRA    20C4
01E04:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01E06:  CLRF   03
01E08:  MOVLB  1
01E0A:  MOVF   xCB,W
01E0C:  MOVWF  02
01E0E:  BCF    FD8.0
01E10:  RLCF   02,F
01E12:  RLCF   03,F
01E14:  MOVF   02,W
01E16:  ADDLW  8B
01E18:  MOVWF  FE9
01E1A:  MOVLW  01
01E1C:  ADDWFC 03,W
01E1E:  MOVWF  FEA
01E20:  MOVFF  FEC,03
01E24:  MOVF   FED,F
01E26:  MOVF   FEF,W
01E28:  MOVWF  01
01E2A:  MOVF   03,W
01E2C:  MOVWF  02
01E2E:  MOVLB  7
01E30:  BRA    20C4
01E32:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01E34:  MOVLW  06
01E36:  MOVLB  7
01E38:  MOVWF  xEE
01E3A:  MOVLB  0
01E3C:  CALL   0FF0
01E40:  MOVF   01,W
01E42:  MOVWF  01
01E44:  MOVF   02,W
01E46:  MOVWF  02
01E48:  MOVLB  7
01E4A:  BRA    20C4
01E4C:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01E4E:  MOVF   xC7,W
01E50:  MOVWF  01
01E52:  MOVF   xC8,W
01E54:  MOVWF  02
01E56:  MOVLB  7
01E58:  BRA    20C4
01E5A:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01E5C:  CLRF   03
01E5E:  MOVLB  1
01E60:  MOVF   xCB,W
01E62:  MOVWF  02
01E64:  BCF    FD8.0
01E66:  RLCF   02,F
01E68:  RLCF   03,F
01E6A:  MOVF   02,W
01E6C:  ADDLW  AB
01E6E:  MOVWF  FE9
01E70:  MOVLW  01
01E72:  ADDWFC 03,W
01E74:  MOVWF  FEA
01E76:  MOVFF  FEC,03
01E7A:  MOVF   FED,F
01E7C:  MOVF   FEF,W
01E7E:  MOVWF  01
01E80:  MOVF   03,W
01E82:  MOVWF  02
01E84:  MOVLB  7
01E86:  BRA    20C4
01E88:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01E8A:  MOVLW  07
01E8C:  MOVLB  7
01E8E:  MOVWF  xEE
01E90:  MOVLB  0
01E92:  CALL   0FF0
01E96:  MOVF   01,W
01E98:  MOVWF  01
01E9A:  MOVF   02,W
01E9C:  MOVWF  02
01E9E:  MOVLB  7
01EA0:  BRA    20C4
01EA2:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01EA4:  MOVF   xC9,W
01EA6:  MOVWF  01
01EA8:  MOVF   xCA,W
01EAA:  MOVWF  02
01EAC:  MOVLB  7
01EAE:  BRA    20C4
01EB0:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01EB2:  MOVLB  1
01EB4:  MOVF   xD3,W
01EB6:  MOVWF  03
01EB8:  MOVF   xD2,W
01EBA:  INCF   xD2,F
01EBC:  BTFSC  FD8.2
01EBE:  INCF   xD3,F
01EC0:  MOVWF  01
01EC2:  MOVF   03,W
01EC4:  MOVWF  02
01EC6:  MOVLB  7
01EC8:  BRA    20C4
01ECA:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01ECC:  MOVLB  1
01ECE:  MOVF   xD6,W
01ED0:  MOVWF  01
01ED2:  MOVF   xD7,W
01ED4:  MOVWF  02
01ED6:  MOVLB  7
01ED8:  BRA    20C4
01EDA:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01EDC:  MOVLB  1
01EDE:  MOVF   xD4,W
01EE0:  MOVWF  01
01EE2:  MOVF   xD5,W
01EE4:  MOVWF  02
01EE6:  MOVLB  7
01EE8:  BRA    20C4
01EEA:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01EEC:  MOVLB  1
01EEE:  MOVF   xD9,W
01EF0:  MOVWF  01
01EF2:  MOVF   xDA,W
01EF4:  MOVWF  02
01EF6:  MOVLB  7
01EF8:  BRA    20C4
01EFA:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01EFC:  GOTO   144C
01F00:  MOVLW  00
01F02:  MOVWF  01
01F04:  MOVWF  02
01F06:  MOVLB  7
01F08:  BRA    20C4
01F0A:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01F0C:  GOTO   1488
01F10:  MOVLW  00
01F12:  MOVWF  01
01F14:  MOVWF  02
01F16:  MOVLB  7
01F18:  BRA    20C4
01F1A:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01F1C:  MOVLB  1
01F1E:  MOVF   xCC,W
01F20:  MOVWF  01
01F22:  MOVF   xCD,W
01F24:  MOVWF  02
01F26:  MOVLB  7
01F28:  BRA    20C4
01F2A:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01F2C:  MOVLB  1
01F2E:  MOVF   xCE,W
01F30:  MOVWF  01
01F32:  MOVF   xCF,W
01F34:  MOVWF  02
01F36:  MOVLB  7
01F38:  BRA    20C4
01F3A:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01F3C:  MOVLB  1
01F3E:  MOVF   xD0,W
01F40:  MOVWF  01
01F42:  MOVF   xD1,W
01F44:  MOVWF  02
01F46:  MOVLB  7
01F48:  BRA    20C4
01F4A:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01F4C:  GOTO   14B0
01F50:  MOVLW  00
01F52:  MOVWF  01
01F54:  MOVWF  02
01F56:  MOVLB  7
01F58:  BRA    20C4
01F5A:  MOVLB  0
.................... 		case 52: return (int16) current.rda_bytes_received; 
01F5C:  MOVLB  1
01F5E:  MOVF   xE2,W
01F60:  MOVWF  01
01F62:  MOVF   xE3,W
01F64:  MOVWF  02
01F66:  MOVLB  7
01F68:  BRA    20C4
01F6A:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
01F6C:  MOVLB  1
01F6E:  MOVF   xE4,W
01F70:  MOVWF  01
01F72:  MOVF   xE5,W
01F74:  MOVWF  02
01F76:  MOVLB  7
01F78:  BRA    20C4
01F7A:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
01F7C:  CLRF   03
01F7E:  MOVF   3A,W
01F80:  MOVWF  01
01F82:  MOVF   03,W
01F84:  MOVWF  02
01F86:  MOVLB  7
01F88:  BRA    20C4
01F8A:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01F8C:  MOVF   3B,W
01F8E:  MOVWF  01
01F90:  MOVF   3C,W
01F92:  MOVWF  02
01F94:  MOVLB  7
01F96:  BRA    20C4
01F98:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01F9A:  MOVLW  50
01F9C:  MOVWF  01
01F9E:  MOVLW  00
01FA0:  MOVWF  02
01FA2:  MOVLB  7
01FA4:  BRA    20C4
01FA6:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01FA8:  MOVLW  57
01FAA:  MOVWF  01
01FAC:  MOVLW  00
01FAE:  MOVWF  02
01FB0:  MOVLB  7
01FB2:  BRA    20C4
01FB4:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01FB6:  MOVLW  58
01FB8:  MOVWF  01
01FBA:  MOVLW  00
01FBC:  MOVWF  02
01FBE:  MOVLB  7
01FC0:  BRA    20C4
01FC2:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01FC4:  MOVLW  01
01FC6:  MOVWF  01
01FC8:  MOVLW  00
01FCA:  MOVWF  02
01FCC:  MOVLB  7
01FCE:  BRA    20C4
01FD0:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01FD2:  CLRF   03
01FD4:  MOVF   36,W
01FD6:  MOVWF  01
01FD8:  MOVF   03,W
01FDA:  MOVWF  02
01FDC:  MOVLB  7
01FDE:  BRA    20C4
01FE0:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01FE2:  MOVF   3D,W
01FE4:  MOVWF  01
01FE6:  MOVF   3E,W
01FE8:  MOVWF  02
01FEA:  MOVLB  7
01FEC:  BRA    20C4
01FEE:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01FF0:  CLRF   03
01FF2:  MOVF   3F,W
01FF4:  MOVWF  01
01FF6:  MOVF   03,W
01FF8:  MOVWF  02
01FFA:  MOVLB  7
01FFC:  BRA    20C4
01FFE:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
02000:  MOVF   40,W
02002:  MOVWF  01
02004:  MOVF   41,W
02006:  MOVWF  02
02008:  MOVLB  7
0200A:  BRA    20C4
0200C:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
0200E:  MOVF   42,W
02010:  MOVWF  01
02012:  MOVF   43,W
02014:  MOVWF  02
02016:  MOVLB  7
02018:  BRA    20C4
0201A:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
0201C:  CLRF   03
0201E:  MOVF   44,W
02020:  MOVWF  01
02022:  MOVF   03,W
02024:  MOVWF  02
02026:  MOVLB  7
02028:  BRA    20C4
0202A:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
0202C:  CLRF   03
0202E:  MOVF   38,W
02030:  MOVWF  01
02032:  MOVF   03,W
02034:  MOVWF  02
02036:  MOVLB  7
02038:  BRA    20C4
0203A:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
0203C:  MOVF   39,F
0203E:  BNZ   204E
02040:  MOVLW  B0
02042:  MOVWF  01
02044:  MOVLW  04
02046:  MOVWF  02
02048:  MOVLB  7
0204A:  BRA    20C4
0204C:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
0204E:  DECFSZ 39,W
02050:  BRA    2060
02052:  MOVLW  60
02054:  MOVWF  01
02056:  MOVLW  09
02058:  MOVWF  02
0205A:  MOVLB  7
0205C:  BRA    20C4
0205E:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
02060:  MOVF   39,W
02062:  SUBLW  02
02064:  BNZ   2074
02066:  MOVLW  C0
02068:  MOVWF  01
0206A:  MOVLW  12
0206C:  MOVWF  02
0206E:  MOVLB  7
02070:  BRA    20C4
02072:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
02074:  MOVF   39,W
02076:  SUBLW  04
02078:  BNZ   2088
0207A:  MOVLW  00
0207C:  MOVWF  01
0207E:  MOVLW  4B
02080:  MOVWF  02
02082:  MOVLB  7
02084:  BRA    20C4
02086:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
02088:  MOVF   39,W
0208A:  SUBLW  05
0208C:  BNZ   209C
0208E:  MOVLW  00
02090:  MOVWF  01
02092:  MOVLW  96
02094:  MOVWF  02
02096:  MOVLB  7
02098:  BRA    20C4
0209A:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
0209C:  MOVF   39,W
0209E:  SUBLW  06
020A0:  BNZ   20B0
020A2:  MOVLW  00
020A4:  MOVWF  01
020A6:  MOVLW  E1
020A8:  MOVWF  02
020AA:  MOVLB  7
020AC:  BRA    20C4
020AE:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
020B0:  MOVLW  80
020B2:  MOVWF  01
020B4:  MOVLW  25
020B6:  MOVWF  02
020B8:  MOVLB  7
020BA:  BRA    20C4
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
020BC:  MOVLW  FF
020BE:  MOVWF  01
020C0:  MOVWF  02
020C2:  BRA    20C4
.................... 	} 
....................  
.................... } 
020C4:  MOVLB  0
020C6:  GOTO   2118 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01244:  MOVLB  7
01246:  MOVF   xDE,W
01248:  SUBLW  1F
0124A:  BNZ   1264
0124C:  MOVF   xDF,W
0124E:  SUBLW  4E
01250:  BNZ   1264
01252:  MOVF   xE0,W
01254:  SUBLW  20
01256:  BNZ   1264
01258:  MOVF   xE1,W
0125A:  SUBLW  4E
0125C:  BNZ   1264
.................... 		return 1; 
0125E:  MOVLW  01
01260:  MOVWF  01
01262:  BRA    132C
....................  
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
01264:  MOVF   xDF,W
01266:  SUBLW  16
01268:  BC    1288
0126A:  XORLW  FF
0126C:  BNZ   1274
0126E:  MOVF   xDE,W
01270:  SUBLW  6F
01272:  BC    1288
01274:  MOVF   xE1,W
01276:  SUBLW  19
01278:  BNC   1288
0127A:  BNZ   1282
0127C:  MOVF   xE0,W
0127E:  SUBLW  50
01280:  BNC   1288
.................... 		return 1; 
01282:  MOVLW  01
01284:  MOVWF  01
01286:  BRA    132C
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
01288:  MOVF   xDF,W
0128A:  SUBLW  12
0128C:  BC    12AC
0128E:  XORLW  FF
01290:  BNZ   1298
01292:  MOVF   xDE,W
01294:  SUBLW  87
01296:  BC    12AC
01298:  MOVF   xE1,W
0129A:  SUBLW  17
0129C:  BNC   12AC
0129E:  BNZ   12A6
012A0:  MOVF   xE0,W
012A2:  SUBLW  48
012A4:  BNC   12AC
.................... 		return 1; 
012A6:  MOVLW  01
012A8:  MOVWF  01
012AA:  BRA    132C
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
012AC:  MOVF   xDF,W
012AE:  SUBLW  03
012B0:  BC    12D0
012B2:  XORLW  FF
012B4:  BNZ   12BC
012B6:  MOVF   xDE,W
012B8:  SUBLW  4B
012BA:  BC    12D0
012BC:  MOVF   xE1,W
012BE:  SUBLW  04
012C0:  BNC   12D0
012C2:  BNZ   12CA
012C4:  MOVF   xE0,W
012C6:  SUBLW  94
012C8:  BNC   12D0
.................... 		return 1; 
012CA:  MOVLW  01
012CC:  MOVWF  01
012CE:  BRA    132C
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
012D0:  MOVF   xDF,W
012D2:  SUBLW  02
012D4:  BC    12F4
012D6:  XORLW  FF
012D8:  BNZ   12E0
012DA:  MOVF   xDE,W
012DC:  SUBLW  E7
012DE:  BC    12F4
012E0:  MOVF   xE1,W
012E2:  SUBLW  03
012E4:  BNC   12F4
012E6:  BNZ   12EE
012E8:  MOVF   xE0,W
012EA:  SUBLW  F6
012EC:  BNC   12F4
.................... 		return 1; 
012EE:  MOVLW  01
012F0:  MOVWF  01
012F2:  BRA    132C
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
012F4:  MOVF   xDF,W
012F6:  SUBLW  06
012F8:  BC    1318
012FA:  XORLW  FF
012FC:  BNZ   1304
012FE:  MOVF   xDE,W
01300:  SUBLW  CF
01302:  BC    1318
01304:  MOVF   xE1,W
01306:  SUBLW  09
01308:  BNC   1318
0130A:  BNZ   1312
0130C:  MOVF   xE0,W
0130E:  SUBLW  D1
01310:  BNC   1318
.................... 		return 1; 
01312:  MOVLW  01
01314:  MOVWF  01
01316:  BRA    132C
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01318:  MOVF   xE1,F
0131A:  BNZ   1328
0131C:  MOVF   xE0,W
0131E:  SUBLW  36
01320:  BNC   1328
.................... 		return 1; 
01322:  MOVLW  01
01324:  MOVWF  01
01326:  BRA    132C
....................  
.................... 	return 0; 
01328:  MOVLW  00
0132A:  MOVWF  01
.................... } 
0132C:  MOVLB  0
0132E:  GOTO   2714 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
020CA:  MOVFF  7DD,7E6
020CE:  MOVFF  7DC,7E7
020D2:  CALL   136E
.................... 	modbus_serial_putc(register_count*2); 
020D6:  BCF    FD8.0
020D8:  MOVLB  7
020DA:  RLCF   xE0,W
020DC:  MOVWF  xE6
020DE:  RLCF   xE1,W
020E0:  MOVWF  xE7
020E2:  MOVFF  7E6,7E8
020E6:  MOVLB  0
020E8:  CALL   133A
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
020EC:  MOVLB  7
020EE:  CLRF   xE3
020F0:  CLRF   xE2
020F2:  MOVF   xE3,W
020F4:  SUBWF  xE1,W
020F6:  BNC   2142
020F8:  BNZ   2100
020FA:  MOVF   xE0,W
020FC:  SUBWF  xE2,W
020FE:  BC    2142
.................... 		l=map_modbus(start_address+i); 
02100:  MOVF   xE2,W
02102:  ADDWF  xDE,W
02104:  MOVWF  xE6
02106:  MOVF   xE3,W
02108:  ADDWFC xDF,W
0210A:  MOVWF  xE7
0210C:  MOVWF  xE9
0210E:  MOVFF  7E6,7E8
02112:  MOVLB  0
02114:  GOTO   14C4
02118:  MOVFF  02,7E5
0211C:  MOVFF  01,7E4
.................... 		modbus_serial_putc(make8(l,1)); 
02120:  MOVFF  7E5,7E6
02124:  MOVFF  7E5,7E8
02128:  CALL   133A
....................   		modbus_serial_putc(make8(l,0)); 
0212C:  MOVFF  7E4,7E6
02130:  MOVFF  7E4,7E8
02134:  CALL   133A
.................... 	} 
02138:  MOVLB  7
0213A:  INCF   xE2,F
0213C:  BTFSC  FD8.2
0213E:  INCF   xE3,F
02140:  BRA    20F2
....................  
.................... 	modbus_serial_send_stop(); 
02142:  MOVLB  0
02144:  CALL   139C
.................... } 
02148:  GOTO   2756 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
0214C:  MOVLB  7
0214E:  MOVF   xE3,W
02150:  SUBLW  06
02152:  BC    21CA
02154:  XORLW  FF
02156:  BNZ   215E
02158:  MOVF   xE2,W
0215A:  SUBLW  CF
0215C:  BC    21CA
0215E:  MOVF   xE3,W
02160:  SUBLW  09
02162:  BNC   21CA
02164:  BNZ   216C
02166:  MOVF   xE2,W
02168:  SUBLW  CF
0216A:  BNC   21CA
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
0216C:  MOVF   xE5,W
0216E:  SUBLW  00
02170:  BC    2182
02172:  XORLW  FF
02174:  BNZ   217C
02176:  MOVF   xE4,W
02178:  SUBLW  00
0217A:  BC    2182
0217C:  MOVLW  03
0217E:  MOVWF  01
02180:  BRA    254C
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
02182:  MOVLW  D0
02184:  SUBWF  xE2,W
02186:  MOVWF  xE8
02188:  MOVLW  07
0218A:  SUBWFB xE3,W
0218C:  MOVWF  xE9
0218E:  MOVLW  02
02190:  ADDWF  xE9,F
02192:  MOVFF  7E9,FAA
02196:  MOVFF  7E8,FA9
0219A:  MOVFF  7E4,FA8
0219E:  BCF    FA6.6
021A0:  BCF    FA6.7
021A2:  BSF    FA6.2
021A4:  MOVF   FF2,W
021A6:  MOVWF  00
021A8:  BCF    FF2.6
021AA:  BCF    FF2.7
021AC:  MOVLB  F
021AE:  MOVLW  55
021B0:  MOVWF  FA7
021B2:  MOVLW  AA
021B4:  MOVWF  FA7
021B6:  BSF    FA6.1
021B8:  BTFSC  FA6.1
021BA:  BRA    21B8
021BC:  BCF    FA6.2
021BE:  MOVF   00,W
021C0:  IORWF  FF2,F
.................... 		return 0; 
021C2:  MOVLW  00
021C4:  MOVWF  01
021C6:  MOVLB  7
021C8:  BRA    254C
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
021CA:  MOVF   xE3,W
021CC:  SUBLW  03
021CE:  BC    2260
021D0:  XORLW  FF
021D2:  BNZ   21DA
021D4:  MOVF   xE2,W
021D6:  SUBLW  4B
021D8:  BC    2260
021DA:  MOVF   xE3,W
021DC:  SUBLW  04
021DE:  BNC   2260
021E0:  BNZ   21E8
021E2:  MOVF   xE2,W
021E4:  SUBLW  93
021E6:  BNC   2260
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
021E8:  MOVF   xE5,W
021EA:  SUBLW  00
021EC:  BC    21FE
021EE:  XORLW  FF
021F0:  BNZ   21F8
021F2:  MOVF   xE4,W
021F4:  SUBLW  00
021F6:  BC    21FE
021F8:  MOVLW  03
021FA:  MOVWF  01
021FC:  BRA    254C
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
021FE:  MOVLW  4C
02200:  SUBWF  xE2,W
02202:  MOVWF  xE6
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
02204:  MOVFF  7E6,7EE
02208:  MOVLW  06
0220A:  MOVWF  xEF
0220C:  MOVLB  0
0220E:  CALL   0AF8
02212:  MOVFF  00,7E7
.................... 		n = n / 6; /* number of sentence */ 
02216:  MOVFF  7E6,7EE
0221A:  MOVLW  06
0221C:  MOVLB  7
0221E:  MOVWF  xEF
02220:  MOVLB  0
02222:  CALL   0AF8
02226:  MOVFF  01,7E6
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
0222A:  MOVLB  7
0222C:  MOVF   xE6,W
0222E:  MULLW  06
02230:  MOVF   FF3,W
02232:  CLRF   03
02234:  ADDLW  19
02236:  MOVWF  xE8
02238:  MOVLW  00
0223A:  ADDWFC 03,W
0223C:  MOVWF  xE9
0223E:  CLRF   03
02240:  MOVF   xE7,W
02242:  ADDWF  xE8,W
02244:  MOVWF  01
02246:  MOVF   xE9,W
02248:  ADDWFC 03,F
0224A:  MOVF   01,W
0224C:  ADDLW  36
0224E:  MOVWF  FE9
02250:  MOVLW  00
02252:  ADDWFC 03,W
02254:  MOVWF  FEA
02256:  MOVFF  7E4,FEF
.................... 		 
.................... 		return 0; 
0225A:  MOVLW  00
0225C:  MOVWF  01
0225E:  BRA    254C
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
02260:  MOVLB  1
02262:  MOVF   xD8,F
02264:  BZ    229C
.................... 		if ( 1000 == address ) { 
02266:  MOVLB  7
02268:  MOVF   xE2,W
0226A:  SUBLW  E8
0226C:  BNZ   2280
0226E:  MOVF   xE3,W
02270:  SUBLW  03
02272:  BNZ   2280
.................... 			config.serial_prefix=value; 
02274:  MOVFF  7E4,3A
.................... 			return 0; 
02278:  MOVLW  00
0227A:  MOVWF  01
0227C:  BRA    254C
.................... 		} else if ( 1001 == address ) { 
0227E:  BRA    229A
02280:  MOVF   xE2,W
02282:  SUBLW  E9
02284:  BNZ   229A
02286:  MOVF   xE3,W
02288:  SUBLW  03
0228A:  BNZ   229A
.................... 			config.serial_number=value; 
0228C:  MOVFF  7E5,3C
02290:  MOVFF  7E4,3B
.................... 			return 0; 
02294:  MOVLW  00
02296:  MOVWF  01
02298:  BRA    254C
0229A:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
0229C:  MOVLB  7
0229E:  MOVF   xE2,W
022A0:  MOVWF  00
022A2:  MOVF   xE3,W
022A4:  MOVWF  03
022A6:  MOVLW  03
022A8:  SUBWF  03,W
022AA:  BNZ   22B8
022AC:  MOVLW  EE
022AE:  SUBWF  00,W
022B0:  MOVLB  0
022B2:  BTFSC  FD8.2
022B4:  BRA    2392
022B6:  MOVLB  7
022B8:  MOVLW  03
022BA:  SUBWF  03,W
022BC:  BNZ   22CA
022BE:  MOVLW  EF
022C0:  SUBWF  00,W
022C2:  MOVLB  0
022C4:  BTFSC  FD8.2
022C6:  BRA    23AA
022C8:  MOVLB  7
022CA:  MOVLW  03
022CC:  SUBWF  03,W
022CE:  BNZ   22DC
022D0:  MOVLW  F0
022D2:  SUBWF  00,W
022D4:  MOVLB  0
022D6:  BTFSC  FD8.2
022D8:  BRA    23BA
022DA:  MOVLB  7
022DC:  MOVLW  03
022DE:  SUBWF  03,W
022E0:  BNZ   22EE
022E2:  MOVLW  F1
022E4:  SUBWF  00,W
022E6:  MOVLB  0
022E8:  BTFSC  FD8.2
022EA:  BRA    23D2
022EC:  MOVLB  7
022EE:  MOVLW  03
022F0:  SUBWF  03,W
022F2:  BNZ   2300
022F4:  MOVLW  F2
022F6:  SUBWF  00,W
022F8:  MOVLB  0
022FA:  BTFSC  FD8.2
022FC:  BRA    23DE
022FE:  MOVLB  7
02300:  MOVLW  03
02302:  SUBWF  03,W
02304:  BNZ   2312
02306:  MOVLW  F3
02308:  SUBWF  00,W
0230A:  MOVLB  0
0230C:  BTFSC  FD8.2
0230E:  BRA    23F8
02310:  MOVLB  7
02312:  MOVLW  03
02314:  SUBWF  03,W
02316:  BNZ   2324
02318:  MOVLW  F4
0231A:  SUBWF  00,W
0231C:  MOVLB  0
0231E:  BTFSC  FD8.2
02320:  BRA    2410
02322:  MOVLB  7
02324:  MOVLW  03
02326:  SUBWF  03,W
02328:  BNZ   2336
0232A:  MOVLW  F5
0232C:  SUBWF  00,W
0232E:  MOVLB  0
02330:  BTFSC  FD8.2
02332:  BRA    2428
02334:  MOVLB  7
02336:  MOVLW  07
02338:  SUBWF  03,W
0233A:  BNZ   2348
0233C:  MOVLW  CC
0233E:  SUBWF  00,W
02340:  MOVLB  0
02342:  BTFSC  FD8.2
02344:  BRA    24A8
02346:  MOVLB  7
02348:  MOVLW  07
0234A:  SUBWF  03,W
0234C:  BNZ   235A
0234E:  MOVLW  CD
02350:  SUBWF  00,W
02352:  MOVLB  0
02354:  BTFSC  FD8.2
02356:  BRA    24D2
02358:  MOVLB  7
0235A:  MOVLW  07
0235C:  SUBWF  03,W
0235E:  BNZ   236C
02360:  MOVLW  CE
02362:  SUBWF  00,W
02364:  MOVLB  0
02366:  BTFSC  FD8.2
02368:  BRA    24E6
0236A:  MOVLB  7
0236C:  MOVLW  07
0236E:  SUBWF  03,W
02370:  BNZ   237E
02372:  MOVLW  CF
02374:  SUBWF  00,W
02376:  MOVLB  0
02378:  BTFSC  FD8.2
0237A:  BRA    2500
0237C:  MOVLB  7
0237E:  MOVLW  4E
02380:  SUBWF  03,W
02382:  BNZ   2390
02384:  MOVLW  1F
02386:  SUBWF  00,W
02388:  MOVLB  0
0238A:  BTFSC  FD8.2
0238C:  BRA    251A
0238E:  MOVLB  7
02390:  BRA    2542
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
02392:  MOVLB  7
02394:  MOVF   xE5,F
02396:  BNZ   239E
02398:  MOVF   xE4,W
0239A:  SUBLW  80
0239C:  BC    23A4
0239E:  MOVLW  03
023A0:  MOVWF  01
023A2:  BRA    254C
.................... 			config.modbus_address=value; 
023A4:  MOVFF  7E4,36
.................... 			break; 
023A8:  BRA    2548
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
023AA:  MOVLB  1
023AC:  BSF    xFA.1
.................... 			config.adc_sample_ticks=value; 
023AE:  MOVFF  7E5,3E
023B2:  MOVFF  7E4,3D
.................... 			break; 
023B6:  MOVLB  7
023B8:  BRA    2548
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
023BA:  MOVLB  7
023BC:  MOVF   xE5,F
023BE:  BNZ   23C6
023C0:  MOVF   xE4,W
023C2:  SUBLW  01
023C4:  BC    23CC
023C6:  MOVLW  03
023C8:  MOVWF  01
023CA:  BRA    254C
.................... 			config.allow_bootload_request=value; 
023CC:  MOVFF  7E4,3F
.................... 			break; 
023D0:  BRA    2548
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
023D2:  MOVFF  7E5,41
023D6:  MOVFF  7E4,40
.................... 			break; 
023DA:  MOVLB  7
023DC:  BRA    2548
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
023DE:  MOVLB  7
023E0:  MOVF   xE4,F
023E2:  BNZ   23EE
023E4:  MOVF   xE5,F
023E6:  BNZ   23EE
023E8:  MOVLW  03
023EA:  MOVWF  01
023EC:  BRA    254C
.................... 			config.pi_offtime_seconds=value; 
023EE:  MOVFF  7E5,43
023F2:  MOVFF  7E4,42
.................... 			break; 
023F6:  BRA    2548
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
023F8:  MOVLB  7
023FA:  MOVF   xE5,F
023FC:  BNZ   2404
023FE:  MOVF   xE4,W
02400:  SUBLW  01
02402:  BC    240A
02404:  MOVLW  03
02406:  MOVWF  01
02408:  BRA    254C
.................... 			config.power_startup=value; 
0240A:  MOVFF  7E4,44
.................... 			break; 
0240E:  BRA    2548
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
02410:  MOVLB  7
02412:  MOVF   xE5,F
02414:  BNZ   241C
02416:  MOVF   xE4,W
02418:  SUBLW  02
0241A:  BC    2422
0241C:  MOVLW  03
0241E:  MOVWF  01
02420:  BRA    254C
.................... 			config.rs485_port_mode=value; 
02422:  MOVFF  7E4,38
.................... 			break; 
02426:  BRA    2548
.................... 		 
.................... 		case 1013: 
.................... 			if ( value > RS485_SPEED_57600 ) return ILLEGAL_DATA_VALUE; 
02428:  MOVLB  7
0242A:  MOVF   xE5,F
0242C:  BNZ   2434
0242E:  MOVF   xE4,W
02430:  SUBLW  06
02432:  BC    243A
02434:  MOVLW  03
02436:  MOVWF  01
02438:  BRA    254C
....................  
.................... 			if ( 1200 == value )  config.rs485_port_speed=RS485_SPEED_1200; 
0243A:  MOVF   xE4,W
0243C:  SUBLW  B0
0243E:  BNZ   2448
02440:  MOVF   xE5,W
02442:  SUBLW  04
02444:  BTFSC  FD8.2
02446:  CLRF   39
.................... 			if ( 2400 == value )  config.rs485_port_speed=RS485_SPEED_2400; 
02448:  MOVF   xE4,W
0244A:  SUBLW  60
0244C:  BNZ   2458
0244E:  MOVF   xE5,W
02450:  SUBLW  09
02452:  BNZ   2458
02454:  MOVLW  01
02456:  MOVWF  39
.................... 			if ( 4800 == value )  config.rs485_port_speed=RS485_SPEED_4800; 
02458:  MOVF   xE4,W
0245A:  SUBLW  C0
0245C:  BNZ   2468
0245E:  MOVF   xE5,W
02460:  SUBLW  12
02462:  BNZ   2468
02464:  MOVLW  02
02466:  MOVWF  39
.................... 			if ( 9600 == value )  config.rs485_port_speed=RS485_SPEED_9600; 
02468:  MOVF   xE4,W
0246A:  SUBLW  80
0246C:  BNZ   2478
0246E:  MOVF   xE5,W
02470:  SUBLW  25
02472:  BNZ   2478
02474:  MOVLW  03
02476:  MOVWF  39
.................... 			if ( 19200 == value ) config.rs485_port_speed=RS485_SPEED_19200; 
02478:  MOVF   xE4,F
0247A:  BNZ   2486
0247C:  MOVF   xE5,W
0247E:  SUBLW  4B
02480:  BNZ   2486
02482:  MOVLW  04
02484:  MOVWF  39
.................... 			if ( 38400 == value ) config.rs485_port_speed=RS485_SPEED_38400; 
02486:  MOVF   xE4,F
02488:  BNZ   2494
0248A:  MOVF   xE5,W
0248C:  SUBLW  96
0248E:  BNZ   2494
02490:  MOVLW  05
02492:  MOVWF  39
.................... 			if ( 57600 == value ) config.rs485_port_speed=RS485_SPEED_57600; 
02494:  MOVF   xE4,F
02496:  BNZ   24A2
02498:  MOVF   xE5,W
0249A:  SUBLW  E1
0249C:  BNZ   24A2
0249E:  MOVLW  06
024A0:  MOVWF  39
....................  
.................... 			set_rs485_speed(); 
024A2:  MOVLB  0
024A4:  CALL   08CC
....................  
.................... 		case 1996: 
.................... 			/* zero out NMEA structure */ 
.................... 			memset(&nmea,0,sizeof(nmea)); 
024A8:  MOVLW  03
024AA:  MOVWF  FEA
024AC:  CLRF   FE9
024AE:  CLRF   00
024B0:  MOVWF  02
024B2:  MOVLW  C0
024B4:  MOVWF  01
024B6:  CALL   08B2
.................... 			memset(timers.rda2_buff,0,256); 
024BA:  MOVLW  01
024BC:  MOVWF  FEA
024BE:  MOVLW  FE
024C0:  MOVWF  FE9
024C2:  CLRF   00
024C4:  MOVLW  01
024C6:  MOVWF  02
024C8:  CLRF   01
024CA:  CALL   08B2
.................... 			break; 
024CE:  MOVLB  7
024D0:  BRA    2548
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
024D2:  MOVLB  7
024D4:  DECFSZ xE4,W
024D6:  BRA    24DC
024D8:  MOVF   xE5,F
024DA:  BZ    24E2
024DC:  MOVLW  03
024DE:  MOVWF  01
024E0:  BRA    254C
.................... 			reset_cpu(); 
024E2:  RESET
024E4:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
024E6:  MOVLB  7
024E8:  DECFSZ xE4,W
024EA:  BRA    24F0
024EC:  MOVF   xE5,F
024EE:  BZ    24F6
024F0:  MOVLW  03
024F2:  MOVWF  01
024F4:  BRA    254C
.................... 			write_default_param_file(); 
024F6:  MOVLB  0
024F8:  CALL   0D30
.................... 			break; 
024FC:  MOVLB  7
024FE:  BRA    2548
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02500:  MOVLB  7
02502:  DECFSZ xE4,W
02504:  BRA    250A
02506:  MOVF   xE5,F
02508:  BZ    2510
0250A:  MOVLW  03
0250C:  MOVWF  01
0250E:  BRA    254C
.................... 			write_param_file(); 
02510:  MOVLB  0
02512:  CALL   0CDC
.................... 			break; 
02516:  MOVLB  7
02518:  BRA    2548
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
0251A:  MOVLB  7
0251C:  MOVF   xE4,W
0251E:  SUBLW  0A
02520:  BNZ   2528
02522:  MOVF   xE5,W
02524:  SUBLW  07
02526:  BZ    2534
.................... 				current.factory_unlocked=0; 
02528:  MOVLB  1
0252A:  CLRF   xD8
.................... 				return ILLEGAL_DATA_VALUE; 
0252C:  MOVLW  03
0252E:  MOVWF  01
02530:  MOVLB  7
02532:  BRA    254C
.................... 			} 
.................... 			current.factory_unlocked=1; 
02534:  MOVLW  01
02536:  MOVLB  1
02538:  MOVWF  xD8
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
0253A:  MOVLW  C8
0253C:  MOVWF  xF7
.................... 			break; 
0253E:  MOVLB  7
02540:  BRA    2548
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02542:  MOVLW  02
02544:  MOVWF  01
02546:  BRA    254C
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02548:  MOVLW  00
0254A:  MOVWF  01
.................... } 
0254C:  MOVLB  0
0254E:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
025E0:  GOTO   11F6
025E4:  MOVF   01,F
025E6:  BTFSC  FD8.2
025E8:  BRA    28CC
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
025EA:  DECFSZ 38,W
025EC:  BRA    26A0
025EE:  MOVF   36,W
025F0:  MOVLB  6
025F2:  SUBWF  xC4,W
025F4:  BTFSS  FD8.2
025F6:  BRA    25FC
025F8:  MOVLB  0
025FA:  BRA    26A0
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
025FC:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
025FE:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02600:  CLRWDT
02602:  MOVLW  02
02604:  MOVLB  7
02606:  MOVWF  xDC
02608:  MOVLW  B5
0260A:  MOVWF  xDD
0260C:  MOVLB  0
0260E:  CALL   121C
02612:  MOVLB  7
02614:  DECFSZ xDC,F
02616:  BRA    2608
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02618:  MOVLB  6
0261A:  MOVF   xC4,W
0261C:  MOVLB  0
0261E:  CALL   123C
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02622:  CLRWDT
02624:  MOVLW  67
02626:  MOVWF  00
02628:  DECFSZ 00,F
0262A:  BRA    2628
0262C:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
0262E:  MOVLB  6
02630:  MOVF   xC6,W
02632:  MOVLB  0
02634:  CALL   123C
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02638:  CLRWDT
0263A:  MOVLW  67
0263C:  MOVWF  00
0263E:  DECFSZ 00,F
02640:  BRA    263E
02642:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02644:  MOVLB  7
02646:  CLRF   xDB
02648:  MOVLW  02
0264A:  MOVLB  6
0264C:  ADDWF  xC5,W
0264E:  MOVLB  7
02650:  SUBWF  xDB,W
02652:  BC    2680
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02654:  MOVLW  C8
02656:  ADDWF  xDB,W
02658:  MOVWF  FE9
0265A:  MOVLW  06
0265C:  MOVWF  FEA
0265E:  BTFSC  FD8.0
02660:  INCF   FEA,F
02662:  MOVFF  FEF,7DC
02666:  MOVF   xDC,W
02668:  MOVLB  0
0266A:  CALL   123C
.................... 				delay_us(104); //one stop bit @ 9600 baud 
0266E:  CLRWDT
02670:  MOVLW  67
02672:  MOVWF  00
02674:  DECFSZ 00,F
02676:  BRA    2674
02678:  NOP   
.................... 			} 
0267A:  MOVLB  7
0267C:  INCF   xDB,F
0267E:  BRA    2648
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02680:  BTFSS  F72.1
02682:  BRA    2680
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02684:  CLRWDT
02686:  MOVLW  02
02688:  MOVWF  xDC
0268A:  MOVLW  B5
0268C:  MOVWF  xDD
0268E:  MOVLB  0
02690:  CALL   121C
02694:  MOVLB  7
02696:  DECFSZ xDC,F
02698:  BRA    268A
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
0269A:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
0269C:  BCF    F8C.0
0269E:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
026A0:  MOVF   36,W
026A2:  SUBLW  80
026A4:  BZ    26B2
026A6:  MOVF   36,W
026A8:  MOVLB  6
026AA:  SUBWF  xC4,W
026AC:  BTFSS  FD8.2
026AE:  BRA    28B6
026B0:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
026B2:  MOVLB  1
026B4:  INCFSZ xCC,W
026B6:  BRA    26BE
026B8:  INCFSZ xCD,W
026BA:  BRA    26BE
026BC:  BRA    26C4
.................... 				current.modbus_our_packets++; 
026BE:  INCF   xCC,F
026C0:  BTFSC  FD8.2
026C2:  INCF   xCD,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
026C4:  MOVLW  14
026C6:  MOVWF  xF7
....................  
.................... 			switch(modbus_rx.func) { 
026C8:  MOVLB  6
026CA:  MOVF   xC6,W
026CC:  XORLW  03
026CE:  MOVLB  0
026D0:  BZ    26E2
026D2:  XORLW  07
026D4:  BZ    26E2
026D6:  XORLW  02
026D8:  BZ    275A
026DA:  XORLW  16
026DC:  BTFSC  FD8.2
026DE:  BRA    27CC
026E0:  BRA    288E
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
026E2:  MOVFF  6C8,7D7
026E6:  MOVFF  6C9,7D6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
026EA:  MOVFF  6CA,7D9
026EE:  MOVFF  6CB,7D8
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
026F2:  MOVLB  7
026F4:  MOVF   xD8,W
026F6:  ADDWF  xD6,W
026F8:  MOVWF  xDC
026FA:  MOVF   xD9,W
026FC:  ADDWFC xD7,W
026FE:  MOVWF  xDD
02700:  MOVFF  7D7,7DF
02704:  MOVFF  7D6,7DE
02708:  MOVWF  xE1
0270A:  MOVFF  7DC,7E0
0270E:  MOVLB  0
02710:  GOTO   1244
02714:  MOVF   01,F
02716:  BNZ   273C
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02718:  MOVFF  6C4,7DC
0271C:  MOVLB  7
0271E:  CLRF   xDE
02720:  MOVFF  6C6,7DD
02724:  MOVLW  02
02726:  MOVWF  xDF
02728:  MOVLB  0
0272A:  CALL   13CA
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
0272E:  MOVLB  1
02730:  CLRF   xD1
02732:  MOVLW  02
02734:  MOVWF  xD0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02736:  CLRF   xF7
.................... 					} else { 
02738:  BRA    2758
0273A:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
0273C:  MOVFF  6C6,7DC
02740:  MOVFF  6C4,7DD
02744:  MOVFF  7D7,7DF
02748:  MOVFF  7D6,7DE
0274C:  MOVFF  7D9,7E1
02750:  MOVFF  7D8,7E0
02754:  BRA    20CA
02756:  MOVLB  1
.................... 					} 
.................... 					break; 
02758:  BRA    28AE
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0275A:  MOVFF  6C8,7D7
0275E:  MOVFF  6C9,7D6
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02762:  MOVFF  6CA,7DD
02766:  MOVFF  6CB,7DC
0276A:  MOVFF  7D7,7E3
0276E:  MOVFF  7D6,7E2
02772:  MOVFF  6CA,7E5
02776:  MOVFF  6CB,7E4
0277A:  RCALL  214C
0277C:  MOVFF  01,7DA
....................  
.................... 					if ( result ) { 
02780:  MOVLB  7
02782:  MOVF   xDA,F
02784:  BZ    27A8
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02786:  MOVFF  6C4,7DC
0278A:  CLRF   xDE
0278C:  MOVFF  6C6,7DD
02790:  MOVFF  7DA,7DF
02794:  MOVLB  0
02796:  CALL   13CA
.................... 						current.modbus_last_error=result; 
0279A:  MOVLB  1
0279C:  CLRF   xD1
0279E:  MOVFF  7DA,1D0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
027A2:  CLRF   xF7
.................... 					}  else { 
027A4:  BRA    27CA
027A6:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
027A8:  MOVFF  6CA,7DD
027AC:  MOVFF  6CB,7DC
027B0:  MOVFF  6C4,7DE
027B4:  MOVFF  7D7,7E0
027B8:  MOVFF  7D6,7DF
027BC:  MOVFF  6CA,7E2
027C0:  MOVFF  6CB,7E1
027C4:  MOVLB  0
027C6:  BRA    2550
027C8:  MOVLB  1
.................... 					} 
.................... 					break; 
027CA:  BRA    28AE
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
027CC:  MOVFF  6C8,7D7
027D0:  MOVFF  6C9,7D6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
027D4:  MOVFF  6CA,7D9
027D8:  MOVFF  6CB,7D8
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
027DC:  MOVLB  7
027DE:  CLRF   xDB
027E0:  MOVF   xD9,F
027E2:  BNZ   27EA
027E4:  MOVF   xD8,W
027E6:  SUBWF  xDB,W
027E8:  BC    286E
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
027EA:  MOVF   xDB,W
027EC:  ADDWF  xD6,W
027EE:  MOVWF  xDC
027F0:  MOVLW  00
027F2:  ADDWFC xD7,W
027F4:  MOVWF  xDD
027F6:  BCF    FD8.0
027F8:  RLCF   xDB,W
027FA:  ADDLW  05
027FC:  ADDLW  C8
027FE:  MOVWF  FE9
02800:  MOVLW  06
02802:  MOVWF  FEA
02804:  BTFSC  FD8.0
02806:  INCF   FEA,F
02808:  MOVFF  FEF,7DE
0280C:  BCF    FD8.0
0280E:  RLCF   xDB,W
02810:  ADDLW  06
02812:  ADDLW  C8
02814:  MOVWF  FE9
02816:  MOVLW  06
02818:  MOVWF  FEA
0281A:  BTFSC  FD8.0
0281C:  INCF   FEA,F
0281E:  MOVFF  FEF,7DF
02822:  MOVFF  7DE,7E1
02826:  MOVFF  7DF,7E0
0282A:  MOVFF  7DD,7E3
0282E:  MOVFF  7DC,7E2
02832:  MOVFF  7DE,7E5
02836:  MOVFF  7DF,7E4
0283A:  MOVLB  0
0283C:  RCALL  214C
0283E:  MOVFF  01,7DA
....................  
.................... 						if ( result ) { 
02842:  MOVLB  7
02844:  MOVF   xDA,F
02846:  BZ    286A
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02848:  MOVFF  6C4,7DC
0284C:  CLRF   xDE
0284E:  MOVFF  6C6,7DD
02852:  MOVFF  7DA,7DF
02856:  MOVLB  0
02858:  CALL   13CA
.................... 							current.modbus_last_error=result; 
0285C:  MOVLB  1
0285E:  CLRF   xD1
02860:  MOVFF  7DA,1D0
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02864:  CLRF   xF7
.................... 			 
.................... 							break; 
02866:  MOVLB  7
02868:  BRA    286E
.................... 						} 
.................... 					} 
0286A:  INCF   xDB,F
0286C:  BRA    27E0
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
0286E:  MOVF   xDA,F
02870:  BNZ   288A
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02872:  MOVFF  6C4,7DC
02876:  MOVFF  7D7,7DE
0287A:  MOVFF  7D6,7DD
0287E:  MOVFF  7D9,7E0
02882:  MOVFF  7D8,7DF
02886:  MOVLB  0
02888:  BRA    2598
.................... 					} 
....................  
.................... 					break;   
0288A:  MOVLB  1
0288C:  BRA    28AE
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
0288E:  MOVFF  6C4,7DC
02892:  MOVLB  7
02894:  CLRF   xDE
02896:  MOVFF  6C6,7DD
0289A:  MOVLW  01
0289C:  MOVWF  xDF
0289E:  MOVLB  0
028A0:  CALL   13CA
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
028A4:  MOVLB  1
028A6:  CLRF   xD1
028A8:  MOVLW  01
028AA:  MOVWF  xD0
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
028AC:  CLRF   xF7
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
028AE:  CLRF   xDA
028B0:  CLRF   xD9
....................  
.................... 		} else { 
028B2:  BRA    28CC
028B4:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
028B6:  MOVLB  1
028B8:  INCFSZ xCE,W
028BA:  BRA    28C2
028BC:  INCFSZ xCF,W
028BE:  BRA    28C2
028C0:  BRA    28C8
.................... 				current.modbus_other_packets++; 
028C2:  INCF   xCE,F
028C4:  BTFSC  FD8.2
028C6:  INCF   xCF,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
028C8:  MOVLW  0A
028CA:  MOVWF  xF7
028CC:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
028CE:  GOTO   2D5E (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00442:  MOVLB  8
00444:  BTFSS  xE9.0
00446:  BRA    0460
00448:  MOVLB  1
0044A:  INCFSZ xE6,W
0044C:  BRA    0458
0044E:  INCFSZ xE7,W
00450:  BRA    0458
00452:  MOVLB  8
00454:  BRA    0460
00456:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00458:  INCF   xE6,F
0045A:  BTFSC  FD8.2
0045C:  INCF   xE7,F
0045E:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00460:  BTFSS  xE9.2
00462:  BRA    047C
00464:  MOVLB  1
00466:  INCFSZ xE8,W
00468:  BRA    0474
0046A:  INCFSZ xE9,W
0046C:  BRA    0474
0046E:  MOVLB  8
00470:  BRA    047C
00472:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00474:  INCF   xE8,F
00476:  BTFSC  FD8.2
00478:  INCF   xE9,F
0047A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0047C:  BTFSS  xE9.4
0047E:  BRA    0498
00480:  MOVLB  1
00482:  INCFSZ xEA,W
00484:  BRA    0490
00486:  INCFSZ xEB,W
00488:  BRA    0490
0048A:  MOVLB  8
0048C:  BRA    0498
0048E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00490:  INCF   xEA,F
00492:  BTFSC  FD8.2
00494:  INCF   xEB,F
00496:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00498:  BCF    xE9.1
0049A:  BTFSC  F81.0
0049C:  BSF    xE9.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0049E:  BTFSC  xE9.1
004A0:  BRA    0524
004A2:  MOVLB  6
004A4:  BTFSC  xC0.1
004A6:  BRA    04AC
004A8:  MOVLB  8
004AA:  BRA    0524
.................... 		current.pulse_count[0]++; 
004AC:  MOVLB  0
004AE:  INCF   xA9,F
004B0:  BTFSC  FD8.2
004B2:  INCF   xAA,F
.................... 		current.pulse_sum[0]++; 
004B4:  MOVLW  01
004B6:  ADDWF  xAF,F
004B8:  BTFSC  FD8.0
004BA:  INCF   xB0,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xB1,F
004C0:  BTFSC  FD8.2
004C2:  INCF   xB2,F
.................... 		if ( 1 == ext0_state ) { 
004C4:  MOVLB  6
004C6:  BTFSS  xC0.2
004C8:  BRA    0512
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004CA:  MOVLB  8
004CC:  BCF    xE9.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004CE:  MOVFF  1E7,98
004D2:  MOVFF  1E6,97
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004D6:  MOVLB  0
004D8:  MOVF   x98,W
004DA:  SUBWF  x9E,W
004DC:  BNC   04EE
004DE:  BNZ   04E6
004E0:  MOVF   x9D,W
004E2:  SUBWF  x97,W
004E4:  BC    04EE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004E6:  MOVFF  98,9E
004EA:  MOVFF  97,9D
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004EE:  MOVF   xA4,W
004F0:  SUBWF  x98,W
004F2:  BNC   050E
004F4:  BNZ   04FC
004F6:  MOVF   x97,W
004F8:  SUBWF  xA3,W
004FA:  BC    050E
004FC:  INCFSZ x97,W
004FE:  BRA    0506
00500:  INCFSZ x98,W
00502:  BRA    0506
00504:  BRA    050E
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00506:  MOVFF  98,A4
0050A:  MOVFF  97,A3
.................... 			} 
.................... 			ext0_state=0; 
0050E:  MOVLB  6
00510:  BCF    xC0.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00512:  BTFSC  xC0.2
00514:  BRA    0524
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00516:  MOVLB  1
00518:  CLRF   xE7
0051A:  CLRF   xE6
.................... 			ext0_count=1; 
0051C:  MOVLB  8
0051E:  BSF    xE9.0
.................... 			ext0_state=1; 
00520:  MOVLB  6
00522:  BSF    xC0.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00524:  MOVLB  6
00526:  BCF    xC0.1
00528:  MOVLB  8
0052A:  BTFSS  xE9.1
0052C:  BRA    0534
0052E:  MOVLB  6
00530:  BSF    xC0.1
00532:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00534:  BCF    xE9.3
00536:  BTFSC  F81.1
00538:  BSF    xE9.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0053A:  BTFSC  xE9.3
0053C:  BRA    05C0
0053E:  MOVLB  6
00540:  BTFSC  xC0.3
00542:  BRA    0548
00544:  MOVLB  8
00546:  BRA    05C0
.................... 		current.pulse_count[1]++; 
00548:  MOVLB  0
0054A:  INCF   xAB,F
0054C:  BTFSC  FD8.2
0054E:  INCF   xAC,F
.................... 		current.pulse_sum[1]++; 
00550:  MOVLW  01
00552:  ADDWF  xB3,F
00554:  BTFSC  FD8.0
00556:  INCF   xB4,F
00558:  BTFSC  FD8.2
0055A:  INCF   xB5,F
0055C:  BTFSC  FD8.2
0055E:  INCF   xB6,F
.................... 		if ( 1 == ext1_state ) { 
00560:  MOVLB  6
00562:  BTFSS  xC0.4
00564:  BRA    05AE
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00566:  MOVLB  8
00568:  BCF    xE9.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0056A:  MOVFF  1E9,9A
0056E:  MOVFF  1E8,99
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00572:  MOVLB  0
00574:  MOVF   x9A,W
00576:  SUBWF  xA0,W
00578:  BNC   058A
0057A:  BNZ   0582
0057C:  MOVF   x9F,W
0057E:  SUBWF  x99,W
00580:  BC    058A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00582:  MOVFF  9A,A0
00586:  MOVFF  99,9F
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0058A:  MOVF   xA6,W
0058C:  SUBWF  x9A,W
0058E:  BNC   05AA
00590:  BNZ   0598
00592:  MOVF   x99,W
00594:  SUBWF  xA5,W
00596:  BC    05AA
00598:  INCFSZ x99,W
0059A:  BRA    05A2
0059C:  INCFSZ x9A,W
0059E:  BRA    05A2
005A0:  BRA    05AA
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005A2:  MOVFF  9A,A6
005A6:  MOVFF  99,A5
.................... 			} 
.................... 			ext1_state=0; 
005AA:  MOVLB  6
005AC:  BCF    xC0.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005AE:  BTFSC  xC0.4
005B0:  BRA    05C0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005B2:  MOVLB  1
005B4:  CLRF   xE9
005B6:  CLRF   xE8
.................... 			ext1_count=1; 
005B8:  MOVLB  8
005BA:  BSF    xE9.2
.................... 			ext1_state=1; 
005BC:  MOVLB  6
005BE:  BSF    xC0.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005C0:  MOVLB  6
005C2:  BCF    xC0.3
005C4:  MOVLB  8
005C6:  BTFSS  xE9.3
005C8:  BRA    05D0
005CA:  MOVLB  6
005CC:  BSF    xC0.3
005CE:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005D0:  BCF    xE9.5
005D2:  BTFSC  F81.2
005D4:  BSF    xE9.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005D6:  BTFSC  xE9.5
005D8:  BRA    065C
005DA:  MOVLB  6
005DC:  BTFSC  xC0.5
005DE:  BRA    05E4
005E0:  MOVLB  8
005E2:  BRA    065C
.................... 		current.pulse_count[2]++; 
005E4:  MOVLB  0
005E6:  INCF   xAD,F
005E8:  BTFSC  FD8.2
005EA:  INCF   xAE,F
.................... 		current.pulse_sum[2]++; 
005EC:  MOVLW  01
005EE:  ADDWF  xB7,F
005F0:  BTFSC  FD8.0
005F2:  INCF   xB8,F
005F4:  BTFSC  FD8.2
005F6:  INCF   xB9,F
005F8:  BTFSC  FD8.2
005FA:  INCF   xBA,F
.................... 		if ( 1 == ext2_state ) { 
005FC:  MOVLB  6
005FE:  BTFSS  xC0.6
00600:  BRA    064A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
00602:  MOVLB  8
00604:  BCF    xE9.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00606:  MOVFF  1EB,9C
0060A:  MOVFF  1EA,9B
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0060E:  MOVLB  0
00610:  MOVF   x9C,W
00612:  SUBWF  xA2,W
00614:  BNC   0626
00616:  BNZ   061E
00618:  MOVF   xA1,W
0061A:  SUBWF  x9B,W
0061C:  BC    0626
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0061E:  MOVFF  9C,A2
00622:  MOVFF  9B,A1
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00626:  MOVF   xA8,W
00628:  SUBWF  x9C,W
0062A:  BNC   0646
0062C:  BNZ   0634
0062E:  MOVF   x9B,W
00630:  SUBWF  xA7,W
00632:  BC    0646
00634:  INCFSZ x9B,W
00636:  BRA    063E
00638:  INCFSZ x9C,W
0063A:  BRA    063E
0063C:  BRA    0646
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0063E:  MOVFF  9C,A8
00642:  MOVFF  9B,A7
.................... 			} 
.................... 			ext2_state=0; 
00646:  MOVLB  6
00648:  BCF    xC0.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0064A:  BTFSC  xC0.6
0064C:  BRA    065C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0064E:  MOVLB  1
00650:  CLRF   xEB
00652:  CLRF   xEA
.................... 			ext2_count=1; 
00654:  MOVLB  8
00656:  BSF    xE9.4
.................... 			ext2_state=1; 
00658:  MOVLB  6
0065A:  BSF    xC0.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0065C:  MOVLB  6
0065E:  BCF    xC0.5
00660:  MOVLB  8
00662:  BTFSS  xE9.5
00664:  BRA    066C
00666:  MOVLB  6
00668:  BSF    xC0.5
0066A:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0066C:  MOVLB  7
0066E:  INCF   xCB,F
.................... 	if ( 10 == tick ) { 
00670:  MOVF   xCB,W
00672:  SUBLW  0A
00674:  BNZ   067E
.................... 		tick=0; 
00676:  CLRF   xCB
.................... 		timers.now_millisecond=1; 
00678:  MOVLB  1
0067A:  BSF    xFA.2
0067C:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0067E:  BCF    F9E.1
00680:  MOVLB  0
00682:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0069E:  BRA    0686
006A0:  MOVFF  01,8E6
.................... 	current.rda2_bytes_received++; 
006A4:  MOVLB  1
006A6:  INCF   xE4,F
006A8:  BTFSC  FD8.2
006AA:  INCF   xE5,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
006AC:  DECFSZ 38,W
006AE:  BRA    06D2
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006B0:  MOVLB  2
006B2:  CLRF   xFF
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006B4:  INCFSZ xFE,W
006B6:  BRA    06BA
006B8:  BRA    06CE
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006BA:  MOVLW  FE
006BC:  ADDWF  xFE,W
006BE:  MOVWF  FE9
006C0:  MOVLW  01
006C2:  MOVWF  FEA
006C4:  BTFSC  FD8.0
006C6:  INCF   FEA,F
006C8:  MOVFF  8E6,FEF
.................... 			timers.rda2_buff_pos++; 
006CC:  INCF   xFE,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006CE:  BRA    0714
006D0:  MOVLB  1
006D2:  MOVF   38,W
006D4:  SUBLW  02
006D6:  BNZ   0716
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
006D8:  MOVLB  8
006DA:  MOVF   xE6,W
006DC:  SUBLW  0A
006DE:  BZ    06E6
006E0:  MOVF   xE6,W
006E2:  SUBLW  0D
006E4:  BNZ   06F6
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
006E6:  MOVLB  2
006E8:  MOVF   xFE,F
006EA:  BZ    06F2
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
006EC:  MOVLW  14
006EE:  MOVWF  xFF
.................... 			}  else { 
006F0:  BRA    06F2
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
006F2:  BRA    0714
006F4:  MOVLB  8
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
006F6:  MOVLB  2
006F8:  CLRF   xFF
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006FA:  INCFSZ xFE,W
006FC:  BRA    0700
006FE:  BRA    0714
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
00700:  MOVLW  FE
00702:  ADDWF  xFE,W
00704:  MOVWF  FE9
00706:  MOVLW  01
00708:  MOVWF  FEA
0070A:  BTFSC  FD8.0
0070C:  INCF   FEA,F
0070E:  MOVFF  8E6,FEF
.................... 				timers.rda2_buff_pos++; 
00712:  INCF   xFE,F
00714:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00716:  BCF    FA4.5
00718:  MOVLB  0
0071A:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
00760:  RCALL  071E
00762:  MOVFF  01,8E6
....................  
.................... 	current.rda_bytes_received++; 
00766:  MOVLB  1
00768:  INCF   xE2,F
0076A:  BTFSC  FD8.2
0076C:  INCF   xE3,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
0076E:  MOVLB  6
00770:  BTFSC  xC0.0
00772:  BRA    07CA
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00774:  MOVF   xC1,F
00776:  BNZ   0788
.................... 			modbus_serial_crc.d = 0xFFFF; 
00778:  SETF   xC3
0077A:  SETF   xC2
.................... 			modbus_rx.address = c; 
0077C:  MOVFF  8E6,6C4
.................... 			modbus_serial_state++; 
00780:  INCF   xC1,F
.................... 			modbus_rx.len = 0; 
00782:  CLRF   xC5
.................... 			modbus_rx.error=0; 
00784:  CLRF   xC7
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00786:  BRA    07B6
00788:  DECFSZ xC1,W
0078A:  BRA    0794
.................... 			modbus_rx.func = c; 
0078C:  MOVFF  8E6,6C6
.................... 			modbus_serial_state++; 
00790:  INCF   xC1,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00792:  BRA    07B6
00794:  MOVF   xC1,W
00796:  SUBLW  02
00798:  BNZ   07B6
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0079A:  INCFSZ xC5,W
0079C:  BRA    07A2
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0079E:  MOVLW  FE
007A0:  MOVWF  xC5
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
007A2:  MOVLW  C8
007A4:  ADDWF  xC5,W
007A6:  MOVWF  FE9
007A8:  MOVLW  06
007AA:  MOVWF  FEA
007AC:  BTFSC  FD8.0
007AE:  INCF   FEA,F
007B0:  MOVFF  8E6,FEF
.................... 			modbus_rx.len++; 
007B4:  INCF   xC5,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
007B6:  MOVFF  8E6,8E7
007BA:  MOVLB  0
007BC:  RCALL  0734
.................... 		modbus_enable_timeout(TRUE); 
007BE:  MOVLW  01
007C0:  MOVLB  8
007C2:  MOVWF  xE7
007C4:  MOVLB  0
007C6:  RCALL  03FC
007C8:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
007CA:  BCF    F9E.5
007CC:  MOVLB  0
007CE:  GOTO   0088
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
008CC:  MOVF   39,W
008CE:  XORLW  00
008D0:  BZ    08E8
008D2:  XORLW  01
008D4:  BZ    08F8
008D6:  XORLW  03
008D8:  BZ    0908
008DA:  XORLW  06
008DC:  BZ    0918
008DE:  XORLW  01
008E0:  BZ    0924
008E2:  XORLW  03
008E4:  BZ    0934
008E6:  BRA    0940
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
008E8:  BSF    F70.3
008EA:  MOVLW  C3
008EC:  MOVWF  F75
008EE:  MOVLW  09
008F0:  MOVWF  F76
008F2:  MOVLW  A6
008F4:  MOVWF  F72
008F6:  BRA    094C
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
008F8:  BSF    F70.3
008FA:  MOVLW  E1
008FC:  MOVWF  F75
008FE:  MOVLW  04
00900:  MOVWF  F76
00902:  MOVLW  A6
00904:  MOVWF  F72
00906:  BRA    094C
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
00908:  BSF    F70.3
0090A:  MOVLW  70
0090C:  MOVWF  F75
0090E:  MOVLW  02
00910:  MOVWF  F76
00912:  MOVLW  A6
00914:  MOVWF  F72
00916:  BRA    094C
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
00918:  BCF    F70.3
0091A:  MOVLW  26
0091C:  MOVWF  F75
0091E:  MOVLW  A6
00920:  MOVWF  F72
00922:  BRA    094C
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
00924:  BSF    F70.3
00926:  MOVLW  4D
00928:  MOVWF  F75
0092A:  MOVLW  00
0092C:  MOVWF  F76
0092E:  MOVLW  A6
00930:  MOVWF  F72
00932:  BRA    094C
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
00934:  BCF    F70.3
00936:  MOVLW  0C
00938:  MOVWF  F75
0093A:  MOVLW  A6
0093C:  MOVWF  F72
0093E:  BRA    094C
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
00940:  BCF    F70.3
00942:  MOVLW  4D
00944:  MOVWF  F75
00946:  MOVLW  A6
00948:  MOVWF  F72
0094A:  BRA    094C
.................... 	} 
.................... } 
0094C:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
0094E:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00950:  MOVLW  08
00952:  MOVWF  F61
00954:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
00956:  MOVLW  00
00958:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
0095A:  MOVLW  FF
0095C:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
0095E:  MOVLW  92
00960:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00962:  MOVLW  80
00964:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00966:  BCF    F96.0
00968:  BCF    F96.1
0096A:  BCF    F96.2
0096C:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
0096E:  MOVLB  1
00970:  CLRF   xF7
.................... 	timers.load_off_seconds=2; 
00972:  CLRF   xF9
00974:  MOVLW  02
00976:  MOVWF  xF8
.................... 	timers.now_adc_sample=0; 
00978:  BCF    xFA.0
.................... 	timers.now_adc_reset_count=0; 
0097A:  BCF    xFA.1
.................... 	timers.now_millisecond=0; 
0097C:  BCF    xFA.2
.................... 	timers.port_b=0b11111111; 
0097E:  SETF   xFB
.................... 	timers.port_c=0b11111111; 
00980:  SETF   xFC
....................  
.................... 	timers.rda2_buff_pos=0; 
00982:  MOVLB  2
00984:  CLRF   xFE
.................... 	timers.rda2_buff_gap=255; 
00986:  SETF   xFF
.................... 	timers.now_parse_rda2=0; 
00988:  MOVLB  1
0098A:  BCF    xFD.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
0098C:  MOVLB  7
0098E:  CLRF   xD6
00990:  MOVF   xD6,W
00992:  SUBLW  02
00994:  BNC   0A44
.................... 		current.pulse_period[i]=0; 
00996:  CLRF   03
00998:  MOVFF  7D6,02
0099C:  BCF    FD8.0
0099E:  RLCF   02,F
009A0:  RLCF   03,F
009A2:  MOVF   02,W
009A4:  ADDLW  97
009A6:  MOVWF  FE9
009A8:  MOVLW  00
009AA:  ADDWFC 03,W
009AC:  MOVWF  FEA
009AE:  CLRF   FEC
009B0:  MOVF   FED,F
009B2:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
009B4:  CLRF   03
009B6:  MOVFF  7D6,02
009BA:  BCF    FD8.0
009BC:  RLCF   02,F
009BE:  RLCF   03,F
009C0:  MOVF   02,W
009C2:  ADDLW  9D
009C4:  MOVWF  FE9
009C6:  MOVLW  00
009C8:  ADDWFC 03,W
009CA:  MOVWF  FEA
009CC:  SETF   FEC
009CE:  MOVF   FED,F
009D0:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
009D2:  CLRF   03
009D4:  MOVFF  7D6,02
009D8:  BCF    FD8.0
009DA:  RLCF   02,F
009DC:  RLCF   03,F
009DE:  MOVF   02,W
009E0:  ADDLW  A3
009E2:  MOVWF  FE9
009E4:  MOVLW  00
009E6:  ADDWFC 03,W
009E8:  MOVWF  FEA
009EA:  CLRF   FEC
009EC:  MOVF   FED,F
009EE:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
009F0:  CLRF   03
009F2:  MOVFF  7D6,02
009F6:  BCF    FD8.0
009F8:  RLCF   02,F
009FA:  RLCF   03,F
009FC:  MOVF   02,W
009FE:  ADDLW  A9
00A00:  MOVWF  FE9
00A02:  MOVLW  00
00A04:  ADDWFC 03,W
00A06:  MOVWF  FEA
00A08:  CLRF   FEC
00A0A:  MOVF   FED,F
00A0C:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00A0E:  MOVLB  8
00A10:  CLRF   xDB
00A12:  MOVFF  7D6,8DA
00A16:  CLRF   xDD
00A18:  MOVLW  04
00A1A:  MOVWF  xDC
00A1C:  MOVLB  0
00A1E:  RCALL  0890
00A20:  MOVF   01,W
00A22:  ADDLW  AF
00A24:  MOVWF  FE9
00A26:  MOVLW  00
00A28:  ADDWFC 02,W
00A2A:  MOVWF  FEA
00A2C:  MOVF   FEE,F
00A2E:  MOVF   FEE,F
00A30:  CLRF   FEC
00A32:  MOVF   FED,F
00A34:  CLRF   FEF
00A36:  MOVF   FED,F
00A38:  CLRF   FEF
00A3A:  MOVF   FED,F
00A3C:  CLRF   FEF
.................... 	} 
00A3E:  MOVLB  7
00A40:  INCF   xD6,F
00A42:  BRA    0990
....................  
.................... 	current.modbus_our_packets=0; 
00A44:  MOVLB  1
00A46:  CLRF   xCD
00A48:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
00A4A:  CLRF   xCF
00A4C:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
00A4E:  CLRF   xD1
00A50:  CLRF   xD0
.................... 	current.sequence_number=0; 
00A52:  CLRF   xD3
00A54:  CLRF   xD2
.................... 	current.uptime_minutes=0; 
00A56:  CLRF   xD5
00A58:  CLRF   xD4
.................... 	current.interval_milliseconds=0; 
00A5A:  CLRF   xD7
00A5C:  CLRF   xD6
.................... 	current.adc_buffer_index=0; 
00A5E:  CLRF   xCB
.................... 	current.factory_unlocked=0; 
00A60:  CLRF   xD8
.................... 	current.watchdog_seconds=0; 
00A62:  CLRF   xDA
00A64:  CLRF   xD9
.................... 	current.rda_bytes_received=0; 
00A66:  CLRF   xE3
00A68:  CLRF   xE2
.................... 	current.rda2_bytes_received=0; 
00A6A:  CLRF   xE5
00A6C:  CLRF   xE4
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
00A6E:  MOVLW  03
00A70:  MOVWF  FEA
00A72:  CLRF   FE9
00A74:  CLRF   00
00A76:  MOVWF  02
00A78:  MOVLW  C0
00A7A:  MOVWF  01
00A7C:  MOVLB  0
00A7E:  RCALL  08B2
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00A80:  MOVFF  4C,1DD
00A84:  MOVFF  4B,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
00A88:  MOVFF  48,1DF
00A8C:  MOVFF  47,1DE
.................... 	current.power_override_timeout=0; 
00A90:  MOVLB  1
00A92:  CLRF   xE1
00A94:  CLRF   xE0
....................  
.................... 	/* UART2 - RS-485 port */ 
.................... 	set_rs485_speed(); 
00A96:  MOVLB  0
00A98:  RCALL  08CC
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00A9A:  MOVLW  00
00A9C:  IORLW  05
00A9E:  MOVWF  FBA
00AA0:  MOVLW  4A
00AA2:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00AA4:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00AA6:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00AA8:  GOTO   2BDA (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
01078:  MOVLB  1
0107A:  BCF    xFA.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
0107C:  BCF    FD8.0
0107E:  MOVLB  7
01080:  RLCF   xD1,W
01082:  MOVWF  xD6
01084:  RLCF   xD2,W
01086:  MOVWF  xD7
01088:  MOVLW  00
0108A:  MOVLB  1
0108C:  BTFSS  xFC.5
0108E:  MOVLW  01
01090:  MOVLB  7
01092:  IORWF  xD6,F
01094:  MOVFF  7D6,7D1
01098:  MOVF   xD7,W
0109A:  IORLW  E0
0109C:  MOVWF  xD2
.................... 	if ( b2_state==0xf000) { 
0109E:  MOVF   xD1,F
010A0:  BNZ   10A8
010A2:  MOVF   xD2,W
010A4:  SUBLW  F0
010A6:  BNZ   10A8
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
010A8:  MOVLB  1
010AA:  INCFSZ xE6,W
010AC:  BRA    10BA
010AE:  INCFSZ xE7,W
010B0:  BRA    10BA
.................... 				current.pulse_period[0]=0; 
010B2:  MOVLB  0
010B4:  CLRF   x98
010B6:  CLRF   x97
010B8:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
010BA:  INCFSZ xE8,W
010BC:  BRA    10CA
010BE:  INCFSZ xE9,W
010C0:  BRA    10CA
.................... 				current.pulse_period[1]=0; 
010C2:  MOVLB  0
010C4:  CLRF   x9A
010C6:  CLRF   x99
010C8:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
010CA:  INCFSZ xEA,W
010CC:  BRA    10DA
010CE:  INCFSZ xEB,W
010D0:  BRA    10DA
.................... 				current.pulse_period[2]=0; 
010D2:  MOVLB  0
010D4:  CLRF   x9C
010D6:  CLRF   x9B
010D8:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
010DA:  MOVFF  F81,1FB
.................... 	timers.port_c=port_c; 
010DE:  MOVFF  F82,1FC
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
010E2:  MOVF   xF7,F
010E4:  BNZ   10EA
.................... 		output_low(LED_GREEN); 
010E6:  BCF    F89.3
.................... 	} else { 
010E8:  BRA    10EE
.................... 		output_high(LED_GREEN); 
010EA:  BSF    F89.3
.................... 		timers.led_on_green--; 
010EC:  DECF   xF7,F
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
010EE:  INCFSZ xD6,W
010F0:  BRA    10F8
010F2:  INCFSZ xD7,W
010F4:  BRA    10F8
010F6:  BRA    10FE
.................... 		current.interval_milliseconds++; 
010F8:  INCF   xD6,F
010FA:  BTFSC  FD8.2
010FC:  INCF   xD7,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
010FE:  MOVLB  7
01100:  INCF   xCF,F
01102:  BTFSC  FD8.2
01104:  INCF   xD0,F
.................... 	if ( 1000 == ticks ) { 
01106:  MOVF   xCF,W
01108:  SUBLW  E8
0110A:  BNZ   1190
0110C:  MOVF   xD0,W
0110E:  SUBLW  03
01110:  BNZ   1190
.................... 		ticks=0; 
01112:  CLRF   xD0
01114:  CLRF   xCF
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
01116:  MOVLB  1
01118:  INCFSZ xD9,W
0111A:  BRA    1122
0111C:  INCFSZ xDA,W
0111E:  BRA    1122
01120:  BRA    1128
.................... 			current.watchdog_seconds++; 
01122:  INCF   xD9,F
01124:  BTFSC  FD8.2
01126:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
01128:  MOVF   40,F
0112A:  BNZ   1130
0112C:  MOVF   41,F
0112E:  BZ    114E
01130:  MOVF   41,W
01132:  SUBWF  xDA,W
01134:  BNC   114E
01136:  BNZ   113E
01138:  MOVF   xD9,W
0113A:  SUBWF  40,W
0113C:  BC    114E
0113E:  MOVF   xF8,F
01140:  BNZ   114E
01142:  MOVF   xF9,F
01144:  BNZ   114E
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
01146:  MOVFF  43,1F9
0114A:  MOVFF  42,1F8
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
0114E:  MOVF   xF8,F
01150:  BNZ   115A
01152:  MOVF   xF9,F
01154:  BNZ   115A
.................... 			output_high(PI_POWER_EN); 
01156:  BSF    F8B.0
.................... 		} else { 
01158:  BRA    1170
.................... 			output_low(PI_POWER_EN); 
0115A:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
0115C:  MOVF   xF8,W
0115E:  BTFSC  FD8.2
01160:  DECF   xF9,F
01162:  DECF   xF8,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
01164:  MOVF   xF8,F
01166:  BNZ   1170
01168:  MOVF   xF9,F
0116A:  BNZ   1170
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
0116C:  CLRF   xDA
0116E:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
01170:  MOVLB  7
01172:  INCF   xCC,F
.................... 		if ( 60 == uptimeTicks ) { 
01174:  MOVF   xCC,W
01176:  SUBLW  3C
01178:  BNZ   1190
.................... 			uptimeTicks=0; 
0117A:  CLRF   xCC
.................... 			if ( current.uptime_minutes < 65535 )  
0117C:  MOVLB  1
0117E:  INCFSZ xD4,W
01180:  BRA    1188
01182:  INCFSZ xD5,W
01184:  BRA    1188
01186:  BRA    118E
.................... 				current.uptime_minutes++; 
01188:  INCF   xD4,F
0118A:  BTFSC  FD8.2
0118C:  INCF   xD5,F
0118E:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
01190:  INCFSZ xD3,W
01192:  BRA    11A6
01194:  INCFSZ xD4,W
01196:  BRA    11A6
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
01198:  CLRF   xEE
0119A:  MOVLB  0
0119C:  RCALL  0FF0
0119E:  MOVFF  02,7D4
011A2:  MOVFF  01,7D3
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
011A6:  MOVLB  1
011A8:  BTFSS  xFA.1
011AA:  BRA    11B4
.................... 		timers.now_adc_reset_count=0; 
011AC:  BCF    xFA.1
.................... 		adcTicks=0; 
011AE:  MOVLB  7
011B0:  CLRF   xCE
011B2:  CLRF   xCD
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
011B4:  MOVLB  7
011B6:  INCF   xCD,F
011B8:  BTFSC  FD8.2
011BA:  INCF   xCE,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
011BC:  MOVF   3D,W
011BE:  SUBWF  xCD,W
011C0:  BNZ   11D6
011C2:  MOVF   3E,W
011C4:  SUBWF  xCE,W
011C6:  BNZ   11D6
.................... 		adcTicks=0; 
011C8:  CLRF   xCE
011CA:  CLRF   xCD
.................... 		timers.now_adc_sample=1; 
011CC:  MOVLB  1
011CE:  BSF    xFA.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
011D0:  MOVLB  7
011D2:  SETF   xD4
011D4:  SETF   xD3
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
011D6:  MOVLB  2
011D8:  INCFSZ xFF,W
011DA:  BRA    11DE
011DC:  BRA    11E0
.................... 		timers.rda2_buff_gap++; 
011DE:  INCF   xFF,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
011E0:  MOVF   xFF,W
011E2:  SUBLW  09
011E4:  BC    11F0
011E6:  MOVF   xFE,F
011E8:  BZ    11F0
.................... 		timers.now_parse_rda2=1;	 
011EA:  MOVLB  1
011EC:  BSF    xFD.0
011EE:  MOVLB  2
.................... 	} 
.................... } 
011F0:  MOVLB  0
011F2:  GOTO   2D4C (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
028D2:  MOVLB  8
028D4:  CLRF   xE2
028D6:  MOVF   xE0,W
028D8:  SUBWF  xE2,W
028DA:  BC    2948
028DC:  CLRF   03
028DE:  MOVF   xE2,W
028E0:  ADDWF  xDE,W
028E2:  MOVWF  FE9
028E4:  MOVF   xDF,W
028E6:  ADDWFC 03,W
028E8:  MOVWF  FEA
028EA:  MOVF   FEF,F
028EC:  BZ    2948
028EE:  CLRF   03
028F0:  MOVF   xE2,W
028F2:  ADDWF  xDE,W
028F4:  MOVWF  FE9
028F6:  MOVF   xDF,W
028F8:  ADDWFC 03,W
028FA:  MOVWF  FEA
028FC:  MOVF   FEF,W
028FE:  SUBLW  0A
02900:  BZ    2948
02902:  CLRF   03
02904:  MOVF   xE2,W
02906:  ADDWF  xDE,W
02908:  MOVWF  FE9
0290A:  MOVF   xDF,W
0290C:  ADDWFC 03,W
0290E:  MOVWF  FEA
02910:  MOVF   FEF,W
02912:  SUBLW  0D
02914:  BZ    2948
.................... 		dest[i] = src[i]; 
02916:  CLRF   03
02918:  MOVF   xE2,W
0291A:  ADDWF  xDC,W
0291C:  MOVWF  01
0291E:  MOVF   xDD,W
02920:  ADDWFC 03,F
02922:  MOVFF  03,8E4
02926:  CLRF   03
02928:  MOVF   xE2,W
0292A:  ADDWF  xDE,W
0292C:  MOVWF  FE9
0292E:  MOVF   xDF,W
02930:  ADDWFC 03,W
02932:  MOVWF  FEA
02934:  MOVFF  FEF,8E5
02938:  MOVFF  8E4,FEA
0293C:  MOVFF  01,FE9
02940:  MOVFF  8E5,FEF
.................... 	} 
02944:  INCF   xE2,F
02946:  BRA    28D6
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
02948:  MOVF   xE1,W
0294A:  SUBWF  xE2,W
0294C:  BC    2962
.................... 		dest[i] = '\0'; 
0294E:  CLRF   03
02950:  MOVF   xE2,W
02952:  ADDWF  xDC,W
02954:  MOVWF  FE9
02956:  MOVF   xDD,W
02958:  ADDWFC 03,W
0295A:  MOVWF  FEA
0295C:  CLRF   FEF
.................... 	} 
0295E:  INCF   xE2,F
02960:  BRA    2948
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
02962:  MOVLW  01
02964:  SUBWF  xE1,W
02966:  CLRF   03
02968:  ADDWF  xDC,W
0296A:  MOVWF  FE9
0296C:  MOVF   xDD,W
0296E:  ADDWFC 03,W
02970:  MOVWF  FEA
02972:  CLRF   FEF
.................... } 
02974:  MOVLB  0
02976:  RETURN 0
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02A10:  MOVFF  2FE,8D6
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02A14:  MOVLB  2
02A16:  SETF   xFE
.................... 	memcpy(buff,timers.rda2_buff,length); 
02A18:  MOVLW  07
02A1A:  MOVWF  FEA
02A1C:  MOVLW  D6
02A1E:  MOVWF  FE9
02A20:  MOVLW  01
02A22:  MOVWF  FE2
02A24:  MOVLW  FE
02A26:  MOVWF  FE1
02A28:  MOVLB  8
02A2A:  MOVF   xD6,W
02A2C:  MOVWF  01
02A2E:  BZ    2A38
02A30:  MOVFF  FE6,FEE
02A34:  DECFSZ 01,F
02A36:  BRA    2A30
.................... 	timers.rda2_buff_gap=0; 
02A38:  MOVLB  2
02A3A:  CLRF   xFF
.................... 	timers.rda2_buff_pos=0; 
02A3C:  CLRF   xFE
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02A3E:  DECFSZ 38,W
02A40:  BRA    2A78
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02A42:  MOVLB  8
02A44:  CLRF   xD8
02A46:  CLRF   xD7
02A48:  MOVF   xD8,F
02A4A:  BNZ   2A74
02A4C:  MOVF   xD6,W
02A4E:  SUBWF  xD7,W
02A50:  BC    2A74
.................... 			fputc(buff[l],STREAM_PI); 
02A52:  MOVLW  D6
02A54:  ADDWF  xD7,W
02A56:  MOVWF  FE9
02A58:  MOVLW  07
02A5A:  ADDWFC xD8,W
02A5C:  MOVWF  FEA
02A5E:  MOVFF  FEF,8DA
02A62:  MOVF   xDA,W
02A64:  MOVLB  0
02A66:  CALL   1332
.................... 		} 
02A6A:  MOVLB  8
02A6C:  INCF   xD7,F
02A6E:  BTFSC  FD8.2
02A70:  INCF   xD8,F
02A72:  BRA    2A48
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
02A74:  BRA    2B30
02A76:  MOVLB  2
02A78:  MOVF   38,W
02A7A:  SUBLW  02
02A7C:  BNZ   2B32
.................... 		/* do something */ 
....................  
.................... 		/* put copy in 11th slot no mater what ... for debugging */ 
.................... 		strncpy_terminate_trim(nmea.sentence[11],buff,length,NMEA_SENTENCE_LENGTH); 
02A7E:  MOVLW  06
02A80:  MOVLB  8
02A82:  MOVWF  xDD
02A84:  MOVLW  70
02A86:  MOVWF  xDC
02A88:  MOVLW  07
02A8A:  MOVWF  xDF
02A8C:  MOVLW  D6
02A8E:  MOVWF  xDE
02A90:  MOVFF  8D6,8E0
02A94:  MOVLW  50
02A96:  MOVWF  xE1
02A98:  MOVLB  0
02A9A:  RCALL  28D2
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
02A9C:  MOVLB  8
02A9E:  MOVF   xD6,W
02AA0:  SUBLW  05
02AA2:  BNC   2AA6
.................... 			return; 
02AA4:  BRA    2B30
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
02AA6:  CLRF   xD9
02AA8:  MOVF   xD9,W
02AAA:  SUBLW  0B
02AAC:  BNC   2B30
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
02AAE:  MOVF   xD9,W
02AB0:  MULLW  06
02AB2:  MOVF   FF3,W
02AB4:  CLRF   03
02AB6:  ADDLW  4F
02AB8:  MOVWF  01
02ABA:  MOVLW  00
02ABC:  ADDWFC 03,F
02ABE:  MOVFF  01,8DA
02AC2:  MOVFF  03,8DB
02AC6:  MOVLW  07
02AC8:  MOVWF  xDD
02ACA:  MOVLW  D6
02ACC:  MOVWF  xDC
02ACE:  MOVFF  03,8DF
02AD2:  MOVFF  01,8DE
02AD6:  CLRF   xE1
02AD8:  MOVLW  06
02ADA:  MOVWF  xE0
02ADC:  MOVLB  0
02ADE:  BRA    2978
02AE0:  MOVF   01,F
02AE2:  BZ    2AE6
.................... 				/* no match */ 
.................... 				continue; 
02AE4:  BRA    2B2A
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
02AE6:  MOVLB  8
02AE8:  CLRF   xDB
02AEA:  MOVFF  8D9,8DA
02AEE:  CLRF   xDD
02AF0:  MOVLW  50
02AF2:  MOVWF  xDC
02AF4:  MOVLB  0
02AF6:  CALL   0890
02AFA:  MOVFF  02,03
02AFE:  MOVF   01,W
02B00:  MOVLW  03
02B02:  ADDWF  03,F
02B04:  MOVFF  01,8DA
02B08:  MOVLB  8
02B0A:  MOVFF  03,8DB
02B0E:  MOVFF  03,8DD
02B12:  MOVFF  01,8DC
02B16:  MOVLW  07
02B18:  MOVWF  xDF
02B1A:  MOVLW  D6
02B1C:  MOVWF  xDE
02B1E:  MOVFF  8D6,8E0
02B22:  MOVLW  50
02B24:  MOVWF  xE1
02B26:  MOVLB  0
02B28:  RCALL  28D2
.................... 		} 
02B2A:  MOVLB  8
02B2C:  INCF   xD9,F
02B2E:  BRA    2AA8
02B30:  MOVLB  2
.................... 	} 
.................... } 
02B32:  MOVLB  0
02B34:  GOTO   2D6A (RETURN)
....................  
....................  
.................... void main(void) { 
02B38:  CLRF   FF8
02B3A:  BCF    FF1.2
02B3C:  BSF    F9F.1
02B3E:  BCF    F9F.5
02B40:  BCF    FA5.5
02B42:  BSF    FD0.7
02B44:  BSF    07.7
02B46:  CLRF   FEA
02B48:  CLRF   FE9
02B4A:  CLRF   35
02B4C:  BCF    FB8.3
02B4E:  MOVLW  0C
02B50:  MOVWF  FAF
02B52:  MOVLW  A6
02B54:  MOVWF  FAC
02B56:  MOVLW  90
02B58:  MOVWF  FAB
02B5A:  BCF    F70.3
02B5C:  MOVLW  4D
02B5E:  MOVWF  F75
02B60:  MOVLW  A6
02B62:  MOVWF  F72
02B64:  MOVLW  90
02B66:  MOVWF  F71
02B68:  MOVLB  6
02B6A:  BCF    xC0.0
02B6C:  CLRF   xC1
02B6E:  MOVLB  7
02B70:  CLRF   xCB
02B72:  MOVLB  6
02B74:  BCF    xC0.1
02B76:  BCF    xC0.2
02B78:  BCF    xC0.3
02B7A:  BCF    xC0.4
02B7C:  BCF    xC0.5
02B7E:  BCF    xC0.6
02B80:  MOVLB  7
02B82:  CLRF   xCC
02B84:  CLRF   xCE
02B86:  CLRF   xCD
02B88:  CLRF   xD0
02B8A:  CLRF   xCF
02B8C:  CLRF   xD2
02B8E:  CLRF   xD1
02B90:  MOVF   FC1,W
02B92:  ANDLW  F0
02B94:  MOVWF  FC1
02B96:  MOVLW  00
02B98:  MOVLB  F
02B9A:  MOVWF  x38
02B9C:  MOVWF  x3C
02B9E:  MOVWF  x39
02BA0:  MOVWF  x3A
02BA2:  MOVWF  x3B
02BA4:  MOVLB  1
02BA6:  CLRF   x88
02BA8:  CLRF   F77
02BAA:  CLRF   F78
02BAC:  CLRF   F79
02BAE:  CLRF   2F
02BB0:  CLRF   30
02BB2:  MOVLB  7
02BB4:  CLRF   xC7
02BB6:  CLRF   xC8
02BB8:  CLRF   xC9
02BBA:  CLRF   xCA
02BBC:  CLRF   xD3
02BBE:  CLRF   xD4
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02BC0:  MOVF   FD0,W
02BC2:  ANDLW  0F
02BC4:  BTFSS  FD0.4
02BC6:  MOVLW  00
02BC8:  BSF    FD0.0
02BCA:  BSF    FD0.1
02BCC:  BSF    FD0.4
02BCE:  BSF    FD8.3
02BD0:  BSF    FD8.4
02BD2:  MOVWF  xD5
....................  
.................... 	init(); 
02BD4:  MOVLB  0
02BD6:  GOTO   094E
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
02BDA:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
02BDC:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
02BDE:  MOVLW  D2
02BE0:  MOVWF  FF6
02BE2:  MOVLW  07
02BE4:  MOVWF  FF7
02BE6:  MOVLW  07
02BE8:  MOVLB  7
02BEA:  MOVWF  xD6
02BEC:  MOVLB  0
02BEE:  CALL   0AAC
02BF2:  MOVLW  DE
02BF4:  MOVWF  FF6
02BF6:  MOVLW  07
02BF8:  MOVWF  FF7
02BFA:  CALL   0AD6
02BFE:  MOVLW  0D
02C00:  BTFSS  FA4.4
02C02:  BRA    2C00
02C04:  MOVWF  F73
02C06:  MOVLW  0A
02C08:  BTFSS  FA4.4
02C0A:  BRA    2C08
02C0C:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
02C0E:  MOVLW  E8
02C10:  MOVWF  FF6
02C12:  MOVLW  07
02C14:  MOVWF  FF7
02C16:  MOVLW  12
02C18:  MOVLB  7
02C1A:  MOVWF  xD6
02C1C:  MOVLB  0
02C1E:  CALL   0AAC
02C22:  MOVFF  7D5,7D6
02C26:  MOVLW  1B
02C28:  MOVLB  7
02C2A:  MOVWF  xD7
02C2C:  MOVLB  0
02C2E:  GOTO   0B24
02C32:  MOVLW  20
02C34:  BTFSS  FA4.4
02C36:  BRA    2C34
02C38:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
02C3A:  MOVLB  7
02C3C:  MOVF   xD5,W
02C3E:  XORLW  07
02C40:  MOVLB  0
02C42:  BZ    2C5E
02C44:  XORLW  0C
02C46:  BZ    2C6C
02C48:  XORLW  04
02C4A:  BZ    2C7A
02C4C:  XORLW  03
02C4E:  BZ    2C88
02C50:  XORLW  02
02C52:  BZ    2C96
02C54:  XORLW  0D
02C56:  BZ    2CA4
02C58:  XORLW  03
02C5A:  BZ    2CB2
02C5C:  BRA    2CC0
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
02C5E:  MOVLW  FE
02C60:  MOVWF  FF6
02C62:  MOVLW  07
02C64:  MOVWF  FF7
02C66:  CALL   0AD6
02C6A:  BRA    2CCC
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
02C6C:  MOVLW  0A
02C6E:  MOVWF  FF6
02C70:  MOVLW  08
02C72:  MOVWF  FF7
02C74:  CALL   0AD6
02C78:  BRA    2CCC
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
02C7A:  MOVLW  1A
02C7C:  MOVWF  FF6
02C7E:  MOVLW  08
02C80:  MOVWF  FF7
02C82:  CALL   0AD6
02C86:  BRA    2CCC
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
02C88:  MOVLW  28
02C8A:  MOVWF  FF6
02C8C:  MOVLW  08
02C8E:  MOVWF  FF7
02C90:  CALL   0AD6
02C94:  BRA    2CCC
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
02C96:  MOVLW  38
02C98:  MOVWF  FF6
02C9A:  MOVLW  08
02C9C:  MOVWF  FF7
02C9E:  CALL   0AD6
02CA2:  BRA    2CCC
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
02CA4:  MOVLW  4A
02CA6:  MOVWF  FF6
02CA8:  MOVLW  08
02CAA:  MOVWF  FF7
02CAC:  CALL   0AD6
02CB0:  BRA    2CCC
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
02CB2:  MOVLW  5A
02CB4:  MOVWF  FF6
02CB6:  MOVLW  08
02CB8:  MOVWF  FF7
02CBA:  CALL   0AD6
02CBE:  BRA    2CCC
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
02CC0:  MOVLW  6C
02CC2:  MOVWF  FF6
02CC4:  MOVLW  08
02CC6:  MOVWF  FF7
02CC8:  CALL   0AD6
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
02CCC:  MOVLW  76
02CCE:  MOVWF  FF6
02CD0:  MOVLW  08
02CD2:  MOVWF  FF7
02CD4:  CALL   0AD6
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02CD8:  GOTO   0DDC
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02CDC:  MOVF   36,W
02CDE:  SUBLW  80
02CE0:  BC    2CE6
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02CE2:  CALL   0D30
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02CE6:  BSF    FAB.7
02CE8:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02CEA:  GOTO   0E3A
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02CEE:  MOVLB  7
02CF0:  CLRF   xD5
02CF2:  MOVF   xD5,W
02CF4:  SUBLW  1D
02CF6:  BNC   2D04
.................... 		adc_update(); 
02CF8:  MOVLB  0
02CFA:  CALL   0EF8
.................... 	} 
02CFE:  MOVLB  7
02D00:  INCF   xD5,F
02D02:  BRA    2CF2
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02D04:  MOVFF  44,1DB
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
02D08:  BTFSS  F72.1
02D0A:  BRA    2D08
.................... 	output_low(RS485_DE); 
02D0C:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02D0E:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02D10:  MOVLW  7A
02D12:  MOVWF  FF6
02D14:  MOVLW  08
02D16:  MOVWF  FF7
02D18:  MOVLW  07
02D1A:  MOVWF  xD6
02D1C:  MOVLB  0
02D1E:  GOTO   0FA0
02D22:  MOVLW  86
02D24:  MOVWF  FF6
02D26:  MOVLW  08
02D28:  MOVWF  FF7
02D2A:  GOTO   0FCC
02D2E:  MOVLW  0D
02D30:  BTFSS  F9E.4
02D32:  BRA    2D30
02D34:  MOVWF  FAD
02D36:  MOVLW  0A
02D38:  BTFSS  F9E.4
02D3A:  BRA    2D38
02D3C:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02D3E:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
02D40:  MOVLB  1
02D42:  BTFSS  xFA.2
02D44:  BRA    2D4E
.................... 			periodic_millisecond(); 
02D46:  MOVLB  0
02D48:  GOTO   1078
02D4C:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02D4E:  BTFSS  xFA.0
02D50:  BRA    2D5A
.................... 			timers.now_adc_sample=0; 
02D52:  BCF    xFA.0
.................... 			adc_update(); 
02D54:  MOVLB  0
02D56:  CALL   0EF8
.................... 		} 
....................  
.................... 		modbus_process(); 
02D5A:  MOVLB  0
02D5C:  BRA    25E0
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
02D5E:  MOVLB  1
02D60:  BTFSS  xFD.0
02D62:  BRA    2D6C
.................... 			timers.now_parse_rda2=0; 
02D64:  BCF    xFD.0
.................... 			rs485_to_host(); 
02D66:  MOVLB  0
02D68:  BRA    2A10
02D6A:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
02D6C:  MOVLB  0
02D6E:  BRA    2D3E
.................... } 
02D70:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
