CCS PCH C Compiler, Version 4.135, 4375               23-Nov-15 11:49

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 11140 bytes (17%)
                         Largest free fragment is 54392
               RAM used: 2005 (51%) at main() level
                         2280 (59%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   294E
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   0410
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0760
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   069E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0442
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
0278E:  MOVLB  8
02790:  MOVF   xDF,F
02792:  BNZ   2798
02794:  MOVF   xE0,F
02796:  BZ    281C
....................       if (*s1 != *s2) 
02798:  MOVFF  8DB,FE9
0279C:  MOVFF  8DC,FEA
027A0:  MOVFF  FEF,8E1
027A4:  MOVFF  8DE,03
027A8:  MOVFF  8DD,FE9
027AC:  MOVFF  8DE,FEA
027B0:  MOVF   FEF,W
027B2:  SUBWF  xE1,W
027B4:  BZ    27E4
....................          return((*s1 <*s2) ? -1: 1); 
027B6:  MOVFF  8DC,03
027BA:  MOVFF  8DB,FE9
027BE:  MOVFF  8DC,FEA
027C2:  MOVFF  FEF,8E1
027C6:  MOVFF  8DE,03
027CA:  MOVFF  8DD,FE9
027CE:  MOVFF  8DE,FEA
027D2:  MOVF   FEF,W
027D4:  SUBWF  xE1,W
027D6:  BC    27DC
027D8:  MOVLW  FF
027DA:  BRA    27DE
027DC:  MOVLW  01
027DE:  MOVWF  01
027E0:  BRA    2820
....................       else if (*s1 == '\0') 
027E2:  BRA    27FA
027E4:  MOVFF  8DC,03
027E8:  MOVFF  8DB,FE9
027EC:  MOVFF  8DC,FEA
027F0:  MOVF   FEF,F
027F2:  BNZ   27FA
....................          return(0); 
027F4:  MOVLW  00
027F6:  MOVWF  01
027F8:  BRA    2820
027FA:  MOVFF  8DC,03
027FE:  MOVF   xDB,W
02800:  INCF   xDB,F
02802:  BTFSC  FD8.2
02804:  INCF   xDC,F
02806:  MOVFF  8DE,03
0280A:  MOVF   xDD,W
0280C:  INCF   xDD,F
0280E:  BTFSC  FD8.2
02810:  INCF   xDE,F
02812:  MOVF   xDF,W
02814:  BTFSC  FD8.2
02816:  DECF   xE0,F
02818:  DECF   xDF,F
0281A:  BRA    2790
....................    return(0); 
0281C:  MOVLW  00
0281E:  MOVWF  01
.................... } 
02820:  MOVLB  0
02822:  GOTO   28F6 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
01196:  MOVLW  05
01198:  MOVLB  7
0119A:  SUBWF  xDC,F
0119C:  BNC   11B2
0119E:  MOVLW  07
011A0:  MOVWF  FEA
011A2:  MOVLW  DC
011A4:  MOVWF  FE9
011A6:  MOVF   FEF,W
011A8:  BZ    11B2
011AA:  BRA    11AE
011AC:  CLRWDT
011AE:  DECFSZ FEF,F
011B0:  BRA    11AC
011B2:  MOVLB  0
011B4:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0071E:  BTFSS  F9E.5
00720:  BRA    071E
00722:  MOVFF  FAB,35
00726:  MOVFF  FAE,01
0072A:  BTFSS  35.1
0072C:  BRA    0732
0072E:  BCF    FAB.4
00730:  BSF    FAB.4
00732:  RETURN 0
*
012AC:  BTFSS  F9E.4
012AE:  BRA    12AC
012B0:  MOVWF  FAD
012B2:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00686:  BTFSS  FA4.5
00688:  BRA    0686
0068A:  MOVFF  F71,35
0068E:  MOVFF  F74,01
00692:  BTFSS  35.1
00694:  BRA    069A
00696:  BCF    F71.4
00698:  BSF    F71.4
0069A:  GOTO   06A0 (RETURN)
*
011B6:  BTFSS  FA4.4
011B8:  BRA    11B6
011BA:  MOVWF  F73
011BC:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00E62:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00DC2:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00DC4:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00DC6:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00DC8:  MOVLB  7
00DCA:  MOVF   xD8,F
00DCC:  BNZ   0DD4
.................... 		c=0b00011; 
00DCE:  MOVLW  03
00DD0:  MOVWF  xDC
.................... 	else if ( 1 == ch )  
00DD2:  BRA    0E1E
00DD4:  DECFSZ xD8,W
00DD6:  BRA    0DDE
.................... 		c=0b10011; 
00DD8:  MOVLW  13
00DDA:  MOVWF  xDC
.................... 	else if ( 2 == ch )  
00DDC:  BRA    0E1E
00DDE:  MOVF   xD8,W
00DE0:  SUBLW  02
00DE2:  BNZ   0DEA
.................... 		c=0b01011; 
00DE4:  MOVLW  0B
00DE6:  MOVWF  xDC
.................... 	else if ( 3 == ch )  
00DE8:  BRA    0E1E
00DEA:  MOVF   xD8,W
00DEC:  SUBLW  03
00DEE:  BNZ   0DF6
.................... 		c=0b11011; 
00DF0:  MOVLW  1B
00DF2:  MOVWF  xDC
.................... 	else if ( 4 == ch ) 
00DF4:  BRA    0E1E
00DF6:  MOVF   xD8,W
00DF8:  SUBLW  04
00DFA:  BNZ   0E02
.................... 		c=0b00111; 
00DFC:  MOVLW  07
00DFE:  MOVWF  xDC
.................... 	else if ( 5 == ch )  
00E00:  BRA    0E1E
00E02:  MOVF   xD8,W
00E04:  SUBLW  05
00E06:  BNZ   0E0E
.................... 		c=0b10111; 
00E08:  MOVLW  17
00E0A:  MOVWF  xDC
.................... 	else if ( 6 == ch ) 
00E0C:  BRA    0E1E
00E0E:  MOVF   xD8,W
00E10:  SUBLW  06
00E12:  BNZ   0E1A
.................... 		c=0b01111; 
00E14:  MOVLW  0F
00E16:  MOVWF  xDC
.................... 	else 
00E18:  BRA    0E1E
.................... 		c=0b11111; 
00E1A:  MOVLW  1F
00E1C:  MOVWF  xDC
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00E1E:  CLRF   xDB
00E20:  MOVF   xDB,W
00E22:  SUBLW  04
00E24:  BNC   0E3C
.................... 		output_low(MCP3208_CLK); 
00E26:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00E28:  BTFSC  xDC.0
00E2A:  BRA    0E30
00E2C:  BCF    F8B.5
00E2E:  BRA    0E32
00E30:  BSF    F8B.5
.................... 		c=c>>1; 
00E32:  BCF    FD8.0
00E34:  RRCF   xDC,F
.................... 		output_high(MCP3208_CLK); 
00E36:  BSF    F8B.3
.................... 	} 
00E38:  INCF   xDB,F
00E3A:  BRA    0E20
....................  
....................  
.................... 	value=0; 
00E3C:  CLRF   xDA
00E3E:  CLRF   xD9
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00E40:  CLRF   xDB
00E42:  MOVF   xDB,W
00E44:  SUBLW  0D
00E46:  BNC   0E5E
.................... 		output_low(MCP3208_CLK); 
00E48:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00E4A:  BTFSC  F82.4
00E4C:  BRA    0E52
00E4E:  BCF    FD8.0
00E50:  BRA    0E54
00E52:  BSF    FD8.0
00E54:  RLCF   xD9,F
00E56:  RLCF   xDA,F
.................... 		output_high(MCP3208_CLK); 
00E58:  BSF    F8B.3
.................... 	} 
00E5A:  INCF   xDB,F
00E5C:  BRA    0E42
....................  
.................... 	bit_clear(value,13); 
00E5E:  BCF    xDA.5
.................... 	bit_clear(value,12); 
00E60:  BCF    xDA.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00E64:  MOVFF  7D9,01
00E68:  MOVFF  7DA,02
.................... } 
00E6C:  MOVLB  0
00E6E:  GOTO   0EE0 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00F6A:  MOVLB  8
00F6C:  CLRF   xDA
00F6E:  MOVFF  7ED,8D9
00F72:  CLRF   xDC
00F74:  MOVLW  20
00F76:  MOVWF  xDB
00F78:  MOVLB  0
00F7A:  RCALL  0890
00F7C:  MOVFF  02,03
00F80:  MOVF   01,W
00F82:  ADDLW  CA
00F84:  MOVWF  01
00F86:  MOVLW  00
00F88:  ADDWFC 03,F
00F8A:  MOVFF  01,7F1
00F8E:  MOVLB  7
00F90:  MOVFF  03,7F2
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00F94:  CLRF   xEF
00F96:  CLRF   xEE
.................... 	for( i = 0; i < 16 ; i++ ) { 
00F98:  CLRF   xF0
00F9A:  MOVF   xF0,W
00F9C:  SUBLW  0F
00F9E:  BNC   0FC2
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00FA0:  BCF    FD8.0
00FA2:  RLCF   xF0,W
00FA4:  CLRF   03
00FA6:  ADDWF  xF1,W
00FA8:  MOVWF  FE9
00FAA:  MOVF   xF2,W
00FAC:  ADDWFC 03,W
00FAE:  MOVWF  FEA
00FB0:  MOVFF  FEC,03
00FB4:  MOVF   FED,F
00FB6:  MOVF   FEF,W
00FB8:  ADDWF  xEE,F
00FBA:  MOVF   03,W
00FBC:  ADDWFC xEF,F
.................... 	} 
00FBE:  INCF   xF0,F
00FC0:  BRA    0F9A
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00FC2:  MOVLW  08
00FC4:  ADDWF  xEE,W
00FC6:  MOVWF  xF3
00FC8:  MOVLW  00
00FCA:  ADDWFC xEF,W
00FCC:  MOVWF  xF4
00FCE:  RRCF   xF4,W
00FD0:  MOVWF  03
00FD2:  RRCF   xF3,W
00FD4:  MOVWF  02
00FD6:  RRCF   03,F
00FD8:  RRCF   02,F
00FDA:  RRCF   03,F
00FDC:  RRCF   02,F
00FDE:  RRCF   03,F
00FE0:  RRCF   02,F
00FE2:  MOVLW  0F
00FE4:  ANDWF  03,F
00FE6:  MOVFF  02,01
00FEA:  MOVFF  03,02
.................... } 
00FEE:  MOVLB  0
00FF0:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00E72:  MOVLB  1
00E74:  INCF   xCA,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00E76:  MOVF   xCA,W
00E78:  SUBLW  0F
00E7A:  BC    0E7E
.................... 		current.adc_buffer_index=0; 
00E7C:  CLRF   xCA
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00E7E:  MOVLB  7
00E80:  CLRF   xD5
00E82:  MOVF   xD5,W
00E84:  SUBLW  07
00E86:  BNC   0F16
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00E88:  MOVLB  8
00E8A:  CLRF   xDA
00E8C:  MOVFF  7D5,8D9
00E90:  CLRF   xDC
00E92:  MOVLW  20
00E94:  MOVWF  xDB
00E96:  MOVLB  0
00E98:  RCALL  0890
00E9A:  MOVFF  02,03
00E9E:  MOVF   01,W
00EA0:  ADDLW  34
00EA2:  MOVLB  7
00EA4:  MOVWF  xD6
00EA6:  MOVLW  00
00EA8:  ADDWFC 02,W
00EAA:  MOVWF  xD7
00EAC:  CLRF   03
00EAE:  MOVLB  1
00EB0:  MOVFF  1CA,02
00EB4:  BCF    FD8.0
00EB6:  RLCF   02,F
00EB8:  RLCF   03,F
00EBA:  MOVF   02,W
00EBC:  MOVLB  7
00EBE:  ADDWF  xD6,W
00EC0:  MOVWF  01
00EC2:  MOVF   xD7,W
00EC4:  ADDWFC 03,F
00EC6:  MOVF   01,W
00EC8:  ADDLW  96
00ECA:  MOVWF  01
00ECC:  MOVLW  00
00ECE:  ADDWFC 03,F
00ED0:  MOVFF  01,7D6
00ED4:  MOVFF  03,7D7
00ED8:  MOVFF  7D5,7D8
00EDC:  MOVLB  0
00EDE:  BRA    0DC2
00EE0:  MOVFF  7D7,FEA
00EE4:  MOVFF  7D6,FE9
00EE8:  MOVFF  02,FEC
00EEC:  MOVF   FED,F
00EEE:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00EF2:  CLRF   03
00EF4:  MOVLB  7
00EF6:  MOVFF  7D5,02
00EFA:  BCF    FD8.0
00EFC:  RLCF   02,F
00EFE:  RLCF   03,F
00F00:  MOVF   02,W
00F02:  ADDLW  BA
00F04:  MOVWF  FE9
00F06:  MOVLW  00
00F08:  ADDWFC 03,W
00F0A:  MOVWF  FEA
00F0C:  CLRF   FEC
00F0E:  MOVF   FED,F
00F10:  CLRF   FEF
....................  
.................... 	} 
00F12:  INCF   xD5,F
00F14:  BRA    0E82
.................... } 
00F16:  MOVLB  0
00F18:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00B98:  MOVF   xF2,W
00B9A:  XORWF  xF3,W
00B9C:  MOVWF  01
*
00BEA:  MOVF   xF2,W
00BEC:  XORWF  xF3,W
00BEE:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00B22:  MOVLB  7
00B24:  CLRF   xDE
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B26:  MOVFF  7DD,03
00B2A:  MOVF   xDC,W
00B2C:  BTFSC  FD8.2
00B2E:  DECF   xDD,F
00B30:  DECF   xDC,F
00B32:  MOVWF  xDF
00B34:  MOVFF  03,7E0
00B38:  MOVF   xDF,F
00B3A:  BNZ   0B40
00B3C:  MOVF   xE0,F
00B3E:  BZ    0BAA
.................... 		*data = read_eeprom( address++ ); 
00B40:  MOVFF  7DB,03
00B44:  MOVF   xDA,W
00B46:  MOVWF  FE9
00B48:  MOVFF  03,FEA
00B4C:  MOVF   xD9,W
00B4E:  MOVWF  03
00B50:  MOVF   xD8,W
00B52:  INCF   xD8,F
00B54:  BTFSC  FD8.2
00B56:  INCF   xD9,F
00B58:  MOVWF  xE1
00B5A:  MOVFF  03,7E2
00B5E:  MOVFF  FF2,7E3
00B62:  BCF    FF2.6
00B64:  BCF    FF2.7
00B66:  MOVFF  7E2,FAA
00B6A:  MOVFF  7E1,FA9
00B6E:  BCF    FA6.6
00B70:  BCF    FA6.7
00B72:  BSF    FA6.0
00B74:  MOVF   FA8,W
00B76:  BTFSC  xE3.6
00B78:  BSF    FF2.6
00B7A:  BTFSC  xE3.7
00B7C:  BSF    FF2.7
00B7E:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00B80:  MOVFF  7DB,03
00B84:  MOVF   xDA,W
00B86:  MOVWF  FE9
00B88:  MOVFF  03,FEA
00B8C:  MOVFF  FEF,7DF
00B90:  MOVFF  7DE,7F2
00B94:  MOVFF  7DF,7F3
*
00B9E:  MOVFF  01,7DE
.................... 		data++; 
00BA2:  INCF   xDA,F
00BA4:  BTFSC  FD8.2
00BA6:  INCF   xDB,F
.................... 	} 
00BA8:  BRA    0B26
.................... 	return crc; 
00BAA:  MOVFF  7DE,01
.................... } 
00BAE:  MOVLB  0
00BB0:  GOTO   0D76 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00BB4:  MOVLB  7
00BB6:  CLRF   xF0
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BB8:  MOVFF  7EF,03
00BBC:  MOVF   xEE,W
00BBE:  BTFSC  FD8.2
00BC0:  DECF   xEF,F
00BC2:  DECF   xEE,F
00BC4:  MOVWF  xF1
00BC6:  MOVFF  03,7F2
00BCA:  MOVF   xF1,F
00BCC:  BNZ   0BD2
00BCE:  MOVF   xF2,F
00BD0:  BZ    0C50
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00BD2:  MOVFF  7ED,03
00BD6:  MOVF   xEC,W
00BD8:  MOVWF  FE9
00BDA:  MOVFF  03,FEA
00BDE:  MOVFF  FEF,7F1
00BE2:  MOVFF  7F0,7F2
00BE6:  MOVFF  7F1,7F3
*
00BF0:  MOVFF  01,7F0
.................... 		write_eeprom( address++, *data++ ); 
00BF4:  MOVF   xEB,W
00BF6:  MOVWF  03
00BF8:  MOVF   xEA,W
00BFA:  INCF   xEA,F
00BFC:  BTFSC  FD8.2
00BFE:  INCF   xEB,F
00C00:  MOVWF  xF1
00C02:  MOVFF  03,7F2
00C06:  MOVF   xED,W
00C08:  MOVWF  03
00C0A:  MOVF   xEC,W
00C0C:  INCF   xEC,F
00C0E:  BTFSC  FD8.2
00C10:  INCF   xED,F
00C12:  MOVWF  FE9
00C14:  MOVFF  03,FEA
00C18:  MOVFF  FEF,7F3
00C1C:  MOVFF  7F2,FAA
00C20:  MOVFF  7F1,FA9
00C24:  MOVFF  7F3,FA8
00C28:  BCF    FA6.6
00C2A:  BCF    FA6.7
00C2C:  BSF    FA6.2
00C2E:  MOVF   FF2,W
00C30:  MOVWF  00
00C32:  BCF    FF2.6
00C34:  BCF    FF2.7
00C36:  MOVLB  F
00C38:  MOVLW  55
00C3A:  MOVWF  FA7
00C3C:  MOVLW  AA
00C3E:  MOVWF  FA7
00C40:  BSF    FA6.1
00C42:  BTFSC  FA6.1
00C44:  BRA    0C42
00C46:  BCF    FA6.2
00C48:  MOVF   00,W
00C4A:  IORWF  FF2,F
.................... 	} 
00C4C:  MOVLB  7
00C4E:  BRA    0BB8
....................  
.................... 	return crc; 
00C50:  MOVFF  7F0,01
.................... } 
00C54:  MOVLB  0
00C56:  GOTO   0C7A (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00C5A:  MOVLB  7
00C5C:  CLRF   xE9
00C5E:  MOVLW  36
00C60:  MOVWF  xE8
00C62:  CLRF   xEB
00C64:  MOVLW  02
00C66:  MOVWF  xEA
00C68:  MOVFF  7E9,7ED
00C6C:  MOVFF  7E8,7EC
00C70:  CLRF   xEF
00C72:  MOVLW  60
00C74:  MOVWF  xEE
00C76:  MOVLB  0
00C78:  BRA    0BB4
00C7A:  MOVFF  01,7E7
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00C7E:  CLRF   FAA
00C80:  CLRF   FA9
00C82:  MOVFF  7E7,FA8
00C86:  BCF    FA6.6
00C88:  BCF    FA6.7
00C8A:  BSF    FA6.2
00C8C:  MOVF   FF2,W
00C8E:  MOVWF  00
00C90:  BCF    FF2.6
00C92:  BCF    FF2.7
00C94:  MOVLB  F
00C96:  MOVLW  55
00C98:  MOVWF  FA7
00C9A:  MOVLW  AA
00C9C:  MOVWF  FA7
00C9E:  BSF    FA6.1
00CA0:  BTFSC  FA6.1
00CA2:  BRA    0CA0
00CA4:  BCF    FA6.2
00CA6:  MOVF   00,W
00CA8:  IORWF  FF2,F
.................... } 
00CAA:  MOVLB  0
00CAC:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00CAE:  MOVLW  96
00CB0:  MOVLB  1
00CB2:  MOVWF  xF6
....................  
.................... 	config.modbus_address=38; 
00CB4:  MOVLW  26
00CB6:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00CB8:  MOVLW  02
00CBA:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00CBC:  MOVLW  50
00CBE:  MOVWF  39
.................... 	config.serial_number=9876; 
00CC0:  MOVLW  26
00CC2:  MOVWF  3B
00CC4:  MOVLW  94
00CC6:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00CC8:  CLRF   3D
00CCA:  MOVLW  14
00CCC:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00CCE:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00CD0:  MOVLW  02
00CD2:  MOVWF  40
00CD4:  MOVLW  76
00CD6:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00CD8:  CLRF   42
00CDA:  MOVLW  02
00CDC:  MOVWF  41
.................... 	config.power_startup=0; 
00CDE:  CLRF   43
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00CE0:  CLRF   FEA
00CE2:  MOVLW  4E
00CE4:  MOVWF  FE9
00CE6:  CLRF   00
00CE8:  CLRF   02
00CEA:  MOVLW  48
00CEC:  MOVWF  01
00CEE:  MOVLB  0
00CF0:  RCALL  08B2
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00CF2:  CLRF   FEA
00CF4:  MOVLW  4E
00CF6:  MOVWF  FE9
00CF8:  MOVLW  00
00CFA:  CALL   017C
00CFE:  TBLRD*-
00D00:  TBLRD*+
00D02:  MOVF   FF5,W
00D04:  MOVWF  FEE
00D06:  IORLW  00
00D08:  BNZ   0D00
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00D0A:  CLRF   FEA
00D0C:  MOVLW  54
00D0E:  MOVWF  FE9
00D10:  MOVLW  00
00D12:  CALL   0194
00D16:  TBLRD*-
00D18:  TBLRD*+
00D1A:  MOVF   FF5,W
00D1C:  MOVWF  FEE
00D1E:  IORLW  00
00D20:  BNZ   0D18
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00D22:  CLRF   FEA
00D24:  MOVLW  5A
00D26:  MOVWF  FE9
00D28:  MOVLW  00
00D2A:  CALL   01AC
00D2E:  TBLRD*-
00D30:  TBLRD*+
00D32:  MOVF   FF5,W
00D34:  MOVWF  FEE
00D36:  IORLW  00
00D38:  BNZ   0D30
....................  
.................... 	strcpy(config.nmea0183_sentence[10],"$WIMDA"); 
00D3A:  CLRF   FEA
00D3C:  MOVLW  8A
00D3E:  MOVWF  FE9
00D40:  MOVLW  00
00D42:  CALL   01C4
00D46:  TBLRD*-
00D48:  TBLRD*+
00D4A:  MOVF   FF5,W
00D4C:  MOVWF  FEE
00D4E:  IORLW  00
00D50:  BNZ   0D48
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00D52:  RCALL  0C5A
....................  
.................... } 
00D54:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00D56:  MOVLB  7
00D58:  CLRF   xD7
00D5A:  MOVLW  36
00D5C:  MOVWF  xD6
00D5E:  CLRF   xD9
00D60:  MOVLW  02
00D62:  MOVWF  xD8
00D64:  MOVFF  7D7,7DB
00D68:  MOVFF  7D6,7DA
00D6C:  CLRF   xDD
00D6E:  MOVLW  60
00D70:  MOVWF  xDC
00D72:  MOVLB  0
00D74:  BRA    0B22
00D76:  MOVFF  01,7D5
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00D7A:  MOVFF  FF2,7D6
00D7E:  BCF    FF2.6
00D80:  BCF    FF2.7
00D82:  CLRF   FAA
00D84:  CLRF   FA9
00D86:  BCF    FA6.6
00D88:  BCF    FA6.7
00D8A:  BSF    FA6.0
00D8C:  MOVF   FA8,W
00D8E:  MOVLB  7
00D90:  BTFSC  xD6.6
00D92:  BSF    FF2.6
00D94:  BTFSC  xD6.7
00D96:  BSF    FF2.7
00D98:  SUBWF  xD5,W
00D9A:  BZ    0DA2
.................... 		write_default_param_file(); 
00D9C:  MOVLB  0
00D9E:  RCALL  0CAE
00DA0:  MOVLB  7
.................... 	} 
.................... } 
00DA2:  MOVLB  0
00DA4:  GOTO   2AF2 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
0130E:  BTFSS  FAC.1
01310:  BRA    130E
.................... } 
01312:  GOTO   132C (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00DA8:  BTFSS  F9E.5
00DAA:  BRA    0DB0
.................... 		fgetc(STREAM_PI); 
00DAC:  RCALL  071E
.................... 	} 
00DAE:  BRA    0DA8
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00DB0:  BSF    F9D.5
.................... } 
00DB2:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00DB4:  RCALL  0DA8
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00DB6:  MOVLW  C6
00DB8:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00DBA:  MOVLW  C0
00DBC:  IORWF  FF2,F
.................... } 
00DBE:  GOTO   2B04 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003FC:  BCF    FF2.5
.................... 	if (enable) { 
003FE:  MOVLB  8
00400:  MOVF   xE5,F
00402:  BZ    040C
.................... 		set_timer0(0); 
00404:  CLRF   FD7
00406:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00408:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
0040A:  BSF    FF2.5
.................... 	} 
.................... } 
0040C:  MOVLB  0
0040E:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
00410:  MOVLB  6
00412:  MOVF   xC0,W
00414:  SUBLW  02
00416:  BNZ   042C
00418:  MOVF   xC1,F
0041A:  BNZ   042C
0041C:  MOVF   xC2,F
0041E:  BNZ   042C
00420:  BTFSC  xBF.0
00422:  BRA    042C
....................    { 
....................       modbus_rx.len-=2; 
00424:  MOVLW  02
00426:  SUBWF  xC4,F
....................       modbus_serial_new=TRUE; 
00428:  BSF    xBF.0
....................    } 
....................    else 
0042A:  BRA    042E
....................       modbus_serial_new=FALSE; 
0042C:  BCF    xBF.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0042E:  SETF   xC2
00430:  SETF   xC1
....................    modbus_serial_state=MODBUS_GETADDY; 
00432:  CLRF   xC0
....................    modbus_enable_timeout(FALSE); 
00434:  MOVLB  8
00436:  CLRF   xE5
00438:  MOVLB  0
0043A:  RCALL  03FC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0043C:  BCF    FF2.2
0043E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00734:  MOVLB  6
00736:  MOVF   xC2,W
00738:  MOVLB  8
0073A:  XORWF  xE5,W
0073C:  MOVWF  xE6
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0073E:  CLRF   03
00740:  MOVF   xE6,W
00742:  MOVLB  0
00744:  RCALL  01DC
00746:  MOVWF  01
00748:  MOVLB  6
0074A:  MOVF   xC1,W
0074C:  XORWF  01,W
0074E:  MOVWF  xC2
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00750:  CLRF   03
00752:  MOVLB  8
00754:  MOVF   xE6,W
00756:  MOVLB  0
00758:  RCALL  02EC
0075A:  MOVFF  FE8,6C1
.................... } 
0075E:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
012B4:  MOVLB  7
012B6:  MOVF   xE7,W
012B8:  MOVLB  0
012BA:  RCALL  12AC
012BC:  CLRF   19
012BE:  BTFSC  FF2.6
012C0:  BSF    19.6
012C2:  BCF    FF2.6
012C4:  BTFSC  FF2.7
012C6:  BSF    19.7
012C8:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
012CA:  MOVFF  7E7,8E5
012CE:  CALL   0734
012D2:  BTFSC  19.6
012D4:  BSF    FF2.6
012D6:  BTFSC  19.7
012D8:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
012DA:  CLRWDT
012DC:  MOVLW  08
012DE:  MOVWF  00
012E0:  DECFSZ 00,F
012E2:  BRA    12E0
012E4:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
012E6:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
012E8:  MOVLB  6
012EA:  SETF   xC2
012EC:  SETF   xC1
....................    modbus_serial_new=FALSE; 
012EE:  BCF    xBF.0
....................  
....................    RCV_OFF(); 
012F0:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
012F2:  CLRWDT
012F4:  MOVLW  3C
012F6:  MOVWF  00
012F8:  DECFSZ 00,F
012FA:  BRA    12F8
012FC:  NOP   
....................  
....................    modbus_serial_putc(to); 
012FE:  MOVFF  7E5,7E7
01302:  MOVLB  0
01304:  RCALL  12B4
....................    modbus_serial_putc(func); 
01306:  MOVFF  7E6,7E7
0130A:  RCALL  12B4
.................... } 
0130C:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
01316:  MOVFF  6C2,7E6
....................    crc_low=modbus_serial_crc.b[0]; 
0131A:  MOVFF  6C1,7E5
....................  
....................    modbus_serial_putc(crc_high); 
0131E:  MOVFF  7E6,7E7
01322:  RCALL  12B4
....................    modbus_serial_putc(crc_low); 
01324:  MOVFF  7E5,7E7
01328:  RCALL  12B4
....................  
....................    WAIT_FOR_HW_BUFFER(); 
0132A:  BRA    130E
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
0132C:  CLRWDT
0132E:  MOVLW  3C
01330:  MOVWF  00
01332:  DECFSZ 00,F
01334:  BRA    1332
01336:  NOP   
....................  
....................  
....................    RCV_ON(); 
01338:  RCALL  0DA8
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0133A:  MOVLB  6
0133C:  SETF   xC2
0133E:  SETF   xC1
.................... } 
01340:  MOVLB  0
01342:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
01170:  MOVLB  6
01172:  BTFSC  xBF.0
01174:  BRA    117E
....................       return FALSE; 
01176:  MOVLW  00
01178:  MOVWF  01
0117A:  BRA    1190
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
0117C:  BRA    118A
0117E:  BTFSS  xC5.7
01180:  BRA    118A
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
01182:  MOVFF  6C7,6C6
....................       modbus_rx.len = 1; 
01186:  MOVLW  01
01188:  MOVWF  xC4
....................    } 
....................    modbus_serial_new=FALSE; 
0118A:  BCF    xBF.0
....................    return TRUE; 
0118C:  MOVLW  01
0118E:  MOVWF  01
.................... } 
01190:  MOVLB  0
01192:  GOTO   23FA (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02366:  MOVFF  7DD,7E5
0236A:  MOVLW  06
0236C:  MOVLB  7
0236E:  MOVWF  xE6
02370:  MOVLB  0
02372:  CALL   12E8
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02376:  MOVFF  7DF,7E2
0237A:  MOVFF  7DF,7E7
0237E:  CALL   12B4
....................    modbus_serial_putc(make8(reg_address,0)); 
02382:  MOVFF  7DE,7E2
02386:  MOVFF  7DE,7E7
0238A:  CALL   12B4
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
0238E:  MOVFF  7E1,7E2
02392:  MOVFF  7E1,7E7
02396:  CALL   12B4
....................    modbus_serial_putc(make8(reg_value,0)); 
0239A:  MOVFF  7E0,7E2
0239E:  MOVFF  7E0,7E7
023A2:  CALL   12B4
....................  
....................    modbus_serial_send_stop(); 
023A6:  CALL   1316
.................... } 
023AA:  GOTO   25DE (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
023AE:  MOVFF  7DB,7E5
023B2:  MOVLW  10
023B4:  MOVLB  7
023B6:  MOVWF  xE6
023B8:  MOVLB  0
023BA:  CALL   12E8
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
023BE:  MOVFF  7DD,7E0
023C2:  MOVFF  7DD,7E7
023C6:  CALL   12B4
....................    modbus_serial_putc(make8(start_address,0)); 
023CA:  MOVFF  7DC,7E0
023CE:  MOVFF  7DC,7E7
023D2:  CALL   12B4
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
023D6:  MOVFF  7DF,7E0
023DA:  MOVFF  7DF,7E7
023DE:  CALL   12B4
....................    modbus_serial_putc(make8(quantity,0)); 
023E2:  MOVFF  7DE,7E0
023E6:  MOVFF  7DE,7E7
023EA:  CALL   12B4
....................  
....................    modbus_serial_send_stop(); 
023EE:  CALL   1316
.................... } 
023F2:  GOTO   26A0 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01344:  MOVLB  7
01346:  MOVF   xDC,W
01348:  IORLW  80
0134A:  MOVWF  xDF
0134C:  MOVFF  7DD,7E0
01350:  MOVFF  7DB,7E5
01354:  MOVWF  xE6
01356:  MOVLB  0
01358:  RCALL  12E8
....................    modbus_serial_putc(error); 
0135A:  MOVFF  7DE,7E7
0135E:  RCALL  12B4
....................    modbus_serial_send_stop(); 
01360:  RCALL  1316
.................... } 
01362:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          53 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1012 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
0142A:  MOVLB  1
0142C:  CLRF   xCC
0142E:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
01430:  CLRF   xCE
01432:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
01434:  CLRF   xD0
01436:  CLRF   xCF
.................... } 
01438:  MOVLB  0
0143A:  GOTO   1EB8 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
013C6:  BCF    FF2.6
013C8:  BCF    FF2.7
013CA:  BTFSC  FF2.7
013CC:  BRA    13C8
....................  
.................... 	current.pulse_count[0]=0; 
013CE:  CLRF   xA9
013D0:  CLRF   xA8
.................... 	current.pulse_count[1]=0; 
013D2:  CLRF   xAB
013D4:  CLRF   xAA
.................... 	current.pulse_count[2]=0; 
013D6:  CLRF   xAD
013D8:  CLRF   xAC
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
013DA:  SETF   x9D
013DC:  SETF   x9C
.................... 	current.pulse_min_period[1]=65535; 
013DE:  SETF   x9F
013E0:  SETF   x9E
.................... 	current.pulse_min_period[2]=65535; 
013E2:  SETF   xA1
013E4:  SETF   xA0
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
013E6:  CLRF   xA3
013E8:  CLRF   xA2
.................... 	current.pulse_max_period[1]=0; 
013EA:  CLRF   xA5
013EC:  CLRF   xA4
.................... 	current.pulse_max_period[2]=0; 
013EE:  CLRF   xA7
013F0:  CLRF   xA6
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
013F2:  MOVLB  1
013F4:  CLRF   xD6
013F6:  CLRF   xD5
....................  
.................... 	enable_interrupts(GLOBAL); 
013F8:  MOVLW  C0
013FA:  IORWF  FF2,F
.................... } 
013FC:  MOVLB  0
013FE:  GOTO   1E68 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
01402:  BCF    FF2.6
01404:  BCF    FF2.7
01406:  BTFSC  FF2.7
01408:  BRA    1404
.................... 	current.pulse_sum[0]=0; 
0140A:  CLRF   xB1
0140C:  CLRF   xB0
0140E:  CLRF   xAF
01410:  CLRF   xAE
.................... 	current.pulse_sum[1]=0; 
01412:  CLRF   xB5
01414:  CLRF   xB4
01416:  CLRF   xB3
01418:  CLRF   xB2
.................... 	current.pulse_sum[2]=0; 
0141A:  CLRF   xB9
0141C:  CLRF   xB8
0141E:  CLRF   xB7
01420:  CLRF   xB6
.................... 	enable_interrupts(GLOBAL); 
01422:  MOVLW  C0
01424:  IORWF  FF2,F
.................... } 
01426:  GOTO   1E78 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01364:  BCF    FF2.6
01366:  BCF    FF2.7
01368:  BTFSC  FF2.7
0136A:  BRA    1366
.................... 	l=current.pulse_sum[ch]; 
0136C:  MOVLB  8
0136E:  CLRF   xDA
01370:  MOVFF  7ED,8D9
01374:  CLRF   xDC
01376:  MOVLW  04
01378:  MOVWF  xDB
0137A:  MOVLB  0
0137C:  CALL   0890
01380:  MOVFF  02,03
01384:  MOVF   01,W
01386:  ADDLW  AE
01388:  MOVWF  FE9
0138A:  MOVLW  00
0138C:  ADDWFC 02,W
0138E:  MOVWF  FEA
01390:  MOVFF  FEF,00
01394:  MOVFF  FEC,01
01398:  MOVFF  FEC,02
0139C:  MOVFF  FEC,03
013A0:  MOVFF  03,7F1
013A4:  MOVFF  02,7F0
013A8:  MOVFF  01,7EF
013AC:  MOVFF  00,7EE
.................... 	enable_interrupts(GLOBAL); 
013B0:  MOVLW  C0
013B2:  IORWF  FF2,F
....................  
.................... 	return l; 
013B4:  MOVFF  7EE,00
013B8:  MOVFF  7EF,01
013BC:  MOVFF  7F0,02
013C0:  MOVFF  7F1,03
.................... } 
013C4:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
0143E:  MOVLB  7
01440:  MOVF   xE8,W
01442:  SUBLW  06
01444:  BC    149A
01446:  XORLW  FF
01448:  BNZ   1450
0144A:  MOVF   xE7,W
0144C:  SUBLW  CF
0144E:  BC    149A
01450:  MOVF   xE8,W
01452:  SUBLW  09
01454:  BNC   149A
01456:  BNZ   145E
01458:  MOVF   xE7,W
0145A:  SUBLW  CF
0145C:  BNC   149A
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
0145E:  MOVLW  D0
01460:  SUBWF  xE7,W
01462:  MOVWF  xED
01464:  MOVLW  07
01466:  SUBWFB xE8,W
01468:  MOVWF  xEE
0146A:  MOVLW  02
0146C:  ADDWF  xEE,F
0146E:  MOVFF  FF2,7EF
01472:  BCF    FF2.6
01474:  BCF    FF2.7
01476:  MOVFF  7EE,FAA
0147A:  MOVFF  7ED,FA9
0147E:  BCF    FA6.6
01480:  BCF    FA6.7
01482:  BSF    FA6.0
01484:  MOVF   FA8,W
01486:  BTFSC  xEF.6
01488:  BSF    FF2.6
0148A:  BTFSC  xEF.7
0148C:  BSF    FF2.7
0148E:  CLRF   03
01490:  MOVWF  01
01492:  MOVF   03,W
01494:  MOVWF  02
01496:  GOTO   1FAA
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
0149A:  MOVF   xE8,W
0149C:  SUBLW  03
0149E:  BC    151E
014A0:  XORLW  FF
014A2:  BNZ   14AA
014A4:  MOVF   xE7,W
014A6:  SUBLW  4B
014A8:  BC    151E
014AA:  MOVF   xE8,W
014AC:  SUBLW  04
014AE:  BNC   151E
014B0:  BNZ   14B8
014B2:  MOVF   xE7,W
014B4:  SUBLW  93
014B6:  BNC   151E
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
014B8:  MOVLW  4C
014BA:  SUBWF  xE7,W
014BC:  MOVWF  xE9
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
014BE:  MOVFF  7E9,7ED
014C2:  MOVLW  06
014C4:  MOVWF  xEE
014C6:  MOVLB  0
014C8:  CALL   0A76
014CC:  MOVFF  00,7EA
.................... 		n = n / 6; /* number of sentence */ 
014D0:  MOVFF  7E9,7ED
014D4:  MOVLW  06
014D6:  MOVLB  7
014D8:  MOVWF  xEE
014DA:  MOVLB  0
014DC:  CALL   0A76
014E0:  MOVFF  01,7E9
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
014E4:  MOVLB  7
014E6:  MOVF   xE9,W
014E8:  MULLW  06
014EA:  MOVF   FF3,W
014EC:  CLRF   03
014EE:  ADDLW  18
014F0:  MOVWF  xED
014F2:  MOVLW  00
014F4:  ADDWFC 03,W
014F6:  MOVWF  xEE
014F8:  CLRF   03
014FA:  MOVF   xEA,W
014FC:  ADDWF  xED,W
014FE:  MOVWF  01
01500:  MOVF   xEE,W
01502:  ADDWFC 03,F
01504:  MOVF   01,W
01506:  ADDLW  36
01508:  MOVWF  FE9
0150A:  MOVLW  00
0150C:  ADDWFC 03,W
0150E:  MOVWF  FEA
01510:  MOVF   FEF,W
01512:  CLRF   03
01514:  MOVWF  01
01516:  MOVFF  03,02
0151A:  GOTO   1FAA
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
0151E:  MOVF   xE8,W
01520:  SUBLW  12
01522:  BC    1564
01524:  XORLW  FF
01526:  BNZ   152E
01528:  MOVF   xE7,W
0152A:  SUBLW  87
0152C:  BC    1564
0152E:  MOVF   xE8,W
01530:  SUBLW  17
01532:  BNC   1564
01534:  BNZ   153C
01536:  MOVF   xE7,W
01538:  SUBLW  47
0153A:  BNC   1564
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
0153C:  MOVLW  88
0153E:  SUBWF  xE7,F
01540:  MOVLW  13
01542:  SUBWFB xE8,F
....................  
....................  		p  = nmea.sentence[0]; 
01544:  MOVLW  02
01546:  MOVWF  xEC
01548:  SETF   xEB
.................... 		return (int16) p[addr]; 
0154A:  MOVF   xEB,W
0154C:  ADDWF  xE7,W
0154E:  MOVWF  FE9
01550:  MOVF   xEC,W
01552:  ADDWFC xE8,W
01554:  MOVWF  FEA
01556:  MOVF   FEF,W
01558:  CLRF   03
0155A:  MOVWF  01
0155C:  MOVFF  03,02
01560:  GOTO   1FAA
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
01564:  MOVF   xE8,W
01566:  SUBLW  16
01568:  BC    15D2
0156A:  XORLW  FF
0156C:  BNZ   1574
0156E:  MOVF   xE7,W
01570:  SUBLW  6F
01572:  BC    15D2
01574:  MOVF   xE8,W
01576:  SUBLW  19
01578:  BNC   15D2
0157A:  BNZ   1582
0157C:  MOVF   xE7,W
0157E:  SUBLW  4F
01580:  BNC   15D2
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01582:  MOVLW  70
01584:  SUBWF  xE7,F
01586:  MOVLW  17
01588:  SUBWFB xE8,F
.................... 		addr = addr * 2; 
0158A:  BCF    FD8.0
0158C:  RLCF   xE7,F
0158E:  RLCF   xE8,F
....................  
....................  		p  = nmea.sentence[0]; 
01590:  MOVLW  02
01592:  MOVWF  xEC
01594:  SETF   xEB
.................... 		return (int16) make16(p[addr],p[addr+1]); 
01596:  MOVF   xEB,W
01598:  ADDWF  xE7,W
0159A:  MOVWF  FE9
0159C:  MOVF   xEC,W
0159E:  ADDWFC xE8,W
015A0:  MOVWF  FEA
015A2:  MOVFF  FEF,7ED
015A6:  MOVLW  01
015A8:  ADDWF  xE7,W
015AA:  MOVWF  xEE
015AC:  MOVLW  00
015AE:  ADDWFC xE8,W
015B0:  MOVWF  xEF
015B2:  MOVF   xEB,W
015B4:  ADDWF  xEE,W
015B6:  MOVWF  FE9
015B8:  MOVF   xEC,W
015BA:  ADDWFC xEF,W
015BC:  MOVWF  FEA
015BE:  MOVFF  FEF,7F0
015C2:  MOVFF  7ED,03
015C6:  MOVFF  7F0,01
015CA:  MOVFF  7ED,02
015CE:  GOTO   1FAA
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
015D2:  MOVF   xE7,W
015D4:  MOVWF  00
015D6:  MOVF   xE8,W
015D8:  MOVWF  03
015DA:  MOVF   03,W
015DC:  BNZ   15E8
015DE:  MOVF   00,F
015E0:  MOVLB  0
015E2:  BTFSC  FD8.2
015E4:  BRA    1A24
015E6:  MOVLB  7
015E8:  MOVF   03,W
015EA:  BNZ   15F8
015EC:  MOVLW  01
015EE:  SUBWF  00,W
015F0:  MOVLB  0
015F2:  BTFSC  FD8.2
015F4:  BRA    1A32
015F6:  MOVLB  7
015F8:  MOVF   03,W
015FA:  BNZ   1608
015FC:  MOVLW  02
015FE:  SUBWF  00,W
01600:  MOVLB  0
01602:  BTFSC  FD8.2
01604:  BRA    1A40
01606:  MOVLB  7
01608:  MOVF   03,W
0160A:  BNZ   1618
0160C:  MOVLW  03
0160E:  SUBWF  00,W
01610:  MOVLB  0
01612:  BTFSC  FD8.2
01614:  BRA    1A4E
01616:  MOVLB  7
01618:  MOVF   03,W
0161A:  BNZ   1628
0161C:  MOVLW  04
0161E:  SUBWF  00,W
01620:  MOVLB  0
01622:  BTFSC  FD8.2
01624:  BRA    1A5C
01626:  MOVLB  7
01628:  MOVF   03,W
0162A:  BNZ   1638
0162C:  MOVLW  05
0162E:  SUBWF  00,W
01630:  MOVLB  0
01632:  BTFSC  FD8.2
01634:  BRA    1A82
01636:  MOVLB  7
01638:  MOVF   03,W
0163A:  BNZ   1648
0163C:  MOVLW  06
0163E:  SUBWF  00,W
01640:  MOVLB  0
01642:  BTFSC  FD8.2
01644:  BRA    1A90
01646:  MOVLB  7
01648:  MOVF   03,W
0164A:  BNZ   1658
0164C:  MOVLW  07
0164E:  SUBWF  00,W
01650:  MOVLB  0
01652:  BTFSC  FD8.2
01654:  BRA    1A9E
01656:  MOVLB  7
01658:  MOVF   03,W
0165A:  BNZ   1668
0165C:  MOVLW  08
0165E:  SUBWF  00,W
01660:  MOVLB  0
01662:  BTFSC  FD8.2
01664:  BRA    1AAC
01666:  MOVLB  7
01668:  MOVF   03,W
0166A:  BNZ   1678
0166C:  MOVLW  09
0166E:  SUBWF  00,W
01670:  MOVLB  0
01672:  BTFSC  FD8.2
01674:  BRA    1ABA
01676:  MOVLB  7
01678:  MOVF   03,W
0167A:  BNZ   1688
0167C:  MOVLW  0A
0167E:  SUBWF  00,W
01680:  MOVLB  0
01682:  BTFSC  FD8.2
01684:  BRA    1AC8
01686:  MOVLB  7
01688:  MOVF   03,W
0168A:  BNZ   1698
0168C:  MOVLW  0B
0168E:  SUBWF  00,W
01690:  MOVLB  0
01692:  BTFSC  FD8.2
01694:  BRA    1AF0
01696:  MOVLB  7
01698:  MOVF   03,W
0169A:  BNZ   16A8
0169C:  MOVLW  0C
0169E:  SUBWF  00,W
016A0:  MOVLB  0
016A2:  BTFSC  FD8.2
016A4:  BRA    1AFE
016A6:  MOVLB  7
016A8:  MOVF   03,W
016AA:  BNZ   16B8
016AC:  MOVLW  0D
016AE:  SUBWF  00,W
016B0:  MOVLB  0
016B2:  BTFSC  FD8.2
016B4:  BRA    1B0C
016B6:  MOVLB  7
016B8:  MOVF   03,W
016BA:  BNZ   16C8
016BC:  MOVLW  0E
016BE:  SUBWF  00,W
016C0:  MOVLB  0
016C2:  BTFSC  FD8.2
016C4:  BRA    1B1A
016C6:  MOVLB  7
016C8:  MOVF   03,W
016CA:  BNZ   16D8
016CC:  MOVLW  0F
016CE:  SUBWF  00,W
016D0:  MOVLB  0
016D2:  BTFSC  FD8.2
016D4:  BRA    1B28
016D6:  MOVLB  7
016D8:  MOVF   03,W
016DA:  BNZ   16E8
016DC:  MOVLW  10
016DE:  SUBWF  00,W
016E0:  MOVLB  0
016E2:  BTFSC  FD8.2
016E4:  BRA    1B36
016E6:  MOVLB  7
016E8:  MOVF   03,W
016EA:  BNZ   16F8
016EC:  MOVLW  11
016EE:  SUBWF  00,W
016F0:  MOVLB  0
016F2:  BTFSC  FD8.2
016F4:  BRA    1B5E
016F6:  MOVLB  7
016F8:  MOVF   03,W
016FA:  BNZ   1708
016FC:  MOVLW  12
016FE:  SUBWF  00,W
01700:  MOVLB  0
01702:  BTFSC  FD8.2
01704:  BRA    1B6C
01706:  MOVLB  7
01708:  MOVF   03,W
0170A:  BNZ   1718
0170C:  MOVLW  13
0170E:  SUBWF  00,W
01710:  MOVLB  0
01712:  BTFSC  FD8.2
01714:  BRA    1B9A
01716:  MOVLB  7
01718:  MOVF   03,W
0171A:  BNZ   1728
0171C:  MOVLW  14
0171E:  SUBWF  00,W
01720:  MOVLB  0
01722:  BTFSC  FD8.2
01724:  BRA    1BB2
01726:  MOVLB  7
01728:  MOVF   03,W
0172A:  BNZ   1738
0172C:  MOVLW  15
0172E:  SUBWF  00,W
01730:  MOVLB  0
01732:  BTFSC  FD8.2
01734:  BRA    1BC0
01736:  MOVLB  7
01738:  MOVF   03,W
0173A:  BNZ   1748
0173C:  MOVLW  16
0173E:  SUBWF  00,W
01740:  MOVLB  0
01742:  BTFSC  FD8.2
01744:  BRA    1BEE
01746:  MOVLB  7
01748:  MOVF   03,W
0174A:  BNZ   1758
0174C:  MOVLW  17
0174E:  SUBWF  00,W
01750:  MOVLB  0
01752:  BTFSC  FD8.2
01754:  BRA    1C08
01756:  MOVLB  7
01758:  MOVF   03,W
0175A:  BNZ   1768
0175C:  MOVLW  18
0175E:  SUBWF  00,W
01760:  MOVLB  0
01762:  BTFSC  FD8.2
01764:  BRA    1C16
01766:  MOVLB  7
01768:  MOVF   03,W
0176A:  BNZ   1778
0176C:  MOVLW  19
0176E:  SUBWF  00,W
01770:  MOVLB  0
01772:  BTFSC  FD8.2
01774:  BRA    1C44
01776:  MOVLB  7
01778:  MOVF   03,W
0177A:  BNZ   1788
0177C:  MOVLW  1A
0177E:  SUBWF  00,W
01780:  MOVLB  0
01782:  BTFSC  FD8.2
01784:  BRA    1C5E
01786:  MOVLB  7
01788:  MOVF   03,W
0178A:  BNZ   1798
0178C:  MOVLW  1B
0178E:  SUBWF  00,W
01790:  MOVLB  0
01792:  BTFSC  FD8.2
01794:  BRA    1C6C
01796:  MOVLB  7
01798:  MOVF   03,W
0179A:  BNZ   17A8
0179C:  MOVLW  1C
0179E:  SUBWF  00,W
017A0:  MOVLB  0
017A2:  BTFSC  FD8.2
017A4:  BRA    1C9A
017A6:  MOVLB  7
017A8:  MOVF   03,W
017AA:  BNZ   17B8
017AC:  MOVLW  1D
017AE:  SUBWF  00,W
017B0:  MOVLB  0
017B2:  BTFSC  FD8.2
017B4:  BRA    1CB4
017B6:  MOVLB  7
017B8:  MOVF   03,W
017BA:  BNZ   17C8
017BC:  MOVLW  1E
017BE:  SUBWF  00,W
017C0:  MOVLB  0
017C2:  BTFSC  FD8.2
017C4:  BRA    1CC2
017C6:  MOVLB  7
017C8:  MOVF   03,W
017CA:  BNZ   17D8
017CC:  MOVLW  1F
017CE:  SUBWF  00,W
017D0:  MOVLB  0
017D2:  BTFSC  FD8.2
017D4:  BRA    1CF0
017D6:  MOVLB  7
017D8:  MOVF   03,W
017DA:  BNZ   17E8
017DC:  MOVLW  20
017DE:  SUBWF  00,W
017E0:  MOVLB  0
017E2:  BTFSC  FD8.2
017E4:  BRA    1D0A
017E6:  MOVLB  7
017E8:  MOVF   03,W
017EA:  BNZ   17F8
017EC:  MOVLW  21
017EE:  SUBWF  00,W
017F0:  MOVLB  0
017F2:  BTFSC  FD8.2
017F4:  BRA    1D18
017F6:  MOVLB  7
017F8:  MOVF   03,W
017FA:  BNZ   1808
017FC:  MOVLW  22
017FE:  SUBWF  00,W
01800:  MOVLB  0
01802:  BTFSC  FD8.2
01804:  BRA    1D46
01806:  MOVLB  7
01808:  MOVF   03,W
0180A:  BNZ   1818
0180C:  MOVLW  23
0180E:  SUBWF  00,W
01810:  MOVLB  0
01812:  BTFSC  FD8.2
01814:  BRA    1D60
01816:  MOVLB  7
01818:  MOVF   03,W
0181A:  BNZ   1828
0181C:  MOVLW  24
0181E:  SUBWF  00,W
01820:  MOVLB  0
01822:  BTFSC  FD8.2
01824:  BRA    1D6E
01826:  MOVLB  7
01828:  MOVF   03,W
0182A:  BNZ   1838
0182C:  MOVLW  25
0182E:  SUBWF  00,W
01830:  MOVLB  0
01832:  BTFSC  FD8.2
01834:  BRA    1D9C
01836:  MOVLB  7
01838:  MOVF   03,W
0183A:  BNZ   1848
0183C:  MOVLW  26
0183E:  SUBWF  00,W
01840:  MOVLB  0
01842:  BTFSC  FD8.2
01844:  BRA    1DB6
01846:  MOVLB  7
01848:  MOVF   03,W
0184A:  BNZ   1858
0184C:  MOVLW  27
0184E:  SUBWF  00,W
01850:  MOVLB  0
01852:  BTFSC  FD8.2
01854:  BRA    1DC4
01856:  MOVLB  7
01858:  MOVF   03,W
0185A:  BNZ   1868
0185C:  MOVLW  28
0185E:  SUBWF  00,W
01860:  MOVLB  0
01862:  BTFSC  FD8.2
01864:  BRA    1DF2
01866:  MOVLB  7
01868:  MOVF   03,W
0186A:  BNZ   1878
0186C:  MOVLW  29
0186E:  SUBWF  00,W
01870:  MOVLB  0
01872:  BTFSC  FD8.2
01874:  BRA    1E0C
01876:  MOVLB  7
01878:  MOVF   03,W
0187A:  BNZ   1888
0187C:  MOVLW  2A
0187E:  SUBWF  00,W
01880:  MOVLB  0
01882:  BTFSC  FD8.2
01884:  BRA    1E1A
01886:  MOVLB  7
01888:  MOVF   03,W
0188A:  BNZ   1898
0188C:  MOVLW  2B
0188E:  SUBWF  00,W
01890:  MOVLB  0
01892:  BTFSC  FD8.2
01894:  BRA    1E34
01896:  MOVLB  7
01898:  MOVF   03,W
0189A:  BNZ   18A8
0189C:  MOVLW  2C
0189E:  SUBWF  00,W
018A0:  MOVLB  0
018A2:  BTFSC  FD8.2
018A4:  BRA    1E44
018A6:  MOVLB  7
018A8:  MOVF   03,W
018AA:  BNZ   18B8
018AC:  MOVLW  2D
018AE:  SUBWF  00,W
018B0:  MOVLB  0
018B2:  BTFSC  FD8.2
018B4:  BRA    1E54
018B6:  MOVLB  7
018B8:  MOVF   03,W
018BA:  BNZ   18C8
018BC:  MOVLW  2E
018BE:  SUBWF  00,W
018C0:  MOVLB  0
018C2:  BTFSC  FD8.2
018C4:  BRA    1E64
018C6:  MOVLB  7
018C8:  MOVF   03,W
018CA:  BNZ   18D8
018CC:  MOVLW  2F
018CE:  SUBWF  00,W
018D0:  MOVLB  0
018D2:  BTFSC  FD8.2
018D4:  BRA    1E74
018D6:  MOVLB  7
018D8:  MOVF   03,W
018DA:  BNZ   18E8
018DC:  MOVLW  30
018DE:  SUBWF  00,W
018E0:  MOVLB  0
018E2:  BTFSC  FD8.2
018E4:  BRA    1E84
018E6:  MOVLB  7
018E8:  MOVF   03,W
018EA:  BNZ   18F8
018EC:  MOVLW  31
018EE:  SUBWF  00,W
018F0:  MOVLB  0
018F2:  BTFSC  FD8.2
018F4:  BRA    1E94
018F6:  MOVLB  7
018F8:  MOVF   03,W
018FA:  BNZ   1908
018FC:  MOVLW  32
018FE:  SUBWF  00,W
01900:  MOVLB  0
01902:  BTFSC  FD8.2
01904:  BRA    1EA4
01906:  MOVLB  7
01908:  MOVF   03,W
0190A:  BNZ   1918
0190C:  MOVLW  33
0190E:  SUBWF  00,W
01910:  MOVLB  0
01912:  BTFSC  FD8.2
01914:  BRA    1EB4
01916:  MOVLB  7
01918:  MOVF   03,W
0191A:  BNZ   1928
0191C:  MOVLW  34
0191E:  SUBWF  00,W
01920:  MOVLB  0
01922:  BTFSC  FD8.2
01924:  BRA    1EC4
01926:  MOVLB  7
01928:  MOVF   03,W
0192A:  BNZ   1938
0192C:  MOVLW  35
0192E:  SUBWF  00,W
01930:  MOVLB  0
01932:  BTFSC  FD8.2
01934:  BRA    1ED4
01936:  MOVLB  7
01938:  MOVLW  03
0193A:  SUBWF  03,W
0193C:  BNZ   194A
0193E:  MOVLW  E8
01940:  SUBWF  00,W
01942:  MOVLB  0
01944:  BTFSC  FD8.2
01946:  BRA    1EE4
01948:  MOVLB  7
0194A:  MOVLW  03
0194C:  SUBWF  03,W
0194E:  BNZ   195C
01950:  MOVLW  E9
01952:  SUBWF  00,W
01954:  MOVLB  0
01956:  BTFSC  FD8.2
01958:  BRA    1EF4
0195A:  MOVLB  7
0195C:  MOVLW  03
0195E:  SUBWF  03,W
01960:  BNZ   196E
01962:  MOVLW  EA
01964:  SUBWF  00,W
01966:  MOVLB  0
01968:  BTFSC  FD8.2
0196A:  BRA    1F02
0196C:  MOVLB  7
0196E:  MOVLW  03
01970:  SUBWF  03,W
01972:  BNZ   1980
01974:  MOVLW  EB
01976:  SUBWF  00,W
01978:  MOVLB  0
0197A:  BTFSC  FD8.2
0197C:  BRA    1F10
0197E:  MOVLB  7
01980:  MOVLW  03
01982:  SUBWF  03,W
01984:  BNZ   1992
01986:  MOVLW  EC
01988:  SUBWF  00,W
0198A:  MOVLB  0
0198C:  BTFSC  FD8.2
0198E:  BRA    1F1E
01990:  MOVLB  7
01992:  MOVLW  03
01994:  SUBWF  03,W
01996:  BNZ   19A4
01998:  MOVLW  ED
0199A:  SUBWF  00,W
0199C:  MOVLB  0
0199E:  BTFSC  FD8.2
019A0:  BRA    1F2C
019A2:  MOVLB  7
019A4:  MOVLW  03
019A6:  SUBWF  03,W
019A8:  BNZ   19B6
019AA:  MOVLW  EE
019AC:  SUBWF  00,W
019AE:  MOVLB  0
019B0:  BTFSC  FD8.2
019B2:  BRA    1F3A
019B4:  MOVLB  7
019B6:  MOVLW  03
019B8:  SUBWF  03,W
019BA:  BNZ   19C8
019BC:  MOVLW  EF
019BE:  SUBWF  00,W
019C0:  MOVLB  0
019C2:  BTFSC  FD8.2
019C4:  BRA    1F4A
019C6:  MOVLB  7
019C8:  MOVLW  03
019CA:  SUBWF  03,W
019CC:  BNZ   19DA
019CE:  MOVLW  F0
019D0:  SUBWF  00,W
019D2:  MOVLB  0
019D4:  BTFSC  FD8.2
019D6:  BRA    1F58
019D8:  MOVLB  7
019DA:  MOVLW  03
019DC:  SUBWF  03,W
019DE:  BNZ   19EC
019E0:  MOVLW  F1
019E2:  SUBWF  00,W
019E4:  MOVLB  0
019E6:  BTFSC  FD8.2
019E8:  BRA    1F68
019EA:  MOVLB  7
019EC:  MOVLW  03
019EE:  SUBWF  03,W
019F0:  BNZ   19FE
019F2:  MOVLW  F2
019F4:  SUBWF  00,W
019F6:  MOVLB  0
019F8:  BTFSC  FD8.2
019FA:  BRA    1F76
019FC:  MOVLB  7
019FE:  MOVLW  03
01A00:  SUBWF  03,W
01A02:  BNZ   1A10
01A04:  MOVLW  F3
01A06:  SUBWF  00,W
01A08:  MOVLB  0
01A0A:  BTFSC  FD8.2
01A0C:  BRA    1F84
01A0E:  MOVLB  7
01A10:  MOVLW  03
01A12:  SUBWF  03,W
01A14:  BNZ   1A22
01A16:  MOVLW  F4
01A18:  SUBWF  00,W
01A1A:  MOVLB  0
01A1C:  BTFSC  FD8.2
01A1E:  BRA    1F94
01A20:  MOVLB  7
01A22:  BRA    1FA2
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01A24:  MOVFF  A8,01
01A28:  MOVFF  A9,02
01A2C:  MOVLB  7
01A2E:  BRA    1FAA
01A30:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01A32:  MOVF   x96,W
01A34:  MOVWF  01
01A36:  MOVF   x97,W
01A38:  MOVWF  02
01A3A:  MOVLB  7
01A3C:  BRA    1FAA
01A3E:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01A40:  MOVF   x9C,W
01A42:  MOVWF  01
01A44:  MOVF   x9D,W
01A46:  MOVWF  02
01A48:  MOVLB  7
01A4A:  BRA    1FAA
01A4C:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01A4E:  MOVF   xA2,W
01A50:  MOVWF  01
01A52:  MOVF   xA3,W
01A54:  MOVWF  02
01A56:  MOVLB  7
01A58:  BRA    1FAA
01A5A:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01A5C:  MOVLB  7
01A5E:  CLRF   xED
01A60:  MOVLB  0
01A62:  RCALL  1364
01A64:  MOVFF  03,7C9
01A68:  MOVFF  02,7C8
01A6C:  MOVFF  01,7C7
01A70:  MOVFF  00,7C6
01A74:  MOVLB  7
01A76:  MOVF   xC6,W
01A78:  MOVWF  01
01A7A:  MOVF   xC7,W
01A7C:  MOVWF  02
01A7E:  BRA    1FAA
01A80:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01A82:  MOVLB  7
01A84:  MOVF   xC8,W
01A86:  MOVWF  01
01A88:  MOVF   xC9,W
01A8A:  MOVWF  02
01A8C:  BRA    1FAA
01A8E:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01A90:  MOVF   xAA,W
01A92:  MOVWF  01
01A94:  MOVF   xAB,W
01A96:  MOVWF  02
01A98:  MOVLB  7
01A9A:  BRA    1FAA
01A9C:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01A9E:  MOVF   x98,W
01AA0:  MOVWF  01
01AA2:  MOVF   x99,W
01AA4:  MOVWF  02
01AA6:  MOVLB  7
01AA8:  BRA    1FAA
01AAA:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01AAC:  MOVF   x9E,W
01AAE:  MOVWF  01
01AB0:  MOVF   x9F,W
01AB2:  MOVWF  02
01AB4:  MOVLB  7
01AB6:  BRA    1FAA
01AB8:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01ABA:  MOVF   xA4,W
01ABC:  MOVWF  01
01ABE:  MOVF   xA5,W
01AC0:  MOVWF  02
01AC2:  MOVLB  7
01AC4:  BRA    1FAA
01AC6:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01AC8:  MOVLW  01
01ACA:  MOVLB  7
01ACC:  MOVWF  xED
01ACE:  MOVLB  0
01AD0:  RCALL  1364
01AD2:  MOVFF  03,7C9
01AD6:  MOVFF  02,7C8
01ADA:  MOVFF  01,7C7
01ADE:  MOVFF  00,7C6
01AE2:  MOVLB  7
01AE4:  MOVF   xC6,W
01AE6:  MOVWF  01
01AE8:  MOVF   xC7,W
01AEA:  MOVWF  02
01AEC:  BRA    1FAA
01AEE:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01AF0:  MOVLB  7
01AF2:  MOVF   xC8,W
01AF4:  MOVWF  01
01AF6:  MOVF   xC9,W
01AF8:  MOVWF  02
01AFA:  BRA    1FAA
01AFC:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01AFE:  MOVF   xAC,W
01B00:  MOVWF  01
01B02:  MOVF   xAD,W
01B04:  MOVWF  02
01B06:  MOVLB  7
01B08:  BRA    1FAA
01B0A:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01B0C:  MOVF   x9A,W
01B0E:  MOVWF  01
01B10:  MOVF   x9B,W
01B12:  MOVWF  02
01B14:  MOVLB  7
01B16:  BRA    1FAA
01B18:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01B1A:  MOVF   xA0,W
01B1C:  MOVWF  01
01B1E:  MOVF   xA1,W
01B20:  MOVWF  02
01B22:  MOVLB  7
01B24:  BRA    1FAA
01B26:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01B28:  MOVF   xA6,W
01B2A:  MOVWF  01
01B2C:  MOVF   xA7,W
01B2E:  MOVWF  02
01B30:  MOVLB  7
01B32:  BRA    1FAA
01B34:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01B36:  MOVLW  02
01B38:  MOVLB  7
01B3A:  MOVWF  xED
01B3C:  MOVLB  0
01B3E:  RCALL  1364
01B40:  MOVFF  03,7C9
01B44:  MOVFF  02,7C8
01B48:  MOVFF  01,7C7
01B4C:  MOVFF  00,7C6
01B50:  MOVLB  7
01B52:  MOVF   xC6,W
01B54:  MOVWF  01
01B56:  MOVF   xC7,W
01B58:  MOVWF  02
01B5A:  BRA    1FAA
01B5C:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01B5E:  MOVLB  7
01B60:  MOVF   xC8,W
01B62:  MOVWF  01
01B64:  MOVF   xC9,W
01B66:  MOVWF  02
01B68:  BRA    1FAA
01B6A:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01B6C:  CLRF   03
01B6E:  MOVLB  1
01B70:  MOVF   xCA,W
01B72:  MOVWF  02
01B74:  BCF    FD8.0
01B76:  RLCF   02,F
01B78:  RLCF   03,F
01B7A:  MOVF   02,W
01B7C:  ADDLW  CA
01B7E:  MOVWF  FE9
01B80:  MOVLW  00
01B82:  ADDWFC 03,W
01B84:  MOVWF  FEA
01B86:  MOVFF  FEC,03
01B8A:  MOVF   FED,F
01B8C:  MOVF   FEF,W
01B8E:  MOVWF  01
01B90:  MOVF   03,W
01B92:  MOVWF  02
01B94:  MOVLB  7
01B96:  BRA    1FAA
01B98:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01B9A:  MOVLB  7
01B9C:  CLRF   xED
01B9E:  MOVLB  0
01BA0:  CALL   0F6A
01BA4:  MOVF   01,W
01BA6:  MOVWF  01
01BA8:  MOVF   02,W
01BAA:  MOVWF  02
01BAC:  MOVLB  7
01BAE:  BRA    1FAA
01BB0:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01BB2:  MOVF   xBA,W
01BB4:  MOVWF  01
01BB6:  MOVF   xBB,W
01BB8:  MOVWF  02
01BBA:  MOVLB  7
01BBC:  BRA    1FAA
01BBE:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01BC0:  CLRF   03
01BC2:  MOVLB  1
01BC4:  MOVF   xCA,W
01BC6:  MOVWF  02
01BC8:  BCF    FD8.0
01BCA:  RLCF   02,F
01BCC:  RLCF   03,F
01BCE:  MOVF   02,W
01BD0:  ADDLW  EA
01BD2:  MOVWF  FE9
01BD4:  MOVLW  00
01BD6:  ADDWFC 03,W
01BD8:  MOVWF  FEA
01BDA:  MOVFF  FEC,03
01BDE:  MOVF   FED,F
01BE0:  MOVF   FEF,W
01BE2:  MOVWF  01
01BE4:  MOVF   03,W
01BE6:  MOVWF  02
01BE8:  MOVLB  7
01BEA:  BRA    1FAA
01BEC:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01BEE:  MOVLW  01
01BF0:  MOVLB  7
01BF2:  MOVWF  xED
01BF4:  MOVLB  0
01BF6:  CALL   0F6A
01BFA:  MOVF   01,W
01BFC:  MOVWF  01
01BFE:  MOVF   02,W
01C00:  MOVWF  02
01C02:  MOVLB  7
01C04:  BRA    1FAA
01C06:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01C08:  MOVF   xBC,W
01C0A:  MOVWF  01
01C0C:  MOVF   xBD,W
01C0E:  MOVWF  02
01C10:  MOVLB  7
01C12:  BRA    1FAA
01C14:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01C16:  CLRF   03
01C18:  MOVLB  1
01C1A:  MOVF   xCA,W
01C1C:  MOVWF  02
01C1E:  BCF    FD8.0
01C20:  RLCF   02,F
01C22:  RLCF   03,F
01C24:  MOVF   02,W
01C26:  ADDLW  0A
01C28:  MOVWF  FE9
01C2A:  MOVLW  01
01C2C:  ADDWFC 03,W
01C2E:  MOVWF  FEA
01C30:  MOVFF  FEC,03
01C34:  MOVF   FED,F
01C36:  MOVF   FEF,W
01C38:  MOVWF  01
01C3A:  MOVF   03,W
01C3C:  MOVWF  02
01C3E:  MOVLB  7
01C40:  BRA    1FAA
01C42:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01C44:  MOVLW  02
01C46:  MOVLB  7
01C48:  MOVWF  xED
01C4A:  MOVLB  0
01C4C:  CALL   0F6A
01C50:  MOVF   01,W
01C52:  MOVWF  01
01C54:  MOVF   02,W
01C56:  MOVWF  02
01C58:  MOVLB  7
01C5A:  BRA    1FAA
01C5C:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01C5E:  MOVF   xBE,W
01C60:  MOVWF  01
01C62:  MOVF   xBF,W
01C64:  MOVWF  02
01C66:  MOVLB  7
01C68:  BRA    1FAA
01C6A:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01C6C:  CLRF   03
01C6E:  MOVLB  1
01C70:  MOVF   xCA,W
01C72:  MOVWF  02
01C74:  BCF    FD8.0
01C76:  RLCF   02,F
01C78:  RLCF   03,F
01C7A:  MOVF   02,W
01C7C:  ADDLW  2A
01C7E:  MOVWF  FE9
01C80:  MOVLW  01
01C82:  ADDWFC 03,W
01C84:  MOVWF  FEA
01C86:  MOVFF  FEC,03
01C8A:  MOVF   FED,F
01C8C:  MOVF   FEF,W
01C8E:  MOVWF  01
01C90:  MOVF   03,W
01C92:  MOVWF  02
01C94:  MOVLB  7
01C96:  BRA    1FAA
01C98:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01C9A:  MOVLW  03
01C9C:  MOVLB  7
01C9E:  MOVWF  xED
01CA0:  MOVLB  0
01CA2:  CALL   0F6A
01CA6:  MOVF   01,W
01CA8:  MOVWF  01
01CAA:  MOVF   02,W
01CAC:  MOVWF  02
01CAE:  MOVLB  7
01CB0:  BRA    1FAA
01CB2:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01CB4:  MOVF   xC0,W
01CB6:  MOVWF  01
01CB8:  MOVF   xC1,W
01CBA:  MOVWF  02
01CBC:  MOVLB  7
01CBE:  BRA    1FAA
01CC0:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01CC2:  CLRF   03
01CC4:  MOVLB  1
01CC6:  MOVF   xCA,W
01CC8:  MOVWF  02
01CCA:  BCF    FD8.0
01CCC:  RLCF   02,F
01CCE:  RLCF   03,F
01CD0:  MOVF   02,W
01CD2:  ADDLW  4A
01CD4:  MOVWF  FE9
01CD6:  MOVLW  01
01CD8:  ADDWFC 03,W
01CDA:  MOVWF  FEA
01CDC:  MOVFF  FEC,03
01CE0:  MOVF   FED,F
01CE2:  MOVF   FEF,W
01CE4:  MOVWF  01
01CE6:  MOVF   03,W
01CE8:  MOVWF  02
01CEA:  MOVLB  7
01CEC:  BRA    1FAA
01CEE:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01CF0:  MOVLW  04
01CF2:  MOVLB  7
01CF4:  MOVWF  xED
01CF6:  MOVLB  0
01CF8:  CALL   0F6A
01CFC:  MOVF   01,W
01CFE:  MOVWF  01
01D00:  MOVF   02,W
01D02:  MOVWF  02
01D04:  MOVLB  7
01D06:  BRA    1FAA
01D08:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01D0A:  MOVF   xC2,W
01D0C:  MOVWF  01
01D0E:  MOVF   xC3,W
01D10:  MOVWF  02
01D12:  MOVLB  7
01D14:  BRA    1FAA
01D16:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01D18:  CLRF   03
01D1A:  MOVLB  1
01D1C:  MOVF   xCA,W
01D1E:  MOVWF  02
01D20:  BCF    FD8.0
01D22:  RLCF   02,F
01D24:  RLCF   03,F
01D26:  MOVF   02,W
01D28:  ADDLW  6A
01D2A:  MOVWF  FE9
01D2C:  MOVLW  01
01D2E:  ADDWFC 03,W
01D30:  MOVWF  FEA
01D32:  MOVFF  FEC,03
01D36:  MOVF   FED,F
01D38:  MOVF   FEF,W
01D3A:  MOVWF  01
01D3C:  MOVF   03,W
01D3E:  MOVWF  02
01D40:  MOVLB  7
01D42:  BRA    1FAA
01D44:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01D46:  MOVLW  05
01D48:  MOVLB  7
01D4A:  MOVWF  xED
01D4C:  MOVLB  0
01D4E:  CALL   0F6A
01D52:  MOVF   01,W
01D54:  MOVWF  01
01D56:  MOVF   02,W
01D58:  MOVWF  02
01D5A:  MOVLB  7
01D5C:  BRA    1FAA
01D5E:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01D60:  MOVF   xC4,W
01D62:  MOVWF  01
01D64:  MOVF   xC5,W
01D66:  MOVWF  02
01D68:  MOVLB  7
01D6A:  BRA    1FAA
01D6C:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01D6E:  CLRF   03
01D70:  MOVLB  1
01D72:  MOVF   xCA,W
01D74:  MOVWF  02
01D76:  BCF    FD8.0
01D78:  RLCF   02,F
01D7A:  RLCF   03,F
01D7C:  MOVF   02,W
01D7E:  ADDLW  8A
01D80:  MOVWF  FE9
01D82:  MOVLW  01
01D84:  ADDWFC 03,W
01D86:  MOVWF  FEA
01D88:  MOVFF  FEC,03
01D8C:  MOVF   FED,F
01D8E:  MOVF   FEF,W
01D90:  MOVWF  01
01D92:  MOVF   03,W
01D94:  MOVWF  02
01D96:  MOVLB  7
01D98:  BRA    1FAA
01D9A:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01D9C:  MOVLW  06
01D9E:  MOVLB  7
01DA0:  MOVWF  xED
01DA2:  MOVLB  0
01DA4:  CALL   0F6A
01DA8:  MOVF   01,W
01DAA:  MOVWF  01
01DAC:  MOVF   02,W
01DAE:  MOVWF  02
01DB0:  MOVLB  7
01DB2:  BRA    1FAA
01DB4:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01DB6:  MOVF   xC6,W
01DB8:  MOVWF  01
01DBA:  MOVF   xC7,W
01DBC:  MOVWF  02
01DBE:  MOVLB  7
01DC0:  BRA    1FAA
01DC2:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01DC4:  CLRF   03
01DC6:  MOVLB  1
01DC8:  MOVF   xCA,W
01DCA:  MOVWF  02
01DCC:  BCF    FD8.0
01DCE:  RLCF   02,F
01DD0:  RLCF   03,F
01DD2:  MOVF   02,W
01DD4:  ADDLW  AA
01DD6:  MOVWF  FE9
01DD8:  MOVLW  01
01DDA:  ADDWFC 03,W
01DDC:  MOVWF  FEA
01DDE:  MOVFF  FEC,03
01DE2:  MOVF   FED,F
01DE4:  MOVF   FEF,W
01DE6:  MOVWF  01
01DE8:  MOVF   03,W
01DEA:  MOVWF  02
01DEC:  MOVLB  7
01DEE:  BRA    1FAA
01DF0:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01DF2:  MOVLW  07
01DF4:  MOVLB  7
01DF6:  MOVWF  xED
01DF8:  MOVLB  0
01DFA:  CALL   0F6A
01DFE:  MOVF   01,W
01E00:  MOVWF  01
01E02:  MOVF   02,W
01E04:  MOVWF  02
01E06:  MOVLB  7
01E08:  BRA    1FAA
01E0A:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01E0C:  MOVF   xC8,W
01E0E:  MOVWF  01
01E10:  MOVF   xC9,W
01E12:  MOVWF  02
01E14:  MOVLB  7
01E16:  BRA    1FAA
01E18:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01E1A:  MOVLB  1
01E1C:  MOVF   xD2,W
01E1E:  MOVWF  03
01E20:  MOVF   xD1,W
01E22:  INCF   xD1,F
01E24:  BTFSC  FD8.2
01E26:  INCF   xD2,F
01E28:  MOVWF  01
01E2A:  MOVF   03,W
01E2C:  MOVWF  02
01E2E:  MOVLB  7
01E30:  BRA    1FAA
01E32:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01E34:  MOVLB  1
01E36:  MOVF   xD5,W
01E38:  MOVWF  01
01E3A:  MOVF   xD6,W
01E3C:  MOVWF  02
01E3E:  MOVLB  7
01E40:  BRA    1FAA
01E42:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01E44:  MOVLB  1
01E46:  MOVF   xD3,W
01E48:  MOVWF  01
01E4A:  MOVF   xD4,W
01E4C:  MOVWF  02
01E4E:  MOVLB  7
01E50:  BRA    1FAA
01E52:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01E54:  MOVLB  1
01E56:  MOVF   xD8,W
01E58:  MOVWF  01
01E5A:  MOVF   xD9,W
01E5C:  MOVWF  02
01E5E:  MOVLB  7
01E60:  BRA    1FAA
01E62:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01E64:  GOTO   13C6
01E68:  MOVLW  00
01E6A:  MOVWF  01
01E6C:  MOVWF  02
01E6E:  MOVLB  7
01E70:  BRA    1FAA
01E72:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01E74:  GOTO   1402
01E78:  MOVLW  00
01E7A:  MOVWF  01
01E7C:  MOVWF  02
01E7E:  MOVLB  7
01E80:  BRA    1FAA
01E82:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01E84:  MOVLB  1
01E86:  MOVF   xCB,W
01E88:  MOVWF  01
01E8A:  MOVF   xCC,W
01E8C:  MOVWF  02
01E8E:  MOVLB  7
01E90:  BRA    1FAA
01E92:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01E94:  MOVLB  1
01E96:  MOVF   xCD,W
01E98:  MOVWF  01
01E9A:  MOVF   xCE,W
01E9C:  MOVWF  02
01E9E:  MOVLB  7
01EA0:  BRA    1FAA
01EA2:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01EA4:  MOVLB  1
01EA6:  MOVF   xCF,W
01EA8:  MOVWF  01
01EAA:  MOVF   xD0,W
01EAC:  MOVWF  02
01EAE:  MOVLB  7
01EB0:  BRA    1FAA
01EB2:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01EB4:  GOTO   142A
01EB8:  MOVLW  00
01EBA:  MOVWF  01
01EBC:  MOVWF  02
01EBE:  MOVLB  7
01EC0:  BRA    1FAA
01EC2:  MOVLB  0
.................... 		case 52: return (int16) current.rda_bytes_received; 
01EC4:  MOVLB  1
01EC6:  MOVF   xE1,W
01EC8:  MOVWF  01
01ECA:  MOVF   xE2,W
01ECC:  MOVWF  02
01ECE:  MOVLB  7
01ED0:  BRA    1FAA
01ED2:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
01ED4:  MOVLB  1
01ED6:  MOVF   xE3,W
01ED8:  MOVWF  01
01EDA:  MOVF   xE4,W
01EDC:  MOVWF  02
01EDE:  MOVLB  7
01EE0:  BRA    1FAA
01EE2:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01EE4:  CLRF   03
01EE6:  MOVF   39,W
01EE8:  MOVWF  01
01EEA:  MOVF   03,W
01EEC:  MOVWF  02
01EEE:  MOVLB  7
01EF0:  BRA    1FAA
01EF2:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01EF4:  MOVF   3A,W
01EF6:  MOVWF  01
01EF8:  MOVF   3B,W
01EFA:  MOVWF  02
01EFC:  MOVLB  7
01EFE:  BRA    1FAA
01F00:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01F02:  MOVLW  50
01F04:  MOVWF  01
01F06:  MOVLW  00
01F08:  MOVWF  02
01F0A:  MOVLB  7
01F0C:  BRA    1FAA
01F0E:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01F10:  MOVLW  57
01F12:  MOVWF  01
01F14:  MOVLW  00
01F16:  MOVWF  02
01F18:  MOVLB  7
01F1A:  BRA    1FAA
01F1C:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01F1E:  MOVLW  58
01F20:  MOVWF  01
01F22:  MOVLW  00
01F24:  MOVWF  02
01F26:  MOVLB  7
01F28:  BRA    1FAA
01F2A:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01F2C:  MOVLW  01
01F2E:  MOVWF  01
01F30:  MOVLW  00
01F32:  MOVWF  02
01F34:  MOVLB  7
01F36:  BRA    1FAA
01F38:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01F3A:  CLRF   03
01F3C:  MOVF   36,W
01F3E:  MOVWF  01
01F40:  MOVF   03,W
01F42:  MOVWF  02
01F44:  MOVLB  7
01F46:  BRA    1FAA
01F48:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01F4A:  MOVF   3C,W
01F4C:  MOVWF  01
01F4E:  MOVF   3D,W
01F50:  MOVWF  02
01F52:  MOVLB  7
01F54:  BRA    1FAA
01F56:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01F58:  CLRF   03
01F5A:  MOVF   3E,W
01F5C:  MOVWF  01
01F5E:  MOVF   03,W
01F60:  MOVWF  02
01F62:  MOVLB  7
01F64:  BRA    1FAA
01F66:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01F68:  MOVF   3F,W
01F6A:  MOVWF  01
01F6C:  MOVF   40,W
01F6E:  MOVWF  02
01F70:  MOVLB  7
01F72:  BRA    1FAA
01F74:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01F76:  MOVF   41,W
01F78:  MOVWF  01
01F7A:  MOVF   42,W
01F7C:  MOVWF  02
01F7E:  MOVLB  7
01F80:  BRA    1FAA
01F82:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01F84:  CLRF   03
01F86:  MOVF   43,W
01F88:  MOVWF  01
01F8A:  MOVF   03,W
01F8C:  MOVWF  02
01F8E:  MOVLB  7
01F90:  BRA    1FAA
01F92:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01F94:  CLRF   03
01F96:  MOVF   38,W
01F98:  MOVWF  01
01F9A:  MOVF   03,W
01F9C:  MOVWF  02
01F9E:  MOVLB  7
01FA0:  BRA    1FAA
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01FA2:  MOVLW  FF
01FA4:  MOVWF  01
01FA6:  MOVWF  02
01FA8:  BRA    1FAA
.................... 	} 
....................  
.................... } 
01FAA:  MOVLB  0
01FAC:  GOTO   1FFE (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
011BE:  MOVLB  7
011C0:  MOVF   xDD,W
011C2:  SUBLW  1F
011C4:  BNZ   11DE
011C6:  MOVF   xDE,W
011C8:  SUBLW  4E
011CA:  BNZ   11DE
011CC:  MOVF   xDF,W
011CE:  SUBLW  20
011D0:  BNZ   11DE
011D2:  MOVF   xE0,W
011D4:  SUBLW  4E
011D6:  BNZ   11DE
.................... 		return 1; 
011D8:  MOVLW  01
011DA:  MOVWF  01
011DC:  BRA    12A6
....................  
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
011DE:  MOVF   xDE,W
011E0:  SUBLW  16
011E2:  BC    1202
011E4:  XORLW  FF
011E6:  BNZ   11EE
011E8:  MOVF   xDD,W
011EA:  SUBLW  6F
011EC:  BC    1202
011EE:  MOVF   xE0,W
011F0:  SUBLW  19
011F2:  BNC   1202
011F4:  BNZ   11FC
011F6:  MOVF   xDF,W
011F8:  SUBLW  50
011FA:  BNC   1202
.................... 		return 1; 
011FC:  MOVLW  01
011FE:  MOVWF  01
01200:  BRA    12A6
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
01202:  MOVF   xDE,W
01204:  SUBLW  12
01206:  BC    1226
01208:  XORLW  FF
0120A:  BNZ   1212
0120C:  MOVF   xDD,W
0120E:  SUBLW  87
01210:  BC    1226
01212:  MOVF   xE0,W
01214:  SUBLW  17
01216:  BNC   1226
01218:  BNZ   1220
0121A:  MOVF   xDF,W
0121C:  SUBLW  48
0121E:  BNC   1226
.................... 		return 1; 
01220:  MOVLW  01
01222:  MOVWF  01
01224:  BRA    12A6
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01226:  MOVF   xDE,W
01228:  SUBLW  03
0122A:  BC    124A
0122C:  XORLW  FF
0122E:  BNZ   1236
01230:  MOVF   xDD,W
01232:  SUBLW  4B
01234:  BC    124A
01236:  MOVF   xE0,W
01238:  SUBLW  04
0123A:  BNC   124A
0123C:  BNZ   1244
0123E:  MOVF   xDF,W
01240:  SUBLW  94
01242:  BNC   124A
.................... 		return 1; 
01244:  MOVLW  01
01246:  MOVWF  01
01248:  BRA    12A6
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
0124A:  MOVF   xDE,W
0124C:  SUBLW  02
0124E:  BC    126E
01250:  XORLW  FF
01252:  BNZ   125A
01254:  MOVF   xDD,W
01256:  SUBLW  E7
01258:  BC    126E
0125A:  MOVF   xE0,W
0125C:  SUBLW  03
0125E:  BNC   126E
01260:  BNZ   1268
01262:  MOVF   xDF,W
01264:  SUBLW  F5
01266:  BNC   126E
.................... 		return 1; 
01268:  MOVLW  01
0126A:  MOVWF  01
0126C:  BRA    12A6
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
0126E:  MOVF   xDE,W
01270:  SUBLW  06
01272:  BC    1292
01274:  XORLW  FF
01276:  BNZ   127E
01278:  MOVF   xDD,W
0127A:  SUBLW  CF
0127C:  BC    1292
0127E:  MOVF   xE0,W
01280:  SUBLW  09
01282:  BNC   1292
01284:  BNZ   128C
01286:  MOVF   xDF,W
01288:  SUBLW  D1
0128A:  BNC   1292
.................... 		return 1; 
0128C:  MOVLW  01
0128E:  MOVWF  01
01290:  BRA    12A6
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01292:  MOVF   xE0,F
01294:  BNZ   12A2
01296:  MOVF   xDF,W
01298:  SUBLW  36
0129A:  BNC   12A2
.................... 		return 1; 
0129C:  MOVLW  01
0129E:  MOVWF  01
012A0:  BRA    12A6
....................  
.................... 	return 0; 
012A2:  MOVLW  00
012A4:  MOVWF  01
.................... } 
012A6:  MOVLB  0
012A8:  GOTO   252A (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01FB0:  MOVFF  7DC,7E5
01FB4:  MOVFF  7DB,7E6
01FB8:  CALL   12E8
.................... 	modbus_serial_putc(register_count*2); 
01FBC:  BCF    FD8.0
01FBE:  MOVLB  7
01FC0:  RLCF   xDF,W
01FC2:  MOVWF  xE5
01FC4:  RLCF   xE0,W
01FC6:  MOVWF  xE6
01FC8:  MOVFF  7E5,7E7
01FCC:  MOVLB  0
01FCE:  CALL   12B4
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01FD2:  MOVLB  7
01FD4:  CLRF   xE2
01FD6:  CLRF   xE1
01FD8:  MOVF   xE2,W
01FDA:  SUBWF  xE0,W
01FDC:  BNC   2028
01FDE:  BNZ   1FE6
01FE0:  MOVF   xDF,W
01FE2:  SUBWF  xE1,W
01FE4:  BC    2028
.................... 		l=map_modbus(start_address+i); 
01FE6:  MOVF   xE1,W
01FE8:  ADDWF  xDD,W
01FEA:  MOVWF  xE5
01FEC:  MOVF   xE2,W
01FEE:  ADDWFC xDE,W
01FF0:  MOVWF  xE6
01FF2:  MOVWF  xE8
01FF4:  MOVFF  7E5,7E7
01FF8:  MOVLB  0
01FFA:  GOTO   143E
01FFE:  MOVFF  02,7E4
02002:  MOVFF  01,7E3
.................... 		modbus_serial_putc(make8(l,1)); 
02006:  MOVFF  7E4,7E5
0200A:  MOVFF  7E4,7E7
0200E:  CALL   12B4
....................   		modbus_serial_putc(make8(l,0)); 
02012:  MOVFF  7E3,7E5
02016:  MOVFF  7E3,7E7
0201A:  CALL   12B4
.................... 	} 
0201E:  MOVLB  7
02020:  INCF   xE1,F
02022:  BTFSC  FD8.2
02024:  INCF   xE2,F
02026:  BRA    1FD8
....................  
.................... 	modbus_serial_send_stop(); 
02028:  MOVLB  0
0202A:  CALL   1316
.................... } 
0202E:  GOTO   256C (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
02032:  MOVLB  7
02034:  MOVF   xE2,W
02036:  SUBLW  06
02038:  BC    20B0
0203A:  XORLW  FF
0203C:  BNZ   2044
0203E:  MOVF   xE1,W
02040:  SUBLW  CF
02042:  BC    20B0
02044:  MOVF   xE2,W
02046:  SUBLW  09
02048:  BNC   20B0
0204A:  BNZ   2052
0204C:  MOVF   xE1,W
0204E:  SUBLW  CF
02050:  BNC   20B0
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02052:  MOVF   xE4,W
02054:  SUBLW  00
02056:  BC    2068
02058:  XORLW  FF
0205A:  BNZ   2062
0205C:  MOVF   xE3,W
0205E:  SUBLW  00
02060:  BC    2068
02062:  MOVLW  03
02064:  MOVWF  01
02066:  BRA    2362
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
02068:  MOVLW  D0
0206A:  SUBWF  xE1,W
0206C:  MOVWF  xE7
0206E:  MOVLW  07
02070:  SUBWFB xE2,W
02072:  MOVWF  xE8
02074:  MOVLW  02
02076:  ADDWF  xE8,F
02078:  MOVFF  7E8,FAA
0207C:  MOVFF  7E7,FA9
02080:  MOVFF  7E3,FA8
02084:  BCF    FA6.6
02086:  BCF    FA6.7
02088:  BSF    FA6.2
0208A:  MOVF   FF2,W
0208C:  MOVWF  00
0208E:  BCF    FF2.6
02090:  BCF    FF2.7
02092:  MOVLB  F
02094:  MOVLW  55
02096:  MOVWF  FA7
02098:  MOVLW  AA
0209A:  MOVWF  FA7
0209C:  BSF    FA6.1
0209E:  BTFSC  FA6.1
020A0:  BRA    209E
020A2:  BCF    FA6.2
020A4:  MOVF   00,W
020A6:  IORWF  FF2,F
.................... 		return 0; 
020A8:  MOVLW  00
020AA:  MOVWF  01
020AC:  MOVLB  7
020AE:  BRA    2362
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
020B0:  MOVF   xE2,W
020B2:  SUBLW  03
020B4:  BC    2146
020B6:  XORLW  FF
020B8:  BNZ   20C0
020BA:  MOVF   xE1,W
020BC:  SUBLW  4B
020BE:  BC    2146
020C0:  MOVF   xE2,W
020C2:  SUBLW  04
020C4:  BNC   2146
020C6:  BNZ   20CE
020C8:  MOVF   xE1,W
020CA:  SUBLW  93
020CC:  BNC   2146
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
020CE:  MOVF   xE4,W
020D0:  SUBLW  00
020D2:  BC    20E4
020D4:  XORLW  FF
020D6:  BNZ   20DE
020D8:  MOVF   xE3,W
020DA:  SUBLW  00
020DC:  BC    20E4
020DE:  MOVLW  03
020E0:  MOVWF  01
020E2:  BRA    2362
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
020E4:  MOVLW  4C
020E6:  SUBWF  xE1,W
020E8:  MOVWF  xE5
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
020EA:  MOVFF  7E5,7ED
020EE:  MOVLW  06
020F0:  MOVWF  xEE
020F2:  MOVLB  0
020F4:  CALL   0A76
020F8:  MOVFF  00,7E6
.................... 		n = n / 6; /* number of sentence */ 
020FC:  MOVFF  7E5,7ED
02100:  MOVLW  06
02102:  MOVLB  7
02104:  MOVWF  xEE
02106:  MOVLB  0
02108:  CALL   0A76
0210C:  MOVFF  01,7E5
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
02110:  MOVLB  7
02112:  MOVF   xE5,W
02114:  MULLW  06
02116:  MOVF   FF3,W
02118:  CLRF   03
0211A:  ADDLW  18
0211C:  MOVWF  xE7
0211E:  MOVLW  00
02120:  ADDWFC 03,W
02122:  MOVWF  xE8
02124:  CLRF   03
02126:  MOVF   xE6,W
02128:  ADDWF  xE7,W
0212A:  MOVWF  01
0212C:  MOVF   xE8,W
0212E:  ADDWFC 03,F
02130:  MOVF   01,W
02132:  ADDLW  36
02134:  MOVWF  FE9
02136:  MOVLW  00
02138:  ADDWFC 03,W
0213A:  MOVWF  FEA
0213C:  MOVFF  7E3,FEF
.................... 		 
.................... 		return 0; 
02140:  MOVLW  00
02142:  MOVWF  01
02144:  BRA    2362
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
02146:  MOVLB  1
02148:  MOVF   xD7,F
0214A:  BZ    2182
.................... 		if ( 1000 == address ) { 
0214C:  MOVLB  7
0214E:  MOVF   xE1,W
02150:  SUBLW  E8
02152:  BNZ   2166
02154:  MOVF   xE2,W
02156:  SUBLW  03
02158:  BNZ   2166
.................... 			config.serial_prefix=value; 
0215A:  MOVFF  7E3,39
.................... 			return 0; 
0215E:  MOVLW  00
02160:  MOVWF  01
02162:  BRA    2362
.................... 		} else if ( 1001 == address ) { 
02164:  BRA    2180
02166:  MOVF   xE1,W
02168:  SUBLW  E9
0216A:  BNZ   2180
0216C:  MOVF   xE2,W
0216E:  SUBLW  03
02170:  BNZ   2180
.................... 			config.serial_number=value; 
02172:  MOVFF  7E4,3B
02176:  MOVFF  7E3,3A
.................... 			return 0; 
0217A:  MOVLW  00
0217C:  MOVWF  01
0217E:  BRA    2362
02180:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
02182:  MOVLB  7
02184:  MOVF   xE1,W
02186:  MOVWF  00
02188:  MOVF   xE2,W
0218A:  MOVWF  03
0218C:  MOVLW  03
0218E:  SUBWF  03,W
02190:  BNZ   219C
02192:  MOVLW  EE
02194:  SUBWF  00,W
02196:  MOVLB  0
02198:  BZ    2252
0219A:  MOVLB  7
0219C:  MOVLW  03
0219E:  SUBWF  03,W
021A0:  BNZ   21AE
021A2:  MOVLW  EF
021A4:  SUBWF  00,W
021A6:  MOVLB  0
021A8:  BTFSC  FD8.2
021AA:  BRA    226A
021AC:  MOVLB  7
021AE:  MOVLW  03
021B0:  SUBWF  03,W
021B2:  BNZ   21C0
021B4:  MOVLW  F0
021B6:  SUBWF  00,W
021B8:  MOVLB  0
021BA:  BTFSC  FD8.2
021BC:  BRA    227A
021BE:  MOVLB  7
021C0:  MOVLW  03
021C2:  SUBWF  03,W
021C4:  BNZ   21D2
021C6:  MOVLW  F1
021C8:  SUBWF  00,W
021CA:  MOVLB  0
021CC:  BTFSC  FD8.2
021CE:  BRA    2292
021D0:  MOVLB  7
021D2:  MOVLW  03
021D4:  SUBWF  03,W
021D6:  BNZ   21E4
021D8:  MOVLW  F2
021DA:  SUBWF  00,W
021DC:  MOVLB  0
021DE:  BTFSC  FD8.2
021E0:  BRA    229E
021E2:  MOVLB  7
021E4:  MOVLW  03
021E6:  SUBWF  03,W
021E8:  BNZ   21F6
021EA:  MOVLW  F3
021EC:  SUBWF  00,W
021EE:  MOVLB  0
021F0:  BTFSC  FD8.2
021F2:  BRA    22B8
021F4:  MOVLB  7
021F6:  MOVLW  03
021F8:  SUBWF  03,W
021FA:  BNZ   2208
021FC:  MOVLW  F4
021FE:  SUBWF  00,W
02200:  MOVLB  0
02202:  BTFSC  FD8.2
02204:  BRA    22D0
02206:  MOVLB  7
02208:  MOVLW  07
0220A:  SUBWF  03,W
0220C:  BNZ   221A
0220E:  MOVLW  CD
02210:  SUBWF  00,W
02212:  MOVLB  0
02214:  BTFSC  FD8.2
02216:  BRA    22E8
02218:  MOVLB  7
0221A:  MOVLW  07
0221C:  SUBWF  03,W
0221E:  BNZ   222C
02220:  MOVLW  CE
02222:  SUBWF  00,W
02224:  MOVLB  0
02226:  BTFSC  FD8.2
02228:  BRA    22FC
0222A:  MOVLB  7
0222C:  MOVLW  07
0222E:  SUBWF  03,W
02230:  BNZ   223E
02232:  MOVLW  CF
02234:  SUBWF  00,W
02236:  MOVLB  0
02238:  BTFSC  FD8.2
0223A:  BRA    2316
0223C:  MOVLB  7
0223E:  MOVLW  4E
02240:  SUBWF  03,W
02242:  BNZ   2250
02244:  MOVLW  1F
02246:  SUBWF  00,W
02248:  MOVLB  0
0224A:  BTFSC  FD8.2
0224C:  BRA    2330
0224E:  MOVLB  7
02250:  BRA    2358
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
02252:  MOVLB  7
02254:  MOVF   xE4,F
02256:  BNZ   225E
02258:  MOVF   xE3,W
0225A:  SUBLW  80
0225C:  BC    2264
0225E:  MOVLW  03
02260:  MOVWF  01
02262:  BRA    2362
.................... 			config.modbus_address=value; 
02264:  MOVFF  7E3,36
.................... 			break; 
02268:  BRA    235E
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
0226A:  MOVLB  1
0226C:  BSF    xF9.1
.................... 			config.adc_sample_ticks=value; 
0226E:  MOVFF  7E4,3D
02272:  MOVFF  7E3,3C
.................... 			break; 
02276:  MOVLB  7
02278:  BRA    235E
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
0227A:  MOVLB  7
0227C:  MOVF   xE4,F
0227E:  BNZ   2286
02280:  MOVF   xE3,W
02282:  SUBLW  01
02284:  BC    228C
02286:  MOVLW  03
02288:  MOVWF  01
0228A:  BRA    2362
.................... 			config.allow_bootload_request=value; 
0228C:  MOVFF  7E3,3E
.................... 			break; 
02290:  BRA    235E
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
02292:  MOVFF  7E4,40
02296:  MOVFF  7E3,3F
.................... 			break; 
0229A:  MOVLB  7
0229C:  BRA    235E
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
0229E:  MOVLB  7
022A0:  MOVF   xE3,F
022A2:  BNZ   22AE
022A4:  MOVF   xE4,F
022A6:  BNZ   22AE
022A8:  MOVLW  03
022AA:  MOVWF  01
022AC:  BRA    2362
.................... 			config.pi_offtime_seconds=value; 
022AE:  MOVFF  7E4,42
022B2:  MOVFF  7E3,41
.................... 			break; 
022B6:  BRA    235E
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
022B8:  MOVLB  7
022BA:  MOVF   xE4,F
022BC:  BNZ   22C4
022BE:  MOVF   xE3,W
022C0:  SUBLW  01
022C2:  BC    22CA
022C4:  MOVLW  03
022C6:  MOVWF  01
022C8:  BRA    2362
.................... 			config.power_startup=value; 
022CA:  MOVFF  7E3,43
.................... 			break; 
022CE:  BRA    235E
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
022D0:  MOVLB  7
022D2:  MOVF   xE4,F
022D4:  BNZ   22DC
022D6:  MOVF   xE3,W
022D8:  SUBLW  02
022DA:  BC    22E2
022DC:  MOVLW  03
022DE:  MOVWF  01
022E0:  BRA    2362
.................... 			config.rs485_port_mode=value; 
022E2:  MOVFF  7E3,38
.................... 			break; 
022E6:  BRA    235E
.................... 		 
....................  
....................  
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
022E8:  MOVLB  7
022EA:  DECFSZ xE3,W
022EC:  BRA    22F2
022EE:  MOVF   xE4,F
022F0:  BZ    22F8
022F2:  MOVLW  03
022F4:  MOVWF  01
022F6:  BRA    2362
.................... 			reset_cpu(); 
022F8:  RESET
022FA:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
022FC:  MOVLB  7
022FE:  DECFSZ xE3,W
02300:  BRA    2306
02302:  MOVF   xE4,F
02304:  BZ    230C
02306:  MOVLW  03
02308:  MOVWF  01
0230A:  BRA    2362
.................... 			write_default_param_file(); 
0230C:  MOVLB  0
0230E:  CALL   0CAE
.................... 			break; 
02312:  MOVLB  7
02314:  BRA    235E
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02316:  MOVLB  7
02318:  DECFSZ xE3,W
0231A:  BRA    2320
0231C:  MOVF   xE4,F
0231E:  BZ    2326
02320:  MOVLW  03
02322:  MOVWF  01
02324:  BRA    2362
.................... 			write_param_file(); 
02326:  MOVLB  0
02328:  CALL   0C5A
.................... 			break; 
0232C:  MOVLB  7
0232E:  BRA    235E
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
02330:  MOVLB  7
02332:  MOVF   xE3,W
02334:  SUBLW  0A
02336:  BNZ   233E
02338:  MOVF   xE4,W
0233A:  SUBLW  07
0233C:  BZ    234A
.................... 				current.factory_unlocked=0; 
0233E:  MOVLB  1
02340:  CLRF   xD7
.................... 				return ILLEGAL_DATA_VALUE; 
02342:  MOVLW  03
02344:  MOVWF  01
02346:  MOVLB  7
02348:  BRA    2362
.................... 			} 
.................... 			current.factory_unlocked=1; 
0234A:  MOVLW  01
0234C:  MOVLB  1
0234E:  MOVWF  xD7
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02350:  MOVLW  C8
02352:  MOVWF  xF6
.................... 			break; 
02354:  MOVLB  7
02356:  BRA    235E
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02358:  MOVLW  02
0235A:  MOVWF  01
0235C:  BRA    2362
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
0235E:  MOVLW  00
02360:  MOVWF  01
.................... } 
02362:  MOVLB  0
02364:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
023F6:  GOTO   1170
023FA:  MOVF   01,F
023FC:  BTFSC  FD8.2
023FE:  BRA    26E2
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02400:  DECFSZ 38,W
02402:  BRA    24B6
02404:  MOVF   36,W
02406:  MOVLB  6
02408:  SUBWF  xC3,W
0240A:  BTFSS  FD8.2
0240C:  BRA    2412
0240E:  MOVLB  0
02410:  BRA    24B6
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02412:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02414:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02416:  CLRWDT
02418:  MOVLW  02
0241A:  MOVLB  7
0241C:  MOVWF  xDB
0241E:  MOVLW  B5
02420:  MOVWF  xDC
02422:  MOVLB  0
02424:  CALL   1196
02428:  MOVLB  7
0242A:  DECFSZ xDB,F
0242C:  BRA    241E
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
0242E:  MOVLB  6
02430:  MOVF   xC3,W
02432:  MOVLB  0
02434:  CALL   11B6
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02438:  CLRWDT
0243A:  MOVLW  67
0243C:  MOVWF  00
0243E:  DECFSZ 00,F
02440:  BRA    243E
02442:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02444:  MOVLB  6
02446:  MOVF   xC5,W
02448:  MOVLB  0
0244A:  CALL   11B6
.................... 			delay_us(104); //one stop bit @ 9600 baud 
0244E:  CLRWDT
02450:  MOVLW  67
02452:  MOVWF  00
02454:  DECFSZ 00,F
02456:  BRA    2454
02458:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
0245A:  MOVLB  7
0245C:  CLRF   xDA
0245E:  MOVLW  02
02460:  MOVLB  6
02462:  ADDWF  xC4,W
02464:  MOVLB  7
02466:  SUBWF  xDA,W
02468:  BC    2496
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
0246A:  MOVLW  C7
0246C:  ADDWF  xDA,W
0246E:  MOVWF  FE9
02470:  MOVLW  06
02472:  MOVWF  FEA
02474:  BTFSC  FD8.0
02476:  INCF   FEA,F
02478:  MOVFF  FEF,7DB
0247C:  MOVF   xDB,W
0247E:  MOVLB  0
02480:  CALL   11B6
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02484:  CLRWDT
02486:  MOVLW  67
02488:  MOVWF  00
0248A:  DECFSZ 00,F
0248C:  BRA    248A
0248E:  NOP   
.................... 			} 
02490:  MOVLB  7
02492:  INCF   xDA,F
02494:  BRA    245E
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02496:  BTFSS  F72.1
02498:  BRA    2496
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
0249A:  CLRWDT
0249C:  MOVLW  02
0249E:  MOVWF  xDB
024A0:  MOVLW  B5
024A2:  MOVWF  xDC
024A4:  MOVLB  0
024A6:  CALL   1196
024AA:  MOVLB  7
024AC:  DECFSZ xDB,F
024AE:  BRA    24A0
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
024B0:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
024B2:  BCF    F8C.0
024B4:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
024B6:  MOVF   36,W
024B8:  SUBLW  80
024BA:  BZ    24C8
024BC:  MOVF   36,W
024BE:  MOVLB  6
024C0:  SUBWF  xC3,W
024C2:  BTFSS  FD8.2
024C4:  BRA    26CC
024C6:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
024C8:  MOVLB  1
024CA:  INCFSZ xCB,W
024CC:  BRA    24D4
024CE:  INCFSZ xCC,W
024D0:  BRA    24D4
024D2:  BRA    24DA
.................... 				current.modbus_our_packets++; 
024D4:  INCF   xCB,F
024D6:  BTFSC  FD8.2
024D8:  INCF   xCC,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
024DA:  MOVLW  14
024DC:  MOVWF  xF6
....................  
.................... 			switch(modbus_rx.func) { 
024DE:  MOVLB  6
024E0:  MOVF   xC5,W
024E2:  XORLW  03
024E4:  MOVLB  0
024E6:  BZ    24F8
024E8:  XORLW  07
024EA:  BZ    24F8
024EC:  XORLW  02
024EE:  BZ    2570
024F0:  XORLW  16
024F2:  BTFSC  FD8.2
024F4:  BRA    25E2
024F6:  BRA    26A4
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
024F8:  MOVFF  6C7,7D6
024FC:  MOVFF  6C8,7D5
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02500:  MOVFF  6C9,7D8
02504:  MOVFF  6CA,7D7
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02508:  MOVLB  7
0250A:  MOVF   xD7,W
0250C:  ADDWF  xD5,W
0250E:  MOVWF  xDB
02510:  MOVF   xD8,W
02512:  ADDWFC xD6,W
02514:  MOVWF  xDC
02516:  MOVFF  7D6,7DE
0251A:  MOVFF  7D5,7DD
0251E:  MOVWF  xE0
02520:  MOVFF  7DB,7DF
02524:  MOVLB  0
02526:  GOTO   11BE
0252A:  MOVF   01,F
0252C:  BNZ   2552
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0252E:  MOVFF  6C3,7DB
02532:  MOVLB  7
02534:  CLRF   xDD
02536:  MOVFF  6C5,7DC
0253A:  MOVLW  02
0253C:  MOVWF  xDE
0253E:  MOVLB  0
02540:  CALL   1344
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02544:  MOVLB  1
02546:  CLRF   xD0
02548:  MOVLW  02
0254A:  MOVWF  xCF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0254C:  CLRF   xF6
.................... 					} else { 
0254E:  BRA    256E
02550:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02552:  MOVFF  6C5,7DB
02556:  MOVFF  6C3,7DC
0255A:  MOVFF  7D6,7DE
0255E:  MOVFF  7D5,7DD
02562:  MOVFF  7D8,7E0
02566:  MOVFF  7D7,7DF
0256A:  BRA    1FB0
0256C:  MOVLB  1
.................... 					} 
.................... 					break; 
0256E:  BRA    26C4
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02570:  MOVFF  6C7,7D6
02574:  MOVFF  6C8,7D5
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02578:  MOVFF  6C9,7DC
0257C:  MOVFF  6CA,7DB
02580:  MOVFF  7D6,7E2
02584:  MOVFF  7D5,7E1
02588:  MOVFF  6C9,7E4
0258C:  MOVFF  6CA,7E3
02590:  RCALL  2032
02592:  MOVFF  01,7D9
....................  
.................... 					if ( result ) { 
02596:  MOVLB  7
02598:  MOVF   xD9,F
0259A:  BZ    25BE
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
0259C:  MOVFF  6C3,7DB
025A0:  CLRF   xDD
025A2:  MOVFF  6C5,7DC
025A6:  MOVFF  7D9,7DE
025AA:  MOVLB  0
025AC:  CALL   1344
.................... 						current.modbus_last_error=result; 
025B0:  MOVLB  1
025B2:  CLRF   xD0
025B4:  MOVFF  7D9,1CF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
025B8:  CLRF   xF6
.................... 					}  else { 
025BA:  BRA    25E0
025BC:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
025BE:  MOVFF  6C9,7DC
025C2:  MOVFF  6CA,7DB
025C6:  MOVFF  6C3,7DD
025CA:  MOVFF  7D6,7DF
025CE:  MOVFF  7D5,7DE
025D2:  MOVFF  6C9,7E1
025D6:  MOVFF  6CA,7E0
025DA:  MOVLB  0
025DC:  BRA    2366
025DE:  MOVLB  1
.................... 					} 
.................... 					break; 
025E0:  BRA    26C4
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
025E2:  MOVFF  6C7,7D6
025E6:  MOVFF  6C8,7D5
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
025EA:  MOVFF  6C9,7D8
025EE:  MOVFF  6CA,7D7
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
025F2:  MOVLB  7
025F4:  CLRF   xDA
025F6:  MOVF   xD8,F
025F8:  BNZ   2600
025FA:  MOVF   xD7,W
025FC:  SUBWF  xDA,W
025FE:  BC    2684
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02600:  MOVF   xDA,W
02602:  ADDWF  xD5,W
02604:  MOVWF  xDB
02606:  MOVLW  00
02608:  ADDWFC xD6,W
0260A:  MOVWF  xDC
0260C:  BCF    FD8.0
0260E:  RLCF   xDA,W
02610:  ADDLW  05
02612:  ADDLW  C7
02614:  MOVWF  FE9
02616:  MOVLW  06
02618:  MOVWF  FEA
0261A:  BTFSC  FD8.0
0261C:  INCF   FEA,F
0261E:  MOVFF  FEF,7DD
02622:  BCF    FD8.0
02624:  RLCF   xDA,W
02626:  ADDLW  06
02628:  ADDLW  C7
0262A:  MOVWF  FE9
0262C:  MOVLW  06
0262E:  MOVWF  FEA
02630:  BTFSC  FD8.0
02632:  INCF   FEA,F
02634:  MOVFF  FEF,7DE
02638:  MOVFF  7DD,7E0
0263C:  MOVFF  7DE,7DF
02640:  MOVFF  7DC,7E2
02644:  MOVFF  7DB,7E1
02648:  MOVFF  7DD,7E4
0264C:  MOVFF  7DE,7E3
02650:  MOVLB  0
02652:  RCALL  2032
02654:  MOVFF  01,7D9
....................  
.................... 						if ( result ) { 
02658:  MOVLB  7
0265A:  MOVF   xD9,F
0265C:  BZ    2680
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
0265E:  MOVFF  6C3,7DB
02662:  CLRF   xDD
02664:  MOVFF  6C5,7DC
02668:  MOVFF  7D9,7DE
0266C:  MOVLB  0
0266E:  CALL   1344
.................... 							current.modbus_last_error=result; 
02672:  MOVLB  1
02674:  CLRF   xD0
02676:  MOVFF  7D9,1CF
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
0267A:  CLRF   xF6
.................... 			 
.................... 							break; 
0267C:  MOVLB  7
0267E:  BRA    2684
.................... 						} 
.................... 					} 
02680:  INCF   xDA,F
02682:  BRA    25F6
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02684:  MOVF   xD9,F
02686:  BNZ   26A0
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02688:  MOVFF  6C3,7DB
0268C:  MOVFF  7D6,7DD
02690:  MOVFF  7D5,7DC
02694:  MOVFF  7D8,7DF
02698:  MOVFF  7D7,7DE
0269C:  MOVLB  0
0269E:  BRA    23AE
.................... 					} 
....................  
.................... 					break;   
026A0:  MOVLB  1
026A2:  BRA    26C4
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
026A4:  MOVFF  6C3,7DB
026A8:  MOVLB  7
026AA:  CLRF   xDD
026AC:  MOVFF  6C5,7DC
026B0:  MOVLW  01
026B2:  MOVWF  xDE
026B4:  MOVLB  0
026B6:  CALL   1344
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
026BA:  MOVLB  1
026BC:  CLRF   xD0
026BE:  MOVLW  01
026C0:  MOVWF  xCF
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
026C2:  CLRF   xF6
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
026C4:  CLRF   xD9
026C6:  CLRF   xD8
....................  
.................... 		} else { 
026C8:  BRA    26E2
026CA:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
026CC:  MOVLB  1
026CE:  INCFSZ xCD,W
026D0:  BRA    26D8
026D2:  INCFSZ xCE,W
026D4:  BRA    26D8
026D6:  BRA    26DE
.................... 				current.modbus_other_packets++; 
026D8:  INCF   xCD,F
026DA:  BTFSC  FD8.2
026DC:  INCF   xCE,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
026DE:  MOVLW  0A
026E0:  MOVWF  xF6
026E2:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
026E4:  GOTO   2B74 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00442:  MOVLB  8
00444:  BTFSS  xE7.0
00446:  BRA    0460
00448:  MOVLB  1
0044A:  INCFSZ xE5,W
0044C:  BRA    0458
0044E:  INCFSZ xE6,W
00450:  BRA    0458
00452:  MOVLB  8
00454:  BRA    0460
00456:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00458:  INCF   xE5,F
0045A:  BTFSC  FD8.2
0045C:  INCF   xE6,F
0045E:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00460:  BTFSS  xE7.2
00462:  BRA    047C
00464:  MOVLB  1
00466:  INCFSZ xE7,W
00468:  BRA    0474
0046A:  INCFSZ xE8,W
0046C:  BRA    0474
0046E:  MOVLB  8
00470:  BRA    047C
00472:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00474:  INCF   xE7,F
00476:  BTFSC  FD8.2
00478:  INCF   xE8,F
0047A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0047C:  BTFSS  xE7.4
0047E:  BRA    0498
00480:  MOVLB  1
00482:  INCFSZ xE9,W
00484:  BRA    0490
00486:  INCFSZ xEA,W
00488:  BRA    0490
0048A:  MOVLB  8
0048C:  BRA    0498
0048E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00490:  INCF   xE9,F
00492:  BTFSC  FD8.2
00494:  INCF   xEA,F
00496:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00498:  BCF    xE7.1
0049A:  BTFSC  F81.0
0049C:  BSF    xE7.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0049E:  BTFSC  xE7.1
004A0:  BRA    0524
004A2:  MOVLB  6
004A4:  BTFSC  xBF.1
004A6:  BRA    04AC
004A8:  MOVLB  8
004AA:  BRA    0524
.................... 		current.pulse_count[0]++; 
004AC:  MOVLB  0
004AE:  INCF   xA8,F
004B0:  BTFSC  FD8.2
004B2:  INCF   xA9,F
.................... 		current.pulse_sum[0]++; 
004B4:  MOVLW  01
004B6:  ADDWF  xAE,F
004B8:  BTFSC  FD8.0
004BA:  INCF   xAF,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xB0,F
004C0:  BTFSC  FD8.2
004C2:  INCF   xB1,F
.................... 		if ( 1 == ext0_state ) { 
004C4:  MOVLB  6
004C6:  BTFSS  xBF.2
004C8:  BRA    0512
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004CA:  MOVLB  8
004CC:  BCF    xE7.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004CE:  MOVFF  1E6,97
004D2:  MOVFF  1E5,96
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004D6:  MOVLB  0
004D8:  MOVF   x97,W
004DA:  SUBWF  x9D,W
004DC:  BNC   04EE
004DE:  BNZ   04E6
004E0:  MOVF   x9C,W
004E2:  SUBWF  x96,W
004E4:  BC    04EE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004E6:  MOVFF  97,9D
004EA:  MOVFF  96,9C
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004EE:  MOVF   xA3,W
004F0:  SUBWF  x97,W
004F2:  BNC   050E
004F4:  BNZ   04FC
004F6:  MOVF   x96,W
004F8:  SUBWF  xA2,W
004FA:  BC    050E
004FC:  INCFSZ x96,W
004FE:  BRA    0506
00500:  INCFSZ x97,W
00502:  BRA    0506
00504:  BRA    050E
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00506:  MOVFF  97,A3
0050A:  MOVFF  96,A2
.................... 			} 
.................... 			ext0_state=0; 
0050E:  MOVLB  6
00510:  BCF    xBF.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00512:  BTFSC  xBF.2
00514:  BRA    0524
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00516:  MOVLB  1
00518:  CLRF   xE6
0051A:  CLRF   xE5
.................... 			ext0_count=1; 
0051C:  MOVLB  8
0051E:  BSF    xE7.0
.................... 			ext0_state=1; 
00520:  MOVLB  6
00522:  BSF    xBF.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00524:  MOVLB  6
00526:  BCF    xBF.1
00528:  MOVLB  8
0052A:  BTFSS  xE7.1
0052C:  BRA    0534
0052E:  MOVLB  6
00530:  BSF    xBF.1
00532:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00534:  BCF    xE7.3
00536:  BTFSC  F81.1
00538:  BSF    xE7.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0053A:  BTFSC  xE7.3
0053C:  BRA    05C0
0053E:  MOVLB  6
00540:  BTFSC  xBF.3
00542:  BRA    0548
00544:  MOVLB  8
00546:  BRA    05C0
.................... 		current.pulse_count[1]++; 
00548:  MOVLB  0
0054A:  INCF   xAA,F
0054C:  BTFSC  FD8.2
0054E:  INCF   xAB,F
.................... 		current.pulse_sum[1]++; 
00550:  MOVLW  01
00552:  ADDWF  xB2,F
00554:  BTFSC  FD8.0
00556:  INCF   xB3,F
00558:  BTFSC  FD8.2
0055A:  INCF   xB4,F
0055C:  BTFSC  FD8.2
0055E:  INCF   xB5,F
.................... 		if ( 1 == ext1_state ) { 
00560:  MOVLB  6
00562:  BTFSS  xBF.4
00564:  BRA    05AE
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00566:  MOVLB  8
00568:  BCF    xE7.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0056A:  MOVFF  1E8,99
0056E:  MOVFF  1E7,98
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00572:  MOVLB  0
00574:  MOVF   x99,W
00576:  SUBWF  x9F,W
00578:  BNC   058A
0057A:  BNZ   0582
0057C:  MOVF   x9E,W
0057E:  SUBWF  x98,W
00580:  BC    058A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00582:  MOVFF  99,9F
00586:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0058A:  MOVF   xA5,W
0058C:  SUBWF  x99,W
0058E:  BNC   05AA
00590:  BNZ   0598
00592:  MOVF   x98,W
00594:  SUBWF  xA4,W
00596:  BC    05AA
00598:  INCFSZ x98,W
0059A:  BRA    05A2
0059C:  INCFSZ x99,W
0059E:  BRA    05A2
005A0:  BRA    05AA
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005A2:  MOVFF  99,A5
005A6:  MOVFF  98,A4
.................... 			} 
.................... 			ext1_state=0; 
005AA:  MOVLB  6
005AC:  BCF    xBF.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005AE:  BTFSC  xBF.4
005B0:  BRA    05C0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005B2:  MOVLB  1
005B4:  CLRF   xE8
005B6:  CLRF   xE7
.................... 			ext1_count=1; 
005B8:  MOVLB  8
005BA:  BSF    xE7.2
.................... 			ext1_state=1; 
005BC:  MOVLB  6
005BE:  BSF    xBF.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005C0:  MOVLB  6
005C2:  BCF    xBF.3
005C4:  MOVLB  8
005C6:  BTFSS  xE7.3
005C8:  BRA    05D0
005CA:  MOVLB  6
005CC:  BSF    xBF.3
005CE:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005D0:  BCF    xE7.5
005D2:  BTFSC  F81.2
005D4:  BSF    xE7.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005D6:  BTFSC  xE7.5
005D8:  BRA    065C
005DA:  MOVLB  6
005DC:  BTFSC  xBF.5
005DE:  BRA    05E4
005E0:  MOVLB  8
005E2:  BRA    065C
.................... 		current.pulse_count[2]++; 
005E4:  MOVLB  0
005E6:  INCF   xAC,F
005E8:  BTFSC  FD8.2
005EA:  INCF   xAD,F
.................... 		current.pulse_sum[2]++; 
005EC:  MOVLW  01
005EE:  ADDWF  xB6,F
005F0:  BTFSC  FD8.0
005F2:  INCF   xB7,F
005F4:  BTFSC  FD8.2
005F6:  INCF   xB8,F
005F8:  BTFSC  FD8.2
005FA:  INCF   xB9,F
.................... 		if ( 1 == ext2_state ) { 
005FC:  MOVLB  6
005FE:  BTFSS  xBF.6
00600:  BRA    064A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
00602:  MOVLB  8
00604:  BCF    xE7.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00606:  MOVFF  1EA,9B
0060A:  MOVFF  1E9,9A
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0060E:  MOVLB  0
00610:  MOVF   x9B,W
00612:  SUBWF  xA1,W
00614:  BNC   0626
00616:  BNZ   061E
00618:  MOVF   xA0,W
0061A:  SUBWF  x9A,W
0061C:  BC    0626
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0061E:  MOVFF  9B,A1
00622:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00626:  MOVF   xA7,W
00628:  SUBWF  x9B,W
0062A:  BNC   0646
0062C:  BNZ   0634
0062E:  MOVF   x9A,W
00630:  SUBWF  xA6,W
00632:  BC    0646
00634:  INCFSZ x9A,W
00636:  BRA    063E
00638:  INCFSZ x9B,W
0063A:  BRA    063E
0063C:  BRA    0646
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0063E:  MOVFF  9B,A7
00642:  MOVFF  9A,A6
.................... 			} 
.................... 			ext2_state=0; 
00646:  MOVLB  6
00648:  BCF    xBF.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0064A:  BTFSC  xBF.6
0064C:  BRA    065C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0064E:  MOVLB  1
00650:  CLRF   xEA
00652:  CLRF   xE9
.................... 			ext2_count=1; 
00654:  MOVLB  8
00656:  BSF    xE7.4
.................... 			ext2_state=1; 
00658:  MOVLB  6
0065A:  BSF    xBF.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0065C:  MOVLB  6
0065E:  BCF    xBF.5
00660:  MOVLB  8
00662:  BTFSS  xE7.5
00664:  BRA    066C
00666:  MOVLB  6
00668:  BSF    xBF.5
0066A:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0066C:  MOVLB  7
0066E:  INCF   xCA,F
.................... 	if ( 10 == tick ) { 
00670:  MOVF   xCA,W
00672:  SUBLW  0A
00674:  BNZ   067E
.................... 		tick=0; 
00676:  CLRF   xCA
.................... 		timers.now_millisecond=1; 
00678:  MOVLB  1
0067A:  BSF    xF9.2
0067C:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0067E:  BCF    F9E.1
00680:  MOVLB  0
00682:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0069E:  BRA    0686
006A0:  MOVFF  01,8E4
.................... 	current.rda2_bytes_received++; 
006A4:  MOVLB  1
006A6:  INCF   xE3,F
006A8:  BTFSC  FD8.2
006AA:  INCF   xE4,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
006AC:  DECFSZ 38,W
006AE:  BRA    06D2
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006B0:  MOVLB  2
006B2:  CLRF   xFE
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006B4:  INCFSZ xFD,W
006B6:  BRA    06BA
006B8:  BRA    06CE
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006BA:  MOVLW  FD
006BC:  ADDWF  xFD,W
006BE:  MOVWF  FE9
006C0:  MOVLW  01
006C2:  MOVWF  FEA
006C4:  BTFSC  FD8.0
006C6:  INCF   FEA,F
006C8:  MOVFF  8E4,FEF
.................... 			timers.rda2_buff_pos++; 
006CC:  INCF   xFD,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006CE:  BRA    0714
006D0:  MOVLB  1
006D2:  MOVF   38,W
006D4:  SUBLW  02
006D6:  BNZ   0716
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
006D8:  MOVLB  8
006DA:  MOVF   xE4,W
006DC:  SUBLW  0A
006DE:  BZ    06E6
006E0:  MOVF   xE4,W
006E2:  SUBLW  0D
006E4:  BNZ   06F6
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
006E6:  MOVLB  2
006E8:  MOVF   xFD,F
006EA:  BZ    06F2
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
006EC:  MOVLW  14
006EE:  MOVWF  xFE
.................... 			}  else { 
006F0:  BRA    06F2
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
006F2:  BRA    0714
006F4:  MOVLB  8
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
006F6:  MOVLB  2
006F8:  CLRF   xFE
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006FA:  INCFSZ xFD,W
006FC:  BRA    0700
006FE:  BRA    0714
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
00700:  MOVLW  FD
00702:  ADDWF  xFD,W
00704:  MOVWF  FE9
00706:  MOVLW  01
00708:  MOVWF  FEA
0070A:  BTFSC  FD8.0
0070C:  INCF   FEA,F
0070E:  MOVFF  8E4,FEF
.................... 				timers.rda2_buff_pos++; 
00712:  INCF   xFD,F
00714:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00716:  BCF    FA4.5
00718:  MOVLB  0
0071A:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
00760:  RCALL  071E
00762:  MOVFF  01,8E4
....................  
.................... 	current.rda_bytes_received++; 
00766:  MOVLB  1
00768:  INCF   xE1,F
0076A:  BTFSC  FD8.2
0076C:  INCF   xE2,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
0076E:  MOVLB  6
00770:  BTFSC  xBF.0
00772:  BRA    07CA
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00774:  MOVF   xC0,F
00776:  BNZ   0788
.................... 			modbus_serial_crc.d = 0xFFFF; 
00778:  SETF   xC2
0077A:  SETF   xC1
.................... 			modbus_rx.address = c; 
0077C:  MOVFF  8E4,6C3
.................... 			modbus_serial_state++; 
00780:  INCF   xC0,F
.................... 			modbus_rx.len = 0; 
00782:  CLRF   xC4
.................... 			modbus_rx.error=0; 
00784:  CLRF   xC6
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00786:  BRA    07B6
00788:  DECFSZ xC0,W
0078A:  BRA    0794
.................... 			modbus_rx.func = c; 
0078C:  MOVFF  8E4,6C5
.................... 			modbus_serial_state++; 
00790:  INCF   xC0,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00792:  BRA    07B6
00794:  MOVF   xC0,W
00796:  SUBLW  02
00798:  BNZ   07B6
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0079A:  INCFSZ xC4,W
0079C:  BRA    07A2
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0079E:  MOVLW  FE
007A0:  MOVWF  xC4
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
007A2:  MOVLW  C7
007A4:  ADDWF  xC4,W
007A6:  MOVWF  FE9
007A8:  MOVLW  06
007AA:  MOVWF  FEA
007AC:  BTFSC  FD8.0
007AE:  INCF   FEA,F
007B0:  MOVFF  8E4,FEF
.................... 			modbus_rx.len++; 
007B4:  INCF   xC4,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
007B6:  MOVFF  8E4,8E5
007BA:  MOVLB  0
007BC:  RCALL  0734
.................... 		modbus_enable_timeout(TRUE); 
007BE:  MOVLW  01
007C0:  MOVLB  8
007C2:  MOVWF  xE5
007C4:  MOVLB  0
007C6:  RCALL  03FC
007C8:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
....................  
007CA:  BCF    F9E.5
007CC:  MOVLB  0
007CE:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
008CC:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
008CE:  MOVLW  08
008D0:  MOVWF  F61
008D2:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
008D4:  MOVLW  00
008D6:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
008D8:  MOVLW  FF
008DA:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
008DC:  MOVLW  92
008DE:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
008E0:  MOVLW  80
008E2:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
008E4:  BCF    F96.0
008E6:  BCF    F96.1
008E8:  BCF    F96.2
008EA:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
008EC:  MOVLB  1
008EE:  CLRF   xF6
.................... 	timers.load_off_seconds=2; 
008F0:  CLRF   xF8
008F2:  MOVLW  02
008F4:  MOVWF  xF7
.................... 	timers.now_adc_sample=0; 
008F6:  BCF    xF9.0
.................... 	timers.now_adc_reset_count=0; 
008F8:  BCF    xF9.1
.................... 	timers.now_millisecond=0; 
008FA:  BCF    xF9.2
.................... 	timers.port_b=0b11111111; 
008FC:  SETF   xFA
.................... 	timers.port_c=0b11111111; 
008FE:  SETF   xFB
....................  
.................... 	timers.rda2_buff_pos=0; 
00900:  MOVLB  2
00902:  CLRF   xFD
.................... 	timers.rda2_buff_gap=255; 
00904:  SETF   xFE
.................... 	timers.now_parse_rda2=0; 
00906:  MOVLB  1
00908:  BCF    xFC.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
0090A:  MOVLB  7
0090C:  CLRF   xD5
0090E:  MOVF   xD5,W
00910:  SUBLW  02
00912:  BNC   09C2
.................... 		current.pulse_period[i]=0; 
00914:  CLRF   03
00916:  MOVFF  7D5,02
0091A:  BCF    FD8.0
0091C:  RLCF   02,F
0091E:  RLCF   03,F
00920:  MOVF   02,W
00922:  ADDLW  96
00924:  MOVWF  FE9
00926:  MOVLW  00
00928:  ADDWFC 03,W
0092A:  MOVWF  FEA
0092C:  CLRF   FEC
0092E:  MOVF   FED,F
00930:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
00932:  CLRF   03
00934:  MOVFF  7D5,02
00938:  BCF    FD8.0
0093A:  RLCF   02,F
0093C:  RLCF   03,F
0093E:  MOVF   02,W
00940:  ADDLW  9C
00942:  MOVWF  FE9
00944:  MOVLW  00
00946:  ADDWFC 03,W
00948:  MOVWF  FEA
0094A:  SETF   FEC
0094C:  MOVF   FED,F
0094E:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00950:  CLRF   03
00952:  MOVFF  7D5,02
00956:  BCF    FD8.0
00958:  RLCF   02,F
0095A:  RLCF   03,F
0095C:  MOVF   02,W
0095E:  ADDLW  A2
00960:  MOVWF  FE9
00962:  MOVLW  00
00964:  ADDWFC 03,W
00966:  MOVWF  FEA
00968:  CLRF   FEC
0096A:  MOVF   FED,F
0096C:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
0096E:  CLRF   03
00970:  MOVFF  7D5,02
00974:  BCF    FD8.0
00976:  RLCF   02,F
00978:  RLCF   03,F
0097A:  MOVF   02,W
0097C:  ADDLW  A8
0097E:  MOVWF  FE9
00980:  MOVLW  00
00982:  ADDWFC 03,W
00984:  MOVWF  FEA
00986:  CLRF   FEC
00988:  MOVF   FED,F
0098A:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
0098C:  MOVLB  8
0098E:  CLRF   xDA
00990:  MOVFF  7D5,8D9
00994:  CLRF   xDC
00996:  MOVLW  04
00998:  MOVWF  xDB
0099A:  MOVLB  0
0099C:  RCALL  0890
0099E:  MOVF   01,W
009A0:  ADDLW  AE
009A2:  MOVWF  FE9
009A4:  MOVLW  00
009A6:  ADDWFC 02,W
009A8:  MOVWF  FEA
009AA:  MOVF   FEE,F
009AC:  MOVF   FEE,F
009AE:  CLRF   FEC
009B0:  MOVF   FED,F
009B2:  CLRF   FEF
009B4:  MOVF   FED,F
009B6:  CLRF   FEF
009B8:  MOVF   FED,F
009BA:  CLRF   FEF
.................... 	} 
009BC:  MOVLB  7
009BE:  INCF   xD5,F
009C0:  BRA    090E
....................  
.................... 	current.modbus_our_packets=0; 
009C2:  MOVLB  1
009C4:  CLRF   xCC
009C6:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
009C8:  CLRF   xCE
009CA:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
009CC:  CLRF   xD0
009CE:  CLRF   xCF
.................... 	current.sequence_number=0; 
009D0:  CLRF   xD2
009D2:  CLRF   xD1
.................... 	current.uptime_minutes=0; 
009D4:  CLRF   xD4
009D6:  CLRF   xD3
.................... 	current.interval_milliseconds=0; 
009D8:  CLRF   xD6
009DA:  CLRF   xD5
.................... 	current.adc_buffer_index=0; 
009DC:  CLRF   xCA
.................... 	current.factory_unlocked=0; 
009DE:  CLRF   xD7
.................... 	current.watchdog_seconds=0; 
009E0:  CLRF   xD9
009E2:  CLRF   xD8
.................... 	current.rda_bytes_received=0; 
009E4:  CLRF   xE2
009E6:  CLRF   xE1
.................... 	current.rda2_bytes_received=0; 
009E8:  CLRF   xE4
009EA:  CLRF   xE3
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
009EC:  MOVLW  02
009EE:  MOVWF  FEA
009F0:  SETF   FE9
009F2:  CLRF   00
009F4:  MOVLW  03
009F6:  MOVWF  02
009F8:  MOVLW  C0
009FA:  MOVWF  01
009FC:  MOVLB  0
009FE:  RCALL  08B2
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00A00:  MOVFF  4B,1DC
00A04:  MOVFF  4A,1DB
.................... 	current.power_off_delay=config.power_off_below_delay; 
00A08:  MOVFF  47,1DE
00A0C:  MOVFF  46,1DD
.................... 	current.power_override_timeout=0; 
00A10:  MOVLB  1
00A12:  CLRF   xE0
00A14:  CLRF   xDF
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00A16:  MOVLW  00
00A18:  IORLW  05
00A1A:  MOVWF  FBA
00A1C:  MOVLW  4A
00A1E:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00A20:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00A22:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00A24:  MOVLB  0
00A26:  GOTO   29F0 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00FF2:  MOVLB  1
00FF4:  BCF    xF9.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00FF6:  BCF    FD8.0
00FF8:  MOVLB  7
00FFA:  RLCF   xD0,W
00FFC:  MOVWF  xD5
00FFE:  RLCF   xD1,W
01000:  MOVWF  xD6
01002:  MOVLW  00
01004:  MOVLB  1
01006:  BTFSS  xFB.5
01008:  MOVLW  01
0100A:  MOVLB  7
0100C:  IORWF  xD5,F
0100E:  MOVFF  7D5,7D0
01012:  MOVF   xD6,W
01014:  IORLW  E0
01016:  MOVWF  xD1
.................... 	if ( b2_state==0xf000) { 
01018:  MOVF   xD0,F
0101A:  BNZ   1022
0101C:  MOVF   xD1,W
0101E:  SUBLW  F0
01020:  BNZ   1022
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
01022:  MOVLB  1
01024:  INCFSZ xE5,W
01026:  BRA    1034
01028:  INCFSZ xE6,W
0102A:  BRA    1034
.................... 				current.pulse_period[0]=0; 
0102C:  MOVLB  0
0102E:  CLRF   x97
01030:  CLRF   x96
01032:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
01034:  INCFSZ xE7,W
01036:  BRA    1044
01038:  INCFSZ xE8,W
0103A:  BRA    1044
.................... 				current.pulse_period[1]=0; 
0103C:  MOVLB  0
0103E:  CLRF   x99
01040:  CLRF   x98
01042:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
01044:  INCFSZ xE9,W
01046:  BRA    1054
01048:  INCFSZ xEA,W
0104A:  BRA    1054
.................... 				current.pulse_period[2]=0; 
0104C:  MOVLB  0
0104E:  CLRF   x9B
01050:  CLRF   x9A
01052:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
01054:  MOVFF  F81,1FA
.................... 	timers.port_c=port_c; 
01058:  MOVFF  F82,1FB
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
0105C:  MOVF   xF6,F
0105E:  BNZ   1064
.................... 		output_low(LED_GREEN); 
01060:  BCF    F89.3
.................... 	} else { 
01062:  BRA    1068
.................... 		output_high(LED_GREEN); 
01064:  BSF    F89.3
.................... 		timers.led_on_green--; 
01066:  DECF   xF6,F
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
01068:  INCFSZ xD5,W
0106A:  BRA    1072
0106C:  INCFSZ xD6,W
0106E:  BRA    1072
01070:  BRA    1078
.................... 		current.interval_milliseconds++; 
01072:  INCF   xD5,F
01074:  BTFSC  FD8.2
01076:  INCF   xD6,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
01078:  MOVLB  7
0107A:  INCF   xCE,F
0107C:  BTFSC  FD8.2
0107E:  INCF   xCF,F
.................... 	if ( 1000 == ticks ) { 
01080:  MOVF   xCE,W
01082:  SUBLW  E8
01084:  BNZ   110A
01086:  MOVF   xCF,W
01088:  SUBLW  03
0108A:  BNZ   110A
.................... 		ticks=0; 
0108C:  CLRF   xCF
0108E:  CLRF   xCE
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
01090:  MOVLB  1
01092:  INCFSZ xD8,W
01094:  BRA    109C
01096:  INCFSZ xD9,W
01098:  BRA    109C
0109A:  BRA    10A2
.................... 			current.watchdog_seconds++; 
0109C:  INCF   xD8,F
0109E:  BTFSC  FD8.2
010A0:  INCF   xD9,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
010A2:  MOVF   3F,F
010A4:  BNZ   10AA
010A6:  MOVF   40,F
010A8:  BZ    10C8
010AA:  MOVF   40,W
010AC:  SUBWF  xD9,W
010AE:  BNC   10C8
010B0:  BNZ   10B8
010B2:  MOVF   xD8,W
010B4:  SUBWF  3F,W
010B6:  BC    10C8
010B8:  MOVF   xF7,F
010BA:  BNZ   10C8
010BC:  MOVF   xF8,F
010BE:  BNZ   10C8
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
010C0:  MOVFF  42,1F8
010C4:  MOVFF  41,1F7
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
010C8:  MOVF   xF7,F
010CA:  BNZ   10D4
010CC:  MOVF   xF8,F
010CE:  BNZ   10D4
.................... 			output_high(PI_POWER_EN); 
010D0:  BSF    F8B.0
.................... 		} else { 
010D2:  BRA    10EA
.................... 			output_low(PI_POWER_EN); 
010D4:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
010D6:  MOVF   xF7,W
010D8:  BTFSC  FD8.2
010DA:  DECF   xF8,F
010DC:  DECF   xF7,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
010DE:  MOVF   xF7,F
010E0:  BNZ   10EA
010E2:  MOVF   xF8,F
010E4:  BNZ   10EA
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
010E6:  CLRF   xD9
010E8:  CLRF   xD8
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
010EA:  MOVLB  7
010EC:  INCF   xCB,F
.................... 		if ( 60 == uptimeTicks ) { 
010EE:  MOVF   xCB,W
010F0:  SUBLW  3C
010F2:  BNZ   110A
.................... 			uptimeTicks=0; 
010F4:  CLRF   xCB
.................... 			if ( current.uptime_minutes < 65535 )  
010F6:  MOVLB  1
010F8:  INCFSZ xD3,W
010FA:  BRA    1102
010FC:  INCFSZ xD4,W
010FE:  BRA    1102
01100:  BRA    1108
.................... 				current.uptime_minutes++; 
01102:  INCF   xD3,F
01104:  BTFSC  FD8.2
01106:  INCF   xD4,F
01108:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
0110A:  INCFSZ xD2,W
0110C:  BRA    1120
0110E:  INCFSZ xD3,W
01110:  BRA    1120
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
01112:  CLRF   xED
01114:  MOVLB  0
01116:  RCALL  0F6A
01118:  MOVFF  02,7D3
0111C:  MOVFF  01,7D2
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
01120:  MOVLB  1
01122:  BTFSS  xF9.1
01124:  BRA    112E
.................... 		timers.now_adc_reset_count=0; 
01126:  BCF    xF9.1
.................... 		adcTicks=0; 
01128:  MOVLB  7
0112A:  CLRF   xCD
0112C:  CLRF   xCC
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
0112E:  MOVLB  7
01130:  INCF   xCC,F
01132:  BTFSC  FD8.2
01134:  INCF   xCD,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
01136:  MOVF   3C,W
01138:  SUBWF  xCC,W
0113A:  BNZ   1150
0113C:  MOVF   3D,W
0113E:  SUBWF  xCD,W
01140:  BNZ   1150
.................... 		adcTicks=0; 
01142:  CLRF   xCD
01144:  CLRF   xCC
.................... 		timers.now_adc_sample=1; 
01146:  MOVLB  1
01148:  BSF    xF9.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
0114A:  MOVLB  7
0114C:  SETF   xD3
0114E:  SETF   xD2
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01150:  MOVLB  2
01152:  INCFSZ xFE,W
01154:  BRA    1158
01156:  BRA    115A
.................... 		timers.rda2_buff_gap++; 
01158:  INCF   xFE,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
0115A:  MOVF   xFE,W
0115C:  SUBLW  09
0115E:  BC    116A
01160:  MOVF   xFD,F
01162:  BZ    116A
.................... 		timers.now_parse_rda2=1;	 
01164:  MOVLB  1
01166:  BSF    xFC.0
01168:  MOVLB  2
.................... 	} 
.................... } 
0116A:  MOVLB  0
0116C:  GOTO   2B62 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 n) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < n && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
026E8:  MOVLB  8
026EA:  CLRF   xE0
026EC:  MOVF   xDF,W
026EE:  SUBWF  xE0,W
026F0:  BC    275E
026F2:  CLRF   03
026F4:  MOVF   xE0,W
026F6:  ADDWF  xDD,W
026F8:  MOVWF  FE9
026FA:  MOVF   xDE,W
026FC:  ADDWFC 03,W
026FE:  MOVWF  FEA
02700:  MOVF   FEF,F
02702:  BZ    275E
02704:  CLRF   03
02706:  MOVF   xE0,W
02708:  ADDWF  xDD,W
0270A:  MOVWF  FE9
0270C:  MOVF   xDE,W
0270E:  ADDWFC 03,W
02710:  MOVWF  FEA
02712:  MOVF   FEF,W
02714:  SUBLW  0A
02716:  BZ    275E
02718:  CLRF   03
0271A:  MOVF   xE0,W
0271C:  ADDWF  xDD,W
0271E:  MOVWF  FE9
02720:  MOVF   xDE,W
02722:  ADDWFC 03,W
02724:  MOVWF  FEA
02726:  MOVF   FEF,W
02728:  SUBLW  0D
0272A:  BZ    275E
.................... 		dest[i] = src[i]; 
0272C:  CLRF   03
0272E:  MOVF   xE0,W
02730:  ADDWF  xDB,W
02732:  MOVWF  01
02734:  MOVF   xDC,W
02736:  ADDWFC 03,F
02738:  MOVFF  03,8E2
0273C:  CLRF   03
0273E:  MOVF   xE0,W
02740:  ADDWF  xDD,W
02742:  MOVWF  FE9
02744:  MOVF   xDE,W
02746:  ADDWFC 03,W
02748:  MOVWF  FEA
0274A:  MOVFF  FEF,8E3
0274E:  MOVFF  8E2,FEA
02752:  MOVFF  01,FE9
02756:  MOVFF  8E3,FEF
.................... 	} 
0275A:  INCF   xE0,F
0275C:  BRA    26EC
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < n ; i++) { 
0275E:  MOVF   xDF,W
02760:  SUBWF  xE0,W
02762:  BC    2778
.................... 		dest[i] = '\0'; 
02764:  CLRF   03
02766:  MOVF   xE0,W
02768:  ADDWF  xDB,W
0276A:  MOVWF  FE9
0276C:  MOVF   xDC,W
0276E:  ADDWFC 03,W
02770:  MOVWF  FEA
02772:  CLRF   FEF
.................... 	} 
02774:  INCF   xE0,F
02776:  BRA    275E
....................  
.................... 	/* always null terminate */ 
.................... 	dest[n-1]='\0'; 
02778:  MOVLW  01
0277A:  SUBWF  xDF,W
0277C:  CLRF   03
0277E:  ADDWF  xDB,W
02780:  MOVWF  FE9
02782:  MOVF   xDC,W
02784:  ADDWFC 03,W
02786:  MOVWF  FEA
02788:  CLRF   FEF
.................... } 
0278A:  MOVLB  0
0278C:  RETURN 0
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02826:  MOVFF  2FD,8D5
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
0282A:  MOVLB  2
0282C:  SETF   xFD
.................... 	memcpy(buff,timers.rda2_buff,length); 
0282E:  MOVLW  07
02830:  MOVWF  FEA
02832:  MOVLW  D5
02834:  MOVWF  FE9
02836:  MOVLW  01
02838:  MOVWF  FE2
0283A:  MOVLW  FD
0283C:  MOVWF  FE1
0283E:  MOVLB  8
02840:  MOVF   xD5,W
02842:  MOVWF  01
02844:  BZ    284E
02846:  MOVFF  FE6,FEE
0284A:  DECFSZ 01,F
0284C:  BRA    2846
.................... 	timers.rda2_buff_gap=0; 
0284E:  MOVLB  2
02850:  CLRF   xFE
.................... 	timers.rda2_buff_pos=0; 
02852:  CLRF   xFD
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02854:  DECFSZ 38,W
02856:  BRA    288E
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02858:  MOVLB  8
0285A:  CLRF   xD7
0285C:  CLRF   xD6
0285E:  MOVF   xD7,F
02860:  BNZ   288A
02862:  MOVF   xD5,W
02864:  SUBWF  xD6,W
02866:  BC    288A
.................... 			fputc(buff[l],STREAM_PI); 
02868:  MOVLW  D5
0286A:  ADDWF  xD6,W
0286C:  MOVWF  FE9
0286E:  MOVLW  07
02870:  ADDWFC xD7,W
02872:  MOVWF  FEA
02874:  MOVFF  FEF,8D9
02878:  MOVF   xD9,W
0287A:  MOVLB  0
0287C:  CALL   12AC
.................... 		} 
02880:  MOVLB  8
02882:  INCF   xD6,F
02884:  BTFSC  FD8.2
02886:  INCF   xD7,F
02888:  BRA    285E
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
0288A:  BRA    2946
0288C:  MOVLB  2
0288E:  MOVF   38,W
02890:  SUBLW  02
02892:  BNZ   2948
.................... 		/* do something */ 
....................  
.................... 		/* put copy in 11th slot no mater what ... for debugging */ 
.................... 		strncpy_terminate_trim(nmea.sentence[11],buff,NMEA_SENTENCE_LENGTH-1); 
02894:  MOVLW  06
02896:  MOVLB  8
02898:  MOVWF  xDC
0289A:  MOVLW  6F
0289C:  MOVWF  xDB
0289E:  MOVLW  07
028A0:  MOVWF  xDE
028A2:  MOVLW  D5
028A4:  MOVWF  xDD
028A6:  MOVLW  4F
028A8:  MOVWF  xDF
028AA:  MOVLB  0
028AC:  RCALL  26E8
.................... //		strncpy(nmea.sentence[11],buff,NMEA_SENTENCE_LENGTH-1); 
.................... 		/* always null terminate final character */ 
.................... 		nmea.sentence[11][NMEA_SENTENCE_LENGTH-1]='\0'; 
028AE:  MOVLB  6
028B0:  CLRF   xBE
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
028B2:  MOVLB  8
028B4:  MOVF   xD5,W
028B6:  SUBLW  05
028B8:  BNC   28BC
.................... 			return; 
028BA:  BRA    2946
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
028BC:  CLRF   xD8
028BE:  MOVF   xD8,W
028C0:  SUBLW  0B
028C2:  BNC   2946
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
028C4:  MOVF   xD8,W
028C6:  MULLW  06
028C8:  MOVF   FF3,W
028CA:  CLRF   03
028CC:  ADDLW  4E
028CE:  MOVWF  01
028D0:  MOVLW  00
028D2:  ADDWFC 03,F
028D4:  MOVFF  01,8D9
028D8:  MOVFF  03,8DA
028DC:  MOVLW  07
028DE:  MOVWF  xDC
028E0:  MOVLW  D5
028E2:  MOVWF  xDB
028E4:  MOVFF  03,8DE
028E8:  MOVFF  01,8DD
028EC:  CLRF   xE0
028EE:  MOVLW  06
028F0:  MOVWF  xDF
028F2:  MOVLB  0
028F4:  BRA    278E
028F6:  MOVF   01,F
028F8:  BZ    28FC
.................... 				/* no match */ 
.................... 				continue; 
028FA:  BRA    2940
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,NMEA_SENTENCE_LENGTH-1); 
028FC:  MOVLB  8
028FE:  CLRF   xDA
02900:  MOVFF  8D8,8D9
02904:  CLRF   xDC
02906:  MOVLW  50
02908:  MOVWF  xDB
0290A:  MOVLB  0
0290C:  CALL   0890
02910:  MOVFF  02,03
02914:  MOVF   01,W
02916:  ADDLW  FF
02918:  MOVWF  01
0291A:  MOVLW  02
0291C:  ADDWFC 03,F
0291E:  MOVFF  01,8D9
02922:  MOVLB  8
02924:  MOVFF  03,8DA
02928:  MOVFF  03,8DC
0292C:  MOVFF  01,8DB
02930:  MOVLW  07
02932:  MOVWF  xDE
02934:  MOVLW  D5
02936:  MOVWF  xDD
02938:  MOVLW  4F
0293A:  MOVWF  xDF
0293C:  MOVLB  0
0293E:  RCALL  26E8
.................... 		} 
02940:  MOVLB  8
02942:  INCF   xD8,F
02944:  BRA    28BE
02946:  MOVLB  2
.................... 	} 
.................... } 
02948:  MOVLB  0
0294A:  GOTO   2B80 (RETURN)
....................  
....................  
.................... void main(void) { 
0294E:  CLRF   FF8
02950:  BCF    FF1.2
02952:  BSF    F9F.1
02954:  BCF    F9F.5
02956:  BCF    FA5.5
02958:  BSF    FD0.7
0295A:  BSF    07.7
0295C:  CLRF   FEA
0295E:  CLRF   FE9
02960:  CLRF   35
02962:  BCF    FB8.3
02964:  MOVLW  0C
02966:  MOVWF  FAF
02968:  MOVLW  A6
0296A:  MOVWF  FAC
0296C:  MOVLW  90
0296E:  MOVWF  FAB
02970:  BCF    F70.3
02972:  MOVLW  4D
02974:  MOVWF  F75
02976:  MOVLW  A6
02978:  MOVWF  F72
0297A:  MOVLW  90
0297C:  MOVWF  F71
0297E:  MOVLB  6
02980:  BCF    xBF.0
02982:  CLRF   xC0
02984:  MOVLB  7
02986:  CLRF   xCA
02988:  MOVLB  6
0298A:  BCF    xBF.1
0298C:  BCF    xBF.2
0298E:  BCF    xBF.3
02990:  BCF    xBF.4
02992:  BCF    xBF.5
02994:  BCF    xBF.6
02996:  MOVLB  7
02998:  CLRF   xCB
0299A:  CLRF   xCD
0299C:  CLRF   xCC
0299E:  CLRF   xCF
029A0:  CLRF   xCE
029A2:  CLRF   xD1
029A4:  CLRF   xD0
029A6:  MOVF   FC1,W
029A8:  ANDLW  F0
029AA:  MOVWF  FC1
029AC:  MOVLW  00
029AE:  MOVLB  F
029B0:  MOVWF  x38
029B2:  MOVWF  x3C
029B4:  MOVWF  x39
029B6:  MOVWF  x3A
029B8:  MOVWF  x3B
029BA:  MOVLB  1
029BC:  CLRF   x88
029BE:  CLRF   F77
029C0:  CLRF   F78
029C2:  CLRF   F79
029C4:  CLRF   2F
029C6:  CLRF   30
029C8:  MOVLB  7
029CA:  CLRF   xC6
029CC:  CLRF   xC7
029CE:  CLRF   xC8
029D0:  CLRF   xC9
029D2:  CLRF   xD2
029D4:  CLRF   xD3
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
029D6:  MOVF   FD0,W
029D8:  ANDLW  0F
029DA:  BTFSS  FD0.4
029DC:  MOVLW  00
029DE:  BSF    FD0.0
029E0:  BSF    FD0.1
029E2:  BSF    FD0.4
029E4:  BSF    FD8.3
029E6:  BSF    FD8.4
029E8:  MOVWF  xD4
....................  
.................... 	init(); 
029EA:  MOVLB  0
029EC:  GOTO   08CC
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
029F0:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
029F2:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
029F4:  MOVLW  D2
029F6:  MOVWF  FF6
029F8:  MOVLW  07
029FA:  MOVWF  FF7
029FC:  MOVLW  07
029FE:  MOVLB  7
02A00:  MOVWF  xD5
02A02:  MOVLB  0
02A04:  CALL   0A2A
02A08:  MOVLW  DE
02A0A:  MOVWF  FF6
02A0C:  MOVLW  07
02A0E:  MOVWF  FF7
02A10:  CALL   0A54
02A14:  MOVLW  0D
02A16:  BTFSS  FA4.4
02A18:  BRA    2A16
02A1A:  MOVWF  F73
02A1C:  MOVLW  0A
02A1E:  BTFSS  FA4.4
02A20:  BRA    2A1E
02A22:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
02A24:  MOVLW  E8
02A26:  MOVWF  FF6
02A28:  MOVLW  07
02A2A:  MOVWF  FF7
02A2C:  MOVLW  12
02A2E:  MOVLB  7
02A30:  MOVWF  xD5
02A32:  MOVLB  0
02A34:  CALL   0A2A
02A38:  MOVFF  7D4,7D5
02A3C:  MOVLW  1B
02A3E:  MOVLB  7
02A40:  MOVWF  xD6
02A42:  MOVLB  0
02A44:  GOTO   0AA2
02A48:  MOVLW  20
02A4A:  BTFSS  FA4.4
02A4C:  BRA    2A4A
02A4E:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
02A50:  MOVLB  7
02A52:  MOVF   xD4,W
02A54:  XORLW  07
02A56:  MOVLB  0
02A58:  BZ    2A74
02A5A:  XORLW  0C
02A5C:  BZ    2A82
02A5E:  XORLW  04
02A60:  BZ    2A90
02A62:  XORLW  03
02A64:  BZ    2A9E
02A66:  XORLW  02
02A68:  BZ    2AAC
02A6A:  XORLW  0D
02A6C:  BZ    2ABA
02A6E:  XORLW  03
02A70:  BZ    2AC8
02A72:  BRA    2AD6
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
02A74:  MOVLW  FE
02A76:  MOVWF  FF6
02A78:  MOVLW  07
02A7A:  MOVWF  FF7
02A7C:  CALL   0A54
02A80:  BRA    2AE2
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
02A82:  MOVLW  0A
02A84:  MOVWF  FF6
02A86:  MOVLW  08
02A88:  MOVWF  FF7
02A8A:  CALL   0A54
02A8E:  BRA    2AE2
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
02A90:  MOVLW  1A
02A92:  MOVWF  FF6
02A94:  MOVLW  08
02A96:  MOVWF  FF7
02A98:  CALL   0A54
02A9C:  BRA    2AE2
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
02A9E:  MOVLW  28
02AA0:  MOVWF  FF6
02AA2:  MOVLW  08
02AA4:  MOVWF  FF7
02AA6:  CALL   0A54
02AAA:  BRA    2AE2
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
02AAC:  MOVLW  38
02AAE:  MOVWF  FF6
02AB0:  MOVLW  08
02AB2:  MOVWF  FF7
02AB4:  CALL   0A54
02AB8:  BRA    2AE2
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
02ABA:  MOVLW  4A
02ABC:  MOVWF  FF6
02ABE:  MOVLW  08
02AC0:  MOVWF  FF7
02AC2:  CALL   0A54
02AC6:  BRA    2AE2
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
02AC8:  MOVLW  5A
02ACA:  MOVWF  FF6
02ACC:  MOVLW  08
02ACE:  MOVWF  FF7
02AD0:  CALL   0A54
02AD4:  BRA    2AE2
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
02AD6:  MOVLW  6C
02AD8:  MOVWF  FF6
02ADA:  MOVLW  08
02ADC:  MOVWF  FF7
02ADE:  CALL   0A54
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
02AE2:  MOVLW  76
02AE4:  MOVWF  FF6
02AE6:  MOVLW  08
02AE8:  MOVWF  FF7
02AEA:  CALL   0A54
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02AEE:  GOTO   0D56
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02AF2:  MOVF   36,W
02AF4:  SUBLW  80
02AF6:  BC    2AFC
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02AF8:  CALL   0CAE
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02AFC:  BSF    FAB.7
02AFE:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02B00:  GOTO   0DB4
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02B04:  MOVLB  7
02B06:  CLRF   xD4
02B08:  MOVF   xD4,W
02B0A:  SUBLW  1D
02B0C:  BNC   2B1A
.................... 		adc_update(); 
02B0E:  MOVLB  0
02B10:  CALL   0E72
.................... 	} 
02B14:  MOVLB  7
02B16:  INCF   xD4,F
02B18:  BRA    2B08
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02B1A:  MOVFF  43,1DA
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
02B1E:  BTFSS  F72.1
02B20:  BRA    2B1E
.................... 	output_low(RS485_DE); 
02B22:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02B24:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02B26:  MOVLW  7A
02B28:  MOVWF  FF6
02B2A:  MOVLW  08
02B2C:  MOVWF  FF7
02B2E:  MOVLW  07
02B30:  MOVWF  xD5
02B32:  MOVLB  0
02B34:  GOTO   0F1A
02B38:  MOVLW  86
02B3A:  MOVWF  FF6
02B3C:  MOVLW  08
02B3E:  MOVWF  FF7
02B40:  GOTO   0F46
02B44:  MOVLW  0D
02B46:  BTFSS  F9E.4
02B48:  BRA    2B46
02B4A:  MOVWF  FAD
02B4C:  MOVLW  0A
02B4E:  BTFSS  F9E.4
02B50:  BRA    2B4E
02B52:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02B54:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
02B56:  MOVLB  1
02B58:  BTFSS  xF9.2
02B5A:  BRA    2B64
.................... 			periodic_millisecond(); 
02B5C:  MOVLB  0
02B5E:  GOTO   0FF2
02B62:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02B64:  BTFSS  xF9.0
02B66:  BRA    2B70
.................... 			timers.now_adc_sample=0; 
02B68:  BCF    xF9.0
.................... 			adc_update(); 
02B6A:  MOVLB  0
02B6C:  CALL   0E72
.................... 		} 
....................  
.................... 		modbus_process(); 
02B70:  MOVLB  0
02B72:  BRA    23F6
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
02B74:  MOVLB  1
02B76:  BTFSS  xFC.0
02B78:  BRA    2B82
.................... 			timers.now_parse_rda2=0; 
02B7A:  BCF    xFC.0
.................... 			rs485_to_host(); 
02B7C:  MOVLB  0
02B7E:  BRA    2826
02B80:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
02B82:  MOVLB  0
02B84:  BRA    2B54
.................... } 
02B86:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
