CCS PCH C Compiler, Version 4.135, 4375               07-Dec-15 15:20

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 13124 bytes (20%)
                         Largest free fragment is 52408
               RAM used: 2300 (59%) at main() level
                         2581 (66%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   30E0
*
00008:  GOTO   00E2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   041C
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   07B0
0007C:  BTFSS  F9D.4
0007E:  GOTO   0088
00082:  BTFSC  F9E.4
00084:  GOTO   073A
00088:  BTFSS  FA3.5
0008A:  GOTO   0094
0008E:  BTFSC  FA4.5
00090:  GOTO   06AA
00094:  MOVFF  0E,00
00098:  MOVFF  0F,01
0009C:  MOVFF  10,02
000A0:  MOVFF  11,03
000A4:  MOVFF  0C,FE9
000A8:  MOVFF  07,FEA
000AC:  BSF    07.7
000AE:  MOVFF  08,FE1
000B2:  MOVFF  09,FE2
000B6:  MOVFF  0A,FD9
000BA:  MOVFF  0B,FDA
000BE:  MOVFF  12,FF3
000C2:  MOVFF  13,FF4
000C6:  MOVFF  14,FFA
000CA:  MOVFF  15,FF5
000CE:  MOVFF  16,FF6
000D2:  MOVFF  17,FF7
000D6:  MOVF   04,W
000D8:  MOVFF  06,FE0
000DC:  MOVFF  05,FD8
000E0:  RETFIE 0
000E2:  MOVWF  1A
000E4:  MOVFF  FD8,1B
000E8:  MOVFF  FE0,1C
000EC:  MOVLB  0
000EE:  MOVFF  FE9,22
000F2:  MOVFF  FEA,1D
000F6:  MOVFF  FE1,1E
000FA:  MOVFF  FE2,1F
000FE:  MOVFF  FD9,20
00102:  MOVFF  FDA,21
00106:  MOVFF  FF3,28
0010A:  MOVFF  FF4,29
0010E:  MOVFF  FFA,2A
00112:  MOVFF  FF5,2B
00116:  MOVFF  FF6,2C
0011A:  MOVFF  FF7,2D
0011E:  MOVFF  00,24
00122:  MOVFF  01,25
00126:  MOVFF  02,26
0012A:  MOVFF  03,27
0012E:  BTFSS  F9D.1
00130:  GOTO   013A
00134:  BTFSC  F9E.1
00136:  GOTO   044E
0013A:  MOVFF  24,00
0013E:  MOVFF  25,01
00142:  MOVFF  26,02
00146:  MOVFF  27,03
0014A:  MOVFF  22,FE9
0014E:  MOVFF  1D,FEA
00152:  BSF    1D.7
00154:  MOVFF  1E,FE1
00158:  MOVFF  1F,FE2
0015C:  MOVFF  20,FD9
00160:  MOVFF  21,FDA
00164:  MOVFF  28,FF3
00168:  MOVFF  29,FF4
0016C:  MOVFF  2A,FFA
00170:  MOVFF  2B,FF5
00174:  MOVFF  2C,FF6
00178:  MOVFF  2D,FF7
0017C:  MOVF   1A,W
0017E:  MOVFF  1C,FE0
00182:  MOVFF  1B,FD8
00186:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02EE0:  MOVLB  A
02EE2:  MOVF   x06,F
02EE4:  BNZ   2EEA
02EE6:  MOVF   x07,F
02EE8:  BZ    2F6E
....................       if (*s1 != *s2) 
02EEA:  MOVFF  A02,FE9
02EEE:  MOVFF  A03,FEA
02EF2:  MOVFF  FEF,A08
02EF6:  MOVFF  A05,03
02EFA:  MOVFF  A04,FE9
02EFE:  MOVFF  A05,FEA
02F02:  MOVF   FEF,W
02F04:  SUBWF  x08,W
02F06:  BZ    2F36
....................          return((*s1 <*s2) ? -1: 1); 
02F08:  MOVFF  A03,03
02F0C:  MOVFF  A02,FE9
02F10:  MOVFF  A03,FEA
02F14:  MOVFF  FEF,A08
02F18:  MOVFF  A05,03
02F1C:  MOVFF  A04,FE9
02F20:  MOVFF  A05,FEA
02F24:  MOVF   FEF,W
02F26:  SUBWF  x08,W
02F28:  BC    2F2E
02F2A:  MOVLW  FF
02F2C:  BRA    2F30
02F2E:  MOVLW  01
02F30:  MOVWF  01
02F32:  BRA    2F72
....................       else if (*s1 == '\0') 
02F34:  BRA    2F4C
02F36:  MOVFF  A03,03
02F3A:  MOVFF  A02,FE9
02F3E:  MOVFF  A03,FEA
02F42:  MOVF   FEF,F
02F44:  BNZ   2F4C
....................          return(0); 
02F46:  MOVLW  00
02F48:  MOVWF  01
02F4A:  BRA    2F72
02F4C:  MOVFF  A03,03
02F50:  MOVF   x02,W
02F52:  INCF   x02,F
02F54:  BTFSC  FD8.2
02F56:  INCF   x03,F
02F58:  MOVFF  A05,03
02F5C:  MOVF   x04,W
02F5E:  INCF   x04,F
02F60:  BTFSC  FD8.2
02F62:  INCF   x05,F
02F64:  MOVF   x06,W
02F66:  BTFSC  FD8.2
02F68:  DECF   x07,F
02F6A:  DECF   x06,F
02F6C:  BRA    2EE2
....................    return(0); 
02F6E:  MOVLW  00
02F70:  MOVWF  01
.................... } 
02F72:  MOVLB  0
02F74:  GOTO   304E (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
012AE:  MOVLW  05
012B0:  MOVLB  9
012B2:  SUBWF  x07,F
012B4:  BNC   12CA
012B6:  MOVLW  09
012B8:  MOVWF  FEA
012BA:  MOVLW  07
012BC:  MOVWF  FE9
012BE:  MOVF   FEF,W
012C0:  BZ    12CA
012C2:  BRA    12C6
012C4:  CLRWDT
012C6:  DECFSZ FEF,F
012C8:  BRA    12C4
012CA:  MOVLB  0
012CC:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00732:  BTFSS  F9E.4
00734:  BRA    0732
00736:  MOVWF  FAD
00738:  RETURN 0
*
0076E:  BTFSS  F9E.5
00770:  BRA    076E
00772:  MOVFF  FAB,35
00776:  MOVFF  FAE,01
0077A:  BTFSS  35.1
0077C:  BRA    0782
0077E:  BCF    FAB.4
00780:  BSF    FAB.4
00782:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00692:  BTFSS  FA4.5
00694:  BRA    0692
00696:  MOVFF  F71,35
0069A:  MOVFF  F74,01
0069E:  BTFSS  35.1
006A0:  BRA    06A6
006A2:  BCF    F71.4
006A4:  BSF    F71.4
006A6:  GOTO   06AC (RETURN)
*
012CE:  BTFSS  FA4.4
012D0:  BRA    12CE
012D2:  MOVWF  F73
012D4:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define _PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
....................  
.................... 	/* push button on board */ 
.................... 	int8 button_state; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
....................  
.................... 	/* transmit buffer for PIC to PI */ 
.................... 	int8 rda_tx_buff[256]; 
.................... 	int8 rda_tx_length; 
.................... 	int8 rda_tx_pos; 
.................... 	int1 now_rda_tx_ready; 
.................... 	int1 now_rda_tx_done; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][NMEA_SENTENCE_LENGTH]; 
.................... 	int16 sentence_age[N_NMEA0183_SENTENCES]; 
.................... 	int8 sentence_length[N_NMEA0183_SENTENCES]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00FB4:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00EF8:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00EFA:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00EFC:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00EFE:  MOVLB  8
00F00:  MOVF   xFF,F
00F02:  BNZ   0F0E
.................... 		c=0b00011; 
00F04:  MOVLW  03
00F06:  MOVLB  9
00F08:  MOVWF  x03
.................... 	else if ( 1 == ch )  
00F0A:  BRA    0F70
00F0C:  MOVLB  8
00F0E:  DECFSZ xFF,W
00F10:  BRA    0F1C
.................... 		c=0b10011; 
00F12:  MOVLW  13
00F14:  MOVLB  9
00F16:  MOVWF  x03
.................... 	else if ( 2 == ch )  
00F18:  BRA    0F70
00F1A:  MOVLB  8
00F1C:  MOVF   xFF,W
00F1E:  SUBLW  02
00F20:  BNZ   0F2C
.................... 		c=0b01011; 
00F22:  MOVLW  0B
00F24:  MOVLB  9
00F26:  MOVWF  x03
.................... 	else if ( 3 == ch )  
00F28:  BRA    0F70
00F2A:  MOVLB  8
00F2C:  MOVF   xFF,W
00F2E:  SUBLW  03
00F30:  BNZ   0F3C
.................... 		c=0b11011; 
00F32:  MOVLW  1B
00F34:  MOVLB  9
00F36:  MOVWF  x03
.................... 	else if ( 4 == ch ) 
00F38:  BRA    0F70
00F3A:  MOVLB  8
00F3C:  MOVF   xFF,W
00F3E:  SUBLW  04
00F40:  BNZ   0F4C
.................... 		c=0b00111; 
00F42:  MOVLW  07
00F44:  MOVLB  9
00F46:  MOVWF  x03
.................... 	else if ( 5 == ch )  
00F48:  BRA    0F70
00F4A:  MOVLB  8
00F4C:  MOVF   xFF,W
00F4E:  SUBLW  05
00F50:  BNZ   0F5C
.................... 		c=0b10111; 
00F52:  MOVLW  17
00F54:  MOVLB  9
00F56:  MOVWF  x03
.................... 	else if ( 6 == ch ) 
00F58:  BRA    0F70
00F5A:  MOVLB  8
00F5C:  MOVF   xFF,W
00F5E:  SUBLW  06
00F60:  BNZ   0F6A
.................... 		c=0b01111; 
00F62:  MOVLW  0F
00F64:  MOVLB  9
00F66:  MOVWF  x03
.................... 	else 
00F68:  BRA    0F70
.................... 		c=0b11111; 
00F6A:  MOVLW  1F
00F6C:  MOVLB  9
00F6E:  MOVWF  x03
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00F70:  CLRF   x02
00F72:  MOVF   x02,W
00F74:  SUBLW  04
00F76:  BNC   0F8E
.................... 		output_low(MCP3208_CLK); 
00F78:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00F7A:  BTFSC  x03.0
00F7C:  BRA    0F82
00F7E:  BCF    F8B.5
00F80:  BRA    0F84
00F82:  BSF    F8B.5
.................... 		c=c>>1; 
00F84:  BCF    FD8.0
00F86:  RRCF   x03,F
.................... 		output_high(MCP3208_CLK); 
00F88:  BSF    F8B.3
.................... 	} 
00F8A:  INCF   x02,F
00F8C:  BRA    0F72
....................  
....................  
.................... 	value=0; 
00F8E:  CLRF   x01
00F90:  CLRF   x00
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00F92:  CLRF   x02
00F94:  MOVF   x02,W
00F96:  SUBLW  0D
00F98:  BNC   0FB0
.................... 		output_low(MCP3208_CLK); 
00F9A:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00F9C:  BTFSC  F82.4
00F9E:  BRA    0FA4
00FA0:  BCF    FD8.0
00FA2:  BRA    0FA6
00FA4:  BSF    FD8.0
00FA6:  RLCF   x00,F
00FA8:  RLCF   x01,F
.................... 		output_high(MCP3208_CLK); 
00FAA:  BSF    F8B.3
.................... 	} 
00FAC:  INCF   x02,F
00FAE:  BRA    0F94
....................  
.................... 	bit_clear(value,13); 
00FB0:  BCF    x01.5
.................... 	bit_clear(value,12); 
00FB2:  BCF    x01.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00FB6:  MOVFF  900,01
00FBA:  MOVFF  901,02
.................... } 
00FBE:  MOVLB  0
00FC0:  GOTO   1032 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
014E2:  MOVLB  A
014E4:  CLRF   x01
014E6:  MOVFF  918,A00
014EA:  CLRF   x03
014EC:  MOVLW  20
014EE:  MOVWF  x02
014F0:  MOVLB  0
014F2:  CALL   08E2
014F6:  MOVFF  02,03
014FA:  MOVF   01,W
014FC:  ADDLW  CB
014FE:  MOVWF  01
01500:  MOVLW  00
01502:  ADDWFC 03,F
01504:  MOVFF  01,91C
01508:  MOVLB  9
0150A:  MOVFF  03,91D
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
0150E:  CLRF   x1A
01510:  CLRF   x19
.................... 	for( i = 0; i < 16 ; i++ ) { 
01512:  CLRF   x1B
01514:  MOVF   x1B,W
01516:  SUBLW  0F
01518:  BNC   153C
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
0151A:  BCF    FD8.0
0151C:  RLCF   x1B,W
0151E:  CLRF   03
01520:  ADDWF  x1C,W
01522:  MOVWF  FE9
01524:  MOVF   x1D,W
01526:  ADDWFC 03,W
01528:  MOVWF  FEA
0152A:  MOVFF  FEC,03
0152E:  MOVF   FED,F
01530:  MOVF   FEF,W
01532:  ADDWF  x19,F
01534:  MOVF   03,W
01536:  ADDWFC x1A,F
.................... 	} 
01538:  INCF   x1B,F
0153A:  BRA    1514
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
0153C:  MOVLW  08
0153E:  ADDWF  x19,W
01540:  MOVWF  x1E
01542:  MOVLW  00
01544:  ADDWFC x1A,W
01546:  MOVWF  x1F
01548:  RRCF   x1F,W
0154A:  MOVWF  03
0154C:  RRCF   x1E,W
0154E:  MOVWF  02
01550:  RRCF   03,F
01552:  RRCF   02,F
01554:  RRCF   03,F
01556:  RRCF   02,F
01558:  RRCF   03,F
0155A:  RRCF   02,F
0155C:  MOVLW  0F
0155E:  ANDWF  03,F
01560:  MOVFF  02,01
01564:  MOVFF  03,02
.................... } 
01568:  MOVLB  0
0156A:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00FC4:  MOVLB  1
00FC6:  INCF   xCB,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00FC8:  MOVF   xCB,W
00FCA:  SUBLW  0F
00FCC:  BC    0FD0
.................... 		current.adc_buffer_index=0; 
00FCE:  CLRF   xCB
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00FD0:  MOVLB  8
00FD2:  CLRF   xFC
00FD4:  MOVF   xFC,W
00FD6:  SUBLW  07
00FD8:  BNC   1068
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00FDA:  MOVLB  A
00FDC:  CLRF   x01
00FDE:  MOVFF  8FC,A00
00FE2:  CLRF   x03
00FE4:  MOVLW  20
00FE6:  MOVWF  x02
00FE8:  MOVLB  0
00FEA:  RCALL  08E2
00FEC:  MOVFF  02,03
00FF0:  MOVF   01,W
00FF2:  ADDLW  34
00FF4:  MOVLB  8
00FF6:  MOVWF  xFD
00FF8:  MOVLW  00
00FFA:  ADDWFC 02,W
00FFC:  MOVWF  xFE
00FFE:  CLRF   03
01000:  MOVLB  1
01002:  MOVFF  1CB,02
01006:  BCF    FD8.0
01008:  RLCF   02,F
0100A:  RLCF   03,F
0100C:  MOVF   02,W
0100E:  MOVLB  8
01010:  ADDWF  xFD,W
01012:  MOVWF  01
01014:  MOVF   xFE,W
01016:  ADDWFC 03,F
01018:  MOVF   01,W
0101A:  ADDLW  97
0101C:  MOVWF  01
0101E:  MOVLW  00
01020:  ADDWFC 03,F
01022:  MOVFF  01,8FD
01026:  MOVFF  03,8FE
0102A:  MOVFF  8FC,8FF
0102E:  MOVLB  0
01030:  BRA    0EF8
01032:  MOVFF  8FE,FEA
01036:  MOVFF  8FD,FE9
0103A:  MOVFF  02,FEC
0103E:  MOVF   FED,F
01040:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
01044:  CLRF   03
01046:  MOVLB  8
01048:  MOVFF  8FC,02
0104C:  BCF    FD8.0
0104E:  RLCF   02,F
01050:  RLCF   03,F
01052:  MOVF   02,W
01054:  ADDLW  BB
01056:  MOVWF  FE9
01058:  MOVLW  00
0105A:  ADDWFC 03,W
0105C:  MOVWF  FEA
0105E:  CLRF   FEC
01060:  MOVF   FED,F
01062:  CLRF   FEF
....................  
.................... 	} 
01064:  INCF   xFC,F
01066:  BRA    0FD4
.................... } 
01068:  MOVLB  0
0106A:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00CC4:  MOVF   x1D,W
00CC6:  XORWF  x1E,W
00CC8:  MOVWF  01
*
00D16:  MOVF   x1D,W
00D18:  XORWF  x1E,W
00D1A:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00C44:  MOVLB  9
00C46:  CLRF   x05
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00C48:  MOVFF  904,03
00C4C:  MOVF   x03,W
00C4E:  BTFSC  FD8.2
00C50:  DECF   x04,F
00C52:  DECF   x03,F
00C54:  MOVWF  x06
00C56:  MOVFF  03,907
00C5A:  MOVF   x06,F
00C5C:  BNZ   0C62
00C5E:  MOVF   x07,F
00C60:  BZ    0CD6
.................... 		*data = read_eeprom( address++ ); 
00C62:  MOVFF  902,03
00C66:  MOVF   x01,W
00C68:  MOVWF  FE9
00C6A:  MOVFF  03,FEA
00C6E:  MOVF   x00,W
00C70:  MOVWF  03
00C72:  MOVLB  8
00C74:  MOVF   xFF,W
00C76:  INCF   xFF,F
00C78:  BTFSS  FD8.2
00C7A:  BRA    0C82
00C7C:  MOVLB  9
00C7E:  INCF   x00,F
00C80:  MOVLB  8
00C82:  MOVLB  9
00C84:  MOVWF  x08
00C86:  MOVFF  03,909
00C8A:  MOVFF  FF2,90A
00C8E:  BCF    FF2.6
00C90:  BCF    FF2.7
00C92:  MOVFF  909,FAA
00C96:  MOVFF  908,FA9
00C9A:  BCF    FA6.6
00C9C:  BCF    FA6.7
00C9E:  BSF    FA6.0
00CA0:  MOVF   FA8,W
00CA2:  BTFSC  x0A.6
00CA4:  BSF    FF2.6
00CA6:  BTFSC  x0A.7
00CA8:  BSF    FF2.7
00CAA:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00CAC:  MOVFF  902,03
00CB0:  MOVF   x01,W
00CB2:  MOVWF  FE9
00CB4:  MOVFF  03,FEA
00CB8:  MOVFF  FEF,906
00CBC:  MOVFF  905,91D
00CC0:  MOVFF  906,91E
*
00CCA:  MOVFF  01,905
.................... 		data++; 
00CCE:  INCF   x01,F
00CD0:  BTFSC  FD8.2
00CD2:  INCF   x02,F
.................... 	} 
00CD4:  BRA    0C48
.................... 	return crc; 
00CD6:  MOVFF  905,01
.................... } 
00CDA:  MOVLB  0
00CDC:  GOTO   0EAC (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00CE0:  MOVLB  9
00CE2:  CLRF   x1B
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00CE4:  MOVFF  91A,03
00CE8:  MOVF   x19,W
00CEA:  BTFSC  FD8.2
00CEC:  DECF   x1A,F
00CEE:  DECF   x19,F
00CF0:  MOVWF  x1C
00CF2:  MOVFF  03,91D
00CF6:  MOVF   x1C,F
00CF8:  BNZ   0CFE
00CFA:  MOVF   x1D,F
00CFC:  BZ    0D7C
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00CFE:  MOVFF  918,03
00D02:  MOVF   x17,W
00D04:  MOVWF  FE9
00D06:  MOVFF  03,FEA
00D0A:  MOVFF  FEF,91C
00D0E:  MOVFF  91B,91D
00D12:  MOVFF  91C,91E
*
00D1C:  MOVFF  01,91B
.................... 		write_eeprom( address++, *data++ ); 
00D20:  MOVF   x16,W
00D22:  MOVWF  03
00D24:  MOVF   x15,W
00D26:  INCF   x15,F
00D28:  BTFSC  FD8.2
00D2A:  INCF   x16,F
00D2C:  MOVWF  x1C
00D2E:  MOVFF  03,91D
00D32:  MOVF   x18,W
00D34:  MOVWF  03
00D36:  MOVF   x17,W
00D38:  INCF   x17,F
00D3A:  BTFSC  FD8.2
00D3C:  INCF   x18,F
00D3E:  MOVWF  FE9
00D40:  MOVFF  03,FEA
00D44:  MOVFF  FEF,91E
00D48:  MOVFF  91D,FAA
00D4C:  MOVFF  91C,FA9
00D50:  MOVFF  91E,FA8
00D54:  BCF    FA6.6
00D56:  BCF    FA6.7
00D58:  BSF    FA6.2
00D5A:  MOVF   FF2,W
00D5C:  MOVWF  00
00D5E:  BCF    FF2.6
00D60:  BCF    FF2.7
00D62:  MOVLB  F
00D64:  MOVLW  55
00D66:  MOVWF  FA7
00D68:  MOVLW  AA
00D6A:  MOVWF  FA7
00D6C:  BSF    FA6.1
00D6E:  BTFSC  FA6.1
00D70:  BRA    0D6E
00D72:  BCF    FA6.2
00D74:  MOVF   00,W
00D76:  IORWF  FF2,F
.................... 	} 
00D78:  MOVLB  9
00D7A:  BRA    0CE4
....................  
.................... 	return crc; 
00D7C:  MOVFF  91B,01
.................... } 
00D80:  MOVLB  0
00D82:  GOTO   0DA6 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00D86:  MOVLB  9
00D88:  CLRF   x14
00D8A:  MOVLW  36
00D8C:  MOVWF  x13
00D8E:  CLRF   x16
00D90:  MOVLW  02
00D92:  MOVWF  x15
00D94:  MOVFF  914,918
00D98:  MOVFF  913,917
00D9C:  CLRF   x1A
00D9E:  MOVLW  61
00DA0:  MOVWF  x19
00DA2:  MOVLB  0
00DA4:  BRA    0CE0
00DA6:  MOVFF  01,912
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00DAA:  CLRF   FAA
00DAC:  CLRF   FA9
00DAE:  MOVFF  912,FA8
00DB2:  BCF    FA6.6
00DB4:  BCF    FA6.7
00DB6:  BSF    FA6.2
00DB8:  MOVF   FF2,W
00DBA:  MOVWF  00
00DBC:  BCF    FF2.6
00DBE:  BCF    FF2.7
00DC0:  MOVLB  F
00DC2:  MOVLW  55
00DC4:  MOVWF  FA7
00DC6:  MOVLW  AA
00DC8:  MOVWF  FA7
00DCA:  BSF    FA6.1
00DCC:  BTFSC  FA6.1
00DCE:  BRA    0DCC
00DD0:  BCF    FA6.2
00DD2:  MOVF   00,W
00DD4:  IORWF  FF2,F
.................... } 
00DD6:  MOVLB  0
00DD8:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00DDA:  MOVLW  96
00DDC:  MOVLB  1
00DDE:  MOVWF  xF8
....................  
.................... 	config.modbus_address=38; 
00DE0:  MOVLW  26
00DE2:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00DE4:  MOVLW  03
00DE6:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00DE8:  MOVLW  02
00DEA:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00DEC:  MOVLW  50
00DEE:  MOVWF  3A
.................... 	config.serial_number=9876; 
00DF0:  MOVLW  26
00DF2:  MOVWF  3C
00DF4:  MOVLW  94
00DF6:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00DF8:  CLRF   3E
00DFA:  MOVLW  14
00DFC:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00DFE:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00E00:  MOVLW  02
00E02:  MOVWF  41
00E04:  MOVLW  76
00E06:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00E08:  CLRF   43
00E0A:  MOVLW  02
00E0C:  MOVWF  42
.................... 	config.power_startup=0; 
00E0E:  CLRF   44
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00E10:  CLRF   FEA
00E12:  MOVLW  4F
00E14:  MOVWF  FE9
00E16:  CLRF   00
00E18:  CLRF   02
00E1A:  MOVLW  48
00E1C:  MOVWF  01
00E1E:  MOVLB  0
00E20:  RCALL  0904
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00E22:  CLRF   FEA
00E24:  MOVLW  4F
00E26:  MOVWF  FE9
00E28:  MOVLW  00
00E2A:  CALL   0188
00E2E:  TBLRD*-
00E30:  TBLRD*+
00E32:  MOVF   FF5,W
00E34:  MOVWF  FEE
00E36:  IORLW  00
00E38:  BNZ   0E30
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00E3A:  CLRF   FEA
00E3C:  MOVLW  55
00E3E:  MOVWF  FE9
00E40:  MOVLW  00
00E42:  CALL   01A0
00E46:  TBLRD*-
00E48:  TBLRD*+
00E4A:  MOVF   FF5,W
00E4C:  MOVWF  FEE
00E4E:  IORLW  00
00E50:  BNZ   0E48
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00E52:  CLRF   FEA
00E54:  MOVLW  5B
00E56:  MOVWF  FE9
00E58:  MOVLW  00
00E5A:  CALL   01B8
00E5E:  TBLRD*-
00E60:  TBLRD*+
00E62:  MOVF   FF5,W
00E64:  MOVWF  FEE
00E66:  IORLW  00
00E68:  BNZ   0E60
....................  
.................... 	strcpy(config.nmea0183_sentence[10],"$WIMDA"); 
00E6A:  CLRF   FEA
00E6C:  MOVLW  8B
00E6E:  MOVWF  FE9
00E70:  MOVLW  00
00E72:  CALL   01D0
00E76:  TBLRD*-
00E78:  TBLRD*+
00E7A:  MOVF   FF5,W
00E7C:  MOVWF  FEE
00E7E:  IORLW  00
00E80:  BNZ   0E78
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00E82:  RCALL  0D86
....................  
.................... } 
00E84:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00E86:  MOVLB  8
00E88:  CLRF   xFE
00E8A:  MOVLW  36
00E8C:  MOVWF  xFD
00E8E:  MOVLB  9
00E90:  CLRF   x00
00E92:  MOVLW  02
00E94:  MOVLB  8
00E96:  MOVWF  xFF
00E98:  MOVFF  8FE,902
00E9C:  MOVFF  8FD,901
00EA0:  MOVLB  9
00EA2:  CLRF   x04
00EA4:  MOVLW  61
00EA6:  MOVWF  x03
00EA8:  MOVLB  0
00EAA:  BRA    0C44
00EAC:  MOVFF  01,8FC
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00EB0:  MOVFF  FF2,8FD
00EB4:  BCF    FF2.6
00EB6:  BCF    FF2.7
00EB8:  CLRF   FAA
00EBA:  CLRF   FA9
00EBC:  BCF    FA6.6
00EBE:  BCF    FA6.7
00EC0:  BSF    FA6.0
00EC2:  MOVF   FA8,W
00EC4:  MOVLB  8
00EC6:  BTFSC  xFD.6
00EC8:  BSF    FF2.6
00ECA:  BTFSC  xFD.7
00ECC:  BSF    FF2.7
00ECE:  SUBWF  xFC,W
00ED0:  BZ    0ED8
.................... 		write_default_param_file(); 
00ED2:  MOVLB  0
00ED4:  RCALL  0DDA
00ED6:  MOVLB  8
.................... 	} 
.................... } 
00ED8:  MOVLB  0
00EDA:  GOTO   3282 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
.................... } 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
00EDE:  BTFSS  F9E.5
00EE0:  BRA    0EE6
.................... 		fgetc(STREAM_PI); 
00EE2:  RCALL  076E
.................... 	} 
00EE4:  BRA    0EDE
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00EE6:  BSF    F9D.5
.................... } 
00EE8:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00EEA:  RCALL  0EDE
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_8 | T0_8_BIT); /* 0.683 ms @ 12 MHz. Use fosc/4 not fosc */ 
00EEC:  MOVLW  C2
00EEE:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00EF0:  MOVLW  C0
00EF2:  IORWF  FF2,F
.................... } 
00EF4:  GOTO   3294 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
00408:  BCF    FF2.5
.................... 	if (enable) { 
0040A:  MOVLB  A
0040C:  MOVF   x12,F
0040E:  BZ    0418
.................... 		set_timer0(0); 
00410:  CLRF   FD7
00412:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00414:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00416:  BSF    FF2.5
.................... 	} 
.................... } 
00418:  MOVLB  0
0041A:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0041C:  MOVLB  7
0041E:  MOVF   xE9,W
00420:  SUBLW  02
00422:  BNZ   0438
00424:  MOVF   xEA,F
00426:  BNZ   0438
00428:  MOVF   xEB,F
0042A:  BNZ   0438
0042C:  BTFSC  xE8.0
0042E:  BRA    0438
....................    { 
....................       modbus_rx.len-=2; 
00430:  MOVLW  02
00432:  SUBWF  xED,F
....................       modbus_serial_new=TRUE; 
00434:  BSF    xE8.0
....................    } 
....................    else 
00436:  BRA    043A
....................       modbus_serial_new=FALSE; 
00438:  BCF    xE8.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0043A:  SETF   xEB
0043C:  SETF   xEA
....................    modbus_serial_state=MODBUS_GETADDY; 
0043E:  CLRF   xE9
....................    modbus_enable_timeout(FALSE); 
00440:  MOVLB  A
00442:  CLRF   x12
00444:  MOVLB  0
00446:  RCALL  0408
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
00448:  BCF    FF2.2
0044A:  GOTO   0094
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00784:  MOVLB  7
00786:  MOVF   xEB,W
00788:  MOVLB  A
0078A:  XORWF  x12,W
0078C:  MOVWF  x13
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0078E:  CLRF   03
00790:  MOVF   x13,W
00792:  MOVLB  0
00794:  RCALL  01E8
00796:  MOVWF  01
00798:  MOVLB  7
0079A:  MOVF   xEA,W
0079C:  XORWF  01,W
0079E:  MOVWF  xEB
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
007A0:  CLRF   03
007A2:  MOVLB  A
007A4:  MOVF   x13,W
007A6:  MOVLB  0
007A8:  RCALL  02F8
007AA:  MOVFF  FE8,7EA
.................... } 
007AE:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	timers.rda_tx_buff[timers.rda_tx_length]=c; 
*
013E8:  MOVLW  01
013EA:  MOVLB  4
013EC:  ADDWF  x01,W
013EE:  MOVWF  FE9
013F0:  MOVLW  03
013F2:  MOVWF  FEA
013F4:  BTFSC  FD8.0
013F6:  INCF   FEA,F
013F8:  MOVFF  912,FEF
.................... 	timers.rda_tx_length++; 
013FC:  INCF   x01,F
013FE:  CLRF   19
01400:  BTFSC  FF2.6
01402:  BSF    19.6
01404:  BCF    FF2.6
01406:  BTFSC  FF2.7
01408:  BSF    19.7
0140A:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
0140C:  MOVFF  912,A12
01410:  MOVLB  0
01412:  CALL   0784
01416:  BTFSC  19.6
01418:  BSF    FF2.6
0141A:  BTFSC  19.7
0141C:  BSF    FF2.7
.................... } 
0141E:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) { 
.................... 	/* reset out transmit buffer */ 
.................... 	timers.rda_tx_length=0; 
01420:  MOVLB  4
01422:  CLRF   x01
.................... 	timers.rda_tx_pos=0; 
01424:  CLRF   x02
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01426:  MOVLB  7
01428:  SETF   xEB
0142A:  SETF   xEA
.................... 	modbus_serial_new=FALSE; 
0142C:  BCF    xE8.0
....................  
.................... 	modbus_serial_putc(to); 
0142E:  MOVFF  910,912
01432:  MOVLB  0
01434:  RCALL  13E8
.................... 	modbus_serial_putc(func); 
01436:  MOVFF  911,912
0143A:  RCALL  13E8
.................... } 
0143C:  RETURN 0
....................  
.................... void modbus_serial_send_stop() { 
.................... 	int8 crc_low, crc_high; 
....................  
.................... 	crc_high=modbus_serial_crc.b[1]; 
0143E:  MOVFF  7EB,911
.................... 	crc_low=modbus_serial_crc.b[0]; 
01442:  MOVFF  7EA,910
....................  
.................... 	modbus_serial_putc(crc_high); 
01446:  MOVFF  911,912
0144A:  RCALL  13E8
.................... 	modbus_serial_putc(crc_low); 
0144C:  MOVFF  910,912
01450:  RCALL  13E8
....................  
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01452:  MOVLB  7
01454:  SETF   xEB
01456:  SETF   xEA
....................  
.................... 	/* ready to transmit from buffer flag set. Elsewhere we start sending */ 
.................... 	timers.now_rda_tx_ready=1; 
01458:  MOVLB  4
0145A:  BSF    x03.0
.................... } 
0145C:  MOVLB  0
0145E:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
01288:  MOVLB  7
0128A:  BTFSC  xE8.0
0128C:  BRA    1296
....................       return FALSE; 
0128E:  MOVLW  00
01290:  MOVWF  01
01292:  BRA    12A8
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
01294:  BRA    12A2
01296:  BTFSS  xEE.7
01298:  BRA    12A2
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0129A:  MOVFF  7F0,7EF
....................       modbus_rx.len = 1; 
0129E:  MOVLW  01
012A0:  MOVWF  xED
....................    } 
....................    modbus_serial_new=FALSE; 
012A2:  BCF    xE8.0
....................    return TRUE; 
012A4:  MOVLW  01
012A6:  MOVWF  01
.................... } 
012A8:  MOVLB  0
012AA:  GOTO   2B2E (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02A9A:  MOVFF  908,910
02A9E:  MOVLW  06
02AA0:  MOVLB  9
02AA2:  MOVWF  x11
02AA4:  MOVLB  0
02AA6:  CALL   1420
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02AAA:  MOVFF  90A,90D
02AAE:  MOVFF  90A,912
02AB2:  CALL   13E8
....................    modbus_serial_putc(make8(reg_address,0)); 
02AB6:  MOVFF  909,90D
02ABA:  MOVFF  909,912
02ABE:  CALL   13E8
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02AC2:  MOVFF  90C,90D
02AC6:  MOVFF  90C,912
02ACA:  CALL   13E8
....................    modbus_serial_putc(make8(reg_value,0)); 
02ACE:  MOVFF  90B,90D
02AD2:  MOVFF  90B,912
02AD6:  CALL   13E8
....................  
....................    modbus_serial_send_stop(); 
02ADA:  CALL   143E
.................... } 
02ADE:  GOTO   2D1A (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02AE2:  MOVFF  906,910
02AE6:  MOVLW  10
02AE8:  MOVLB  9
02AEA:  MOVWF  x11
02AEC:  MOVLB  0
02AEE:  CALL   1420
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02AF2:  MOVFF  908,90B
02AF6:  MOVFF  908,912
02AFA:  CALL   13E8
....................    modbus_serial_putc(make8(start_address,0)); 
02AFE:  MOVFF  907,90B
02B02:  MOVFF  907,912
02B06:  CALL   13E8
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02B0A:  MOVFF  90A,90B
02B0E:  MOVFF  90A,912
02B12:  CALL   13E8
....................    modbus_serial_putc(make8(quantity,0)); 
02B16:  MOVFF  909,90B
02B1A:  MOVFF  909,912
02B1E:  CALL   13E8
....................  
....................    modbus_serial_send_stop(); 
02B22:  CALL   143E
.................... } 
02B26:  GOTO   2DEC (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01460:  MOVLB  9
01462:  MOVF   x07,W
01464:  IORLW  80
01466:  MOVWF  x0A
01468:  MOVFF  908,90B
0146C:  MOVFF  906,910
01470:  MOVWF  x11
01472:  MOVLB  0
01474:  RCALL  1420
....................    modbus_serial_putc(error); 
01476:  MOVFF  909,912
0147A:  RCALL  13E8
....................    modbus_serial_send_stop(); 
0147C:  RCALL  143E
.................... } 
0147E:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          54 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1013 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
.................... #define MIN_NMEA0183_META_REGISTER   6500 
.................... #define MAX_NMEA0183_META_REGISTER   MIN_NMEA0183_META_REGISTER + N_NMEA0183_SENTENCES*2 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
015D0:  MOVLB  1
015D2:  CLRF   xCD
015D4:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
015D6:  CLRF   xCF
015D8:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
015DA:  CLRF   xD1
015DC:  CLRF   xD0
.................... } 
015DE:  MOVLB  0
015E0:  GOTO   230E (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0156C:  BCF    FF2.6
0156E:  BCF    FF2.7
01570:  BTFSC  FF2.7
01572:  BRA    156E
....................  
.................... 	current.pulse_count[0]=0; 
01574:  CLRF   xAA
01576:  CLRF   xA9
.................... 	current.pulse_count[1]=0; 
01578:  CLRF   xAC
0157A:  CLRF   xAB
.................... 	current.pulse_count[2]=0; 
0157C:  CLRF   xAE
0157E:  CLRF   xAD
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
01580:  SETF   x9E
01582:  SETF   x9D
.................... 	current.pulse_min_period[1]=65535; 
01584:  SETF   xA0
01586:  SETF   x9F
.................... 	current.pulse_min_period[2]=65535; 
01588:  SETF   xA2
0158A:  SETF   xA1
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
0158C:  CLRF   xA4
0158E:  CLRF   xA3
.................... 	current.pulse_max_period[1]=0; 
01590:  CLRF   xA6
01592:  CLRF   xA5
.................... 	current.pulse_max_period[2]=0; 
01594:  CLRF   xA8
01596:  CLRF   xA7
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01598:  MOVLB  1
0159A:  CLRF   xD7
0159C:  CLRF   xD6
....................  
.................... 	enable_interrupts(GLOBAL); 
0159E:  MOVLW  C0
015A0:  IORWF  FF2,F
.................... } 
015A2:  MOVLB  0
015A4:  GOTO   22BE (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
015A8:  BCF    FF2.6
015AA:  BCF    FF2.7
015AC:  BTFSC  FF2.7
015AE:  BRA    15AA
.................... 	current.pulse_sum[0]=0; 
015B0:  CLRF   xB2
015B2:  CLRF   xB1
015B4:  CLRF   xB0
015B6:  CLRF   xAF
.................... 	current.pulse_sum[1]=0; 
015B8:  CLRF   xB6
015BA:  CLRF   xB5
015BC:  CLRF   xB4
015BE:  CLRF   xB3
.................... 	current.pulse_sum[2]=0; 
015C0:  CLRF   xBA
015C2:  CLRF   xB9
015C4:  CLRF   xB8
015C6:  CLRF   xB7
.................... 	enable_interrupts(GLOBAL); 
015C8:  MOVLW  C0
015CA:  IORWF  FF2,F
.................... } 
015CC:  GOTO   22CE (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01480:  BCF    FF2.6
01482:  BCF    FF2.7
01484:  BTFSC  FF2.7
01486:  BRA    1482
.................... 	l=current.pulse_sum[ch]; 
01488:  MOVLB  A
0148A:  CLRF   x01
0148C:  MOVFF  918,A00
01490:  CLRF   x03
01492:  MOVLW  04
01494:  MOVWF  x02
01496:  MOVLB  0
01498:  CALL   08E2
0149C:  MOVFF  02,03
014A0:  MOVF   01,W
014A2:  ADDLW  AF
014A4:  MOVWF  FE9
014A6:  MOVLW  00
014A8:  ADDWFC 02,W
014AA:  MOVWF  FEA
014AC:  MOVFF  FEF,00
014B0:  MOVFF  FEC,01
014B4:  MOVFF  FEC,02
014B8:  MOVFF  FEC,03
014BC:  MOVFF  03,91C
014C0:  MOVFF  02,91B
014C4:  MOVFF  01,91A
014C8:  MOVFF  00,919
.................... 	enable_interrupts(GLOBAL); 
014CC:  MOVLW  C0
014CE:  IORWF  FF2,F
....................  
.................... 	return l; 
014D0:  MOVFF  919,00
014D4:  MOVFF  91A,01
014D8:  MOVFF  91B,02
014DC:  MOVFF  91C,03
.................... } 
014E0:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
015E4:  MOVLB  9
015E6:  MOVF   x13,W
015E8:  SUBLW  06
015EA:  BC    1640
015EC:  XORLW  FF
015EE:  BNZ   15F6
015F0:  MOVF   x12,W
015F2:  SUBLW  CF
015F4:  BC    1640
015F6:  MOVF   x13,W
015F8:  SUBLW  09
015FA:  BNC   1640
015FC:  BNZ   1604
015FE:  MOVF   x12,W
01600:  SUBLW  CF
01602:  BNC   1640
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01604:  MOVLW  D0
01606:  SUBWF  x12,W
01608:  MOVWF  x18
0160A:  MOVLW  07
0160C:  SUBWFB x13,W
0160E:  MOVWF  x19
01610:  MOVLW  02
01612:  ADDWF  x19,F
01614:  MOVFF  FF2,91A
01618:  BCF    FF2.6
0161A:  BCF    FF2.7
0161C:  MOVFF  919,FAA
01620:  MOVFF  918,FA9
01624:  BCF    FA6.6
01626:  BCF    FA6.7
01628:  BSF    FA6.0
0162A:  MOVF   FA8,W
0162C:  BTFSC  x1A.6
0162E:  BSF    FF2.6
01630:  BTFSC  x1A.7
01632:  BSF    FF2.7
01634:  CLRF   03
01636:  MOVWF  01
01638:  MOVF   03,W
0163A:  MOVWF  02
0163C:  GOTO   262C
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
01640:  MOVF   x13,W
01642:  SUBLW  03
01644:  BC    16C4
01646:  XORLW  FF
01648:  BNZ   1650
0164A:  MOVF   x12,W
0164C:  SUBLW  4B
0164E:  BC    16C4
01650:  MOVF   x13,W
01652:  SUBLW  04
01654:  BNC   16C4
01656:  BNZ   165E
01658:  MOVF   x12,W
0165A:  SUBLW  93
0165C:  BNC   16C4
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0165E:  MOVLW  4C
01660:  SUBWF  x12,W
01662:  MOVWF  x14
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01664:  MOVFF  914,918
01668:  MOVLW  06
0166A:  MOVWF  x19
0166C:  MOVLB  0
0166E:  CALL   0B96
01672:  MOVFF  00,915
.................... 		n = n / 6; /* number of sentence */ 
01676:  MOVFF  914,918
0167A:  MOVLW  06
0167C:  MOVLB  9
0167E:  MOVWF  x19
01680:  MOVLB  0
01682:  CALL   0B96
01686:  MOVFF  01,914
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
0168A:  MOVLB  9
0168C:  MOVF   x14,W
0168E:  MULLW  06
01690:  MOVF   FF3,W
01692:  CLRF   03
01694:  ADDLW  19
01696:  MOVWF  x18
01698:  MOVLW  00
0169A:  ADDWFC 03,W
0169C:  MOVWF  x19
0169E:  CLRF   03
016A0:  MOVF   x15,W
016A2:  ADDWF  x18,W
016A4:  MOVWF  01
016A6:  MOVF   x19,W
016A8:  ADDWFC 03,F
016AA:  MOVF   01,W
016AC:  ADDLW  36
016AE:  MOVWF  FE9
016B0:  MOVLW  00
016B2:  ADDWFC 03,W
016B4:  MOVWF  FEA
016B6:  MOVF   FEF,W
016B8:  CLRF   03
016BA:  MOVWF  01
016BC:  MOVFF  03,02
016C0:  GOTO   262C
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
016C4:  MOVF   x13,W
016C6:  SUBLW  12
016C8:  BC    170A
016CA:  XORLW  FF
016CC:  BNZ   16D4
016CE:  MOVF   x12,W
016D0:  SUBLW  87
016D2:  BC    170A
016D4:  MOVF   x13,W
016D6:  SUBLW  17
016D8:  BNC   170A
016DA:  BNZ   16E2
016DC:  MOVF   x12,W
016DE:  SUBLW  47
016E0:  BNC   170A
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
016E2:  MOVLW  88
016E4:  SUBWF  x12,F
016E6:  MOVLW  13
016E8:  SUBWFB x13,F
....................  
....................  		p  = nmea.sentence[0]; 
016EA:  MOVLW  04
016EC:  MOVWF  x17
016EE:  MOVWF  x16
.................... 		return (int16) p[addr]; 
016F0:  MOVF   x16,W
016F2:  ADDWF  x12,W
016F4:  MOVWF  FE9
016F6:  MOVF   x17,W
016F8:  ADDWFC x13,W
016FA:  MOVWF  FEA
016FC:  MOVF   FEF,W
016FE:  CLRF   03
01700:  MOVWF  01
01702:  MOVFF  03,02
01706:  GOTO   262C
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
0170A:  MOVF   x13,W
0170C:  SUBLW  16
0170E:  BC    1778
01710:  XORLW  FF
01712:  BNZ   171A
01714:  MOVF   x12,W
01716:  SUBLW  6F
01718:  BC    1778
0171A:  MOVF   x13,W
0171C:  SUBLW  19
0171E:  BNC   1778
01720:  BNZ   1728
01722:  MOVF   x12,W
01724:  SUBLW  4F
01726:  BNC   1778
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01728:  MOVLW  70
0172A:  SUBWF  x12,F
0172C:  MOVLW  17
0172E:  SUBWFB x13,F
.................... 		addr = addr * 2; 
01730:  BCF    FD8.0
01732:  RLCF   x12,F
01734:  RLCF   x13,F
....................  
....................  		p  = nmea.sentence[0]; 
01736:  MOVLW  04
01738:  MOVWF  x17
0173A:  MOVWF  x16
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0173C:  MOVF   x16,W
0173E:  ADDWF  x12,W
01740:  MOVWF  FE9
01742:  MOVF   x17,W
01744:  ADDWFC x13,W
01746:  MOVWF  FEA
01748:  MOVFF  FEF,918
0174C:  MOVLW  01
0174E:  ADDWF  x12,W
01750:  MOVWF  x19
01752:  MOVLW  00
01754:  ADDWFC x13,W
01756:  MOVWF  x1A
01758:  MOVF   x16,W
0175A:  ADDWF  x19,W
0175C:  MOVWF  FE9
0175E:  MOVF   x17,W
01760:  ADDWFC x1A,W
01762:  MOVWF  FEA
01764:  MOVFF  FEF,91B
01768:  MOVFF  918,03
0176C:  MOVFF  91B,01
01770:  MOVFF  918,02
01774:  GOTO   262C
.................... 	} 
....................  
....................  
.................... 	switch ( addr ) { 
01778:  MOVF   x12,W
0177A:  MOVWF  00
0177C:  MOVF   x13,W
0177E:  MOVWF  03
01780:  MOVF   03,W
01782:  BNZ   1790
01784:  MOVF   00,F
01786:  MOVLB  0
01788:  BTFSC  FD8.2
0178A:  GOTO   1E58
0178E:  MOVLB  9
01790:  MOVF   03,W
01792:  BNZ   17A2
01794:  MOVLW  01
01796:  SUBWF  00,W
01798:  MOVLB  0
0179A:  BTFSC  FD8.2
0179C:  GOTO   1E68
017A0:  MOVLB  9
017A2:  MOVF   03,W
017A4:  BNZ   17B4
017A6:  MOVLW  02
017A8:  SUBWF  00,W
017AA:  MOVLB  0
017AC:  BTFSC  FD8.2
017AE:  GOTO   1E78
017B2:  MOVLB  9
017B4:  MOVF   03,W
017B6:  BNZ   17C6
017B8:  MOVLW  03
017BA:  SUBWF  00,W
017BC:  MOVLB  0
017BE:  BTFSC  FD8.2
017C0:  GOTO   1E88
017C4:  MOVLB  9
017C6:  MOVF   03,W
017C8:  BNZ   17D8
017CA:  MOVLW  04
017CC:  SUBWF  00,W
017CE:  MOVLB  0
017D0:  BTFSC  FD8.2
017D2:  GOTO   1E98
017D6:  MOVLB  9
017D8:  MOVF   03,W
017DA:  BNZ   17EA
017DC:  MOVLW  05
017DE:  SUBWF  00,W
017E0:  MOVLB  0
017E2:  BTFSC  FD8.2
017E4:  GOTO   1EC4
017E8:  MOVLB  9
017EA:  MOVF   03,W
017EC:  BNZ   17FC
017EE:  MOVLW  06
017F0:  SUBWF  00,W
017F2:  MOVLB  0
017F4:  BTFSC  FD8.2
017F6:  GOTO   1ED6
017FA:  MOVLB  9
017FC:  MOVF   03,W
017FE:  BNZ   180E
01800:  MOVLW  07
01802:  SUBWF  00,W
01804:  MOVLB  0
01806:  BTFSC  FD8.2
01808:  GOTO   1EE6
0180C:  MOVLB  9
0180E:  MOVF   03,W
01810:  BNZ   1820
01812:  MOVLW  08
01814:  SUBWF  00,W
01816:  MOVLB  0
01818:  BTFSC  FD8.2
0181A:  GOTO   1EF6
0181E:  MOVLB  9
01820:  MOVF   03,W
01822:  BNZ   1832
01824:  MOVLW  09
01826:  SUBWF  00,W
01828:  MOVLB  0
0182A:  BTFSC  FD8.2
0182C:  GOTO   1F04
01830:  MOVLB  9
01832:  MOVF   03,W
01834:  BNZ   1844
01836:  MOVLW  0A
01838:  SUBWF  00,W
0183A:  MOVLB  0
0183C:  BTFSC  FD8.2
0183E:  GOTO   1F12
01842:  MOVLB  9
01844:  MOVF   03,W
01846:  BNZ   1856
01848:  MOVLW  0B
0184A:  SUBWF  00,W
0184C:  MOVLB  0
0184E:  BTFSC  FD8.2
01850:  GOTO   1F3E
01854:  MOVLB  9
01856:  MOVF   03,W
01858:  BNZ   1868
0185A:  MOVLW  0C
0185C:  SUBWF  00,W
0185E:  MOVLB  0
01860:  BTFSC  FD8.2
01862:  GOTO   1F4E
01866:  MOVLB  9
01868:  MOVF   03,W
0186A:  BNZ   187A
0186C:  MOVLW  0D
0186E:  SUBWF  00,W
01870:  MOVLB  0
01872:  BTFSC  FD8.2
01874:  GOTO   1F5C
01878:  MOVLB  9
0187A:  MOVF   03,W
0187C:  BNZ   188C
0187E:  MOVLW  0E
01880:  SUBWF  00,W
01882:  MOVLB  0
01884:  BTFSC  FD8.2
01886:  GOTO   1F6A
0188A:  MOVLB  9
0188C:  MOVF   03,W
0188E:  BNZ   189E
01890:  MOVLW  0F
01892:  SUBWF  00,W
01894:  MOVLB  0
01896:  BTFSC  FD8.2
01898:  GOTO   1F78
0189C:  MOVLB  9
0189E:  MOVF   03,W
018A0:  BNZ   18B0
018A2:  MOVLW  10
018A4:  SUBWF  00,W
018A6:  MOVLB  0
018A8:  BTFSC  FD8.2
018AA:  GOTO   1F86
018AE:  MOVLB  9
018B0:  MOVF   03,W
018B2:  BNZ   18C2
018B4:  MOVLW  11
018B6:  SUBWF  00,W
018B8:  MOVLB  0
018BA:  BTFSC  FD8.2
018BC:  GOTO   1FB2
018C0:  MOVLB  9
018C2:  MOVF   03,W
018C4:  BNZ   18D4
018C6:  MOVLW  12
018C8:  SUBWF  00,W
018CA:  MOVLB  0
018CC:  BTFSC  FD8.2
018CE:  GOTO   1FC2
018D2:  MOVLB  9
018D4:  MOVF   03,W
018D6:  BNZ   18E6
018D8:  MOVLW  13
018DA:  SUBWF  00,W
018DC:  MOVLB  0
018DE:  BTFSC  FD8.2
018E0:  GOTO   1FF0
018E4:  MOVLB  9
018E6:  MOVF   03,W
018E8:  BNZ   18F8
018EA:  MOVLW  14
018EC:  SUBWF  00,W
018EE:  MOVLB  0
018F0:  BTFSC  FD8.2
018F2:  GOTO   2008
018F6:  MOVLB  9
018F8:  MOVF   03,W
018FA:  BNZ   190A
018FC:  MOVLW  15
018FE:  SUBWF  00,W
01900:  MOVLB  0
01902:  BTFSC  FD8.2
01904:  GOTO   2016
01908:  MOVLB  9
0190A:  MOVF   03,W
0190C:  BNZ   191C
0190E:  MOVLW  16
01910:  SUBWF  00,W
01912:  MOVLB  0
01914:  BTFSC  FD8.2
01916:  GOTO   2044
0191A:  MOVLB  9
0191C:  MOVF   03,W
0191E:  BNZ   192E
01920:  MOVLW  17
01922:  SUBWF  00,W
01924:  MOVLB  0
01926:  BTFSC  FD8.2
01928:  GOTO   205E
0192C:  MOVLB  9
0192E:  MOVF   03,W
01930:  BNZ   1940
01932:  MOVLW  18
01934:  SUBWF  00,W
01936:  MOVLB  0
01938:  BTFSC  FD8.2
0193A:  GOTO   206C
0193E:  MOVLB  9
01940:  MOVF   03,W
01942:  BNZ   1952
01944:  MOVLW  19
01946:  SUBWF  00,W
01948:  MOVLB  0
0194A:  BTFSC  FD8.2
0194C:  GOTO   209A
01950:  MOVLB  9
01952:  MOVF   03,W
01954:  BNZ   1964
01956:  MOVLW  1A
01958:  SUBWF  00,W
0195A:  MOVLB  0
0195C:  BTFSC  FD8.2
0195E:  GOTO   20B4
01962:  MOVLB  9
01964:  MOVF   03,W
01966:  BNZ   1976
01968:  MOVLW  1B
0196A:  SUBWF  00,W
0196C:  MOVLB  0
0196E:  BTFSC  FD8.2
01970:  GOTO   20C2
01974:  MOVLB  9
01976:  MOVF   03,W
01978:  BNZ   1988
0197A:  MOVLW  1C
0197C:  SUBWF  00,W
0197E:  MOVLB  0
01980:  BTFSC  FD8.2
01982:  GOTO   20F0
01986:  MOVLB  9
01988:  MOVF   03,W
0198A:  BNZ   199A
0198C:  MOVLW  1D
0198E:  SUBWF  00,W
01990:  MOVLB  0
01992:  BTFSC  FD8.2
01994:  GOTO   210A
01998:  MOVLB  9
0199A:  MOVF   03,W
0199C:  BNZ   19AC
0199E:  MOVLW  1E
019A0:  SUBWF  00,W
019A2:  MOVLB  0
019A4:  BTFSC  FD8.2
019A6:  GOTO   2118
019AA:  MOVLB  9
019AC:  MOVF   03,W
019AE:  BNZ   19BE
019B0:  MOVLW  1F
019B2:  SUBWF  00,W
019B4:  MOVLB  0
019B6:  BTFSC  FD8.2
019B8:  GOTO   2146
019BC:  MOVLB  9
019BE:  MOVF   03,W
019C0:  BNZ   19D0
019C2:  MOVLW  20
019C4:  SUBWF  00,W
019C6:  MOVLB  0
019C8:  BTFSC  FD8.2
019CA:  GOTO   2160
019CE:  MOVLB  9
019D0:  MOVF   03,W
019D2:  BNZ   19E2
019D4:  MOVLW  21
019D6:  SUBWF  00,W
019D8:  MOVLB  0
019DA:  BTFSC  FD8.2
019DC:  GOTO   216E
019E0:  MOVLB  9
019E2:  MOVF   03,W
019E4:  BNZ   19F4
019E6:  MOVLW  22
019E8:  SUBWF  00,W
019EA:  MOVLB  0
019EC:  BTFSC  FD8.2
019EE:  GOTO   219C
019F2:  MOVLB  9
019F4:  MOVF   03,W
019F6:  BNZ   1A06
019F8:  MOVLW  23
019FA:  SUBWF  00,W
019FC:  MOVLB  0
019FE:  BTFSC  FD8.2
01A00:  GOTO   21B6
01A04:  MOVLB  9
01A06:  MOVF   03,W
01A08:  BNZ   1A18
01A0A:  MOVLW  24
01A0C:  SUBWF  00,W
01A0E:  MOVLB  0
01A10:  BTFSC  FD8.2
01A12:  GOTO   21C4
01A16:  MOVLB  9
01A18:  MOVF   03,W
01A1A:  BNZ   1A2A
01A1C:  MOVLW  25
01A1E:  SUBWF  00,W
01A20:  MOVLB  0
01A22:  BTFSC  FD8.2
01A24:  GOTO   21F2
01A28:  MOVLB  9
01A2A:  MOVF   03,W
01A2C:  BNZ   1A3C
01A2E:  MOVLW  26
01A30:  SUBWF  00,W
01A32:  MOVLB  0
01A34:  BTFSC  FD8.2
01A36:  GOTO   220C
01A3A:  MOVLB  9
01A3C:  MOVF   03,W
01A3E:  BNZ   1A4E
01A40:  MOVLW  27
01A42:  SUBWF  00,W
01A44:  MOVLB  0
01A46:  BTFSC  FD8.2
01A48:  GOTO   221A
01A4C:  MOVLB  9
01A4E:  MOVF   03,W
01A50:  BNZ   1A60
01A52:  MOVLW  28
01A54:  SUBWF  00,W
01A56:  MOVLB  0
01A58:  BTFSC  FD8.2
01A5A:  GOTO   2248
01A5E:  MOVLB  9
01A60:  MOVF   03,W
01A62:  BNZ   1A72
01A64:  MOVLW  29
01A66:  SUBWF  00,W
01A68:  MOVLB  0
01A6A:  BTFSC  FD8.2
01A6C:  GOTO   2262
01A70:  MOVLB  9
01A72:  MOVF   03,W
01A74:  BNZ   1A84
01A76:  MOVLW  2A
01A78:  SUBWF  00,W
01A7A:  MOVLB  0
01A7C:  BTFSC  FD8.2
01A7E:  GOTO   2270
01A82:  MOVLB  9
01A84:  MOVF   03,W
01A86:  BNZ   1A96
01A88:  MOVLW  2B
01A8A:  SUBWF  00,W
01A8C:  MOVLB  0
01A8E:  BTFSC  FD8.2
01A90:  GOTO   228A
01A94:  MOVLB  9
01A96:  MOVF   03,W
01A98:  BNZ   1AA8
01A9A:  MOVLW  2C
01A9C:  SUBWF  00,W
01A9E:  MOVLB  0
01AA0:  BTFSC  FD8.2
01AA2:  GOTO   229A
01AA6:  MOVLB  9
01AA8:  MOVF   03,W
01AAA:  BNZ   1ABA
01AAC:  MOVLW  2D
01AAE:  SUBWF  00,W
01AB0:  MOVLB  0
01AB2:  BTFSC  FD8.2
01AB4:  GOTO   22AA
01AB8:  MOVLB  9
01ABA:  MOVF   03,W
01ABC:  BNZ   1ACC
01ABE:  MOVLW  2E
01AC0:  SUBWF  00,W
01AC2:  MOVLB  0
01AC4:  BTFSC  FD8.2
01AC6:  GOTO   22BA
01ACA:  MOVLB  9
01ACC:  MOVF   03,W
01ACE:  BNZ   1ADE
01AD0:  MOVLW  2F
01AD2:  SUBWF  00,W
01AD4:  MOVLB  0
01AD6:  BTFSC  FD8.2
01AD8:  GOTO   22CA
01ADC:  MOVLB  9
01ADE:  MOVF   03,W
01AE0:  BNZ   1AF0
01AE2:  MOVLW  30
01AE4:  SUBWF  00,W
01AE6:  MOVLB  0
01AE8:  BTFSC  FD8.2
01AEA:  GOTO   22DA
01AEE:  MOVLB  9
01AF0:  MOVF   03,W
01AF2:  BNZ   1B02
01AF4:  MOVLW  31
01AF6:  SUBWF  00,W
01AF8:  MOVLB  0
01AFA:  BTFSC  FD8.2
01AFC:  GOTO   22EA
01B00:  MOVLB  9
01B02:  MOVF   03,W
01B04:  BNZ   1B14
01B06:  MOVLW  32
01B08:  SUBWF  00,W
01B0A:  MOVLB  0
01B0C:  BTFSC  FD8.2
01B0E:  GOTO   22FA
01B12:  MOVLB  9
01B14:  MOVF   03,W
01B16:  BNZ   1B26
01B18:  MOVLW  33
01B1A:  SUBWF  00,W
01B1C:  MOVLB  0
01B1E:  BTFSC  FD8.2
01B20:  GOTO   230A
01B24:  MOVLB  9
01B26:  MOVF   03,W
01B28:  BNZ   1B38
01B2A:  MOVLW  34
01B2C:  SUBWF  00,W
01B2E:  MOVLB  0
01B30:  BTFSC  FD8.2
01B32:  GOTO   231A
01B36:  MOVLB  9
01B38:  MOVF   03,W
01B3A:  BNZ   1B4A
01B3C:  MOVLW  35
01B3E:  SUBWF  00,W
01B40:  MOVLB  0
01B42:  BTFSC  FD8.2
01B44:  GOTO   232A
01B48:  MOVLB  9
01B4A:  MOVF   03,W
01B4C:  BNZ   1B5C
01B4E:  MOVLW  36
01B50:  SUBWF  00,W
01B52:  MOVLB  0
01B54:  BTFSC  FD8.2
01B56:  GOTO   233A
01B5A:  MOVLB  9
01B5C:  MOVLW  03
01B5E:  SUBWF  03,W
01B60:  BNZ   1B70
01B62:  MOVLW  E8
01B64:  SUBWF  00,W
01B66:  MOVLB  0
01B68:  BTFSC  FD8.2
01B6A:  GOTO   234C
01B6E:  MOVLB  9
01B70:  MOVLW  03
01B72:  SUBWF  03,W
01B74:  BNZ   1B84
01B76:  MOVLW  E9
01B78:  SUBWF  00,W
01B7A:  MOVLB  0
01B7C:  BTFSC  FD8.2
01B7E:  GOTO   235C
01B82:  MOVLB  9
01B84:  MOVLW  03
01B86:  SUBWF  03,W
01B88:  BNZ   1B98
01B8A:  MOVLW  EA
01B8C:  SUBWF  00,W
01B8E:  MOVLB  0
01B90:  BTFSC  FD8.2
01B92:  GOTO   236A
01B96:  MOVLB  9
01B98:  MOVLW  03
01B9A:  SUBWF  03,W
01B9C:  BNZ   1BAC
01B9E:  MOVLW  EB
01BA0:  SUBWF  00,W
01BA2:  MOVLB  0
01BA4:  BTFSC  FD8.2
01BA6:  GOTO   2378
01BAA:  MOVLB  9
01BAC:  MOVLW  03
01BAE:  SUBWF  03,W
01BB0:  BNZ   1BC0
01BB2:  MOVLW  EC
01BB4:  SUBWF  00,W
01BB6:  MOVLB  0
01BB8:  BTFSC  FD8.2
01BBA:  GOTO   2386
01BBE:  MOVLB  9
01BC0:  MOVLW  03
01BC2:  SUBWF  03,W
01BC4:  BNZ   1BD4
01BC6:  MOVLW  ED
01BC8:  SUBWF  00,W
01BCA:  MOVLB  0
01BCC:  BTFSC  FD8.2
01BCE:  GOTO   2394
01BD2:  MOVLB  9
01BD4:  MOVLW  03
01BD6:  SUBWF  03,W
01BD8:  BNZ   1BE8
01BDA:  MOVLW  EE
01BDC:  SUBWF  00,W
01BDE:  MOVLB  0
01BE0:  BTFSC  FD8.2
01BE2:  GOTO   23A2
01BE6:  MOVLB  9
01BE8:  MOVLW  03
01BEA:  SUBWF  03,W
01BEC:  BNZ   1BFC
01BEE:  MOVLW  EF
01BF0:  SUBWF  00,W
01BF2:  MOVLB  0
01BF4:  BTFSC  FD8.2
01BF6:  GOTO   23B2
01BFA:  MOVLB  9
01BFC:  MOVLW  03
01BFE:  SUBWF  03,W
01C00:  BNZ   1C10
01C02:  MOVLW  F0
01C04:  SUBWF  00,W
01C06:  MOVLB  0
01C08:  BTFSC  FD8.2
01C0A:  GOTO   23C0
01C0E:  MOVLB  9
01C10:  MOVLW  03
01C12:  SUBWF  03,W
01C14:  BNZ   1C24
01C16:  MOVLW  F1
01C18:  SUBWF  00,W
01C1A:  MOVLB  0
01C1C:  BTFSC  FD8.2
01C1E:  GOTO   23D0
01C22:  MOVLB  9
01C24:  MOVLW  03
01C26:  SUBWF  03,W
01C28:  BNZ   1C38
01C2A:  MOVLW  F2
01C2C:  SUBWF  00,W
01C2E:  MOVLB  0
01C30:  BTFSC  FD8.2
01C32:  GOTO   23DE
01C36:  MOVLB  9
01C38:  MOVLW  03
01C3A:  SUBWF  03,W
01C3C:  BNZ   1C4C
01C3E:  MOVLW  F3
01C40:  SUBWF  00,W
01C42:  MOVLB  0
01C44:  BTFSC  FD8.2
01C46:  GOTO   23EC
01C4A:  MOVLB  9
01C4C:  MOVLW  03
01C4E:  SUBWF  03,W
01C50:  BNZ   1C60
01C52:  MOVLW  F4
01C54:  SUBWF  00,W
01C56:  MOVLB  0
01C58:  BTFSC  FD8.2
01C5A:  GOTO   23FC
01C5E:  MOVLB  9
01C60:  MOVLW  03
01C62:  SUBWF  03,W
01C64:  BNZ   1C74
01C66:  MOVLW  F5
01C68:  SUBWF  00,W
01C6A:  MOVLB  0
01C6C:  BTFSC  FD8.2
01C6E:  GOTO   240C
01C72:  MOVLB  9
01C74:  MOVLW  19
01C76:  SUBWF  03,W
01C78:  BNZ   1C88
01C7A:  MOVLW  64
01C7C:  SUBWF  00,W
01C7E:  MOVLB  0
01C80:  BTFSC  FD8.2
01C82:  GOTO   248E
01C86:  MOVLB  9
01C88:  MOVLW  19
01C8A:  SUBWF  03,W
01C8C:  BNZ   1C9C
01C8E:  MOVLW  65
01C90:  SUBWF  00,W
01C92:  MOVLB  0
01C94:  BTFSC  FD8.2
01C96:  GOTO   249E
01C9A:  MOVLB  9
01C9C:  MOVLW  19
01C9E:  SUBWF  03,W
01CA0:  BNZ   1CB0
01CA2:  MOVLW  66
01CA4:  SUBWF  00,W
01CA6:  MOVLB  0
01CA8:  BTFSC  FD8.2
01CAA:  GOTO   24B0
01CAE:  MOVLB  9
01CB0:  MOVLW  19
01CB2:  SUBWF  03,W
01CB4:  BNZ   1CC4
01CB6:  MOVLW  67
01CB8:  SUBWF  00,W
01CBA:  MOVLB  0
01CBC:  BTFSC  FD8.2
01CBE:  GOTO   24C0
01CC2:  MOVLB  9
01CC4:  MOVLW  19
01CC6:  SUBWF  03,W
01CC8:  BNZ   1CD8
01CCA:  MOVLW  68
01CCC:  SUBWF  00,W
01CCE:  MOVLB  0
01CD0:  BTFSC  FD8.2
01CD2:  GOTO   24D2
01CD6:  MOVLB  9
01CD8:  MOVLW  19
01CDA:  SUBWF  03,W
01CDC:  BNZ   1CEC
01CDE:  MOVLW  69
01CE0:  SUBWF  00,W
01CE2:  MOVLB  0
01CE4:  BTFSC  FD8.2
01CE6:  GOTO   24E2
01CEA:  MOVLB  9
01CEC:  MOVLW  19
01CEE:  SUBWF  03,W
01CF0:  BNZ   1D00
01CF2:  MOVLW  6A
01CF4:  SUBWF  00,W
01CF6:  MOVLB  0
01CF8:  BTFSC  FD8.2
01CFA:  GOTO   24F4
01CFE:  MOVLB  9
01D00:  MOVLW  19
01D02:  SUBWF  03,W
01D04:  BNZ   1D14
01D06:  MOVLW  6B
01D08:  SUBWF  00,W
01D0A:  MOVLB  0
01D0C:  BTFSC  FD8.2
01D0E:  GOTO   2504
01D12:  MOVLB  9
01D14:  MOVLW  19
01D16:  SUBWF  03,W
01D18:  BNZ   1D28
01D1A:  MOVLW  6C
01D1C:  SUBWF  00,W
01D1E:  MOVLB  0
01D20:  BTFSC  FD8.2
01D22:  GOTO   2516
01D26:  MOVLB  9
01D28:  MOVLW  19
01D2A:  SUBWF  03,W
01D2C:  BNZ   1D3C
01D2E:  MOVLW  6D
01D30:  SUBWF  00,W
01D32:  MOVLB  0
01D34:  BTFSC  FD8.2
01D36:  GOTO   2526
01D3A:  MOVLB  9
01D3C:  MOVLW  19
01D3E:  SUBWF  03,W
01D40:  BNZ   1D50
01D42:  MOVLW  6E
01D44:  SUBWF  00,W
01D46:  MOVLB  0
01D48:  BTFSC  FD8.2
01D4A:  GOTO   2538
01D4E:  MOVLB  9
01D50:  MOVLW  19
01D52:  SUBWF  03,W
01D54:  BNZ   1D64
01D56:  MOVLW  6F
01D58:  SUBWF  00,W
01D5A:  MOVLB  0
01D5C:  BTFSC  FD8.2
01D5E:  GOTO   2548
01D62:  MOVLB  9
01D64:  MOVLW  19
01D66:  SUBWF  03,W
01D68:  BNZ   1D78
01D6A:  MOVLW  70
01D6C:  SUBWF  00,W
01D6E:  MOVLB  0
01D70:  BTFSC  FD8.2
01D72:  GOTO   255A
01D76:  MOVLB  9
01D78:  MOVLW  19
01D7A:  SUBWF  03,W
01D7C:  BNZ   1D8C
01D7E:  MOVLW  71
01D80:  SUBWF  00,W
01D82:  MOVLB  0
01D84:  BTFSC  FD8.2
01D86:  GOTO   256A
01D8A:  MOVLB  9
01D8C:  MOVLW  19
01D8E:  SUBWF  03,W
01D90:  BNZ   1DA0
01D92:  MOVLW  72
01D94:  SUBWF  00,W
01D96:  MOVLB  0
01D98:  BTFSC  FD8.2
01D9A:  GOTO   257C
01D9E:  MOVLB  9
01DA0:  MOVLW  19
01DA2:  SUBWF  03,W
01DA4:  BNZ   1DB4
01DA6:  MOVLW  73
01DA8:  SUBWF  00,W
01DAA:  MOVLB  0
01DAC:  BTFSC  FD8.2
01DAE:  GOTO   258C
01DB2:  MOVLB  9
01DB4:  MOVLW  19
01DB6:  SUBWF  03,W
01DB8:  BNZ   1DC8
01DBA:  MOVLW  74
01DBC:  SUBWF  00,W
01DBE:  MOVLB  0
01DC0:  BTFSC  FD8.2
01DC2:  GOTO   259E
01DC6:  MOVLB  9
01DC8:  MOVLW  19
01DCA:  SUBWF  03,W
01DCC:  BNZ   1DDC
01DCE:  MOVLW  75
01DD0:  SUBWF  00,W
01DD2:  MOVLB  0
01DD4:  BTFSC  FD8.2
01DD6:  GOTO   25AE
01DDA:  MOVLB  9
01DDC:  MOVLW  19
01DDE:  SUBWF  03,W
01DE0:  BNZ   1DF0
01DE2:  MOVLW  76
01DE4:  SUBWF  00,W
01DE6:  MOVLB  0
01DE8:  BTFSC  FD8.2
01DEA:  GOTO   25C0
01DEE:  MOVLB  9
01DF0:  MOVLW  19
01DF2:  SUBWF  03,W
01DF4:  BNZ   1E04
01DF6:  MOVLW  77
01DF8:  SUBWF  00,W
01DFA:  MOVLB  0
01DFC:  BTFSC  FD8.2
01DFE:  GOTO   25D0
01E02:  MOVLB  9
01E04:  MOVLW  19
01E06:  SUBWF  03,W
01E08:  BNZ   1E18
01E0A:  MOVLW  78
01E0C:  SUBWF  00,W
01E0E:  MOVLB  0
01E10:  BTFSC  FD8.2
01E12:  GOTO   25E2
01E16:  MOVLB  9
01E18:  MOVLW  19
01E1A:  SUBWF  03,W
01E1C:  BNZ   1E2C
01E1E:  MOVLW  79
01E20:  SUBWF  00,W
01E22:  MOVLB  0
01E24:  BTFSC  FD8.2
01E26:  GOTO   25F2
01E2A:  MOVLB  9
01E2C:  MOVLW  19
01E2E:  SUBWF  03,W
01E30:  BNZ   1E40
01E32:  MOVLW  7A
01E34:  SUBWF  00,W
01E36:  MOVLB  0
01E38:  BTFSC  FD8.2
01E3A:  GOTO   2604
01E3E:  MOVLB  9
01E40:  MOVLW  19
01E42:  SUBWF  03,W
01E44:  BNZ   1E54
01E46:  MOVLW  7B
01E48:  SUBWF  00,W
01E4A:  MOVLB  0
01E4C:  BTFSC  FD8.2
01E4E:  GOTO   2614
01E52:  MOVLB  9
01E54:  GOTO   2624
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01E58:  MOVFF  A9,01
01E5C:  MOVFF  AA,02
01E60:  MOVLB  9
01E62:  GOTO   262C
01E66:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01E68:  MOVF   x97,W
01E6A:  MOVWF  01
01E6C:  MOVF   x98,W
01E6E:  MOVWF  02
01E70:  MOVLB  9
01E72:  GOTO   262C
01E76:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01E78:  MOVF   x9D,W
01E7A:  MOVWF  01
01E7C:  MOVF   x9E,W
01E7E:  MOVWF  02
01E80:  MOVLB  9
01E82:  GOTO   262C
01E86:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01E88:  MOVF   xA3,W
01E8A:  MOVWF  01
01E8C:  MOVF   xA4,W
01E8E:  MOVWF  02
01E90:  MOVLB  9
01E92:  GOTO   262C
01E96:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01E98:  MOVLB  9
01E9A:  CLRF   x18
01E9C:  MOVLB  0
01E9E:  CALL   1480
01EA2:  MOVFF  03,8F2
01EA6:  MOVFF  02,8F1
01EAA:  MOVFF  01,8F0
01EAE:  MOVFF  00,8EF
01EB2:  MOVLB  8
01EB4:  MOVF   xEF,W
01EB6:  MOVWF  01
01EB8:  MOVF   xF0,W
01EBA:  MOVWF  02
01EBC:  MOVLB  9
01EBE:  GOTO   262C
01EC2:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01EC4:  MOVLB  8
01EC6:  MOVF   xF1,W
01EC8:  MOVWF  01
01ECA:  MOVF   xF2,W
01ECC:  MOVWF  02
01ECE:  MOVLB  9
01ED0:  GOTO   262C
01ED4:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01ED6:  MOVF   xAB,W
01ED8:  MOVWF  01
01EDA:  MOVF   xAC,W
01EDC:  MOVWF  02
01EDE:  MOVLB  9
01EE0:  GOTO   262C
01EE4:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01EE6:  MOVF   x99,W
01EE8:  MOVWF  01
01EEA:  MOVF   x9A,W
01EEC:  MOVWF  02
01EEE:  MOVLB  9
01EF0:  GOTO   262C
01EF4:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01EF6:  MOVF   x9F,W
01EF8:  MOVWF  01
01EFA:  MOVF   xA0,W
01EFC:  MOVWF  02
01EFE:  MOVLB  9
01F00:  BRA    262C
01F02:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01F04:  MOVF   xA5,W
01F06:  MOVWF  01
01F08:  MOVF   xA6,W
01F0A:  MOVWF  02
01F0C:  MOVLB  9
01F0E:  BRA    262C
01F10:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01F12:  MOVLW  01
01F14:  MOVLB  9
01F16:  MOVWF  x18
01F18:  MOVLB  0
01F1A:  CALL   1480
01F1E:  MOVFF  03,8F2
01F22:  MOVFF  02,8F1
01F26:  MOVFF  01,8F0
01F2A:  MOVFF  00,8EF
01F2E:  MOVLB  8
01F30:  MOVF   xEF,W
01F32:  MOVWF  01
01F34:  MOVF   xF0,W
01F36:  MOVWF  02
01F38:  MOVLB  9
01F3A:  BRA    262C
01F3C:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01F3E:  MOVLB  8
01F40:  MOVF   xF1,W
01F42:  MOVWF  01
01F44:  MOVF   xF2,W
01F46:  MOVWF  02
01F48:  MOVLB  9
01F4A:  BRA    262C
01F4C:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01F4E:  MOVF   xAD,W
01F50:  MOVWF  01
01F52:  MOVF   xAE,W
01F54:  MOVWF  02
01F56:  MOVLB  9
01F58:  BRA    262C
01F5A:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01F5C:  MOVF   x9B,W
01F5E:  MOVWF  01
01F60:  MOVF   x9C,W
01F62:  MOVWF  02
01F64:  MOVLB  9
01F66:  BRA    262C
01F68:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01F6A:  MOVF   xA1,W
01F6C:  MOVWF  01
01F6E:  MOVF   xA2,W
01F70:  MOVWF  02
01F72:  MOVLB  9
01F74:  BRA    262C
01F76:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01F78:  MOVF   xA7,W
01F7A:  MOVWF  01
01F7C:  MOVF   xA8,W
01F7E:  MOVWF  02
01F80:  MOVLB  9
01F82:  BRA    262C
01F84:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01F86:  MOVLW  02
01F88:  MOVLB  9
01F8A:  MOVWF  x18
01F8C:  MOVLB  0
01F8E:  CALL   1480
01F92:  MOVFF  03,8F2
01F96:  MOVFF  02,8F1
01F9A:  MOVFF  01,8F0
01F9E:  MOVFF  00,8EF
01FA2:  MOVLB  8
01FA4:  MOVF   xEF,W
01FA6:  MOVWF  01
01FA8:  MOVF   xF0,W
01FAA:  MOVWF  02
01FAC:  MOVLB  9
01FAE:  BRA    262C
01FB0:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01FB2:  MOVLB  8
01FB4:  MOVF   xF1,W
01FB6:  MOVWF  01
01FB8:  MOVF   xF2,W
01FBA:  MOVWF  02
01FBC:  MOVLB  9
01FBE:  BRA    262C
01FC0:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01FC2:  CLRF   03
01FC4:  MOVLB  1
01FC6:  MOVF   xCB,W
01FC8:  MOVWF  02
01FCA:  BCF    FD8.0
01FCC:  RLCF   02,F
01FCE:  RLCF   03,F
01FD0:  MOVF   02,W
01FD2:  ADDLW  CB
01FD4:  MOVWF  FE9
01FD6:  MOVLW  00
01FD8:  ADDWFC 03,W
01FDA:  MOVWF  FEA
01FDC:  MOVFF  FEC,03
01FE0:  MOVF   FED,F
01FE2:  MOVF   FEF,W
01FE4:  MOVWF  01
01FE6:  MOVF   03,W
01FE8:  MOVWF  02
01FEA:  MOVLB  9
01FEC:  BRA    262C
01FEE:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01FF0:  MOVLB  9
01FF2:  CLRF   x18
01FF4:  MOVLB  0
01FF6:  CALL   14E2
01FFA:  MOVF   01,W
01FFC:  MOVWF  01
01FFE:  MOVF   02,W
02000:  MOVWF  02
02002:  MOVLB  9
02004:  BRA    262C
02006:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
02008:  MOVF   xBB,W
0200A:  MOVWF  01
0200C:  MOVF   xBC,W
0200E:  MOVWF  02
02010:  MOVLB  9
02012:  BRA    262C
02014:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
02016:  CLRF   03
02018:  MOVLB  1
0201A:  MOVF   xCB,W
0201C:  MOVWF  02
0201E:  BCF    FD8.0
02020:  RLCF   02,F
02022:  RLCF   03,F
02024:  MOVF   02,W
02026:  ADDLW  EB
02028:  MOVWF  FE9
0202A:  MOVLW  00
0202C:  ADDWFC 03,W
0202E:  MOVWF  FEA
02030:  MOVFF  FEC,03
02034:  MOVF   FED,F
02036:  MOVF   FEF,W
02038:  MOVWF  01
0203A:  MOVF   03,W
0203C:  MOVWF  02
0203E:  MOVLB  9
02040:  BRA    262C
02042:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
02044:  MOVLW  01
02046:  MOVLB  9
02048:  MOVWF  x18
0204A:  MOVLB  0
0204C:  CALL   14E2
02050:  MOVF   01,W
02052:  MOVWF  01
02054:  MOVF   02,W
02056:  MOVWF  02
02058:  MOVLB  9
0205A:  BRA    262C
0205C:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0205E:  MOVF   xBD,W
02060:  MOVWF  01
02062:  MOVF   xBE,W
02064:  MOVWF  02
02066:  MOVLB  9
02068:  BRA    262C
0206A:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0206C:  CLRF   03
0206E:  MOVLB  1
02070:  MOVF   xCB,W
02072:  MOVWF  02
02074:  BCF    FD8.0
02076:  RLCF   02,F
02078:  RLCF   03,F
0207A:  MOVF   02,W
0207C:  ADDLW  0B
0207E:  MOVWF  FE9
02080:  MOVLW  01
02082:  ADDWFC 03,W
02084:  MOVWF  FEA
02086:  MOVFF  FEC,03
0208A:  MOVF   FED,F
0208C:  MOVF   FEF,W
0208E:  MOVWF  01
02090:  MOVF   03,W
02092:  MOVWF  02
02094:  MOVLB  9
02096:  BRA    262C
02098:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
0209A:  MOVLW  02
0209C:  MOVLB  9
0209E:  MOVWF  x18
020A0:  MOVLB  0
020A2:  CALL   14E2
020A6:  MOVF   01,W
020A8:  MOVWF  01
020AA:  MOVF   02,W
020AC:  MOVWF  02
020AE:  MOVLB  9
020B0:  BRA    262C
020B2:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
020B4:  MOVF   xBF,W
020B6:  MOVWF  01
020B8:  MOVF   xC0,W
020BA:  MOVWF  02
020BC:  MOVLB  9
020BE:  BRA    262C
020C0:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
020C2:  CLRF   03
020C4:  MOVLB  1
020C6:  MOVF   xCB,W
020C8:  MOVWF  02
020CA:  BCF    FD8.0
020CC:  RLCF   02,F
020CE:  RLCF   03,F
020D0:  MOVF   02,W
020D2:  ADDLW  2B
020D4:  MOVWF  FE9
020D6:  MOVLW  01
020D8:  ADDWFC 03,W
020DA:  MOVWF  FEA
020DC:  MOVFF  FEC,03
020E0:  MOVF   FED,F
020E2:  MOVF   FEF,W
020E4:  MOVWF  01
020E6:  MOVF   03,W
020E8:  MOVWF  02
020EA:  MOVLB  9
020EC:  BRA    262C
020EE:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
020F0:  MOVLW  03
020F2:  MOVLB  9
020F4:  MOVWF  x18
020F6:  MOVLB  0
020F8:  CALL   14E2
020FC:  MOVF   01,W
020FE:  MOVWF  01
02100:  MOVF   02,W
02102:  MOVWF  02
02104:  MOVLB  9
02106:  BRA    262C
02108:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
0210A:  MOVF   xC1,W
0210C:  MOVWF  01
0210E:  MOVF   xC2,W
02110:  MOVWF  02
02112:  MOVLB  9
02114:  BRA    262C
02116:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
02118:  CLRF   03
0211A:  MOVLB  1
0211C:  MOVF   xCB,W
0211E:  MOVWF  02
02120:  BCF    FD8.0
02122:  RLCF   02,F
02124:  RLCF   03,F
02126:  MOVF   02,W
02128:  ADDLW  4B
0212A:  MOVWF  FE9
0212C:  MOVLW  01
0212E:  ADDWFC 03,W
02130:  MOVWF  FEA
02132:  MOVFF  FEC,03
02136:  MOVF   FED,F
02138:  MOVF   FEF,W
0213A:  MOVWF  01
0213C:  MOVF   03,W
0213E:  MOVWF  02
02140:  MOVLB  9
02142:  BRA    262C
02144:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
02146:  MOVLW  04
02148:  MOVLB  9
0214A:  MOVWF  x18
0214C:  MOVLB  0
0214E:  CALL   14E2
02152:  MOVF   01,W
02154:  MOVWF  01
02156:  MOVF   02,W
02158:  MOVWF  02
0215A:  MOVLB  9
0215C:  BRA    262C
0215E:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
02160:  MOVF   xC3,W
02162:  MOVWF  01
02164:  MOVF   xC4,W
02166:  MOVWF  02
02168:  MOVLB  9
0216A:  BRA    262C
0216C:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
0216E:  CLRF   03
02170:  MOVLB  1
02172:  MOVF   xCB,W
02174:  MOVWF  02
02176:  BCF    FD8.0
02178:  RLCF   02,F
0217A:  RLCF   03,F
0217C:  MOVF   02,W
0217E:  ADDLW  6B
02180:  MOVWF  FE9
02182:  MOVLW  01
02184:  ADDWFC 03,W
02186:  MOVWF  FEA
02188:  MOVFF  FEC,03
0218C:  MOVF   FED,F
0218E:  MOVF   FEF,W
02190:  MOVWF  01
02192:  MOVF   03,W
02194:  MOVWF  02
02196:  MOVLB  9
02198:  BRA    262C
0219A:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
0219C:  MOVLW  05
0219E:  MOVLB  9
021A0:  MOVWF  x18
021A2:  MOVLB  0
021A4:  CALL   14E2
021A8:  MOVF   01,W
021AA:  MOVWF  01
021AC:  MOVF   02,W
021AE:  MOVWF  02
021B0:  MOVLB  9
021B2:  BRA    262C
021B4:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
021B6:  MOVF   xC5,W
021B8:  MOVWF  01
021BA:  MOVF   xC6,W
021BC:  MOVWF  02
021BE:  MOVLB  9
021C0:  BRA    262C
021C2:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
021C4:  CLRF   03
021C6:  MOVLB  1
021C8:  MOVF   xCB,W
021CA:  MOVWF  02
021CC:  BCF    FD8.0
021CE:  RLCF   02,F
021D0:  RLCF   03,F
021D2:  MOVF   02,W
021D4:  ADDLW  8B
021D6:  MOVWF  FE9
021D8:  MOVLW  01
021DA:  ADDWFC 03,W
021DC:  MOVWF  FEA
021DE:  MOVFF  FEC,03
021E2:  MOVF   FED,F
021E4:  MOVF   FEF,W
021E6:  MOVWF  01
021E8:  MOVF   03,W
021EA:  MOVWF  02
021EC:  MOVLB  9
021EE:  BRA    262C
021F0:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
021F2:  MOVLW  06
021F4:  MOVLB  9
021F6:  MOVWF  x18
021F8:  MOVLB  0
021FA:  CALL   14E2
021FE:  MOVF   01,W
02200:  MOVWF  01
02202:  MOVF   02,W
02204:  MOVWF  02
02206:  MOVLB  9
02208:  BRA    262C
0220A:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
0220C:  MOVF   xC7,W
0220E:  MOVWF  01
02210:  MOVF   xC8,W
02212:  MOVWF  02
02214:  MOVLB  9
02216:  BRA    262C
02218:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
0221A:  CLRF   03
0221C:  MOVLB  1
0221E:  MOVF   xCB,W
02220:  MOVWF  02
02222:  BCF    FD8.0
02224:  RLCF   02,F
02226:  RLCF   03,F
02228:  MOVF   02,W
0222A:  ADDLW  AB
0222C:  MOVWF  FE9
0222E:  MOVLW  01
02230:  ADDWFC 03,W
02232:  MOVWF  FEA
02234:  MOVFF  FEC,03
02238:  MOVF   FED,F
0223A:  MOVF   FEF,W
0223C:  MOVWF  01
0223E:  MOVF   03,W
02240:  MOVWF  02
02242:  MOVLB  9
02244:  BRA    262C
02246:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
02248:  MOVLW  07
0224A:  MOVLB  9
0224C:  MOVWF  x18
0224E:  MOVLB  0
02250:  CALL   14E2
02254:  MOVF   01,W
02256:  MOVWF  01
02258:  MOVF   02,W
0225A:  MOVWF  02
0225C:  MOVLB  9
0225E:  BRA    262C
02260:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
02262:  MOVF   xC9,W
02264:  MOVWF  01
02266:  MOVF   xCA,W
02268:  MOVWF  02
0226A:  MOVLB  9
0226C:  BRA    262C
0226E:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
02270:  MOVLB  1
02272:  MOVF   xD3,W
02274:  MOVWF  03
02276:  MOVF   xD2,W
02278:  INCF   xD2,F
0227A:  BTFSC  FD8.2
0227C:  INCF   xD3,F
0227E:  MOVWF  01
02280:  MOVF   03,W
02282:  MOVWF  02
02284:  MOVLB  9
02286:  BRA    262C
02288:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
0228A:  MOVLB  1
0228C:  MOVF   xD6,W
0228E:  MOVWF  01
02290:  MOVF   xD7,W
02292:  MOVWF  02
02294:  MOVLB  9
02296:  BRA    262C
02298:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
0229A:  MOVLB  1
0229C:  MOVF   xD4,W
0229E:  MOVWF  01
022A0:  MOVF   xD5,W
022A2:  MOVWF  02
022A4:  MOVLB  9
022A6:  BRA    262C
022A8:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
022AA:  MOVLB  1
022AC:  MOVF   xD9,W
022AE:  MOVWF  01
022B0:  MOVF   xDA,W
022B2:  MOVWF  02
022B4:  MOVLB  9
022B6:  BRA    262C
022B8:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
022BA:  GOTO   156C
022BE:  MOVLW  00
022C0:  MOVWF  01
022C2:  MOVWF  02
022C4:  MOVLB  9
022C6:  BRA    262C
022C8:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
022CA:  GOTO   15A8
022CE:  MOVLW  00
022D0:  MOVWF  01
022D2:  MOVWF  02
022D4:  MOVLB  9
022D6:  BRA    262C
022D8:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
022DA:  MOVLB  1
022DC:  MOVF   xCC,W
022DE:  MOVWF  01
022E0:  MOVF   xCD,W
022E2:  MOVWF  02
022E4:  MOVLB  9
022E6:  BRA    262C
022E8:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
022EA:  MOVLB  1
022EC:  MOVF   xCE,W
022EE:  MOVWF  01
022F0:  MOVF   xCF,W
022F2:  MOVWF  02
022F4:  MOVLB  9
022F6:  BRA    262C
022F8:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
022FA:  MOVLB  1
022FC:  MOVF   xD0,W
022FE:  MOVWF  01
02300:  MOVF   xD1,W
02302:  MOVWF  02
02304:  MOVLB  9
02306:  BRA    262C
02308:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
0230A:  GOTO   15D0
0230E:  MOVLW  00
02310:  MOVWF  01
02312:  MOVWF  02
02314:  MOVLB  9
02316:  BRA    262C
02318:  MOVLB  0
.................... 		 
.................... 		/* meta */ 
.................... 		case 52: return (int16) current.rda_bytes_received; 
0231A:  MOVLB  1
0231C:  MOVF   xE2,W
0231E:  MOVWF  01
02320:  MOVF   xE3,W
02322:  MOVWF  02
02324:  MOVLB  9
02326:  BRA    262C
02328:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
0232A:  MOVLB  1
0232C:  MOVF   xE4,W
0232E:  MOVWF  01
02330:  MOVF   xE5,W
02332:  MOVWF  02
02334:  MOVLB  9
02336:  BRA    262C
02338:  MOVLB  0
.................... 		case 54: return (int16) current.button_state; 
0233A:  CLRF   03
0233C:  MOVLB  1
0233E:  MOVF   xE6,W
02340:  MOVWF  01
02342:  MOVF   03,W
02344:  MOVWF  02
02346:  MOVLB  9
02348:  BRA    262C
0234A:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
0234C:  CLRF   03
0234E:  MOVF   3A,W
02350:  MOVWF  01
02352:  MOVF   03,W
02354:  MOVWF  02
02356:  MOVLB  9
02358:  BRA    262C
0235A:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
0235C:  MOVF   3B,W
0235E:  MOVWF  01
02360:  MOVF   3C,W
02362:  MOVWF  02
02364:  MOVLB  9
02366:  BRA    262C
02368:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
0236A:  MOVLW  50
0236C:  MOVWF  01
0236E:  MOVLW  00
02370:  MOVWF  02
02372:  MOVLB  9
02374:  BRA    262C
02376:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
02378:  MOVLW  57
0237A:  MOVWF  01
0237C:  MOVLW  00
0237E:  MOVWF  02
02380:  MOVLB  9
02382:  BRA    262C
02384:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
02386:  MOVLW  58
02388:  MOVWF  01
0238A:  MOVLW  00
0238C:  MOVWF  02
0238E:  MOVLB  9
02390:  BRA    262C
02392:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
02394:  MOVLW  01
02396:  MOVWF  01
02398:  MOVLW  00
0239A:  MOVWF  02
0239C:  MOVLB  9
0239E:  BRA    262C
023A0:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
023A2:  CLRF   03
023A4:  MOVF   36,W
023A6:  MOVWF  01
023A8:  MOVF   03,W
023AA:  MOVWF  02
023AC:  MOVLB  9
023AE:  BRA    262C
023B0:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
023B2:  MOVF   3D,W
023B4:  MOVWF  01
023B6:  MOVF   3E,W
023B8:  MOVWF  02
023BA:  MOVLB  9
023BC:  BRA    262C
023BE:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
023C0:  CLRF   03
023C2:  MOVF   3F,W
023C4:  MOVWF  01
023C6:  MOVF   03,W
023C8:  MOVWF  02
023CA:  MOVLB  9
023CC:  BRA    262C
023CE:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
023D0:  MOVF   40,W
023D2:  MOVWF  01
023D4:  MOVF   41,W
023D6:  MOVWF  02
023D8:  MOVLB  9
023DA:  BRA    262C
023DC:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
023DE:  MOVF   42,W
023E0:  MOVWF  01
023E2:  MOVF   43,W
023E4:  MOVWF  02
023E6:  MOVLB  9
023E8:  BRA    262C
023EA:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
023EC:  CLRF   03
023EE:  MOVF   44,W
023F0:  MOVWF  01
023F2:  MOVF   03,W
023F4:  MOVWF  02
023F6:  MOVLB  9
023F8:  BRA    262C
023FA:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
023FC:  CLRF   03
023FE:  MOVF   38,W
02400:  MOVWF  01
02402:  MOVF   03,W
02404:  MOVWF  02
02406:  MOVLB  9
02408:  BRA    262C
0240A:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
0240C:  MOVF   39,F
0240E:  BNZ   241E
02410:  MOVLW  B0
02412:  MOVWF  01
02414:  MOVLW  04
02416:  MOVWF  02
02418:  MOVLB  9
0241A:  BRA    262C
0241C:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
0241E:  DECFSZ 39,W
02420:  BRA    2430
02422:  MOVLW  60
02424:  MOVWF  01
02426:  MOVLW  09
02428:  MOVWF  02
0242A:  MOVLB  9
0242C:  BRA    262C
0242E:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
02430:  MOVF   39,W
02432:  SUBLW  02
02434:  BNZ   2444
02436:  MOVLW  C0
02438:  MOVWF  01
0243A:  MOVLW  12
0243C:  MOVWF  02
0243E:  MOVLB  9
02440:  BRA    262C
02442:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
02444:  MOVF   39,W
02446:  SUBLW  04
02448:  BNZ   2458
0244A:  MOVLW  00
0244C:  MOVWF  01
0244E:  MOVLW  4B
02450:  MOVWF  02
02452:  MOVLB  9
02454:  BRA    262C
02456:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
02458:  MOVF   39,W
0245A:  SUBLW  05
0245C:  BNZ   246C
0245E:  MOVLW  00
02460:  MOVWF  01
02462:  MOVLW  96
02464:  MOVWF  02
02466:  MOVLB  9
02468:  BRA    262C
0246A:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
0246C:  MOVF   39,W
0246E:  SUBLW  06
02470:  BNZ   2480
02472:  MOVLW  00
02474:  MOVWF  01
02476:  MOVLW  E1
02478:  MOVWF  02
0247A:  MOVLB  9
0247C:  BRA    262C
0247E:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
02480:  MOVLW  80
02482:  MOVWF  01
02484:  MOVLW  25
02486:  MOVWF  02
02488:  MOVLB  9
0248A:  BRA    262C
0248C:  MOVLB  0
....................  
.................... 		/* NMEA sentence age and length */ 
.................... 		case 6500: return (int16) nmea.sentence_age[0]; 
0248E:  MOVLB  7
02490:  MOVF   xC4,W
02492:  MOVWF  01
02494:  MOVF   xC5,W
02496:  MOVWF  02
02498:  MOVLB  9
0249A:  BRA    262C
0249C:  MOVLB  0
.................... 		case 6501: return (int16) nmea.sentence_length[0]; 
0249E:  CLRF   03
024A0:  MOVLB  7
024A2:  MOVF   xDC,W
024A4:  MOVWF  01
024A6:  MOVF   03,W
024A8:  MOVWF  02
024AA:  MOVLB  9
024AC:  BRA    262C
024AE:  MOVLB  0
.................... 		case 6502: return (int16) nmea.sentence_age[1]; 
024B0:  MOVLB  7
024B2:  MOVF   xC6,W
024B4:  MOVWF  01
024B6:  MOVF   xC7,W
024B8:  MOVWF  02
024BA:  MOVLB  9
024BC:  BRA    262C
024BE:  MOVLB  0
.................... 		case 6503: return (int16) nmea.sentence_length[1]; 
024C0:  CLRF   03
024C2:  MOVLB  7
024C4:  MOVF   xDD,W
024C6:  MOVWF  01
024C8:  MOVF   03,W
024CA:  MOVWF  02
024CC:  MOVLB  9
024CE:  BRA    262C
024D0:  MOVLB  0
.................... 		case 6504: return (int16) nmea.sentence_age[2]; 
024D2:  MOVLB  7
024D4:  MOVF   xC8,W
024D6:  MOVWF  01
024D8:  MOVF   xC9,W
024DA:  MOVWF  02
024DC:  MOVLB  9
024DE:  BRA    262C
024E0:  MOVLB  0
.................... 		case 6505: return (int16) nmea.sentence_length[2]; 
024E2:  CLRF   03
024E4:  MOVLB  7
024E6:  MOVF   xDE,W
024E8:  MOVWF  01
024EA:  MOVF   03,W
024EC:  MOVWF  02
024EE:  MOVLB  9
024F0:  BRA    262C
024F2:  MOVLB  0
.................... 		case 6506: return (int16) nmea.sentence_age[3]; 
024F4:  MOVLB  7
024F6:  MOVF   xCA,W
024F8:  MOVWF  01
024FA:  MOVF   xCB,W
024FC:  MOVWF  02
024FE:  MOVLB  9
02500:  BRA    262C
02502:  MOVLB  0
.................... 		case 6507: return (int16) nmea.sentence_length[3]; 
02504:  CLRF   03
02506:  MOVLB  7
02508:  MOVF   xDF,W
0250A:  MOVWF  01
0250C:  MOVF   03,W
0250E:  MOVWF  02
02510:  MOVLB  9
02512:  BRA    262C
02514:  MOVLB  0
.................... 		case 6508: return (int16) nmea.sentence_age[4]; 
02516:  MOVLB  7
02518:  MOVF   xCC,W
0251A:  MOVWF  01
0251C:  MOVF   xCD,W
0251E:  MOVWF  02
02520:  MOVLB  9
02522:  BRA    262C
02524:  MOVLB  0
.................... 		case 6509: return (int16) nmea.sentence_length[4]; 
02526:  CLRF   03
02528:  MOVLB  7
0252A:  MOVF   xE0,W
0252C:  MOVWF  01
0252E:  MOVF   03,W
02530:  MOVWF  02
02532:  MOVLB  9
02534:  BRA    262C
02536:  MOVLB  0
.................... 		case 6510: return (int16) nmea.sentence_age[5]; 
02538:  MOVLB  7
0253A:  MOVF   xCE,W
0253C:  MOVWF  01
0253E:  MOVF   xCF,W
02540:  MOVWF  02
02542:  MOVLB  9
02544:  BRA    262C
02546:  MOVLB  0
.................... 		case 6511: return (int16) nmea.sentence_length[5]; 
02548:  CLRF   03
0254A:  MOVLB  7
0254C:  MOVF   xE1,W
0254E:  MOVWF  01
02550:  MOVF   03,W
02552:  MOVWF  02
02554:  MOVLB  9
02556:  BRA    262C
02558:  MOVLB  0
.................... 		case 6512: return (int16) nmea.sentence_age[6]; 
0255A:  MOVLB  7
0255C:  MOVF   xD0,W
0255E:  MOVWF  01
02560:  MOVF   xD1,W
02562:  MOVWF  02
02564:  MOVLB  9
02566:  BRA    262C
02568:  MOVLB  0
.................... 		case 6513: return (int16) nmea.sentence_length[6]; 
0256A:  CLRF   03
0256C:  MOVLB  7
0256E:  MOVF   xE2,W
02570:  MOVWF  01
02572:  MOVF   03,W
02574:  MOVWF  02
02576:  MOVLB  9
02578:  BRA    262C
0257A:  MOVLB  0
.................... 		case 6514: return (int16) nmea.sentence_age[7]; 
0257C:  MOVLB  7
0257E:  MOVF   xD2,W
02580:  MOVWF  01
02582:  MOVF   xD3,W
02584:  MOVWF  02
02586:  MOVLB  9
02588:  BRA    262C
0258A:  MOVLB  0
.................... 		case 6515: return (int16) nmea.sentence_length[7]; 
0258C:  CLRF   03
0258E:  MOVLB  7
02590:  MOVF   xE3,W
02592:  MOVWF  01
02594:  MOVF   03,W
02596:  MOVWF  02
02598:  MOVLB  9
0259A:  BRA    262C
0259C:  MOVLB  0
.................... 		case 6516: return (int16) nmea.sentence_age[8]; 
0259E:  MOVLB  7
025A0:  MOVF   xD4,W
025A2:  MOVWF  01
025A4:  MOVF   xD5,W
025A6:  MOVWF  02
025A8:  MOVLB  9
025AA:  BRA    262C
025AC:  MOVLB  0
.................... 		case 6517: return (int16) nmea.sentence_length[8]; 
025AE:  CLRF   03
025B0:  MOVLB  7
025B2:  MOVF   xE4,W
025B4:  MOVWF  01
025B6:  MOVF   03,W
025B8:  MOVWF  02
025BA:  MOVLB  9
025BC:  BRA    262C
025BE:  MOVLB  0
.................... 		case 6518: return (int16) nmea.sentence_age[9]; 
025C0:  MOVLB  7
025C2:  MOVF   xD6,W
025C4:  MOVWF  01
025C6:  MOVF   xD7,W
025C8:  MOVWF  02
025CA:  MOVLB  9
025CC:  BRA    262C
025CE:  MOVLB  0
.................... 		case 6519: return (int16) nmea.sentence_length[9]; 
025D0:  CLRF   03
025D2:  MOVLB  7
025D4:  MOVF   xE5,W
025D6:  MOVWF  01
025D8:  MOVF   03,W
025DA:  MOVWF  02
025DC:  MOVLB  9
025DE:  BRA    262C
025E0:  MOVLB  0
.................... 		case 6520: return (int16) nmea.sentence_age[10]; 
025E2:  MOVLB  7
025E4:  MOVF   xD8,W
025E6:  MOVWF  01
025E8:  MOVF   xD9,W
025EA:  MOVWF  02
025EC:  MOVLB  9
025EE:  BRA    262C
025F0:  MOVLB  0
.................... 		case 6521: return (int16) nmea.sentence_length[10]; 
025F2:  CLRF   03
025F4:  MOVLB  7
025F6:  MOVF   xE6,W
025F8:  MOVWF  01
025FA:  MOVF   03,W
025FC:  MOVWF  02
025FE:  MOVLB  9
02600:  BRA    262C
02602:  MOVLB  0
.................... 		case 6522: return (int16) nmea.sentence_age[11]; 
02604:  MOVLB  7
02606:  MOVF   xDA,W
02608:  MOVWF  01
0260A:  MOVF   xDB,W
0260C:  MOVWF  02
0260E:  MOVLB  9
02610:  BRA    262C
02612:  MOVLB  0
.................... 		case 6523: return (int16) nmea.sentence_length[11]; 
02614:  CLRF   03
02616:  MOVLB  7
02618:  MOVF   xE7,W
0261A:  MOVWF  01
0261C:  MOVF   03,W
0261E:  MOVWF  02
02620:  MOVLB  9
02622:  BRA    262C
....................  
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
02624:  MOVLW  FF
02626:  MOVWF  01
02628:  MOVWF  02
0262A:  BRA    262C
.................... 	} 
....................  
.................... } 
0262C:  MOVLB  0
0262E:  GOTO   2680 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
012D6:  MOVLB  9
012D8:  MOVF   x08,W
012DA:  SUBLW  1F
012DC:  BNZ   12F6
012DE:  MOVF   x09,W
012E0:  SUBLW  4E
012E2:  BNZ   12F6
012E4:  MOVF   x0A,W
012E6:  SUBLW  20
012E8:  BNZ   12F6
012EA:  MOVF   x0B,W
012EC:  SUBLW  4E
012EE:  BNZ   12F6
.................... 		return 1; 
012F0:  MOVLW  01
012F2:  MOVWF  01
012F4:  BRA    13E2
....................  
.................... 	if ( start >= MIN_NMEA0183_META_REGISTER && end <= MAX_NMEA0183_META_REGISTER )  
012F6:  MOVF   x09,W
012F8:  SUBLW  18
012FA:  BC    131A
012FC:  XORLW  FF
012FE:  BNZ   1306
01300:  MOVF   x08,W
01302:  SUBLW  63
01304:  BC    131A
01306:  MOVF   x0B,W
01308:  SUBLW  19
0130A:  BNC   131A
0130C:  BNZ   1314
0130E:  MOVF   x0A,W
01310:  SUBLW  7C
01312:  BNC   131A
.................... 		return 1; 
01314:  MOVLW  01
01316:  MOVWF  01
01318:  BRA    13E2
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
0131A:  MOVF   x09,W
0131C:  SUBLW  16
0131E:  BC    133E
01320:  XORLW  FF
01322:  BNZ   132A
01324:  MOVF   x08,W
01326:  SUBLW  6F
01328:  BC    133E
0132A:  MOVF   x0B,W
0132C:  SUBLW  19
0132E:  BNC   133E
01330:  BNZ   1338
01332:  MOVF   x0A,W
01334:  SUBLW  50
01336:  BNC   133E
.................... 		return 1; 
01338:  MOVLW  01
0133A:  MOVWF  01
0133C:  BRA    13E2
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
0133E:  MOVF   x09,W
01340:  SUBLW  12
01342:  BC    1362
01344:  XORLW  FF
01346:  BNZ   134E
01348:  MOVF   x08,W
0134A:  SUBLW  87
0134C:  BC    1362
0134E:  MOVF   x0B,W
01350:  SUBLW  17
01352:  BNC   1362
01354:  BNZ   135C
01356:  MOVF   x0A,W
01358:  SUBLW  48
0135A:  BNC   1362
.................... 		return 1; 
0135C:  MOVLW  01
0135E:  MOVWF  01
01360:  BRA    13E2
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01362:  MOVF   x09,W
01364:  SUBLW  03
01366:  BC    1386
01368:  XORLW  FF
0136A:  BNZ   1372
0136C:  MOVF   x08,W
0136E:  SUBLW  4B
01370:  BC    1386
01372:  MOVF   x0B,W
01374:  SUBLW  04
01376:  BNC   1386
01378:  BNZ   1380
0137A:  MOVF   x0A,W
0137C:  SUBLW  94
0137E:  BNC   1386
.................... 		return 1; 
01380:  MOVLW  01
01382:  MOVWF  01
01384:  BRA    13E2
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
01386:  MOVF   x09,W
01388:  SUBLW  02
0138A:  BC    13AA
0138C:  XORLW  FF
0138E:  BNZ   1396
01390:  MOVF   x08,W
01392:  SUBLW  E7
01394:  BC    13AA
01396:  MOVF   x0B,W
01398:  SUBLW  03
0139A:  BNC   13AA
0139C:  BNZ   13A4
0139E:  MOVF   x0A,W
013A0:  SUBLW  F6
013A2:  BNC   13AA
.................... 		return 1; 
013A4:  MOVLW  01
013A6:  MOVWF  01
013A8:  BRA    13E2
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
013AA:  MOVF   x09,W
013AC:  SUBLW  06
013AE:  BC    13CE
013B0:  XORLW  FF
013B2:  BNZ   13BA
013B4:  MOVF   x08,W
013B6:  SUBLW  CF
013B8:  BC    13CE
013BA:  MOVF   x0B,W
013BC:  SUBLW  09
013BE:  BNC   13CE
013C0:  BNZ   13C8
013C2:  MOVF   x0A,W
013C4:  SUBLW  D1
013C6:  BNC   13CE
.................... 		return 1; 
013C8:  MOVLW  01
013CA:  MOVWF  01
013CC:  BRA    13E2
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
013CE:  MOVF   x0B,F
013D0:  BNZ   13DE
013D2:  MOVF   x0A,W
013D4:  SUBLW  37
013D6:  BNC   13DE
.................... 		return 1; 
013D8:  MOVLW  01
013DA:  MOVWF  01
013DC:  BRA    13E2
....................  
.................... 	return 0; 
013DE:  MOVLW  00
013E0:  MOVWF  01
.................... } 
013E2:  MOVLB  0
013E4:  GOTO   2C66 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
02632:  MOVFF  907,910
02636:  MOVFF  906,911
0263A:  CALL   1420
.................... 	modbus_serial_putc(register_count*2); 
0263E:  BCF    FD8.0
02640:  MOVLB  9
02642:  RLCF   x0A,W
02644:  MOVWF  x10
02646:  RLCF   x0B,W
02648:  MOVWF  x11
0264A:  MOVFF  910,912
0264E:  MOVLB  0
02650:  CALL   13E8
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
02654:  MOVLB  9
02656:  CLRF   x0D
02658:  CLRF   x0C
0265A:  MOVF   x0D,W
0265C:  SUBWF  x0B,W
0265E:  BNC   26AA
02660:  BNZ   2668
02662:  MOVF   x0A,W
02664:  SUBWF  x0C,W
02666:  BC    26AA
.................... 		l=map_modbus(start_address+i); 
02668:  MOVF   x0C,W
0266A:  ADDWF  x08,W
0266C:  MOVWF  x10
0266E:  MOVF   x0D,W
02670:  ADDWFC x09,W
02672:  MOVWF  x11
02674:  MOVWF  x13
02676:  MOVFF  910,912
0267A:  MOVLB  0
0267C:  GOTO   15E4
02680:  MOVFF  02,90F
02684:  MOVFF  01,90E
.................... 		modbus_serial_putc(make8(l,1)); 
02688:  MOVFF  90F,910
0268C:  MOVFF  90F,912
02690:  CALL   13E8
....................   		modbus_serial_putc(make8(l,0)); 
02694:  MOVFF  90E,910
02698:  MOVFF  90E,912
0269C:  CALL   13E8
.................... 	} 
026A0:  MOVLB  9
026A2:  INCF   x0C,F
026A4:  BTFSC  FD8.2
026A6:  INCF   x0D,F
026A8:  BRA    265A
....................  
.................... 	modbus_serial_send_stop(); 
026AA:  MOVLB  0
026AC:  CALL   143E
.................... } 
026B0:  GOTO   2CA8 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
026B4:  MOVLB  9
026B6:  MOVF   x0D,W
026B8:  SUBLW  06
026BA:  BC    2732
026BC:  XORLW  FF
026BE:  BNZ   26C6
026C0:  MOVF   x0C,W
026C2:  SUBLW  CF
026C4:  BC    2732
026C6:  MOVF   x0D,W
026C8:  SUBLW  09
026CA:  BNC   2732
026CC:  BNZ   26D4
026CE:  MOVF   x0C,W
026D0:  SUBLW  CF
026D2:  BNC   2732
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
026D4:  MOVF   x0F,W
026D6:  SUBLW  00
026D8:  BC    26EA
026DA:  XORLW  FF
026DC:  BNZ   26E4
026DE:  MOVF   x0E,W
026E0:  SUBLW  00
026E2:  BC    26EA
026E4:  MOVLW  03
026E6:  MOVWF  01
026E8:  BRA    2A96
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
026EA:  MOVLW  D0
026EC:  SUBWF  x0C,W
026EE:  MOVWF  x12
026F0:  MOVLW  07
026F2:  SUBWFB x0D,W
026F4:  MOVWF  x13
026F6:  MOVLW  02
026F8:  ADDWF  x13,F
026FA:  MOVFF  913,FAA
026FE:  MOVFF  912,FA9
02702:  MOVFF  90E,FA8
02706:  BCF    FA6.6
02708:  BCF    FA6.7
0270A:  BSF    FA6.2
0270C:  MOVF   FF2,W
0270E:  MOVWF  00
02710:  BCF    FF2.6
02712:  BCF    FF2.7
02714:  MOVLB  F
02716:  MOVLW  55
02718:  MOVWF  FA7
0271A:  MOVLW  AA
0271C:  MOVWF  FA7
0271E:  BSF    FA6.1
02720:  BTFSC  FA6.1
02722:  BRA    2720
02724:  BCF    FA6.2
02726:  MOVF   00,W
02728:  IORWF  FF2,F
.................... 		return 0; 
0272A:  MOVLW  00
0272C:  MOVWF  01
0272E:  MOVLB  9
02730:  BRA    2A96
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
02732:  MOVF   x0D,W
02734:  SUBLW  03
02736:  BC    27C8
02738:  XORLW  FF
0273A:  BNZ   2742
0273C:  MOVF   x0C,W
0273E:  SUBLW  4B
02740:  BC    27C8
02742:  MOVF   x0D,W
02744:  SUBLW  04
02746:  BNC   27C8
02748:  BNZ   2750
0274A:  MOVF   x0C,W
0274C:  SUBLW  93
0274E:  BNC   27C8
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02750:  MOVF   x0F,W
02752:  SUBLW  00
02754:  BC    2766
02756:  XORLW  FF
02758:  BNZ   2760
0275A:  MOVF   x0E,W
0275C:  SUBLW  00
0275E:  BC    2766
02760:  MOVLW  03
02762:  MOVWF  01
02764:  BRA    2A96
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
02766:  MOVLW  4C
02768:  SUBWF  x0C,W
0276A:  MOVWF  x10
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
0276C:  MOVFF  910,918
02770:  MOVLW  06
02772:  MOVWF  x19
02774:  MOVLB  0
02776:  CALL   0B96
0277A:  MOVFF  00,911
.................... 		n = n / 6; /* number of sentence */ 
0277E:  MOVFF  910,918
02782:  MOVLW  06
02784:  MOVLB  9
02786:  MOVWF  x19
02788:  MOVLB  0
0278A:  CALL   0B96
0278E:  MOVFF  01,910
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
02792:  MOVLB  9
02794:  MOVF   x10,W
02796:  MULLW  06
02798:  MOVF   FF3,W
0279A:  CLRF   03
0279C:  ADDLW  19
0279E:  MOVWF  x12
027A0:  MOVLW  00
027A2:  ADDWFC 03,W
027A4:  MOVWF  x13
027A6:  CLRF   03
027A8:  MOVF   x11,W
027AA:  ADDWF  x12,W
027AC:  MOVWF  01
027AE:  MOVF   x13,W
027B0:  ADDWFC 03,F
027B2:  MOVF   01,W
027B4:  ADDLW  36
027B6:  MOVWF  FE9
027B8:  MOVLW  00
027BA:  ADDWFC 03,W
027BC:  MOVWF  FEA
027BE:  MOVFF  90E,FEF
.................... 		 
.................... 		return 0; 
027C2:  MOVLW  00
027C4:  MOVWF  01
027C6:  BRA    2A96
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
027C8:  MOVLB  1
027CA:  MOVF   xD8,F
027CC:  BZ    2804
.................... 		if ( 1000 == address ) { 
027CE:  MOVLB  9
027D0:  MOVF   x0C,W
027D2:  SUBLW  E8
027D4:  BNZ   27E8
027D6:  MOVF   x0D,W
027D8:  SUBLW  03
027DA:  BNZ   27E8
.................... 			config.serial_prefix=value; 
027DC:  MOVFF  90E,3A
.................... 			return 0; 
027E0:  MOVLW  00
027E2:  MOVWF  01
027E4:  BRA    2A96
.................... 		} else if ( 1001 == address ) { 
027E6:  BRA    2802
027E8:  MOVF   x0C,W
027EA:  SUBLW  E9
027EC:  BNZ   2802
027EE:  MOVF   x0D,W
027F0:  SUBLW  03
027F2:  BNZ   2802
.................... 			config.serial_number=value; 
027F4:  MOVFF  90F,3C
027F8:  MOVFF  90E,3B
.................... 			return 0; 
027FC:  MOVLW  00
027FE:  MOVWF  01
02800:  BRA    2A96
02802:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
02804:  MOVLB  9
02806:  MOVF   x0C,W
02808:  MOVWF  00
0280A:  MOVF   x0D,W
0280C:  MOVWF  03
0280E:  MOVLW  03
02810:  SUBWF  03,W
02812:  BNZ   2820
02814:  MOVLW  EE
02816:  SUBWF  00,W
02818:  MOVLB  0
0281A:  BTFSC  FD8.2
0281C:  BRA    28E8
0281E:  MOVLB  9
02820:  MOVLW  03
02822:  SUBWF  03,W
02824:  BNZ   2832
02826:  MOVLW  EF
02828:  SUBWF  00,W
0282A:  MOVLB  0
0282C:  BTFSC  FD8.2
0282E:  BRA    2900
02830:  MOVLB  9
02832:  MOVLW  03
02834:  SUBWF  03,W
02836:  BNZ   2844
02838:  MOVLW  F0
0283A:  SUBWF  00,W
0283C:  MOVLB  0
0283E:  BTFSC  FD8.2
02840:  BRA    2910
02842:  MOVLB  9
02844:  MOVLW  03
02846:  SUBWF  03,W
02848:  BNZ   2856
0284A:  MOVLW  F1
0284C:  SUBWF  00,W
0284E:  MOVLB  0
02850:  BTFSC  FD8.2
02852:  BRA    2928
02854:  MOVLB  9
02856:  MOVLW  03
02858:  SUBWF  03,W
0285A:  BNZ   2868
0285C:  MOVLW  F2
0285E:  SUBWF  00,W
02860:  MOVLB  0
02862:  BTFSC  FD8.2
02864:  BRA    2934
02866:  MOVLB  9
02868:  MOVLW  03
0286A:  SUBWF  03,W
0286C:  BNZ   287A
0286E:  MOVLW  F3
02870:  SUBWF  00,W
02872:  MOVLB  0
02874:  BTFSC  FD8.2
02876:  BRA    294E
02878:  MOVLB  9
0287A:  MOVLW  03
0287C:  SUBWF  03,W
0287E:  BNZ   288C
02880:  MOVLW  F4
02882:  SUBWF  00,W
02884:  MOVLB  0
02886:  BTFSC  FD8.2
02888:  BRA    2966
0288A:  MOVLB  9
0288C:  MOVLW  03
0288E:  SUBWF  03,W
02890:  BNZ   289E
02892:  MOVLW  F5
02894:  SUBWF  00,W
02896:  MOVLB  0
02898:  BTFSC  FD8.2
0289A:  BRA    297E
0289C:  MOVLB  9
0289E:  MOVLW  07
028A0:  SUBWF  03,W
028A2:  BNZ   28B0
028A4:  MOVLW  CD
028A6:  SUBWF  00,W
028A8:  MOVLB  0
028AA:  BTFSC  FD8.2
028AC:  BRA    2A1C
028AE:  MOVLB  9
028B0:  MOVLW  07
028B2:  SUBWF  03,W
028B4:  BNZ   28C2
028B6:  MOVLW  CE
028B8:  SUBWF  00,W
028BA:  MOVLB  0
028BC:  BTFSC  FD8.2
028BE:  BRA    2A30
028C0:  MOVLB  9
028C2:  MOVLW  07
028C4:  SUBWF  03,W
028C6:  BNZ   28D4
028C8:  MOVLW  CF
028CA:  SUBWF  00,W
028CC:  MOVLB  0
028CE:  BTFSC  FD8.2
028D0:  BRA    2A4A
028D2:  MOVLB  9
028D4:  MOVLW  4E
028D6:  SUBWF  03,W
028D8:  BNZ   28E6
028DA:  MOVLW  1F
028DC:  SUBWF  00,W
028DE:  MOVLB  0
028E0:  BTFSC  FD8.2
028E2:  BRA    2A64
028E4:  MOVLB  9
028E6:  BRA    2A8C
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
028E8:  MOVLB  9
028EA:  MOVF   x0F,F
028EC:  BNZ   28F4
028EE:  MOVF   x0E,W
028F0:  SUBLW  80
028F2:  BC    28FA
028F4:  MOVLW  03
028F6:  MOVWF  01
028F8:  BRA    2A96
.................... 			config.modbus_address=value; 
028FA:  MOVFF  90E,36
.................... 			break; 
028FE:  BRA    2A92
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
02900:  MOVLB  1
02902:  BSF    xFB.1
.................... 			config.adc_sample_ticks=value; 
02904:  MOVFF  90F,3E
02908:  MOVFF  90E,3D
.................... 			break; 
0290C:  MOVLB  9
0290E:  BRA    2A92
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02910:  MOVLB  9
02912:  MOVF   x0F,F
02914:  BNZ   291C
02916:  MOVF   x0E,W
02918:  SUBLW  01
0291A:  BC    2922
0291C:  MOVLW  03
0291E:  MOVWF  01
02920:  BRA    2A96
.................... 			config.allow_bootload_request=value; 
02922:  MOVFF  90E,3F
.................... 			break; 
02926:  BRA    2A92
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
02928:  MOVFF  90F,41
0292C:  MOVFF  90E,40
.................... 			break; 
02930:  MOVLB  9
02932:  BRA    2A92
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
02934:  MOVLB  9
02936:  MOVF   x0E,F
02938:  BNZ   2944
0293A:  MOVF   x0F,F
0293C:  BNZ   2944
0293E:  MOVLW  03
02940:  MOVWF  01
02942:  BRA    2A96
.................... 			config.pi_offtime_seconds=value; 
02944:  MOVFF  90F,43
02948:  MOVFF  90E,42
.................... 			break; 
0294C:  BRA    2A92
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
0294E:  MOVLB  9
02950:  MOVF   x0F,F
02952:  BNZ   295A
02954:  MOVF   x0E,W
02956:  SUBLW  01
02958:  BC    2960
0295A:  MOVLW  03
0295C:  MOVWF  01
0295E:  BRA    2A96
.................... 			config.power_startup=value; 
02960:  MOVFF  90E,44
.................... 			break; 
02964:  BRA    2A92
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
02966:  MOVLB  9
02968:  MOVF   x0F,F
0296A:  BNZ   2972
0296C:  MOVF   x0E,W
0296E:  SUBLW  02
02970:  BC    2978
02972:  MOVLW  03
02974:  MOVWF  01
02976:  BRA    2A96
.................... 			config.rs485_port_mode=value; 
02978:  MOVFF  90E,38
.................... 			break; 
0297C:  BRA    2A92
.................... 		 
.................... 		case 1013: 
....................  
.................... 			n=0; 
0297E:  MOVLB  9
02980:  CLRF   x10
.................... 			if ( 1200 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_1200; } 
02982:  MOVF   x0E,W
02984:  SUBLW  B0
02986:  BNZ   2994
02988:  MOVF   x0F,W
0298A:  SUBLW  04
0298C:  BNZ   2994
0298E:  MOVLW  01
02990:  MOVWF  x10
02992:  CLRF   39
.................... 			if ( 2400 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_2400; } 
02994:  MOVF   x0E,W
02996:  SUBLW  60
02998:  BNZ   29A6
0299A:  MOVF   x0F,W
0299C:  SUBLW  09
0299E:  BNZ   29A6
029A0:  MOVLW  01
029A2:  MOVWF  x10
029A4:  MOVWF  39
.................... 			if ( 4800 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_4800; } 
029A6:  MOVF   x0E,W
029A8:  SUBLW  C0
029AA:  BNZ   29BA
029AC:  MOVF   x0F,W
029AE:  SUBLW  12
029B0:  BNZ   29BA
029B2:  MOVLW  01
029B4:  MOVWF  x10
029B6:  MOVLW  02
029B8:  MOVWF  39
.................... 			if ( 9600 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_9600; } 
029BA:  MOVF   x0E,W
029BC:  SUBLW  80
029BE:  BNZ   29CE
029C0:  MOVF   x0F,W
029C2:  SUBLW  25
029C4:  BNZ   29CE
029C6:  MOVLW  01
029C8:  MOVWF  x10
029CA:  MOVLW  03
029CC:  MOVWF  39
.................... 			if ( 19200 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_19200; } 
029CE:  MOVF   x0E,F
029D0:  BNZ   29E0
029D2:  MOVF   x0F,W
029D4:  SUBLW  4B
029D6:  BNZ   29E0
029D8:  MOVLW  01
029DA:  MOVWF  x10
029DC:  MOVLW  04
029DE:  MOVWF  39
.................... 			if ( 38400 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_38400; } 
029E0:  MOVF   x0E,F
029E2:  BNZ   29F2
029E4:  MOVF   x0F,W
029E6:  SUBLW  96
029E8:  BNZ   29F2
029EA:  MOVLW  01
029EC:  MOVWF  x10
029EE:  MOVLW  05
029F0:  MOVWF  39
.................... 			if ( 57600 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_57600; } 
029F2:  MOVF   x0E,F
029F4:  BNZ   2A04
029F6:  MOVF   x0F,W
029F8:  SUBLW  E1
029FA:  BNZ   2A04
029FC:  MOVLW  01
029FE:  MOVWF  x10
02A00:  MOVLW  06
02A02:  MOVWF  39
....................  
.................... 			if (  1==n ) { 
02A04:  DECFSZ x10,W
02A06:  BRA    2A12
.................... 				set_rs485_speed(); 
02A08:  MOVLB  0
02A0A:  CALL   091E
.................... 			}  else { 
02A0E:  BRA    2A18
02A10:  MOVLB  9
.................... 				return ILLEGAL_DATA_VALUE; 
02A12:  MOVLW  03
02A14:  MOVWF  01
02A16:  BRA    2A96
.................... 			} 
.................... 			break; 
02A18:  MOVLB  9
02A1A:  BRA    2A92
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A1C:  MOVLB  9
02A1E:  DECFSZ x0E,W
02A20:  BRA    2A26
02A22:  MOVF   x0F,F
02A24:  BZ    2A2C
02A26:  MOVLW  03
02A28:  MOVWF  01
02A2A:  BRA    2A96
.................... 			reset_cpu(); 
02A2C:  RESET
02A2E:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A30:  MOVLB  9
02A32:  DECFSZ x0E,W
02A34:  BRA    2A3A
02A36:  MOVF   x0F,F
02A38:  BZ    2A40
02A3A:  MOVLW  03
02A3C:  MOVWF  01
02A3E:  BRA    2A96
.................... 			write_default_param_file(); 
02A40:  MOVLB  0
02A42:  CALL   0DDA
.................... 			break; 
02A46:  MOVLB  9
02A48:  BRA    2A92
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A4A:  MOVLB  9
02A4C:  DECFSZ x0E,W
02A4E:  BRA    2A54
02A50:  MOVF   x0F,F
02A52:  BZ    2A5A
02A54:  MOVLW  03
02A56:  MOVWF  01
02A58:  BRA    2A96
.................... 			write_param_file(); 
02A5A:  MOVLB  0
02A5C:  CALL   0D86
.................... 			break; 
02A60:  MOVLB  9
02A62:  BRA    2A92
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
02A64:  MOVLB  9
02A66:  MOVF   x0E,W
02A68:  SUBLW  0A
02A6A:  BNZ   2A72
02A6C:  MOVF   x0F,W
02A6E:  SUBLW  07
02A70:  BZ    2A7E
.................... 				current.factory_unlocked=0; 
02A72:  MOVLB  1
02A74:  CLRF   xD8
.................... 				return ILLEGAL_DATA_VALUE; 
02A76:  MOVLW  03
02A78:  MOVWF  01
02A7A:  MOVLB  9
02A7C:  BRA    2A96
.................... 			} 
.................... 			current.factory_unlocked=1; 
02A7E:  MOVLW  01
02A80:  MOVLB  1
02A82:  MOVWF  xD8
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02A84:  MOVLW  C8
02A86:  MOVWF  xF8
.................... 			break; 
02A88:  MOVLB  9
02A8A:  BRA    2A92
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02A8C:  MOVLW  02
02A8E:  MOVWF  01
02A90:  BRA    2A96
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02A92:  MOVLW  00
02A94:  MOVWF  01
.................... } 
02A96:  MOVLB  0
02A98:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02B2A:  GOTO   1288
02B2E:  MOVF   01,F
02B30:  BTFSC  FD8.2
02B32:  BRA    2E2E
.................... output_low(_PIC_TO_PI); 
02B34:  BCF    F8C.3
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02B36:  DECFSZ 38,W
02B38:  BRA    2BEC
02B3A:  MOVF   36,W
02B3C:  MOVLB  7
02B3E:  SUBWF  xEC,W
02B40:  BTFSS  FD8.2
02B42:  BRA    2B48
02B44:  MOVLB  0
02B46:  BRA    2BEC
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02B48:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02B4A:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02B4C:  CLRWDT
02B4E:  MOVLW  02
02B50:  MOVLB  9
02B52:  MOVWF  x02
02B54:  MOVLW  B5
02B56:  MOVWF  x07
02B58:  MOVLB  0
02B5A:  CALL   12AE
02B5E:  MOVLB  9
02B60:  DECFSZ x02,F
02B62:  BRA    2B54
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02B64:  MOVLB  7
02B66:  MOVF   xEC,W
02B68:  MOVLB  0
02B6A:  CALL   12CE
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02B6E:  CLRWDT
02B70:  MOVLW  67
02B72:  MOVWF  00
02B74:  DECFSZ 00,F
02B76:  BRA    2B74
02B78:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02B7A:  MOVLB  7
02B7C:  MOVF   xEE,W
02B7E:  MOVLB  0
02B80:  CALL   12CE
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02B84:  CLRWDT
02B86:  MOVLW  67
02B88:  MOVWF  00
02B8A:  DECFSZ 00,F
02B8C:  BRA    2B8A
02B8E:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02B90:  MOVLB  9
02B92:  CLRF   x01
02B94:  MOVLW  02
02B96:  MOVLB  7
02B98:  ADDWF  xED,W
02B9A:  MOVLB  9
02B9C:  SUBWF  x01,W
02B9E:  BC    2BCC
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02BA0:  MOVLW  F0
02BA2:  ADDWF  x01,W
02BA4:  MOVWF  FE9
02BA6:  MOVLW  07
02BA8:  MOVWF  FEA
02BAA:  BTFSC  FD8.0
02BAC:  INCF   FEA,F
02BAE:  MOVFF  FEF,902
02BB2:  MOVF   x02,W
02BB4:  MOVLB  0
02BB6:  CALL   12CE
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02BBA:  CLRWDT
02BBC:  MOVLW  67
02BBE:  MOVWF  00
02BC0:  DECFSZ 00,F
02BC2:  BRA    2BC0
02BC4:  NOP   
.................... 			} 
02BC6:  MOVLB  9
02BC8:  INCF   x01,F
02BCA:  BRA    2B94
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02BCC:  BTFSS  F72.1
02BCE:  BRA    2BCC
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02BD0:  CLRWDT
02BD2:  MOVLW  02
02BD4:  MOVWF  x02
02BD6:  MOVLW  B5
02BD8:  MOVWF  x07
02BDA:  MOVLB  0
02BDC:  CALL   12AE
02BE0:  MOVLB  9
02BE2:  DECFSZ x02,F
02BE4:  BRA    2BD6
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02BE6:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02BE8:  BCF    F8C.0
02BEA:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02BEC:  MOVF   36,W
02BEE:  SUBLW  80
02BF0:  BZ    2BFE
02BF2:  MOVF   36,W
02BF4:  MOVLB  7
02BF6:  SUBWF  xEC,W
02BF8:  BTFSS  FD8.2
02BFA:  BRA    2E18
02BFC:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02BFE:  MOVLB  1
02C00:  INCFSZ xCC,W
02C02:  BRA    2C0A
02C04:  INCFSZ xCD,W
02C06:  BRA    2C0A
02C08:  BRA    2C10
.................... 				current.modbus_our_packets++; 
02C0A:  INCF   xCC,F
02C0C:  BTFSC  FD8.2
02C0E:  INCF   xCD,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02C10:  MOVLW  14
02C12:  MOVWF  xF8
....................  
.................... 			switch(modbus_rx.func) { 
02C14:  MOVLB  7
02C16:  MOVF   xEE,W
02C18:  XORLW  03
02C1A:  MOVLB  0
02C1C:  BZ    2C2E
02C1E:  XORLW  07
02C20:  BZ    2C2E
02C22:  XORLW  02
02C24:  BZ    2CAC
02C26:  XORLW  16
02C28:  BTFSC  FD8.2
02C2A:  BRA    2D1E
02C2C:  BRA    2DF0
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02C2E:  MOVFF  7F0,8FD
02C32:  MOVFF  7F1,8FC
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02C36:  MOVFF  7F2,8FF
02C3A:  MOVFF  7F3,8FE
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02C3E:  MOVLB  8
02C40:  MOVF   xFE,W
02C42:  ADDWF  xFC,W
02C44:  MOVLB  9
02C46:  MOVWF  x02
02C48:  MOVLB  8
02C4A:  MOVF   xFF,W
02C4C:  ADDWFC xFD,W
02C4E:  MOVLB  9
02C50:  MOVWF  x03
02C52:  MOVFF  8FD,909
02C56:  MOVFF  8FC,908
02C5A:  MOVWF  x0B
02C5C:  MOVFF  902,90A
02C60:  MOVLB  0
02C62:  GOTO   12D6
02C66:  MOVF   01,F
02C68:  BNZ   2C8E
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02C6A:  MOVFF  7EC,906
02C6E:  MOVLB  9
02C70:  CLRF   x08
02C72:  MOVFF  7EE,907
02C76:  MOVLW  02
02C78:  MOVWF  x09
02C7A:  MOVLB  0
02C7C:  CALL   1460
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02C80:  MOVLB  1
02C82:  CLRF   xD1
02C84:  MOVLW  02
02C86:  MOVWF  xD0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02C88:  CLRF   xF8
.................... 					} else { 
02C8A:  BRA    2CAA
02C8C:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02C8E:  MOVFF  7EE,906
02C92:  MOVFF  7EC,907
02C96:  MOVFF  8FD,909
02C9A:  MOVFF  8FC,908
02C9E:  MOVFF  8FF,90B
02CA2:  MOVFF  8FE,90A
02CA6:  BRA    2632
02CA8:  MOVLB  1
.................... 					} 
.................... 					break; 
02CAA:  BRA    2E10
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02CAC:  MOVFF  7F0,8FD
02CB0:  MOVFF  7F1,8FC
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02CB4:  MOVFF  7F2,903
02CB8:  MOVFF  7F3,902
02CBC:  MOVFF  8FD,90D
02CC0:  MOVFF  8FC,90C
02CC4:  MOVFF  7F2,90F
02CC8:  MOVFF  7F3,90E
02CCC:  RCALL  26B4
02CCE:  MOVFF  01,900
....................  
.................... 					if ( result ) { 
02CD2:  MOVLB  9
02CD4:  MOVF   x00,F
02CD6:  BZ    2CFA
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02CD8:  MOVFF  7EC,906
02CDC:  CLRF   x08
02CDE:  MOVFF  7EE,907
02CE2:  MOVFF  900,909
02CE6:  MOVLB  0
02CE8:  CALL   1460
.................... 						current.modbus_last_error=result; 
02CEC:  MOVLB  1
02CEE:  CLRF   xD1
02CF0:  MOVFF  900,1D0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02CF4:  CLRF   xF8
.................... 					}  else { 
02CF6:  BRA    2D1C
02CF8:  MOVLB  9
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02CFA:  MOVFF  7F2,903
02CFE:  MOVFF  7F3,902
02D02:  MOVFF  7EC,908
02D06:  MOVFF  8FD,90A
02D0A:  MOVFF  8FC,909
02D0E:  MOVFF  7F2,90C
02D12:  MOVFF  7F3,90B
02D16:  MOVLB  0
02D18:  BRA    2A9A
02D1A:  MOVLB  1
.................... 					} 
.................... 					break; 
02D1C:  BRA    2E10
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02D1E:  MOVFF  7F0,8FD
02D22:  MOVFF  7F1,8FC
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02D26:  MOVFF  7F2,8FF
02D2A:  MOVFF  7F3,8FE
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02D2E:  MOVLB  9
02D30:  CLRF   x01
02D32:  MOVLB  8
02D34:  MOVF   xFF,F
02D36:  BNZ   2D42
02D38:  MOVF   xFE,W
02D3A:  MOVLB  9
02D3C:  SUBWF  x01,W
02D3E:  BC    2DD0
02D40:  MOVLB  8
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02D42:  MOVLB  9
02D44:  MOVF   x01,W
02D46:  MOVLB  8
02D48:  ADDWF  xFC,W
02D4A:  MOVLB  9
02D4C:  MOVWF  x02
02D4E:  MOVLW  00
02D50:  MOVLB  8
02D52:  ADDWFC xFD,W
02D54:  MOVLB  9
02D56:  MOVWF  x03
02D58:  BCF    FD8.0
02D5A:  RLCF   x01,W
02D5C:  ADDLW  05
02D5E:  ADDLW  F0
02D60:  MOVWF  FE9
02D62:  MOVLW  07
02D64:  MOVWF  FEA
02D66:  BTFSC  FD8.0
02D68:  INCF   FEA,F
02D6A:  MOVFF  FEF,904
02D6E:  BCF    FD8.0
02D70:  RLCF   x01,W
02D72:  ADDLW  06
02D74:  ADDLW  F0
02D76:  MOVWF  FE9
02D78:  MOVLW  07
02D7A:  MOVWF  FEA
02D7C:  BTFSC  FD8.0
02D7E:  INCF   FEA,F
02D80:  MOVFF  FEF,905
02D84:  MOVFF  904,907
02D88:  MOVFF  905,906
02D8C:  MOVFF  903,90D
02D90:  MOVFF  902,90C
02D94:  MOVFF  904,90F
02D98:  MOVFF  905,90E
02D9C:  MOVLB  0
02D9E:  RCALL  26B4
02DA0:  MOVFF  01,900
....................  
.................... 						if ( result ) { 
02DA4:  MOVLB  9
02DA6:  MOVF   x00,F
02DA8:  BZ    2DCC
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02DAA:  MOVFF  7EC,906
02DAE:  CLRF   x08
02DB0:  MOVFF  7EE,907
02DB4:  MOVFF  900,909
02DB8:  MOVLB  0
02DBA:  CALL   1460
.................... 							current.modbus_last_error=result; 
02DBE:  MOVLB  1
02DC0:  CLRF   xD1
02DC2:  MOVFF  900,1D0
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02DC6:  CLRF   xF8
.................... 			 
.................... 							break; 
02DC8:  MOVLB  9
02DCA:  BRA    2DD0
.................... 						} 
.................... 					} 
02DCC:  INCF   x01,F
02DCE:  BRA    2D32
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02DD0:  MOVF   x00,F
02DD2:  BNZ   2DEC
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02DD4:  MOVFF  7EC,906
02DD8:  MOVFF  8FD,908
02DDC:  MOVFF  8FC,907
02DE0:  MOVFF  8FF,90A
02DE4:  MOVFF  8FE,909
02DE8:  MOVLB  0
02DEA:  BRA    2AE2
.................... 					} 
....................  
.................... 					break;   
02DEC:  MOVLB  1
02DEE:  BRA    2E10
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02DF0:  MOVFF  7EC,906
02DF4:  MOVLB  9
02DF6:  CLRF   x08
02DF8:  MOVFF  7EE,907
02DFC:  MOVLW  01
02DFE:  MOVWF  x09
02E00:  MOVLB  0
02E02:  CALL   1460
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02E06:  MOVLB  1
02E08:  CLRF   xD1
02E0A:  MOVLW  01
02E0C:  MOVWF  xD0
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02E0E:  CLRF   xF8
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02E10:  CLRF   xDA
02E12:  CLRF   xD9
....................  
.................... 		} else { 
02E14:  BRA    2E2E
02E16:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02E18:  MOVLB  1
02E1A:  INCFSZ xCE,W
02E1C:  BRA    2E24
02E1E:  INCFSZ xCF,W
02E20:  BRA    2E24
02E22:  BRA    2E2A
.................... 				current.modbus_other_packets++; 
02E24:  INCF   xCE,F
02E26:  BTFSC  FD8.2
02E28:  INCF   xCF,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02E2A:  MOVLW  0A
02E2C:  MOVWF  xF8
02E2E:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02E30:  GOTO   3304 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
0044E:  MOVLB  A
00450:  BTFSS  x14.0
00452:  BRA    046C
00454:  MOVLB  1
00456:  INCFSZ xE7,W
00458:  BRA    0464
0045A:  INCFSZ xE8,W
0045C:  BRA    0464
0045E:  MOVLB  A
00460:  BRA    046C
00462:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00464:  INCF   xE7,F
00466:  BTFSC  FD8.2
00468:  INCF   xE8,F
0046A:  MOVLB  A
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0046C:  BTFSS  x14.2
0046E:  BRA    0488
00470:  MOVLB  1
00472:  INCFSZ xE9,W
00474:  BRA    0480
00476:  INCFSZ xEA,W
00478:  BRA    0480
0047A:  MOVLB  A
0047C:  BRA    0488
0047E:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00480:  INCF   xE9,F
00482:  BTFSC  FD8.2
00484:  INCF   xEA,F
00486:  MOVLB  A
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
00488:  BTFSS  x14.4
0048A:  BRA    04A4
0048C:  MOVLB  1
0048E:  INCFSZ xEB,W
00490:  BRA    049C
00492:  INCFSZ xEC,W
00494:  BRA    049C
00496:  MOVLB  A
00498:  BRA    04A4
0049A:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
0049C:  INCF   xEB,F
0049E:  BTFSC  FD8.2
004A0:  INCF   xEC,F
004A2:  MOVLB  A
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
004A4:  BCF    x14.1
004A6:  BTFSC  F81.0
004A8:  BSF    x14.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
004AA:  BTFSC  x14.1
004AC:  BRA    0530
004AE:  MOVLB  7
004B0:  BTFSC  xE8.1
004B2:  BRA    04B8
004B4:  MOVLB  A
004B6:  BRA    0530
.................... 		current.pulse_count[0]++; 
004B8:  MOVLB  0
004BA:  INCF   xA9,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xAA,F
.................... 		current.pulse_sum[0]++; 
004C0:  MOVLW  01
004C2:  ADDWF  xAF,F
004C4:  BTFSC  FD8.0
004C6:  INCF   xB0,F
004C8:  BTFSC  FD8.2
004CA:  INCF   xB1,F
004CC:  BTFSC  FD8.2
004CE:  INCF   xB2,F
.................... 		if ( 1 == ext0_state ) { 
004D0:  MOVLB  7
004D2:  BTFSS  xE8.2
004D4:  BRA    051E
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004D6:  MOVLB  A
004D8:  BCF    x14.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004DA:  MOVFF  1E8,98
004DE:  MOVFF  1E7,97
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004E2:  MOVLB  0
004E4:  MOVF   x98,W
004E6:  SUBWF  x9E,W
004E8:  BNC   04FA
004EA:  BNZ   04F2
004EC:  MOVF   x9D,W
004EE:  SUBWF  x97,W
004F0:  BC    04FA
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004F2:  MOVFF  98,9E
004F6:  MOVFF  97,9D
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004FA:  MOVF   xA4,W
004FC:  SUBWF  x98,W
004FE:  BNC   051A
00500:  BNZ   0508
00502:  MOVF   x97,W
00504:  SUBWF  xA3,W
00506:  BC    051A
00508:  INCFSZ x97,W
0050A:  BRA    0512
0050C:  INCFSZ x98,W
0050E:  BRA    0512
00510:  BRA    051A
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00512:  MOVFF  98,A4
00516:  MOVFF  97,A3
.................... 			} 
.................... 			ext0_state=0; 
0051A:  MOVLB  7
0051C:  BCF    xE8.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
0051E:  BTFSC  xE8.2
00520:  BRA    0530
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00522:  MOVLB  1
00524:  CLRF   xE8
00526:  CLRF   xE7
.................... 			ext0_count=1; 
00528:  MOVLB  A
0052A:  BSF    x14.0
.................... 			ext0_state=1; 
0052C:  MOVLB  7
0052E:  BSF    xE8.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00530:  MOVLB  7
00532:  BCF    xE8.1
00534:  MOVLB  A
00536:  BTFSS  x14.1
00538:  BRA    0540
0053A:  MOVLB  7
0053C:  BSF    xE8.1
0053E:  MOVLB  A
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00540:  BCF    x14.3
00542:  BTFSC  F81.1
00544:  BSF    x14.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
00546:  BTFSC  x14.3
00548:  BRA    05CC
0054A:  MOVLB  7
0054C:  BTFSC  xE8.3
0054E:  BRA    0554
00550:  MOVLB  A
00552:  BRA    05CC
.................... 		current.pulse_count[1]++; 
00554:  MOVLB  0
00556:  INCF   xAB,F
00558:  BTFSC  FD8.2
0055A:  INCF   xAC,F
.................... 		current.pulse_sum[1]++; 
0055C:  MOVLW  01
0055E:  ADDWF  xB3,F
00560:  BTFSC  FD8.0
00562:  INCF   xB4,F
00564:  BTFSC  FD8.2
00566:  INCF   xB5,F
00568:  BTFSC  FD8.2
0056A:  INCF   xB6,F
.................... 		if ( 1 == ext1_state ) { 
0056C:  MOVLB  7
0056E:  BTFSS  xE8.4
00570:  BRA    05BA
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00572:  MOVLB  A
00574:  BCF    x14.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00576:  MOVFF  1EA,9A
0057A:  MOVFF  1E9,99
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
0057E:  MOVLB  0
00580:  MOVF   x9A,W
00582:  SUBWF  xA0,W
00584:  BNC   0596
00586:  BNZ   058E
00588:  MOVF   x9F,W
0058A:  SUBWF  x99,W
0058C:  BC    0596
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0058E:  MOVFF  9A,A0
00592:  MOVFF  99,9F
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00596:  MOVF   xA6,W
00598:  SUBWF  x9A,W
0059A:  BNC   05B6
0059C:  BNZ   05A4
0059E:  MOVF   x99,W
005A0:  SUBWF  xA5,W
005A2:  BC    05B6
005A4:  INCFSZ x99,W
005A6:  BRA    05AE
005A8:  INCFSZ x9A,W
005AA:  BRA    05AE
005AC:  BRA    05B6
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005AE:  MOVFF  9A,A6
005B2:  MOVFF  99,A5
.................... 			} 
.................... 			ext1_state=0; 
005B6:  MOVLB  7
005B8:  BCF    xE8.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005BA:  BTFSC  xE8.4
005BC:  BRA    05CC
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005BE:  MOVLB  1
005C0:  CLRF   xEA
005C2:  CLRF   xE9
.................... 			ext1_count=1; 
005C4:  MOVLB  A
005C6:  BSF    x14.2
.................... 			ext1_state=1; 
005C8:  MOVLB  7
005CA:  BSF    xE8.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005CC:  MOVLB  7
005CE:  BCF    xE8.3
005D0:  MOVLB  A
005D2:  BTFSS  x14.3
005D4:  BRA    05DC
005D6:  MOVLB  7
005D8:  BSF    xE8.3
005DA:  MOVLB  A
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005DC:  BCF    x14.5
005DE:  BTFSC  F81.2
005E0:  BSF    x14.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005E2:  BTFSC  x14.5
005E4:  BRA    0668
005E6:  MOVLB  7
005E8:  BTFSC  xE8.5
005EA:  BRA    05F0
005EC:  MOVLB  A
005EE:  BRA    0668
.................... 		current.pulse_count[2]++; 
005F0:  MOVLB  0
005F2:  INCF   xAD,F
005F4:  BTFSC  FD8.2
005F6:  INCF   xAE,F
.................... 		current.pulse_sum[2]++; 
005F8:  MOVLW  01
005FA:  ADDWF  xB7,F
005FC:  BTFSC  FD8.0
005FE:  INCF   xB8,F
00600:  BTFSC  FD8.2
00602:  INCF   xB9,F
00604:  BTFSC  FD8.2
00606:  INCF   xBA,F
.................... 		if ( 1 == ext2_state ) { 
00608:  MOVLB  7
0060A:  BTFSS  xE8.6
0060C:  BRA    0656
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0060E:  MOVLB  A
00610:  BCF    x14.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00612:  MOVFF  1EC,9C
00616:  MOVFF  1EB,9B
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0061A:  MOVLB  0
0061C:  MOVF   x9C,W
0061E:  SUBWF  xA2,W
00620:  BNC   0632
00622:  BNZ   062A
00624:  MOVF   xA1,W
00626:  SUBWF  x9B,W
00628:  BC    0632
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0062A:  MOVFF  9C,A2
0062E:  MOVFF  9B,A1
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00632:  MOVF   xA8,W
00634:  SUBWF  x9C,W
00636:  BNC   0652
00638:  BNZ   0640
0063A:  MOVF   x9B,W
0063C:  SUBWF  xA7,W
0063E:  BC    0652
00640:  INCFSZ x9B,W
00642:  BRA    064A
00644:  INCFSZ x9C,W
00646:  BRA    064A
00648:  BRA    0652
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0064A:  MOVFF  9C,A8
0064E:  MOVFF  9B,A7
.................... 			} 
.................... 			ext2_state=0; 
00652:  MOVLB  7
00654:  BCF    xE8.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
00656:  BTFSC  xE8.6
00658:  BRA    0668
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0065A:  MOVLB  1
0065C:  CLRF   xEC
0065E:  CLRF   xEB
.................... 			ext2_count=1; 
00660:  MOVLB  A
00662:  BSF    x14.4
.................... 			ext2_state=1; 
00664:  MOVLB  7
00666:  BSF    xE8.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
00668:  MOVLB  7
0066A:  BCF    xE8.5
0066C:  MOVLB  A
0066E:  BTFSS  x14.5
00670:  BRA    0678
00672:  MOVLB  7
00674:  BSF    xE8.5
00676:  MOVLB  A
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00678:  MOVLB  8
0067A:  INCF   xF3,F
.................... 	if ( 10 == tick ) { 
0067C:  MOVF   xF3,W
0067E:  SUBLW  0A
00680:  BNZ   068A
.................... 		tick=0; 
00682:  CLRF   xF3
.................... 		timers.now_millisecond=1; 
00684:  MOVLB  1
00686:  BSF    xFB.2
00688:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0068A:  BCF    F9E.1
0068C:  MOVLB  0
0068E:  GOTO   013A
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
006AA:  BRA    0692
006AC:  MOVFF  01,A11
.................... 	current.rda2_bytes_received++; 
006B0:  MOVLB  1
006B2:  INCF   xE4,F
006B4:  BTFSC  FD8.2
006B6:  INCF   xE5,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
006B8:  DECFSZ 38,W
006BA:  BRA    06E0
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006BC:  MOVLB  3
006BE:  CLRF   x00
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006C0:  MOVLB  2
006C2:  INCFSZ xFF,W
006C4:  BRA    06C8
006C6:  BRA    06DC
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006C8:  MOVLW  FF
006CA:  ADDWF  xFF,W
006CC:  MOVWF  FE9
006CE:  MOVLW  01
006D0:  MOVWF  FEA
006D2:  BTFSC  FD8.0
006D4:  INCF   FEA,F
006D6:  MOVFF  A11,FEF
.................... 			timers.rda2_buff_pos++; 
006DA:  INCF   xFF,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006DC:  BRA    0728
006DE:  MOVLB  1
006E0:  MOVF   38,W
006E2:  SUBLW  02
006E4:  BNZ   072A
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
006E6:  MOVLB  A
006E8:  MOVF   x11,W
006EA:  SUBLW  0A
006EC:  BZ    06F4
006EE:  MOVF   x11,W
006F0:  SUBLW  0D
006F2:  BNZ   0708
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
006F4:  MOVLB  2
006F6:  MOVF   xFF,F
006F8:  BZ    0704
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
006FA:  MOVLW  14
006FC:  MOVLB  3
006FE:  MOVWF  x00
.................... 			}  else { 
00700:  BRA    0702
00702:  MOVLB  2
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
00704:  BRA    0728
00706:  MOVLB  A
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
00708:  MOVLB  3
0070A:  CLRF   x00
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
0070C:  MOVLB  2
0070E:  INCFSZ xFF,W
00710:  BRA    0714
00712:  BRA    0728
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
00714:  MOVLW  FF
00716:  ADDWF  xFF,W
00718:  MOVWF  FE9
0071A:  MOVLW  01
0071C:  MOVWF  FEA
0071E:  BTFSC  FD8.0
00720:  INCF   FEA,F
00722:  MOVFF  A11,FEF
.................... 				timers.rda2_buff_pos++; 
00726:  INCF   xFF,F
00728:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /* transmit buffer empty for Modbus to raspberry pi buffer */ 
0072A:  BCF    FA4.5
0072C:  MOVLB  0
0072E:  GOTO   0094
.................... #int_tbe 
.................... void isr_uart1_tbe() { 
.................... 	if ( timers.rda_tx_pos >= timers.rda_tx_length ) { 
*
0073A:  MOVLB  4
0073C:  MOVF   x01,W
0073E:  SUBWF  x02,W
00740:  BNC   0748
.................... 		/* done transmitting */ 
.................... 		timers.now_rda_tx_done=1; 
00742:  BSF    x03.1
.................... 		disable_interrupts(INT_TBE); 
00744:  BCF    F9D.4
.................... 	} else { 
00746:  BRA    0766
.................... 		/* put another character into TX buffer */ 
.................... 		fputc(timers.rda_tx_buff[timers.rda_tx_pos], STREAM_PI); 
00748:  MOVLW  01
0074A:  ADDWF  x02,W
0074C:  MOVWF  FE9
0074E:  MOVLW  03
00750:  MOVWF  FEA
00752:  BTFSC  FD8.0
00754:  INCF   FEA,F
00756:  MOVFF  FEF,A11
0075A:  MOVLB  A
0075C:  MOVF   x11,W
0075E:  MOVLB  0
00760:  RCALL  0732
.................... 		timers.rda_tx_pos++; 
00762:  MOVLB  4
00764:  INCF   x02,F
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00766:  BCF    F9E.4
00768:  MOVLB  0
0076A:  GOTO   0094
.................... #int_rda 
.................... void isr_uart1_rx() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
007B0:  RCALL  076E
007B2:  MOVFF  01,A11
....................  
.................... 	current.rda_bytes_received++; 
007B6:  MOVLB  1
007B8:  INCF   xE2,F
007BA:  BTFSC  FD8.2
007BC:  INCF   xE3,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
007BE:  MOVLB  7
007C0:  BTFSC  xE8.0
007C2:  BRA    081C
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
007C4:  MOVF   xE9,F
007C6:  BNZ   07DA
.................... output_high(_PIC_TO_PI); 
007C8:  BSF    F8C.3
.................... 			modbus_serial_crc.d = 0xFFFF; 
007CA:  SETF   xEB
007CC:  SETF   xEA
.................... 			modbus_rx.address = c; 
007CE:  MOVFF  A11,7EC
.................... 			modbus_serial_state++; 
007D2:  INCF   xE9,F
.................... 			modbus_rx.len = 0; 
007D4:  CLRF   xED
.................... 			modbus_rx.error=0; 
007D6:  CLRF   xEF
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
007D8:  BRA    0808
007DA:  DECFSZ xE9,W
007DC:  BRA    07E6
.................... 			modbus_rx.func = c; 
007DE:  MOVFF  A11,7EE
.................... 			modbus_serial_state++; 
007E2:  INCF   xE9,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
007E4:  BRA    0808
007E6:  MOVF   xE9,W
007E8:  SUBLW  02
007EA:  BNZ   0808
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
007EC:  INCFSZ xED,W
007EE:  BRA    07F4
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
007F0:  MOVLW  FE
007F2:  MOVWF  xED
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
007F4:  MOVLW  F0
007F6:  ADDWF  xED,W
007F8:  MOVWF  FE9
007FA:  MOVLW  07
007FC:  MOVWF  FEA
007FE:  BTFSC  FD8.0
00800:  INCF   FEA,F
00802:  MOVFF  A11,FEF
.................... 			modbus_rx.len++; 
00806:  INCF   xED,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00808:  MOVFF  A11,A12
0080C:  MOVLB  0
0080E:  RCALL  0784
.................... 		modbus_enable_timeout(TRUE); 
00810:  MOVLW  01
00812:  MOVLB  A
00814:  MOVWF  x12
00816:  MOVLB  0
00818:  RCALL  0408
0081A:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
0081C:  BCF    F9E.5
0081E:  MOVLB  0
00820:  GOTO   0094
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
0091E:  MOVF   39,W
00920:  XORLW  00
00922:  BZ    093A
00924:  XORLW  01
00926:  BZ    094A
00928:  XORLW  03
0092A:  BZ    095A
0092C:  XORLW  06
0092E:  BZ    096A
00930:  XORLW  01
00932:  BZ    0976
00934:  XORLW  03
00936:  BZ    0986
00938:  BRA    0992
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
0093A:  BSF    F70.3
0093C:  MOVLW  C3
0093E:  MOVWF  F75
00940:  MOVLW  09
00942:  MOVWF  F76
00944:  MOVLW  A6
00946:  MOVWF  F72
00948:  BRA    099E
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
0094A:  BSF    F70.3
0094C:  MOVLW  E1
0094E:  MOVWF  F75
00950:  MOVLW  04
00952:  MOVWF  F76
00954:  MOVLW  A6
00956:  MOVWF  F72
00958:  BRA    099E
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
0095A:  BSF    F70.3
0095C:  MOVLW  70
0095E:  MOVWF  F75
00960:  MOVLW  02
00962:  MOVWF  F76
00964:  MOVLW  A6
00966:  MOVWF  F72
00968:  BRA    099E
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
0096A:  BCF    F70.3
0096C:  MOVLW  26
0096E:  MOVWF  F75
00970:  MOVLW  A6
00972:  MOVWF  F72
00974:  BRA    099E
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
00976:  BSF    F70.3
00978:  MOVLW  4D
0097A:  MOVWF  F75
0097C:  MOVLW  00
0097E:  MOVWF  F76
00980:  MOVLW  A6
00982:  MOVWF  F72
00984:  BRA    099E
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
00986:  BCF    F70.3
00988:  MOVLW  0C
0098A:  MOVWF  F75
0098C:  MOVLW  A6
0098E:  MOVWF  F72
00990:  BRA    099E
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
00992:  BCF    F70.3
00994:  MOVLW  4D
00996:  MOVWF  F75
00998:  MOVLW  A6
0099A:  MOVWF  F72
0099C:  BRA    099E
.................... 	} 
.................... } 
0099E:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... 	setup_adc(ADC_OFF); 
009A0:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
009A2:  MOVLW  08
009A4:  MOVWF  F61
009A6:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
009A8:  MOVLW  00
009AA:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
009AC:  MOVLW  FF
009AE:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
009B0:  MOVLW  92
009B2:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
009B4:  MOVLW  80
009B6:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
009B8:  BCF    F96.0
009BA:  BCF    F96.1
009BC:  BCF    F96.2
009BE:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
009C0:  MOVLB  1
009C2:  CLRF   xF8
.................... 	timers.load_off_seconds=2; 
009C4:  CLRF   xFA
009C6:  MOVLW  02
009C8:  MOVWF  xF9
.................... 	timers.now_adc_sample=0; 
009CA:  BCF    xFB.0
.................... 	timers.now_adc_reset_count=0; 
009CC:  BCF    xFB.1
.................... 	timers.now_millisecond=0; 
009CE:  BCF    xFB.2
.................... 	timers.port_b=0b11111111; 
009D0:  SETF   xFC
.................... 	timers.port_c=0b11111111; 
009D2:  SETF   xFD
....................  
.................... 	timers.rda2_buff_pos=0; 
009D4:  MOVLB  2
009D6:  CLRF   xFF
.................... 	timers.rda2_buff_gap=255; 
009D8:  MOVLB  3
009DA:  SETF   x00
.................... 	timers.now_parse_rda2=0; 
009DC:  MOVLB  1
009DE:  BCF    xFE.0
....................  
.................... 	timers.rda_tx_length=0; 
009E0:  MOVLB  4
009E2:  CLRF   x01
.................... 	timers.rda_tx_pos=0; 
009E4:  CLRF   x02
.................... 	timers.now_rda_tx_ready=0; 
009E6:  BCF    x03.0
.................... 	timers.now_rda_tx_done=0; 
009E8:  BCF    x03.1
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
009EA:  MOVLB  8
009EC:  CLRF   xFC
009EE:  MOVF   xFC,W
009F0:  SUBLW  02
009F2:  BNC   0AA2
.................... 		current.pulse_period[i]=0; 
009F4:  CLRF   03
009F6:  MOVFF  8FC,02
009FA:  BCF    FD8.0
009FC:  RLCF   02,F
009FE:  RLCF   03,F
00A00:  MOVF   02,W
00A02:  ADDLW  97
00A04:  MOVWF  FE9
00A06:  MOVLW  00
00A08:  ADDWFC 03,W
00A0A:  MOVWF  FEA
00A0C:  CLRF   FEC
00A0E:  MOVF   FED,F
00A10:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
00A12:  CLRF   03
00A14:  MOVFF  8FC,02
00A18:  BCF    FD8.0
00A1A:  RLCF   02,F
00A1C:  RLCF   03,F
00A1E:  MOVF   02,W
00A20:  ADDLW  9D
00A22:  MOVWF  FE9
00A24:  MOVLW  00
00A26:  ADDWFC 03,W
00A28:  MOVWF  FEA
00A2A:  SETF   FEC
00A2C:  MOVF   FED,F
00A2E:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00A30:  CLRF   03
00A32:  MOVFF  8FC,02
00A36:  BCF    FD8.0
00A38:  RLCF   02,F
00A3A:  RLCF   03,F
00A3C:  MOVF   02,W
00A3E:  ADDLW  A3
00A40:  MOVWF  FE9
00A42:  MOVLW  00
00A44:  ADDWFC 03,W
00A46:  MOVWF  FEA
00A48:  CLRF   FEC
00A4A:  MOVF   FED,F
00A4C:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00A4E:  CLRF   03
00A50:  MOVFF  8FC,02
00A54:  BCF    FD8.0
00A56:  RLCF   02,F
00A58:  RLCF   03,F
00A5A:  MOVF   02,W
00A5C:  ADDLW  A9
00A5E:  MOVWF  FE9
00A60:  MOVLW  00
00A62:  ADDWFC 03,W
00A64:  MOVWF  FEA
00A66:  CLRF   FEC
00A68:  MOVF   FED,F
00A6A:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00A6C:  MOVLB  A
00A6E:  CLRF   x01
00A70:  MOVFF  8FC,A00
00A74:  CLRF   x03
00A76:  MOVLW  04
00A78:  MOVWF  x02
00A7A:  MOVLB  0
00A7C:  RCALL  08E2
00A7E:  MOVF   01,W
00A80:  ADDLW  AF
00A82:  MOVWF  FE9
00A84:  MOVLW  00
00A86:  ADDWFC 02,W
00A88:  MOVWF  FEA
00A8A:  MOVF   FEE,F
00A8C:  MOVF   FEE,F
00A8E:  CLRF   FEC
00A90:  MOVF   FED,F
00A92:  CLRF   FEF
00A94:  MOVF   FED,F
00A96:  CLRF   FEF
00A98:  MOVF   FED,F
00A9A:  CLRF   FEF
.................... 	} 
00A9C:  MOVLB  8
00A9E:  INCF   xFC,F
00AA0:  BRA    09EE
....................  
.................... 	current.modbus_our_packets=0; 
00AA2:  MOVLB  1
00AA4:  CLRF   xCD
00AA6:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
00AA8:  CLRF   xCF
00AAA:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
00AAC:  CLRF   xD1
00AAE:  CLRF   xD0
.................... 	current.sequence_number=0; 
00AB0:  CLRF   xD3
00AB2:  CLRF   xD2
.................... 	current.uptime_minutes=0; 
00AB4:  CLRF   xD5
00AB6:  CLRF   xD4
.................... 	current.interval_milliseconds=0; 
00AB8:  CLRF   xD7
00ABA:  CLRF   xD6
.................... 	current.adc_buffer_index=0; 
00ABC:  CLRF   xCB
.................... 	current.factory_unlocked=0; 
00ABE:  CLRF   xD8
.................... 	current.watchdog_seconds=0; 
00AC0:  CLRF   xDA
00AC2:  CLRF   xD9
.................... 	current.rda_bytes_received=0; 
00AC4:  CLRF   xE3
00AC6:  CLRF   xE2
.................... 	current.rda2_bytes_received=0; 
00AC8:  CLRF   xE5
00ACA:  CLRF   xE4
.................... 	current.button_state=0; 
00ACC:  CLRF   xE6
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
00ACE:  MOVLW  04
00AD0:  MOVWF  FEA
00AD2:  MOVWF  FE9
00AD4:  CLRF   00
00AD6:  MOVLW  03
00AD8:  MOVWF  02
00ADA:  MOVLW  E4
00ADC:  MOVWF  01
00ADE:  MOVLB  0
00AE0:  RCALL  0904
.................... 	for ( i=0 ; i < N_NMEA0183_SENTENCES ; i++ ) { 
00AE2:  MOVLB  8
00AE4:  CLRF   xFC
00AE6:  MOVF   xFC,W
00AE8:  SUBLW  0B
00AEA:  BNC   0B1E
.................... 		nmea.sentence_age[i]=0xffff; 
00AEC:  CLRF   03
00AEE:  MOVFF  8FC,02
00AF2:  BCF    FD8.0
00AF4:  RLCF   02,F
00AF6:  RLCF   03,F
00AF8:  MOVF   02,W
00AFA:  ADDLW  C4
00AFC:  MOVWF  FE9
00AFE:  MOVLW  07
00B00:  ADDWFC 03,W
00B02:  MOVWF  FEA
00B04:  SETF   FEC
00B06:  MOVF   FED,F
00B08:  SETF   FEF
.................... 		nmea.sentence_length[i]=0; 
00B0A:  MOVLW  DC
00B0C:  ADDWF  xFC,W
00B0E:  MOVWF  FE9
00B10:  MOVLW  07
00B12:  MOVWF  FEA
00B14:  BTFSC  FD8.0
00B16:  INCF   FEA,F
00B18:  CLRF   FEF
.................... 	} 
00B1A:  INCF   xFC,F
00B1C:  BRA    0AE6
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00B1E:  MOVFF  4C,1DD
00B22:  MOVFF  4B,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
00B26:  MOVFF  48,1DF
00B2A:  MOVFF  47,1DE
.................... 	current.power_override_timeout=0; 
00B2E:  MOVLB  1
00B30:  CLRF   xE1
00B32:  CLRF   xE0
....................  
.................... 	/* UART2 - RS-485 port */ 
.................... 	set_rs485_speed(); 
00B34:  MOVLB  0
00B36:  RCALL  091E
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00B38:  MOVLW  00
00B3A:  IORLW  05
00B3C:  MOVWF  FBA
00B3E:  MOVLW  4A
00B40:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00B42:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00B44:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00B46:  GOTO   3180 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... 	static int16 b0_state=0; /* push button */ 
.................... 	/* power control */ 
.................... 	int8 i; 
....................  
....................  
.................... 	timers.now_millisecond=0; 
*
010BC:  MOVLB  1
010BE:  BCF    xFB.2
....................  
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
010C0:  BCF    FD8.0
010C2:  MOVLB  8
010C4:  RLCF   xF9,W
010C6:  MOVWF  xFD
010C8:  RLCF   xFA,W
010CA:  MOVWF  xFE
010CC:  MOVLW  00
010CE:  MOVLB  1
010D0:  BTFSS  xFC.3
010D2:  MOVLW  01
010D4:  MOVLB  8
010D6:  IORWF  xFD,F
010D8:  MOVFF  8FD,8F9
010DC:  MOVF   xFE,W
010DE:  IORLW  E0
010E0:  MOVWF  xFA
.................... 	if ( b0_state==0xf000) { 
010E2:  MOVF   xF9,F
010E4:  BNZ   10F6
010E6:  MOVF   xFA,W
010E8:  SUBLW  F0
010EA:  BNZ   10F6
.................... 		/* button pressed */ 
.................... 		current.button_state=1; 
010EC:  MOVLW  01
010EE:  MOVLB  1
010F0:  MOVWF  xE6
.................... 	} else { 
010F2:  BRA    10FA
010F4:  MOVLB  8
.................... 		current.button_State=0; 
010F6:  MOVLB  1
010F8:  CLRF   xE6
.................... 	} 
....................  
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
010FA:  INCFSZ xE7,W
010FC:  BRA    110A
010FE:  INCFSZ xE8,W
01100:  BRA    110A
.................... 				current.pulse_period[0]=0; 
01102:  MOVLB  0
01104:  CLRF   x98
01106:  CLRF   x97
01108:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
0110A:  INCFSZ xE9,W
0110C:  BRA    111A
0110E:  INCFSZ xEA,W
01110:  BRA    111A
.................... 				current.pulse_period[1]=0; 
01112:  MOVLB  0
01114:  CLRF   x9A
01116:  CLRF   x99
01118:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
0111A:  INCFSZ xEB,W
0111C:  BRA    112A
0111E:  INCFSZ xEC,W
01120:  BRA    112A
.................... 				current.pulse_period[2]=0; 
01122:  MOVLB  0
01124:  CLRF   x9C
01126:  CLRF   x9B
01128:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
0112A:  MOVFF  F81,1FC
.................... 	timers.port_c=port_c; 
0112E:  MOVFF  F82,1FD
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
01132:  MOVF   xF8,F
01134:  BNZ   113A
.................... 		output_low(LED_GREEN); 
01136:  BCF    F89.3
.................... 	} else { 
01138:  BRA    113E
.................... 		output_high(LED_GREEN); 
0113A:  BSF    F89.3
.................... 		timers.led_on_green--; 
0113C:  DECF   xF8,F
.................... 	} 
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
0113E:  INCFSZ xD6,W
01140:  BRA    1148
01142:  INCFSZ xD7,W
01144:  BRA    1148
01146:  BRA    114E
.................... 		current.interval_milliseconds++; 
01148:  INCF   xD6,F
0114A:  BTFSC  FD8.2
0114C:  INCF   xD7,F
.................... 	} 
....................  
.................... 	/* NMEA sentence age */ 
.................... 	for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
0114E:  MOVLB  8
01150:  CLRF   xFC
01152:  MOVF   xFC,W
01154:  SUBLW  0B
01156:  BNC   11A6
.................... 		if ( 0xffff != nmea.sentence_age[i] ) 
01158:  CLRF   03
0115A:  MOVFF  8FC,02
0115E:  BCF    FD8.0
01160:  RLCF   02,F
01162:  RLCF   03,F
01164:  MOVF   02,W
01166:  ADDLW  C4
01168:  MOVWF  FE9
0116A:  MOVLW  07
0116C:  ADDWFC 03,W
0116E:  MOVWF  FEA
01170:  MOVFF  FEC,03
01174:  MOVF   FED,F
01176:  MOVF   FEF,W
01178:  SUBLW  FF
0117A:  BNZ   1182
0117C:  INCFSZ 03,W
0117E:  BRA    1182
01180:  BRA    11A2
.................... 			nmea.sentence_age[i]++; 
01182:  CLRF   03
01184:  MOVFF  8FC,02
01188:  BCF    FD8.0
0118A:  RLCF   02,F
0118C:  RLCF   03,F
0118E:  MOVF   02,W
01190:  ADDLW  C4
01192:  MOVWF  FE9
01194:  MOVLW  07
01196:  ADDWFC 03,W
01198:  MOVWF  FEA
0119A:  MOVLW  01
0119C:  ADDWF  FEE,F
0119E:  BNC   11A2
011A0:  INCF   FEF,F
.................... 	} 
011A2:  INCF   xFC,F
011A4:  BRA    1152
....................  
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
011A6:  INCF   xF7,F
011A8:  BTFSC  FD8.2
011AA:  INCF   xF8,F
.................... 	if ( 1000 == ticks ) { 
011AC:  MOVF   xF7,W
011AE:  SUBLW  E8
011B0:  BNZ   1236
011B2:  MOVF   xF8,W
011B4:  SUBLW  03
011B6:  BNZ   1236
.................... 		ticks=0; 
011B8:  CLRF   xF8
011BA:  CLRF   xF7
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
011BC:  MOVLB  1
011BE:  INCFSZ xD9,W
011C0:  BRA    11C8
011C2:  INCFSZ xDA,W
011C4:  BRA    11C8
011C6:  BRA    11CE
.................... 			current.watchdog_seconds++; 
011C8:  INCF   xD9,F
011CA:  BTFSC  FD8.2
011CC:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
011CE:  MOVF   40,F
011D0:  BNZ   11D6
011D2:  MOVF   41,F
011D4:  BZ    11F4
011D6:  MOVF   41,W
011D8:  SUBWF  xDA,W
011DA:  BNC   11F4
011DC:  BNZ   11E4
011DE:  MOVF   xD9,W
011E0:  SUBWF  40,W
011E2:  BC    11F4
011E4:  MOVF   xF9,F
011E6:  BNZ   11F4
011E8:  MOVF   xFA,F
011EA:  BNZ   11F4
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
011EC:  MOVFF  43,1FA
011F0:  MOVFF  42,1F9
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
011F4:  MOVF   xF9,F
011F6:  BNZ   1200
011F8:  MOVF   xFA,F
011FA:  BNZ   1200
.................... 			output_high(PI_POWER_EN); 
011FC:  BSF    F8B.0
.................... 		} else { 
011FE:  BRA    1216
.................... 			output_low(PI_POWER_EN); 
01200:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01202:  MOVF   xF9,W
01204:  BTFSC  FD8.2
01206:  DECF   xFA,F
01208:  DECF   xF9,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
0120A:  MOVF   xF9,F
0120C:  BNZ   1216
0120E:  MOVF   xFA,F
01210:  BNZ   1216
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01212:  CLRF   xDA
01214:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
01216:  MOVLB  8
01218:  INCF   xF4,F
.................... 		if ( 60 == uptimeTicks ) { 
0121A:  MOVF   xF4,W
0121C:  SUBLW  3C
0121E:  BNZ   1236
.................... 			uptimeTicks=0; 
01220:  CLRF   xF4
.................... 			if ( current.uptime_minutes < 65535 )  
01222:  MOVLB  1
01224:  INCFSZ xD4,W
01226:  BRA    122E
01228:  INCFSZ xD5,W
0122A:  BRA    122E
0122C:  BRA    1234
.................... 				current.uptime_minutes++; 
0122E:  INCF   xD4,F
01230:  BTFSC  FD8.2
01232:  INCF   xD5,F
01234:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
01236:  MOVLB  1
01238:  BTFSS  xFB.1
0123A:  BRA    1244
.................... 		timers.now_adc_reset_count=0; 
0123C:  BCF    xFB.1
.................... 		adcTicks=0; 
0123E:  MOVLB  8
01240:  CLRF   xF6
01242:  CLRF   xF5
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01244:  MOVLB  8
01246:  INCF   xF5,F
01248:  BTFSC  FD8.2
0124A:  INCF   xF6,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
0124C:  MOVF   3D,W
0124E:  SUBWF  xF5,W
01250:  BNZ   1260
01252:  MOVF   3E,W
01254:  SUBWF  xF6,W
01256:  BNZ   1260
.................... 		adcTicks=0; 
01258:  CLRF   xF6
0125A:  CLRF   xF5
.................... 		timers.now_adc_sample=1; 
0125C:  MOVLB  1
0125E:  BSF    xFB.0
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01260:  MOVLB  3
01262:  INCFSZ x00,W
01264:  BRA    1268
01266:  BRA    126A
.................... 		timers.rda2_buff_gap++; 
01268:  INCF   x00,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
0126A:  MOVF   x00,W
0126C:  SUBLW  09
0126E:  BC    1282
01270:  MOVLB  2
01272:  MOVF   xFF,F
01274:  BTFSS  FD8.2
01276:  BRA    127C
01278:  MOVLB  3
0127A:  BRA    1282
.................... 		timers.now_parse_rda2=1;	 
0127C:  MOVLB  1
0127E:  BSF    xFE.0
01280:  MOVLB  3
.................... 	} 
.................... } 
01282:  MOVLB  0
01284:  GOTO   32F2 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && i < maxLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
02E34:  MOVLB  A
02E36:  CLRF   x08
02E38:  MOVF   x06,W
02E3A:  SUBWF  x08,W
02E3C:  BC    2EB0
02E3E:  MOVF   x07,W
02E40:  SUBWF  x08,W
02E42:  BC    2EB0
02E44:  CLRF   03
02E46:  MOVF   x08,W
02E48:  ADDWF  x04,W
02E4A:  MOVWF  FE9
02E4C:  MOVF   x05,W
02E4E:  ADDWFC 03,W
02E50:  MOVWF  FEA
02E52:  MOVF   FEF,F
02E54:  BZ    2EB0
02E56:  CLRF   03
02E58:  MOVF   x08,W
02E5A:  ADDWF  x04,W
02E5C:  MOVWF  FE9
02E5E:  MOVF   x05,W
02E60:  ADDWFC 03,W
02E62:  MOVWF  FEA
02E64:  MOVF   FEF,W
02E66:  SUBLW  0A
02E68:  BZ    2EB0
02E6A:  CLRF   03
02E6C:  MOVF   x08,W
02E6E:  ADDWF  x04,W
02E70:  MOVWF  FE9
02E72:  MOVF   x05,W
02E74:  ADDWFC 03,W
02E76:  MOVWF  FEA
02E78:  MOVF   FEF,W
02E7A:  SUBLW  0D
02E7C:  BZ    2EB0
.................... 		dest[i] = src[i]; 
02E7E:  CLRF   03
02E80:  MOVF   x08,W
02E82:  ADDWF  x02,W
02E84:  MOVWF  01
02E86:  MOVF   x03,W
02E88:  ADDWFC 03,F
02E8A:  MOVFF  03,A0A
02E8E:  CLRF   03
02E90:  MOVF   x08,W
02E92:  ADDWF  x04,W
02E94:  MOVWF  FE9
02E96:  MOVF   x05,W
02E98:  ADDWFC 03,W
02E9A:  MOVWF  FEA
02E9C:  MOVFF  FEF,A0B
02EA0:  MOVFF  A0A,FEA
02EA4:  MOVFF  01,FE9
02EA8:  MOVFF  A0B,FEF
.................... 	} 
02EAC:  INCF   x08,F
02EAE:  BRA    2E38
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
02EB0:  MOVF   x07,W
02EB2:  SUBWF  x08,W
02EB4:  BC    2ECA
.................... 		dest[i] = '\0'; 
02EB6:  CLRF   03
02EB8:  MOVF   x08,W
02EBA:  ADDWF  x02,W
02EBC:  MOVWF  FE9
02EBE:  MOVF   x03,W
02EC0:  ADDWFC 03,W
02EC2:  MOVWF  FEA
02EC4:  CLRF   FEF
.................... 	} 
02EC6:  INCF   x08,F
02EC8:  BRA    2EB0
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
02ECA:  MOVLW  01
02ECC:  SUBWF  x07,W
02ECE:  CLRF   03
02ED0:  ADDWF  x02,W
02ED2:  MOVWF  FE9
02ED4:  MOVF   x03,W
02ED6:  ADDWFC 03,W
02ED8:  MOVWF  FEA
02EDA:  CLRF   FEF
.................... } 
02EDC:  MOVLB  0
02EDE:  RETURN 0
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02F78:  MOVFF  2FF,9FC
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02F7C:  MOVLB  2
02F7E:  SETF   xFF
.................... 	memcpy(buff,timers.rda2_buff,length); 
02F80:  MOVLW  08
02F82:  MOVWF  FEA
02F84:  MOVLW  FC
02F86:  MOVWF  FE9
02F88:  MOVLW  01
02F8A:  MOVWF  FE2
02F8C:  SETF   FE1
02F8E:  MOVLB  9
02F90:  MOVF   xFC,W
02F92:  MOVWF  01
02F94:  BZ    2F9E
02F96:  MOVFF  FE6,FEE
02F9A:  DECFSZ 01,F
02F9C:  BRA    2F96
.................... 	timers.rda2_buff_gap=0; 
02F9E:  MOVLB  3
02FA0:  CLRF   x00
.................... 	timers.rda2_buff_pos=0; 
02FA2:  MOVLB  2
02FA4:  CLRF   xFF
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02FA6:  DECFSZ 38,W
02FA8:  BRA    2FE2
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02FAA:  MOVLB  9
02FAC:  CLRF   xFE
02FAE:  CLRF   xFD
02FB0:  MOVF   xFE,F
02FB2:  BNZ   2FDE
02FB4:  MOVF   xFC,W
02FB6:  SUBWF  xFD,W
02FB8:  BC    2FDE
.................... 			fputc(buff[l],STREAM_PI); 
02FBA:  MOVLW  FC
02FBC:  ADDWF  xFD,W
02FBE:  MOVWF  FE9
02FC0:  MOVLW  08
02FC2:  ADDWFC xFE,W
02FC4:  MOVWF  FEA
02FC6:  MOVFF  FEF,A00
02FCA:  MOVLB  A
02FCC:  MOVF   x00,W
02FCE:  MOVLB  0
02FD0:  CALL   0732
.................... 		} 
02FD4:  MOVLB  9
02FD6:  INCF   xFD,F
02FD8:  BTFSC  FD8.2
02FDA:  INCF   xFE,F
02FDC:  BRA    2FB0
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
02FDE:  BRA    30D8
02FE0:  MOVLB  2
02FE2:  MOVF   38,W
02FE4:  SUBLW  02
02FE6:  BTFSS  FD8.2
02FE8:  BRA    30DA
.................... 		/* do something */ 
....................  
.................... 		/* put copy in the last slot no mater what ... for debugging */ 
.................... 		strncpy_terminate_trim(nmea.sentence[N_NMEA0183_SENTENCES-1],buff,length,NMEA_SENTENCE_LENGTH); 
02FEA:  MOVLW  07
02FEC:  MOVLB  A
02FEE:  MOVWF  x03
02FF0:  MOVLW  74
02FF2:  MOVWF  x02
02FF4:  MOVLW  08
02FF6:  MOVWF  x05
02FF8:  MOVLW  FC
02FFA:  MOVWF  x04
02FFC:  MOVFF  9FC,A06
03000:  MOVLW  50
03002:  MOVWF  x07
03004:  MOVLB  0
03006:  RCALL  2E34
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
03008:  MOVLB  9
0300A:  MOVF   xFC,W
0300C:  SUBLW  05
0300E:  BNC   3012
.................... 			return; 
03010:  BRA    30D8
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
03012:  CLRF   xFF
03014:  MOVF   xFF,W
03016:  SUBLW  0B
03018:  BNC   30D8
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
0301A:  MOVF   xFF,W
0301C:  MULLW  06
0301E:  MOVF   FF3,W
03020:  CLRF   03
03022:  ADDLW  4F
03024:  MOVWF  01
03026:  MOVLW  00
03028:  ADDWFC 03,F
0302A:  MOVFF  01,A00
0302E:  MOVLB  A
03030:  MOVFF  03,A01
03034:  MOVLW  08
03036:  MOVWF  x03
03038:  MOVLW  FC
0303A:  MOVWF  x02
0303C:  MOVFF  03,A05
03040:  MOVFF  01,A04
03044:  CLRF   x07
03046:  MOVLW  06
03048:  MOVWF  x06
0304A:  MOVLB  0
0304C:  BRA    2EE0
0304E:  MOVF   01,F
03050:  BZ    3054
.................... 				/* no match */ 
.................... 				continue; 
03052:  BRA    30D2
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
03054:  MOVLB  A
03056:  CLRF   x01
03058:  MOVFF  9FF,A00
0305C:  CLRF   x03
0305E:  MOVLW  50
03060:  MOVWF  x02
03062:  MOVLB  0
03064:  CALL   08E2
03068:  MOVFF  02,03
0306C:  MOVF   01,W
0306E:  ADDLW  04
03070:  MOVWF  01
03072:  MOVLW  04
03074:  ADDWFC 03,F
03076:  MOVFF  01,A00
0307A:  MOVLB  A
0307C:  MOVFF  03,A01
03080:  MOVFF  03,A03
03084:  MOVFF  01,A02
03088:  MOVLW  08
0308A:  MOVWF  x05
0308C:  MOVLW  FC
0308E:  MOVWF  x04
03090:  MOVFF  9FC,A06
03094:  MOVLW  50
03096:  MOVWF  x07
03098:  MOVLB  0
0309A:  RCALL  2E34
.................... 			nmea.sentence_age[i]=0; 
0309C:  CLRF   03
0309E:  MOVLB  9
030A0:  MOVFF  9FF,02
030A4:  BCF    FD8.0
030A6:  RLCF   02,F
030A8:  RLCF   03,F
030AA:  MOVF   02,W
030AC:  ADDLW  C4
030AE:  MOVWF  FE9
030B0:  MOVLW  07
030B2:  ADDWFC 03,W
030B4:  MOVWF  FEA
030B6:  CLRF   FEC
030B8:  MOVF   FED,F
030BA:  CLRF   FEF
.................... 			nmea.sentence_length[i]=length; 
030BC:  MOVLW  DC
030BE:  ADDWF  xFF,W
030C0:  MOVWF  FE9
030C2:  MOVLW  07
030C4:  MOVWF  FEA
030C6:  BTFSC  FD8.0
030C8:  INCF   FEA,F
030CA:  MOVFF  9FC,FEF
....................  
.................... 			/* only fill in our first match */ 
.................... 			break; 
030CE:  BRA    30D8
030D0:  MOVLB  0
.................... 		} 
030D2:  MOVLB  9
030D4:  INCF   xFF,F
030D6:  BRA    3014
030D8:  MOVLB  2
.................... 	} 
.................... } 
030DA:  MOVLB  0
030DC:  GOTO   3340 (RETURN)
....................  
....................  
.................... void main(void) { 
030E0:  CLRF   FF8
030E2:  BCF    FF1.2
030E4:  BSF    F9F.1
030E6:  BCF    F9F.5
030E8:  BCF    F9F.4
030EA:  BCF    FA5.5
030EC:  BSF    FD0.7
030EE:  BSF    07.7
030F0:  CLRF   FEA
030F2:  CLRF   FE9
030F4:  CLRF   35
030F6:  BCF    FB8.3
030F8:  MOVLW  0C
030FA:  MOVWF  FAF
030FC:  MOVLW  A6
030FE:  MOVWF  FAC
03100:  MOVLW  90
03102:  MOVWF  FAB
03104:  BCF    F70.3
03106:  MOVLW  4D
03108:  MOVWF  F75
0310A:  MOVLW  A6
0310C:  MOVWF  F72
0310E:  MOVLW  90
03110:  MOVWF  F71
03112:  MOVLB  7
03114:  BCF    xE8.0
03116:  CLRF   xE9
03118:  MOVLB  8
0311A:  CLRF   xF3
0311C:  MOVLB  7
0311E:  BCF    xE8.1
03120:  BCF    xE8.2
03122:  BCF    xE8.3
03124:  BCF    xE8.4
03126:  BCF    xE8.5
03128:  BCF    xE8.6
0312A:  MOVLB  8
0312C:  CLRF   xF4
0312E:  CLRF   xF6
03130:  CLRF   xF5
03132:  CLRF   xF8
03134:  CLRF   xF7
03136:  CLRF   xFA
03138:  CLRF   xF9
0313A:  MOVF   FC1,W
0313C:  ANDLW  F0
0313E:  MOVWF  FC1
03140:  MOVLW  00
03142:  MOVLB  F
03144:  MOVWF  x38
03146:  MOVWF  x3C
03148:  MOVWF  x39
0314A:  MOVWF  x3A
0314C:  MOVWF  x3B
0314E:  MOVLB  1
03150:  CLRF   x88
03152:  CLRF   F77
03154:  CLRF   F78
03156:  CLRF   F79
03158:  CLRF   2F
0315A:  CLRF   30
0315C:  MOVLB  8
0315E:  CLRF   xEF
03160:  CLRF   xF0
03162:  CLRF   xF1
03164:  CLRF   xF2
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
03166:  MOVF   FD0,W
03168:  ANDLW  0F
0316A:  BTFSS  FD0.4
0316C:  MOVLW  00
0316E:  BSF    FD0.0
03170:  BSF    FD0.1
03172:  BSF    FD0.4
03174:  BSF    FD8.3
03176:  BSF    FD8.4
03178:  MOVWF  xFB
....................  
.................... 	init(); 
0317A:  MOVLB  0
0317C:  GOTO   09A0
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
03180:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
03182:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
03184:  MOVLW  24
03186:  MOVWF  FF6
03188:  MOVLW  08
0318A:  MOVWF  FF7
0318C:  MOVLW  07
0318E:  MOVLB  8
03190:  MOVWF  xFC
03192:  MOVLB  0
03194:  CALL   0B4A
03198:  MOVLW  30
0319A:  MOVWF  FF6
0319C:  MOVLW  08
0319E:  MOVWF  FF7
031A0:  CALL   0B74
031A4:  MOVLW  0D
031A6:  BTFSS  FA4.4
031A8:  BRA    31A6
031AA:  MOVWF  F73
031AC:  MOVLW  0A
031AE:  BTFSS  FA4.4
031B0:  BRA    31AE
031B2:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
031B4:  MOVLW  3A
031B6:  MOVWF  FF6
031B8:  MOVLW  08
031BA:  MOVWF  FF7
031BC:  MOVLW  12
031BE:  MOVLB  8
031C0:  MOVWF  xFC
031C2:  MOVLB  0
031C4:  CALL   0B4A
031C8:  MOVFF  8FB,8FC
031CC:  MOVLW  1B
031CE:  MOVLB  8
031D0:  MOVWF  xFD
031D2:  MOVLB  0
031D4:  GOTO   0BC2
031D8:  MOVLW  20
031DA:  BTFSS  FA4.4
031DC:  BRA    31DA
031DE:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
031E0:  MOVLB  8
031E2:  MOVF   xFB,W
031E4:  XORLW  07
031E6:  MOVLB  0
031E8:  BZ    3204
031EA:  XORLW  0C
031EC:  BZ    3212
031EE:  XORLW  04
031F0:  BZ    3220
031F2:  XORLW  03
031F4:  BZ    322E
031F6:  XORLW  02
031F8:  BZ    323C
031FA:  XORLW  0D
031FC:  BZ    324A
031FE:  XORLW  03
03200:  BZ    3258
03202:  BRA    3266
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
03204:  MOVLW  50
03206:  MOVWF  FF6
03208:  MOVLW  08
0320A:  MOVWF  FF7
0320C:  CALL   0B74
03210:  BRA    3272
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
03212:  MOVLW  5C
03214:  MOVWF  FF6
03216:  MOVLW  08
03218:  MOVWF  FF7
0321A:  CALL   0B74
0321E:  BRA    3272
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
03220:  MOVLW  6C
03222:  MOVWF  FF6
03224:  MOVLW  08
03226:  MOVWF  FF7
03228:  CALL   0B74
0322C:  BRA    3272
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
0322E:  MOVLW  7A
03230:  MOVWF  FF6
03232:  MOVLW  08
03234:  MOVWF  FF7
03236:  CALL   0B74
0323A:  BRA    3272
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
0323C:  MOVLW  8A
0323E:  MOVWF  FF6
03240:  MOVLW  08
03242:  MOVWF  FF7
03244:  CALL   0B74
03248:  BRA    3272
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
0324A:  MOVLW  9C
0324C:  MOVWF  FF6
0324E:  MOVLW  08
03250:  MOVWF  FF7
03252:  CALL   0B74
03256:  BRA    3272
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
03258:  MOVLW  AC
0325A:  MOVWF  FF6
0325C:  MOVLW  08
0325E:  MOVWF  FF7
03260:  CALL   0B74
03264:  BRA    3272
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
03266:  MOVLW  BE
03268:  MOVWF  FF6
0326A:  MOVLW  08
0326C:  MOVWF  FF7
0326E:  CALL   0B74
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
03272:  MOVLW  C8
03274:  MOVWF  FF6
03276:  MOVLW  08
03278:  MOVWF  FF7
0327A:  CALL   0B74
.................... #endif 
....................  
....................  
.................... 	read_param_file(); 
0327E:  GOTO   0E86
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
03282:  MOVF   36,W
03284:  SUBLW  80
03286:  BC    328C
.................... 		write_default_param_file(); 
03288:  CALL   0DDA
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
0328C:  BSF    FAB.7
0328E:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	modbus_init(); 
03290:  GOTO   0EEA
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
03294:  MOVLB  8
03296:  CLRF   xFB
03298:  MOVF   xFB,W
0329A:  SUBLW  1D
0329C:  BNC   32AA
.................... 		adc_update(); 
0329E:  MOVLB  0
032A0:  CALL   0FC4
.................... 	} 
032A4:  MOVLB  8
032A6:  INCF   xFB,F
032A8:  BRA    3298
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
032AA:  MOVFF  44,1DB
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
032AE:  BTFSS  F72.1
032B0:  BRA    32AE
.................... 	output_low(RS485_DE); 
032B2:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
032B4:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
032B6:  MOVLW  CC
032B8:  MOVWF  FF6
032BA:  MOVLW  08
032BC:  MOVWF  FF7
032BE:  MOVLW  07
032C0:  MOVWF  xFC
032C2:  MOVLB  0
032C4:  GOTO   106C
032C8:  MOVLW  D8
032CA:  MOVWF  FF6
032CC:  MOVLW  08
032CE:  MOVWF  FF7
032D0:  GOTO   1098
032D4:  MOVLW  0D
032D6:  BTFSS  F9E.4
032D8:  BRA    32D6
032DA:  MOVWF  FAD
032DC:  MOVLW  0A
032DE:  BTFSS  F9E.4
032E0:  BRA    32DE
032E2:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
032E4:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
032E6:  MOVLB  1
032E8:  BTFSS  xFB.2
032EA:  BRA    32F4
.................... 			periodic_millisecond(); 
032EC:  MOVLB  0
032EE:  GOTO   10BC
032F2:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
032F4:  BTFSS  xFB.0
032F6:  BRA    3300
.................... 			timers.now_adc_sample=0; 
032F8:  BCF    xFB.0
.................... 			adc_update(); 
032FA:  MOVLB  0
032FC:  CALL   0FC4
.................... 		} 
....................  
.................... 		modbus_process(); 
03300:  MOVLB  0
03302:  BRA    2B2A
....................  
....................  
.................... 		/* buffered modbus transmit */ 
....................  
.................... 		/* start transmitting */ 
.................... 		if ( timers.now_rda_tx_ready ) { 
03304:  MOVLB  4
03306:  BTFSS  x03.0
03308:  BRA    331C
.................... 			timers.now_rda_tx_ready=0; 
0330A:  BCF    x03.0
....................  
.................... //			output_high(_PIC_TO_PI); 
....................  
.................... 			RCV_OFF(); 
0330C:  BCF    F9D.5
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
0330E:  CLRWDT
03310:  MOVLW  3C
03312:  MOVWF  00
03314:  DECFSZ 00,F
03316:  BRA    3314
03318:  NOP   
....................  
.................... 			/* enable transmit buffer empty interrupt. It will feed itself */ 
.................... 			enable_interrupts(INT_TBE); 
0331A:  BSF    F9D.4
.................... 		} 
....................  
.................... 		/* done transmitting */ 
.................... 		if ( timers.now_rda_tx_done ) { 
0331C:  BTFSS  x03.1
0331E:  BRA    3334
.................... 			timers.now_rda_tx_done=0; 
03320:  BCF    x03.1
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
03322:  CLRWDT
03324:  MOVLW  3C
03326:  MOVWF  00
03328:  DECFSZ 00,F
0332A:  BRA    3328
0332C:  NOP   
....................    			RCV_ON(); 
0332E:  MOVLB  0
03330:  CALL   0EDE
....................  
.................... //			output_low(_PIC_TO_PI); 
.................... 		} 
....................  
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
03334:  MOVLB  1
03336:  BTFSS  xFE.0
03338:  BRA    3342
.................... 			timers.now_parse_rda2=0; 
0333A:  BCF    xFE.0
.................... 			rs485_to_host(); 
0333C:  MOVLB  0
0333E:  BRA    2F78
03340:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
03342:  MOVLB  0
03344:  BRA    32E4
.................... } 
03346:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
