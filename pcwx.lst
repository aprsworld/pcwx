CCS PCH C Compiler, Version 4.135, 4375               31-Oct-15 16:51

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 9210 bytes (14%)
                         Largest free fragment is 56322
               RAM used: 711 (18%) at main() level
                         745 (19%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   217C
*
00008:  GOTO   00CA
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03A4
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   065E
0007C:  MOVFF  0E,00
00080:  MOVFF  0F,01
00084:  MOVFF  10,02
00088:  MOVFF  11,03
0008C:  MOVFF  0C,FE9
00090:  MOVFF  07,FEA
00094:  BSF    07.7
00096:  MOVFF  08,FE1
0009A:  MOVFF  09,FE2
0009E:  MOVFF  0A,FD9
000A2:  MOVFF  0B,FDA
000A6:  MOVFF  12,FF3
000AA:  MOVFF  13,FF4
000AE:  MOVFF  14,FFA
000B2:  MOVFF  15,FF5
000B6:  MOVFF  16,FF6
000BA:  MOVFF  17,FF7
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
000CA:  MOVWF  1A
000CC:  MOVFF  FD8,1B
000D0:  MOVFF  FE0,1C
000D4:  MOVLB  0
000D6:  MOVFF  FE9,22
000DA:  MOVFF  FEA,1D
000DE:  MOVFF  FE1,1E
000E2:  MOVFF  FE2,1F
000E6:  MOVFF  FD9,20
000EA:  MOVFF  FDA,21
000EE:  MOVFF  FF3,28
000F2:  MOVFF  FF4,29
000F6:  MOVFF  FFA,2A
000FA:  MOVFF  FF5,2B
000FE:  MOVFF  FF6,2C
00102:  MOVFF  FF7,2D
00106:  MOVFF  00,24
0010A:  MOVFF  01,25
0010E:  MOVFF  02,26
00112:  MOVFF  03,27
00116:  BTFSS  F9D.1
00118:  GOTO   0122
0011C:  BTFSC  F9E.1
0011E:  GOTO   03D6
00122:  MOVFF  24,00
00126:  MOVFF  25,01
0012A:  MOVFF  26,02
0012E:  MOVFF  27,03
00132:  MOVFF  22,FE9
00136:  MOVFF  1D,FEA
0013A:  BSF    1D.7
0013C:  MOVFF  1E,FE1
00140:  MOVFF  1F,FE2
00144:  MOVFF  20,FD9
00148:  MOVFF  21,FDA
0014C:  MOVFF  28,FF3
00150:  MOVFF  29,FF4
00154:  MOVFF  2A,FFA
00158:  MOVFF  2B,FF5
0015C:  MOVFF  2C,FF6
00160:  MOVFF  2D,FF7
00164:  MOVF   1A,W
00166:  MOVFF  1C,FE0
0016A:  MOVFF  1B,FD8
0016E:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=WEATHER_X_BAUD,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00612:  BTFSS  F9E.5
00614:  BRA    0612
00616:  MOVFF  FAB,35
0061A:  MOVFF  FAE,01
0061E:  BTFSS  35.1
00620:  BRA    0626
00622:  BCF    FAB.4
00624:  BSF    FAB.4
00626:  RETURN 0
*
01088:  BTFSS  F9E.4
0108A:  BRA    1088
0108C:  MOVWF  FAD
0108E:  GOTO   109A (RETURN)
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=DEBUG, baud=9600,errors)	 
*
00628:  BTFSS  FA4.4
0062A:  BRA    0628
0062C:  MOVWF  F73
0062E:  GOTO   0672 (RETURN)
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
.................... } struct_time_keep; 
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00D42:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00CA2:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00CA4:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00CA6:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00CA8:  MOVLB  2
00CAA:  MOVF   xC9,F
00CAC:  BNZ   0CB4
.................... 		c=0b00011; 
00CAE:  MOVLW  03
00CB0:  MOVWF  xCD
.................... 	else if ( 1 == ch )  
00CB2:  BRA    0CFE
00CB4:  DECFSZ xC9,W
00CB6:  BRA    0CBE
.................... 		c=0b10011; 
00CB8:  MOVLW  13
00CBA:  MOVWF  xCD
.................... 	else if ( 2 == ch )  
00CBC:  BRA    0CFE
00CBE:  MOVF   xC9,W
00CC0:  SUBLW  02
00CC2:  BNZ   0CCA
.................... 		c=0b01011; 
00CC4:  MOVLW  0B
00CC6:  MOVWF  xCD
.................... 	else if ( 3 == ch )  
00CC8:  BRA    0CFE
00CCA:  MOVF   xC9,W
00CCC:  SUBLW  03
00CCE:  BNZ   0CD6
.................... 		c=0b11011; 
00CD0:  MOVLW  1B
00CD2:  MOVWF  xCD
.................... 	else if ( 4 == ch ) 
00CD4:  BRA    0CFE
00CD6:  MOVF   xC9,W
00CD8:  SUBLW  04
00CDA:  BNZ   0CE2
.................... 		c=0b00111; 
00CDC:  MOVLW  07
00CDE:  MOVWF  xCD
.................... 	else if ( 5 == ch )  
00CE0:  BRA    0CFE
00CE2:  MOVF   xC9,W
00CE4:  SUBLW  05
00CE6:  BNZ   0CEE
.................... 		c=0b10111; 
00CE8:  MOVLW  17
00CEA:  MOVWF  xCD
.................... 	else if ( 6 == ch ) 
00CEC:  BRA    0CFE
00CEE:  MOVF   xC9,W
00CF0:  SUBLW  06
00CF2:  BNZ   0CFA
.................... 		c=0b01111; 
00CF4:  MOVLW  0F
00CF6:  MOVWF  xCD
.................... 	else 
00CF8:  BRA    0CFE
.................... 		c=0b11111; 
00CFA:  MOVLW  1F
00CFC:  MOVWF  xCD
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00CFE:  CLRF   xCC
00D00:  MOVF   xCC,W
00D02:  SUBLW  04
00D04:  BNC   0D1C
.................... 		output_low(MCP3208_CLK); 
00D06:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00D08:  BTFSC  xCD.0
00D0A:  BRA    0D10
00D0C:  BCF    F8B.5
00D0E:  BRA    0D12
00D10:  BSF    F8B.5
.................... 		c=c>>1; 
00D12:  BCF    FD8.0
00D14:  RRCF   xCD,F
.................... 		output_high(MCP3208_CLK); 
00D16:  BSF    F8B.3
.................... 	} 
00D18:  INCF   xCC,F
00D1A:  BRA    0D00
....................  
....................  
.................... 	value=0; 
00D1C:  CLRF   xCB
00D1E:  CLRF   xCA
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00D20:  CLRF   xCC
00D22:  MOVF   xCC,W
00D24:  SUBLW  0D
00D26:  BNC   0D3E
.................... 		output_low(MCP3208_CLK); 
00D28:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00D2A:  BTFSC  F82.4
00D2C:  BRA    0D32
00D2E:  BCF    FD8.0
00D30:  BRA    0D34
00D32:  BSF    FD8.0
00D34:  RLCF   xCA,F
00D36:  RLCF   xCB,F
.................... 		output_high(MCP3208_CLK); 
00D38:  BSF    F8B.3
.................... 	} 
00D3A:  INCF   xCC,F
00D3C:  BRA    0D22
....................  
.................... 	bit_clear(value,13); 
00D3E:  BCF    xCB.5
.................... 	bit_clear(value,12); 
00D40:  BCF    xCB.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00D44:  MOVFF  2CA,01
00D48:  MOVFF  2CB,02
.................... } 
00D4C:  MOVLB  0
00D4E:  GOTO   0DBE (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00DF8:  MOVLB  2
00DFA:  CLRF   xE1
00DFC:  MOVFF  2DA,2E0
00E00:  CLRF   xE3
00E02:  MOVLW  20
00E04:  MOVWF  xE2
00E06:  MOVLB  0
00E08:  RCALL  0824
00E0A:  MOVFF  02,03
00E0E:  MOVF   01,W
00E10:  ADDLW  81
00E12:  MOVWF  01
00E14:  MOVLW  00
00E16:  ADDWFC 03,F
00E18:  MOVFF  01,2DE
00E1C:  MOVLB  2
00E1E:  MOVFF  03,2DF
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00E22:  CLRF   xDC
00E24:  CLRF   xDB
.................... 	for( i = 0; i < 16 ; i++ ) { 
00E26:  CLRF   xDD
00E28:  MOVF   xDD,W
00E2A:  SUBLW  0F
00E2C:  BNC   0E50
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00E2E:  BCF    FD8.0
00E30:  RLCF   xDD,W
00E32:  CLRF   03
00E34:  ADDWF  xDE,W
00E36:  MOVWF  FE9
00E38:  MOVF   xDF,W
00E3A:  ADDWFC 03,W
00E3C:  MOVWF  FEA
00E3E:  MOVFF  FEC,03
00E42:  MOVF   FED,F
00E44:  MOVF   FEF,W
00E46:  ADDWF  xDB,F
00E48:  MOVF   03,W
00E4A:  ADDWFC xDC,F
.................... 	} 
00E4C:  INCF   xDD,F
00E4E:  BRA    0E28
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00E50:  MOVLW  08
00E52:  ADDWF  xDB,W
00E54:  MOVWF  xE0
00E56:  MOVLW  00
00E58:  ADDWFC xDC,W
00E5A:  MOVWF  xE1
00E5C:  RRCF   xE1,W
00E5E:  MOVWF  03
00E60:  RRCF   xE0,W
00E62:  MOVWF  02
00E64:  RRCF   03,F
00E66:  RRCF   02,F
00E68:  RRCF   03,F
00E6A:  RRCF   02,F
00E6C:  RRCF   03,F
00E6E:  RRCF   02,F
00E70:  MOVLW  0F
00E72:  ANDWF  03,F
00E74:  MOVFF  02,01
00E78:  MOVFF  03,02
.................... } 
00E7C:  MOVLB  0
00E7E:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00D52:  MOVLB  1
00D54:  INCF   x81,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00D56:  MOVF   x81,W
00D58:  SUBLW  0F
00D5A:  BC    0D5E
.................... 		current.adc_buffer_index=0; 
00D5C:  CLRF   x81
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00D5E:  MOVLB  2
00D60:  CLRF   xC6
00D62:  MOVF   xC6,W
00D64:  SUBLW  07
00D66:  BNC   0DF4
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00D68:  CLRF   xE1
00D6A:  MOVFF  2C6,2E0
00D6E:  CLRF   xE3
00D70:  MOVLW  20
00D72:  MOVWF  xE2
00D74:  MOVLB  0
00D76:  RCALL  0824
00D78:  MOVFF  02,03
00D7C:  MOVF   01,W
00D7E:  ADDLW  34
00D80:  MOVLB  2
00D82:  MOVWF  xC7
00D84:  MOVLW  00
00D86:  ADDWFC 02,W
00D88:  MOVWF  xC8
00D8A:  CLRF   03
00D8C:  MOVLB  1
00D8E:  MOVFF  181,02
00D92:  BCF    FD8.0
00D94:  RLCF   02,F
00D96:  RLCF   03,F
00D98:  MOVF   02,W
00D9A:  MOVLB  2
00D9C:  ADDWF  xC7,W
00D9E:  MOVWF  01
00DA0:  MOVF   xC8,W
00DA2:  ADDWFC 03,F
00DA4:  MOVF   01,W
00DA6:  ADDLW  4D
00DA8:  MOVWF  01
00DAA:  MOVLW  00
00DAC:  ADDWFC 03,F
00DAE:  MOVFF  01,2C7
00DB2:  MOVFF  03,2C8
00DB6:  MOVFF  2C6,2C9
00DBA:  MOVLB  0
00DBC:  BRA    0CA2
00DBE:  MOVFF  2C8,FEA
00DC2:  MOVFF  2C7,FE9
00DC6:  MOVFF  02,FEC
00DCA:  MOVF   FED,F
00DCC:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00DD0:  CLRF   03
00DD2:  MOVLB  2
00DD4:  MOVFF  2C6,02
00DD8:  BCF    FD8.0
00DDA:  RLCF   02,F
00DDC:  RLCF   03,F
00DDE:  MOVF   02,W
00DE0:  ADDLW  71
00DE2:  MOVWF  FE9
00DE4:  MOVLW  00
00DE6:  ADDWFC 03,W
00DE8:  MOVWF  FEA
00DEA:  CLRF   FEC
00DEC:  MOVF   FED,F
00DEE:  CLRF   FEF
....................  
.................... 	} 
00DF0:  INCF   xC6,F
00DF2:  BRA    0D62
.................... } 
00DF4:  MOVLB  0
00DF6:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00AEC:  MOVF   xE1,W
00AEE:  XORWF  xE2,W
00AF0:  MOVWF  01
*
00B3E:  MOVF   xE1,W
00B40:  XORWF  xE2,W
00B42:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00A76:  MOVLB  2
00A78:  CLRF   xCF
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00A7A:  MOVFF  2CE,03
00A7E:  MOVF   xCD,W
00A80:  BTFSC  FD8.2
00A82:  DECF   xCE,F
00A84:  DECF   xCD,F
00A86:  MOVWF  xD0
00A88:  MOVFF  03,2D1
00A8C:  MOVF   xD0,F
00A8E:  BNZ   0A94
00A90:  MOVF   xD1,F
00A92:  BZ    0AFE
.................... 		*data = read_eeprom( address++ ); 
00A94:  MOVFF  2CC,03
00A98:  MOVF   xCB,W
00A9A:  MOVWF  FE9
00A9C:  MOVFF  03,FEA
00AA0:  MOVF   xCA,W
00AA2:  MOVWF  03
00AA4:  MOVF   xC9,W
00AA6:  INCF   xC9,F
00AA8:  BTFSC  FD8.2
00AAA:  INCF   xCA,F
00AAC:  MOVWF  xD2
00AAE:  MOVFF  03,2D3
00AB2:  MOVFF  FF2,2D4
00AB6:  BCF    FF2.6
00AB8:  BCF    FF2.7
00ABA:  MOVFF  2D3,FAA
00ABE:  MOVFF  2D2,FA9
00AC2:  BCF    FA6.6
00AC4:  BCF    FA6.7
00AC6:  BSF    FA6.0
00AC8:  MOVF   FA8,W
00ACA:  BTFSC  xD4.6
00ACC:  BSF    FF2.6
00ACE:  BTFSC  xD4.7
00AD0:  BSF    FF2.7
00AD2:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00AD4:  MOVFF  2CC,03
00AD8:  MOVF   xCB,W
00ADA:  MOVWF  FE9
00ADC:  MOVFF  03,FEA
00AE0:  MOVFF  FEF,2D0
00AE4:  MOVFF  2CF,2E1
00AE8:  MOVFF  2D0,2E2
*
00AF2:  MOVFF  01,2CF
.................... 		data++; 
00AF6:  INCF   xCB,F
00AF8:  BTFSC  FD8.2
00AFA:  INCF   xCC,F
.................... 	} 
00AFC:  BRA    0A7A
.................... 	return crc; 
00AFE:  MOVFF  2CF,01
.................... } 
00B02:  MOVLB  0
00B04:  GOTO   0C56 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00B08:  MOVLB  2
00B0A:  CLRF   xDF
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B0C:  MOVFF  2DE,03
00B10:  MOVF   xDD,W
00B12:  BTFSC  FD8.2
00B14:  DECF   xDE,F
00B16:  DECF   xDD,F
00B18:  MOVWF  xE0
00B1A:  MOVFF  03,2E1
00B1E:  MOVF   xE0,F
00B20:  BNZ   0B26
00B22:  MOVF   xE1,F
00B24:  BZ    0BA4
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00B26:  MOVFF  2DC,03
00B2A:  MOVF   xDB,W
00B2C:  MOVWF  FE9
00B2E:  MOVFF  03,FEA
00B32:  MOVFF  FEF,2E0
00B36:  MOVFF  2DF,2E1
00B3A:  MOVFF  2E0,2E2
*
00B44:  MOVFF  01,2DF
.................... 		write_eeprom( address++, *data++ ); 
00B48:  MOVF   xDA,W
00B4A:  MOVWF  03
00B4C:  MOVF   xD9,W
00B4E:  INCF   xD9,F
00B50:  BTFSC  FD8.2
00B52:  INCF   xDA,F
00B54:  MOVWF  xE0
00B56:  MOVFF  03,2E1
00B5A:  MOVF   xDC,W
00B5C:  MOVWF  03
00B5E:  MOVF   xDB,W
00B60:  INCF   xDB,F
00B62:  BTFSC  FD8.2
00B64:  INCF   xDC,F
00B66:  MOVWF  FE9
00B68:  MOVFF  03,FEA
00B6C:  MOVFF  FEF,2E2
00B70:  MOVFF  2E1,FAA
00B74:  MOVFF  2E0,FA9
00B78:  MOVFF  2E2,FA8
00B7C:  BCF    FA6.6
00B7E:  BCF    FA6.7
00B80:  BSF    FA6.2
00B82:  MOVF   FF2,W
00B84:  MOVWF  00
00B86:  BCF    FF2.6
00B88:  BCF    FF2.7
00B8A:  MOVLB  F
00B8C:  MOVLW  55
00B8E:  MOVWF  FA7
00B90:  MOVLW  AA
00B92:  MOVWF  FA7
00B94:  BSF    FA6.1
00B96:  BTFSC  FA6.1
00B98:  BRA    0B96
00B9A:  BCF    FA6.2
00B9C:  MOVF   00,W
00B9E:  IORWF  FF2,F
.................... 	} 
00BA0:  MOVLB  2
00BA2:  BRA    0B0C
....................  
.................... 	return crc; 
00BA4:  MOVFF  2DF,01
.................... } 
00BA8:  MOVLB  0
00BAA:  GOTO   0BCE (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00BAE:  MOVLB  2
00BB0:  CLRF   xD8
00BB2:  MOVLW  36
00BB4:  MOVWF  xD7
00BB6:  CLRF   xDA
00BB8:  MOVLW  02
00BBA:  MOVWF  xD9
00BBC:  MOVFF  2D8,2DC
00BC0:  MOVFF  2D7,2DB
00BC4:  CLRF   xDE
00BC6:  MOVLW  17
00BC8:  MOVWF  xDD
00BCA:  MOVLB  0
00BCC:  BRA    0B08
00BCE:  MOVFF  01,2D6
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00BD2:  CLRF   FAA
00BD4:  CLRF   FA9
00BD6:  MOVFF  2D6,FA8
00BDA:  BCF    FA6.6
00BDC:  BCF    FA6.7
00BDE:  BSF    FA6.2
00BE0:  MOVF   FF2,W
00BE2:  MOVWF  00
00BE4:  BCF    FF2.6
00BE6:  BCF    FF2.7
00BE8:  MOVLB  F
00BEA:  MOVLW  55
00BEC:  MOVWF  FA7
00BEE:  MOVLW  AA
00BF0:  MOVWF  FA7
00BF2:  BSF    FA6.1
00BF4:  BTFSC  FA6.1
00BF6:  BRA    0BF4
00BF8:  BCF    FA6.2
00BFA:  MOVF   00,W
00BFC:  IORWF  FF2,F
.................... } 
00BFE:  MOVLB  0
00C00:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00C02:  MOVLW  96
00C04:  MOVLB  1
00C06:  MOVWF  xAA
....................  
.................... //	config.modbus_address=38; 
.................... 	config.modbus_address=128; /* use any address */ 
00C08:  MOVLW  80
00C0A:  MOVWF  36
....................  
.................... 	config.serial_prefix='P'; 
00C0C:  MOVLW  50
00C0E:  MOVWF  38
.................... 	config.serial_number=9876; 
00C10:  MOVLW  26
00C12:  MOVWF  3A
00C14:  MOVLW  94
00C16:  MOVWF  39
....................  
.................... 	config.adc_sample_ticks=20; 
00C18:  CLRF   3C
00C1A:  MOVLW  14
00C1C:  MOVWF  3B
.................... 	config.allow_bootload_request=0; 
00C1E:  CLRF   3D
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00C20:  MOVLW  02
00C22:  MOVWF  3F
00C24:  MOVLW  76
00C26:  MOVWF  3E
.................... 	config.pi_offtime_seconds=2; 
00C28:  CLRF   41
00C2A:  MOVLW  02
00C2C:  MOVWF  40
.................... 	config.power_startup=0; 
00C2E:  CLRF   42
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00C30:  MOVLB  0
00C32:  RCALL  0BAE
....................  
.................... } 
00C34:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00C36:  MOVLB  2
00C38:  CLRF   xC8
00C3A:  MOVLW  36
00C3C:  MOVWF  xC7
00C3E:  CLRF   xCA
00C40:  MOVLW  02
00C42:  MOVWF  xC9
00C44:  MOVFF  2C8,2CC
00C48:  MOVFF  2C7,2CB
00C4C:  CLRF   xCE
00C4E:  MOVLW  17
00C50:  MOVWF  xCD
00C52:  MOVLB  0
00C54:  BRA    0A76
00C56:  MOVFF  01,2C6
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00C5A:  MOVFF  FF2,2C7
00C5E:  BCF    FF2.6
00C60:  BCF    FF2.7
00C62:  CLRF   FAA
00C64:  CLRF   FA9
00C66:  BCF    FA6.6
00C68:  BCF    FA6.7
00C6A:  BSF    FA6.0
00C6C:  MOVF   FA8,W
00C6E:  MOVLB  2
00C70:  BTFSC  xC7.6
00C72:  BSF    FF2.6
00C74:  BTFSC  xC7.7
00C76:  BSF    FF2.7
00C78:  SUBWF  xC6,W
00C7A:  BZ    0C82
.................... 		write_default_param_file(); 
00C7C:  MOVLB  0
00C7E:  RCALL  0C02
00C80:  MOVLB  2
.................... 	} 
.................... } 
00C82:  MOVLB  0
00C84:  GOTO   232A (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
010EC:  BTFSS  FAC.1
010EE:  BRA    10EC
.................... } 
010F0:  GOTO   110A (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(MODBUS_SERIAL) ) { 
*
00C88:  BTFSS  F9E.5
00C8A:  BRA    0C90
.................... 		fgetc(MODBUS_SERIAL); 
00C8C:  RCALL  0612
.................... 	} 
00C8E:  BRA    0C88
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00C90:  BSF    F9D.5
.................... } 
00C92:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00C94:  RCALL  0C88
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00C96:  MOVLW  C6
00C98:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00C9A:  MOVLW  C0
00C9C:  IORWF  FF2,F
.................... } 
00C9E:  GOTO   236C (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
00390:  BCF    FF2.5
.................... 	if (enable) { 
00392:  MOVLB  2
00394:  MOVF   xE6,F
00396:  BZ    03A0
.................... 		set_timer0(0); 
00398:  CLRF   FD7
0039A:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
0039C:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
0039E:  BSF    FF2.5
.................... 	} 
.................... } 
003A0:  MOVLB  0
003A2:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003A4:  MOVLB  1
003A6:  MOVF   xB1,W
003A8:  SUBLW  02
003AA:  BNZ   03C0
003AC:  MOVF   xB2,F
003AE:  BNZ   03C0
003B0:  MOVF   xB3,F
003B2:  BNZ   03C0
003B4:  BTFSC  xB0.0
003B6:  BRA    03C0
....................    { 
....................       modbus_rx.len-=2; 
003B8:  MOVLW  02
003BA:  SUBWF  xB5,F
....................       modbus_serial_new=TRUE; 
003BC:  BSF    xB0.0
....................    } 
....................    else 
003BE:  BRA    03C2
....................       modbus_serial_new=FALSE; 
003C0:  BCF    xB0.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003C2:  SETF   xB3
003C4:  SETF   xB2
....................    modbus_serial_state=MODBUS_GETADDY; 
003C6:  CLRF   xB1
....................    modbus_enable_timeout(FALSE); 
003C8:  MOVLB  2
003CA:  CLRF   xE6
003CC:  MOVLB  0
003CE:  RCALL  0390
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003D0:  BCF    FF2.2
003D2:  GOTO   007C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00632:  MOVLB  1
00634:  MOVF   xB3,W
00636:  MOVLB  2
00638:  XORWF  xE6,W
0063A:  MOVWF  xE7
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0063C:  CLRF   03
0063E:  MOVF   xE7,W
00640:  MOVLB  0
00642:  RCALL  0170
00644:  MOVWF  01
00646:  MOVLB  1
00648:  MOVF   xB2,W
0064A:  XORWF  01,W
0064C:  MOVWF  xB3
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0064E:  CLRF   03
00650:  MOVLB  2
00652:  MOVF   xE7,W
00654:  MOVLB  0
00656:  RCALL  0280
00658:  MOVFF  FE8,1B2
.................... } 
0065C:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, MODBUS_SERIAL); 
*
01092:  MOVLB  2
01094:  MOVF   xD8,W
01096:  MOVLB  0
01098:  BRA    1088
0109A:  CLRF   19
0109C:  BTFSC  FF2.6
0109E:  BSF    19.6
010A0:  BCF    FF2.6
010A2:  BTFSC  FF2.7
010A4:  BSF    19.7
010A6:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
010A8:  MOVFF  2D8,2E6
010AC:  CALL   0632
010B0:  BTFSC  19.6
010B2:  BSF    FF2.6
010B4:  BTFSC  19.7
010B6:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
010B8:  CLRWDT
010BA:  MOVLW  08
010BC:  MOVWF  00
010BE:  DECFSZ 00,F
010C0:  BRA    10BE
010C2:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
010C4:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
010C6:  MOVLB  1
010C8:  SETF   xB3
010CA:  SETF   xB2
....................    modbus_serial_new=FALSE; 
010CC:  BCF    xB0.0
....................  
....................    RCV_OFF(); 
010CE:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
010D0:  CLRWDT
010D2:  MOVLW  1E
010D4:  MOVWF  00
010D6:  DECFSZ 00,F
010D8:  BRA    10D6
010DA:  NOP   
....................  
....................    modbus_serial_putc(to); 
010DC:  MOVFF  2D6,2D8
010E0:  MOVLB  0
010E2:  RCALL  1092
....................    modbus_serial_putc(func); 
010E4:  MOVFF  2D7,2D8
010E8:  RCALL  1092
.................... } 
010EA:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
010F4:  MOVFF  1B3,2D7
....................    crc_low=modbus_serial_crc.b[0]; 
010F8:  MOVFF  1B2,2D6
....................  
....................    modbus_serial_putc(crc_high); 
010FC:  MOVFF  2D7,2D8
01100:  RCALL  1092
....................    modbus_serial_putc(crc_low); 
01102:  MOVFF  2D6,2D8
01106:  RCALL  1092
....................  
....................    WAIT_FOR_HW_BUFFER(); 
01108:  BRA    10EC
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
0110A:  CLRWDT
0110C:  MOVLW  1E
0110E:  MOVWF  00
01110:  DECFSZ 00,F
01112:  BRA    1110
01114:  NOP   
....................  
....................  
....................    RCV_ON(); 
01116:  RCALL  0C88
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
01118:  MOVLB  1
0111A:  SETF   xB3
0111C:  SETF   xB2
.................... } 
0111E:  MOVLB  0
01120:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00FE0:  MOVLB  1
00FE2:  BTFSC  xB0.0
00FE4:  BRA    0FEE
....................       return FALSE; 
00FE6:  MOVLW  00
00FE8:  MOVWF  01
00FEA:  BRA    1000
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00FEC:  BRA    0FFA
00FEE:  BTFSS  xB6.7
00FF0:  BRA    0FFA
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00FF2:  MOVFF  1B8,1B7
....................       modbus_rx.len = 1; 
00FF6:  MOVLW  01
00FF8:  MOVWF  xB5
....................    } 
....................    modbus_serial_new=FALSE; 
00FFA:  BCF    xB0.0
....................    return TRUE; 
00FFC:  MOVLW  01
00FFE:  MOVWF  01
.................... } 
01000:  MOVLB  0
01002:  GOTO   1F4A (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01EB6:  MOVFF  2CE,2D6
01EBA:  MOVLW  06
01EBC:  MOVLB  2
01EBE:  MOVWF  xD7
01EC0:  MOVLB  0
01EC2:  CALL   10C6
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01EC6:  MOVFF  2D0,2D3
01ECA:  MOVFF  2D0,2D8
01ECE:  CALL   1092
....................    modbus_serial_putc(make8(reg_address,0)); 
01ED2:  MOVFF  2CF,2D3
01ED6:  MOVFF  2CF,2D8
01EDA:  CALL   1092
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01EDE:  MOVFF  2D2,2D3
01EE2:  MOVFF  2D2,2D8
01EE6:  CALL   1092
....................    modbus_serial_putc(make8(reg_value,0)); 
01EEA:  MOVFF  2D1,2D3
01EEE:  MOVFF  2D1,2D8
01EF2:  CALL   1092
....................  
....................    modbus_serial_send_stop(); 
01EF6:  CALL   10F4
.................... } 
01EFA:  GOTO   2076 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01EFE:  MOVFF  2CC,2D6
01F02:  MOVLW  10
01F04:  MOVLB  2
01F06:  MOVWF  xD7
01F08:  MOVLB  0
01F0A:  CALL   10C6
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01F0E:  MOVFF  2CE,2D1
01F12:  MOVFF  2CE,2D8
01F16:  CALL   1092
....................    modbus_serial_putc(make8(start_address,0)); 
01F1A:  MOVFF  2CD,2D1
01F1E:  MOVFF  2CD,2D8
01F22:  CALL   1092
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01F26:  MOVFF  2D0,2D1
01F2A:  MOVFF  2D0,2D8
01F2E:  CALL   1092
....................    modbus_serial_putc(make8(quantity,0)); 
01F32:  MOVFF  2CF,2D1
01F36:  MOVFF  2CF,2D8
01F3A:  CALL   1092
....................  
....................    modbus_serial_send_stop(); 
01F3E:  CALL   10F4
.................... } 
01F42:  GOTO   2138 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01122:  MOVLB  2
01124:  MOVF   xCD,W
01126:  IORLW  80
01128:  MOVWF  xD0
0112A:  MOVFF  2CE,2D1
0112E:  MOVFF  2CC,2D6
01132:  MOVWF  xD7
01134:  MOVLB  0
01136:  RCALL  10C6
....................    modbus_serial_putc(error); 
01138:  MOVFF  2CF,2D8
0113C:  RCALL  1092
....................    modbus_serial_send_stop(); 
0113E:  RCALL  10F4
.................... } 
01140:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1011 
....................  
.................... #define MIN_EE_REGISTER      2000 
.................... #define MAX_EE_REGISTER      MIN_EE_REGISTER + 512 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
01208:  MOVLB  1
0120A:  CLRF   x83
0120C:  CLRF   x82
.................... 	current.modbus_other_packets=0; 
0120E:  CLRF   x85
01210:  CLRF   x84
.................... 	current.modbus_last_error=0; 
01212:  CLRF   x87
01214:  CLRF   x86
.................... } 
01216:  MOVLB  0
01218:  GOTO   1B2C (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
011A4:  BCF    FF2.6
011A6:  BCF    FF2.7
011A8:  BTFSC  FF2.7
011AA:  BRA    11A6
....................  
.................... 	current.pulse_count[0]=0; 
011AC:  CLRF   x60
011AE:  CLRF   5F
.................... 	current.pulse_count[1]=0; 
011B0:  CLRF   x62
011B2:  CLRF   x61
.................... 	current.pulse_count[2]=0; 
011B4:  CLRF   x64
011B6:  CLRF   x63
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
011B8:  SETF   54
011BA:  SETF   53
.................... 	current.pulse_min_period[1]=65535; 
011BC:  SETF   56
011BE:  SETF   55
.................... 	current.pulse_min_period[2]=65535; 
011C0:  SETF   58
011C2:  SETF   57
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
011C4:  CLRF   5A
011C6:  CLRF   59
.................... 	current.pulse_max_period[1]=0; 
011C8:  CLRF   5C
011CA:  CLRF   5B
.................... 	current.pulse_max_period[2]=0; 
011CC:  CLRF   5E
011CE:  CLRF   5D
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
011D0:  MOVLB  1
011D2:  CLRF   x8D
011D4:  CLRF   x8C
....................  
.................... 	enable_interrupts(GLOBAL); 
011D6:  MOVLW  C0
011D8:  IORWF  FF2,F
.................... } 
011DA:  MOVLB  0
011DC:  GOTO   1ADC (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
011E0:  BCF    FF2.6
011E2:  BCF    FF2.7
011E4:  BTFSC  FF2.7
011E6:  BRA    11E2
.................... 	current.pulse_sum[0]=0; 
011E8:  CLRF   x68
011EA:  CLRF   x67
011EC:  CLRF   x66
011EE:  CLRF   x65
.................... 	current.pulse_sum[1]=0; 
011F0:  CLRF   x6C
011F2:  CLRF   x6B
011F4:  CLRF   x6A
011F6:  CLRF   x69
.................... 	current.pulse_sum[2]=0; 
011F8:  CLRF   x70
011FA:  CLRF   x6F
011FC:  CLRF   x6E
011FE:  CLRF   x6D
.................... 	enable_interrupts(GLOBAL); 
01200:  MOVLW  C0
01202:  IORWF  FF2,F
.................... } 
01204:  GOTO   1AEC (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01142:  BCF    FF2.6
01144:  BCF    FF2.7
01146:  BTFSC  FF2.7
01148:  BRA    1144
.................... 	l=current.pulse_sum[ch]; 
0114A:  MOVLB  2
0114C:  CLRF   xE1
0114E:  MOVFF  2DA,2E0
01152:  CLRF   xE3
01154:  MOVLW  04
01156:  MOVWF  xE2
01158:  MOVLB  0
0115A:  CALL   0824
0115E:  MOVFF  02,03
01162:  MOVF   01,W
01164:  ADDLW  65
01166:  MOVWF  FE9
01168:  MOVLW  00
0116A:  ADDWFC 02,W
0116C:  MOVWF  FEA
0116E:  MOVFF  FEF,00
01172:  MOVFF  FEC,01
01176:  MOVFF  FEC,02
0117A:  MOVFF  FEC,03
0117E:  MOVFF  03,2DE
01182:  MOVFF  02,2DD
01186:  MOVFF  01,2DC
0118A:  MOVFF  00,2DB
.................... 	enable_interrupts(GLOBAL); 
0118E:  MOVLW  C0
01190:  IORWF  FF2,F
....................  
.................... 	return l; 
01192:  MOVFF  2DB,00
01196:  MOVFF  2DC,01
0119A:  MOVFF  2DD,02
0119E:  MOVFF  2DE,03
.................... } 
011A2:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
0121C:  MOVLB  2
0121E:  MOVF   xD9,W
01220:  SUBLW  06
01222:  BC    1278
01224:  XORLW  FF
01226:  BNZ   122E
01228:  MOVF   xD8,W
0122A:  SUBLW  CF
0122C:  BC    1278
0122E:  MOVF   xD9,W
01230:  SUBLW  09
01232:  BNC   1278
01234:  BNZ   123C
01236:  MOVF   xD8,W
01238:  SUBLW  CF
0123A:  BNC   1278
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
0123C:  MOVLW  D0
0123E:  SUBWF  xD8,W
01240:  MOVWF  xDA
01242:  MOVLW  07
01244:  SUBWFB xD9,W
01246:  MOVWF  xDB
01248:  MOVLW  02
0124A:  ADDWF  xDB,F
0124C:  MOVFF  FF2,2DC
01250:  BCF    FF2.6
01252:  BCF    FF2.7
01254:  MOVFF  2DB,FAA
01258:  MOVFF  2DA,FA9
0125C:  BCF    FA6.6
0125E:  BCF    FA6.7
01260:  BSF    FA6.0
01262:  MOVF   FA8,W
01264:  BTFSC  xDC.6
01266:  BSF    FF2.6
01268:  BTFSC  xDC.7
0126A:  BSF    FF2.7
0126C:  CLRF   03
0126E:  MOVWF  01
01270:  MOVF   03,W
01272:  MOVWF  02
01274:  GOTO   1BEE
.................... 	} 
....................  
.................... 	switch ( addr ) { 
01278:  MOVF   xD8,W
0127A:  MOVWF  00
0127C:  MOVF   xD9,W
0127E:  MOVWF  03
01280:  MOVF   03,W
01282:  BNZ   128E
01284:  MOVF   00,F
01286:  MOVLB  0
01288:  BTFSC  FD8.2
0128A:  BRA    1698
0128C:  MOVLB  2
0128E:  MOVF   03,W
01290:  BNZ   129E
01292:  MOVLW  01
01294:  SUBWF  00,W
01296:  MOVLB  0
01298:  BTFSC  FD8.2
0129A:  BRA    16A6
0129C:  MOVLB  2
0129E:  MOVF   03,W
012A0:  BNZ   12AE
012A2:  MOVLW  02
012A4:  SUBWF  00,W
012A6:  MOVLB  0
012A8:  BTFSC  FD8.2
012AA:  BRA    16B4
012AC:  MOVLB  2
012AE:  MOVF   03,W
012B0:  BNZ   12BE
012B2:  MOVLW  03
012B4:  SUBWF  00,W
012B6:  MOVLB  0
012B8:  BTFSC  FD8.2
012BA:  BRA    16C2
012BC:  MOVLB  2
012BE:  MOVF   03,W
012C0:  BNZ   12CE
012C2:  MOVLW  04
012C4:  SUBWF  00,W
012C6:  MOVLB  0
012C8:  BTFSC  FD8.2
012CA:  BRA    16D0
012CC:  MOVLB  2
012CE:  MOVF   03,W
012D0:  BNZ   12DE
012D2:  MOVLW  05
012D4:  SUBWF  00,W
012D6:  MOVLB  0
012D8:  BTFSC  FD8.2
012DA:  BRA    16F6
012DC:  MOVLB  2
012DE:  MOVF   03,W
012E0:  BNZ   12EE
012E2:  MOVLW  06
012E4:  SUBWF  00,W
012E6:  MOVLB  0
012E8:  BTFSC  FD8.2
012EA:  BRA    1704
012EC:  MOVLB  2
012EE:  MOVF   03,W
012F0:  BNZ   12FE
012F2:  MOVLW  07
012F4:  SUBWF  00,W
012F6:  MOVLB  0
012F8:  BTFSC  FD8.2
012FA:  BRA    1712
012FC:  MOVLB  2
012FE:  MOVF   03,W
01300:  BNZ   130E
01302:  MOVLW  08
01304:  SUBWF  00,W
01306:  MOVLB  0
01308:  BTFSC  FD8.2
0130A:  BRA    1720
0130C:  MOVLB  2
0130E:  MOVF   03,W
01310:  BNZ   131E
01312:  MOVLW  09
01314:  SUBWF  00,W
01316:  MOVLB  0
01318:  BTFSC  FD8.2
0131A:  BRA    172E
0131C:  MOVLB  2
0131E:  MOVF   03,W
01320:  BNZ   132E
01322:  MOVLW  0A
01324:  SUBWF  00,W
01326:  MOVLB  0
01328:  BTFSC  FD8.2
0132A:  BRA    173C
0132C:  MOVLB  2
0132E:  MOVF   03,W
01330:  BNZ   133E
01332:  MOVLW  0B
01334:  SUBWF  00,W
01336:  MOVLB  0
01338:  BTFSC  FD8.2
0133A:  BRA    1764
0133C:  MOVLB  2
0133E:  MOVF   03,W
01340:  BNZ   134E
01342:  MOVLW  0C
01344:  SUBWF  00,W
01346:  MOVLB  0
01348:  BTFSC  FD8.2
0134A:  BRA    1772
0134C:  MOVLB  2
0134E:  MOVF   03,W
01350:  BNZ   135E
01352:  MOVLW  0D
01354:  SUBWF  00,W
01356:  MOVLB  0
01358:  BTFSC  FD8.2
0135A:  BRA    1780
0135C:  MOVLB  2
0135E:  MOVF   03,W
01360:  BNZ   136E
01362:  MOVLW  0E
01364:  SUBWF  00,W
01366:  MOVLB  0
01368:  BTFSC  FD8.2
0136A:  BRA    178E
0136C:  MOVLB  2
0136E:  MOVF   03,W
01370:  BNZ   137E
01372:  MOVLW  0F
01374:  SUBWF  00,W
01376:  MOVLB  0
01378:  BTFSC  FD8.2
0137A:  BRA    179C
0137C:  MOVLB  2
0137E:  MOVF   03,W
01380:  BNZ   138E
01382:  MOVLW  10
01384:  SUBWF  00,W
01386:  MOVLB  0
01388:  BTFSC  FD8.2
0138A:  BRA    17AA
0138C:  MOVLB  2
0138E:  MOVF   03,W
01390:  BNZ   139E
01392:  MOVLW  11
01394:  SUBWF  00,W
01396:  MOVLB  0
01398:  BTFSC  FD8.2
0139A:  BRA    17D2
0139C:  MOVLB  2
0139E:  MOVF   03,W
013A0:  BNZ   13AE
013A2:  MOVLW  12
013A4:  SUBWF  00,W
013A6:  MOVLB  0
013A8:  BTFSC  FD8.2
013AA:  BRA    17E0
013AC:  MOVLB  2
013AE:  MOVF   03,W
013B0:  BNZ   13BE
013B2:  MOVLW  13
013B4:  SUBWF  00,W
013B6:  MOVLB  0
013B8:  BTFSC  FD8.2
013BA:  BRA    180E
013BC:  MOVLB  2
013BE:  MOVF   03,W
013C0:  BNZ   13CE
013C2:  MOVLW  14
013C4:  SUBWF  00,W
013C6:  MOVLB  0
013C8:  BTFSC  FD8.2
013CA:  BRA    1826
013CC:  MOVLB  2
013CE:  MOVF   03,W
013D0:  BNZ   13DE
013D2:  MOVLW  15
013D4:  SUBWF  00,W
013D6:  MOVLB  0
013D8:  BTFSC  FD8.2
013DA:  BRA    1834
013DC:  MOVLB  2
013DE:  MOVF   03,W
013E0:  BNZ   13EE
013E2:  MOVLW  16
013E4:  SUBWF  00,W
013E6:  MOVLB  0
013E8:  BTFSC  FD8.2
013EA:  BRA    1862
013EC:  MOVLB  2
013EE:  MOVF   03,W
013F0:  BNZ   13FE
013F2:  MOVLW  17
013F4:  SUBWF  00,W
013F6:  MOVLB  0
013F8:  BTFSC  FD8.2
013FA:  BRA    187C
013FC:  MOVLB  2
013FE:  MOVF   03,W
01400:  BNZ   140E
01402:  MOVLW  18
01404:  SUBWF  00,W
01406:  MOVLB  0
01408:  BTFSC  FD8.2
0140A:  BRA    188A
0140C:  MOVLB  2
0140E:  MOVF   03,W
01410:  BNZ   141E
01412:  MOVLW  19
01414:  SUBWF  00,W
01416:  MOVLB  0
01418:  BTFSC  FD8.2
0141A:  BRA    18B8
0141C:  MOVLB  2
0141E:  MOVF   03,W
01420:  BNZ   142E
01422:  MOVLW  1A
01424:  SUBWF  00,W
01426:  MOVLB  0
01428:  BTFSC  FD8.2
0142A:  BRA    18D2
0142C:  MOVLB  2
0142E:  MOVF   03,W
01430:  BNZ   143E
01432:  MOVLW  1B
01434:  SUBWF  00,W
01436:  MOVLB  0
01438:  BTFSC  FD8.2
0143A:  BRA    18E0
0143C:  MOVLB  2
0143E:  MOVF   03,W
01440:  BNZ   144E
01442:  MOVLW  1C
01444:  SUBWF  00,W
01446:  MOVLB  0
01448:  BTFSC  FD8.2
0144A:  BRA    190E
0144C:  MOVLB  2
0144E:  MOVF   03,W
01450:  BNZ   145E
01452:  MOVLW  1D
01454:  SUBWF  00,W
01456:  MOVLB  0
01458:  BTFSC  FD8.2
0145A:  BRA    1928
0145C:  MOVLB  2
0145E:  MOVF   03,W
01460:  BNZ   146E
01462:  MOVLW  1E
01464:  SUBWF  00,W
01466:  MOVLB  0
01468:  BTFSC  FD8.2
0146A:  BRA    1936
0146C:  MOVLB  2
0146E:  MOVF   03,W
01470:  BNZ   147E
01472:  MOVLW  1F
01474:  SUBWF  00,W
01476:  MOVLB  0
01478:  BTFSC  FD8.2
0147A:  BRA    1964
0147C:  MOVLB  2
0147E:  MOVF   03,W
01480:  BNZ   148E
01482:  MOVLW  20
01484:  SUBWF  00,W
01486:  MOVLB  0
01488:  BTFSC  FD8.2
0148A:  BRA    197E
0148C:  MOVLB  2
0148E:  MOVF   03,W
01490:  BNZ   149E
01492:  MOVLW  21
01494:  SUBWF  00,W
01496:  MOVLB  0
01498:  BTFSC  FD8.2
0149A:  BRA    198C
0149C:  MOVLB  2
0149E:  MOVF   03,W
014A0:  BNZ   14AE
014A2:  MOVLW  22
014A4:  SUBWF  00,W
014A6:  MOVLB  0
014A8:  BTFSC  FD8.2
014AA:  BRA    19BA
014AC:  MOVLB  2
014AE:  MOVF   03,W
014B0:  BNZ   14BE
014B2:  MOVLW  23
014B4:  SUBWF  00,W
014B6:  MOVLB  0
014B8:  BTFSC  FD8.2
014BA:  BRA    19D4
014BC:  MOVLB  2
014BE:  MOVF   03,W
014C0:  BNZ   14CE
014C2:  MOVLW  24
014C4:  SUBWF  00,W
014C6:  MOVLB  0
014C8:  BTFSC  FD8.2
014CA:  BRA    19E2
014CC:  MOVLB  2
014CE:  MOVF   03,W
014D0:  BNZ   14DE
014D2:  MOVLW  25
014D4:  SUBWF  00,W
014D6:  MOVLB  0
014D8:  BTFSC  FD8.2
014DA:  BRA    1A10
014DC:  MOVLB  2
014DE:  MOVF   03,W
014E0:  BNZ   14EE
014E2:  MOVLW  26
014E4:  SUBWF  00,W
014E6:  MOVLB  0
014E8:  BTFSC  FD8.2
014EA:  BRA    1A2A
014EC:  MOVLB  2
014EE:  MOVF   03,W
014F0:  BNZ   14FE
014F2:  MOVLW  27
014F4:  SUBWF  00,W
014F6:  MOVLB  0
014F8:  BTFSC  FD8.2
014FA:  BRA    1A38
014FC:  MOVLB  2
014FE:  MOVF   03,W
01500:  BNZ   150E
01502:  MOVLW  28
01504:  SUBWF  00,W
01506:  MOVLB  0
01508:  BTFSC  FD8.2
0150A:  BRA    1A66
0150C:  MOVLB  2
0150E:  MOVF   03,W
01510:  BNZ   151E
01512:  MOVLW  29
01514:  SUBWF  00,W
01516:  MOVLB  0
01518:  BTFSC  FD8.2
0151A:  BRA    1A80
0151C:  MOVLB  2
0151E:  MOVF   03,W
01520:  BNZ   152E
01522:  MOVLW  2A
01524:  SUBWF  00,W
01526:  MOVLB  0
01528:  BTFSC  FD8.2
0152A:  BRA    1A8E
0152C:  MOVLB  2
0152E:  MOVF   03,W
01530:  BNZ   153E
01532:  MOVLW  2B
01534:  SUBWF  00,W
01536:  MOVLB  0
01538:  BTFSC  FD8.2
0153A:  BRA    1AA8
0153C:  MOVLB  2
0153E:  MOVF   03,W
01540:  BNZ   154E
01542:  MOVLW  2C
01544:  SUBWF  00,W
01546:  MOVLB  0
01548:  BTFSC  FD8.2
0154A:  BRA    1AB8
0154C:  MOVLB  2
0154E:  MOVF   03,W
01550:  BNZ   155E
01552:  MOVLW  2D
01554:  SUBWF  00,W
01556:  MOVLB  0
01558:  BTFSC  FD8.2
0155A:  BRA    1AC8
0155C:  MOVLB  2
0155E:  MOVF   03,W
01560:  BNZ   156E
01562:  MOVLW  2E
01564:  SUBWF  00,W
01566:  MOVLB  0
01568:  BTFSC  FD8.2
0156A:  BRA    1AD8
0156C:  MOVLB  2
0156E:  MOVF   03,W
01570:  BNZ   157E
01572:  MOVLW  2F
01574:  SUBWF  00,W
01576:  MOVLB  0
01578:  BTFSC  FD8.2
0157A:  BRA    1AE8
0157C:  MOVLB  2
0157E:  MOVF   03,W
01580:  BNZ   158E
01582:  MOVLW  30
01584:  SUBWF  00,W
01586:  MOVLB  0
01588:  BTFSC  FD8.2
0158A:  BRA    1AF8
0158C:  MOVLB  2
0158E:  MOVF   03,W
01590:  BNZ   159E
01592:  MOVLW  31
01594:  SUBWF  00,W
01596:  MOVLB  0
01598:  BTFSC  FD8.2
0159A:  BRA    1B08
0159C:  MOVLB  2
0159E:  MOVF   03,W
015A0:  BNZ   15AE
015A2:  MOVLW  32
015A4:  SUBWF  00,W
015A6:  MOVLB  0
015A8:  BTFSC  FD8.2
015AA:  BRA    1B18
015AC:  MOVLB  2
015AE:  MOVF   03,W
015B0:  BNZ   15BE
015B2:  MOVLW  33
015B4:  SUBWF  00,W
015B6:  MOVLB  0
015B8:  BTFSC  FD8.2
015BA:  BRA    1B28
015BC:  MOVLB  2
015BE:  MOVLW  03
015C0:  SUBWF  03,W
015C2:  BNZ   15D0
015C4:  MOVLW  E8
015C6:  SUBWF  00,W
015C8:  MOVLB  0
015CA:  BTFSC  FD8.2
015CC:  BRA    1B38
015CE:  MOVLB  2
015D0:  MOVLW  03
015D2:  SUBWF  03,W
015D4:  BNZ   15E2
015D6:  MOVLW  E9
015D8:  SUBWF  00,W
015DA:  MOVLB  0
015DC:  BTFSC  FD8.2
015DE:  BRA    1B48
015E0:  MOVLB  2
015E2:  MOVLW  03
015E4:  SUBWF  03,W
015E6:  BNZ   15F4
015E8:  MOVLW  EA
015EA:  SUBWF  00,W
015EC:  MOVLB  0
015EE:  BTFSC  FD8.2
015F0:  BRA    1B56
015F2:  MOVLB  2
015F4:  MOVLW  03
015F6:  SUBWF  03,W
015F8:  BNZ   1606
015FA:  MOVLW  EB
015FC:  SUBWF  00,W
015FE:  MOVLB  0
01600:  BTFSC  FD8.2
01602:  BRA    1B64
01604:  MOVLB  2
01606:  MOVLW  03
01608:  SUBWF  03,W
0160A:  BNZ   1618
0160C:  MOVLW  EC
0160E:  SUBWF  00,W
01610:  MOVLB  0
01612:  BTFSC  FD8.2
01614:  BRA    1B72
01616:  MOVLB  2
01618:  MOVLW  03
0161A:  SUBWF  03,W
0161C:  BNZ   162A
0161E:  MOVLW  ED
01620:  SUBWF  00,W
01622:  MOVLB  0
01624:  BTFSC  FD8.2
01626:  BRA    1B80
01628:  MOVLB  2
0162A:  MOVLW  03
0162C:  SUBWF  03,W
0162E:  BNZ   163C
01630:  MOVLW  EE
01632:  SUBWF  00,W
01634:  MOVLB  0
01636:  BTFSC  FD8.2
01638:  BRA    1B8E
0163A:  MOVLB  2
0163C:  MOVLW  03
0163E:  SUBWF  03,W
01640:  BNZ   164E
01642:  MOVLW  EF
01644:  SUBWF  00,W
01646:  MOVLB  0
01648:  BTFSC  FD8.2
0164A:  BRA    1B9E
0164C:  MOVLB  2
0164E:  MOVLW  03
01650:  SUBWF  03,W
01652:  BNZ   1660
01654:  MOVLW  F0
01656:  SUBWF  00,W
01658:  MOVLB  0
0165A:  BTFSC  FD8.2
0165C:  BRA    1BAC
0165E:  MOVLB  2
01660:  MOVLW  03
01662:  SUBWF  03,W
01664:  BNZ   1672
01666:  MOVLW  F1
01668:  SUBWF  00,W
0166A:  MOVLB  0
0166C:  BTFSC  FD8.2
0166E:  BRA    1BBC
01670:  MOVLB  2
01672:  MOVLW  03
01674:  SUBWF  03,W
01676:  BNZ   1684
01678:  MOVLW  F2
0167A:  SUBWF  00,W
0167C:  MOVLB  0
0167E:  BTFSC  FD8.2
01680:  BRA    1BCA
01682:  MOVLB  2
01684:  MOVLW  03
01686:  SUBWF  03,W
01688:  BNZ   1696
0168A:  MOVLW  F3
0168C:  SUBWF  00,W
0168E:  MOVLB  0
01690:  BTFSC  FD8.2
01692:  BRA    1BD8
01694:  MOVLB  2
01696:  BRA    1BE6
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01698:  MOVFF  5F,01
0169C:  MOVFF  60,02
016A0:  MOVLB  2
016A2:  BRA    1BEE
016A4:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
016A6:  MOVF   4D,W
016A8:  MOVWF  01
016AA:  MOVF   4E,W
016AC:  MOVWF  02
016AE:  MOVLB  2
016B0:  BRA    1BEE
016B2:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
016B4:  MOVF   53,W
016B6:  MOVWF  01
016B8:  MOVF   54,W
016BA:  MOVWF  02
016BC:  MOVLB  2
016BE:  BRA    1BEE
016C0:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
016C2:  MOVF   59,W
016C4:  MOVWF  01
016C6:  MOVF   5A,W
016C8:  MOVWF  02
016CA:  MOVLB  2
016CC:  BRA    1BEE
016CE:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
016D0:  MOVLB  2
016D2:  CLRF   xDA
016D4:  MOVLB  0
016D6:  RCALL  1142
016D8:  MOVFF  03,2BA
016DC:  MOVFF  02,2B9
016E0:  MOVFF  01,2B8
016E4:  MOVFF  00,2B7
016E8:  MOVLB  2
016EA:  MOVF   xB7,W
016EC:  MOVWF  01
016EE:  MOVF   xB8,W
016F0:  MOVWF  02
016F2:  BRA    1BEE
016F4:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
016F6:  MOVLB  2
016F8:  MOVF   xB9,W
016FA:  MOVWF  01
016FC:  MOVF   xBA,W
016FE:  MOVWF  02
01700:  BRA    1BEE
01702:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01704:  MOVF   x61,W
01706:  MOVWF  01
01708:  MOVF   x62,W
0170A:  MOVWF  02
0170C:  MOVLB  2
0170E:  BRA    1BEE
01710:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01712:  MOVF   4F,W
01714:  MOVWF  01
01716:  MOVF   50,W
01718:  MOVWF  02
0171A:  MOVLB  2
0171C:  BRA    1BEE
0171E:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01720:  MOVF   55,W
01722:  MOVWF  01
01724:  MOVF   56,W
01726:  MOVWF  02
01728:  MOVLB  2
0172A:  BRA    1BEE
0172C:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
0172E:  MOVF   5B,W
01730:  MOVWF  01
01732:  MOVF   5C,W
01734:  MOVWF  02
01736:  MOVLB  2
01738:  BRA    1BEE
0173A:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
0173C:  MOVLW  01
0173E:  MOVLB  2
01740:  MOVWF  xDA
01742:  MOVLB  0
01744:  RCALL  1142
01746:  MOVFF  03,2BA
0174A:  MOVFF  02,2B9
0174E:  MOVFF  01,2B8
01752:  MOVFF  00,2B7
01756:  MOVLB  2
01758:  MOVF   xB7,W
0175A:  MOVWF  01
0175C:  MOVF   xB8,W
0175E:  MOVWF  02
01760:  BRA    1BEE
01762:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01764:  MOVLB  2
01766:  MOVF   xB9,W
01768:  MOVWF  01
0176A:  MOVF   xBA,W
0176C:  MOVWF  02
0176E:  BRA    1BEE
01770:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01772:  MOVF   x63,W
01774:  MOVWF  01
01776:  MOVF   x64,W
01778:  MOVWF  02
0177A:  MOVLB  2
0177C:  BRA    1BEE
0177E:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01780:  MOVF   51,W
01782:  MOVWF  01
01784:  MOVF   52,W
01786:  MOVWF  02
01788:  MOVLB  2
0178A:  BRA    1BEE
0178C:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
0178E:  MOVF   57,W
01790:  MOVWF  01
01792:  MOVF   58,W
01794:  MOVWF  02
01796:  MOVLB  2
01798:  BRA    1BEE
0179A:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
0179C:  MOVF   5D,W
0179E:  MOVWF  01
017A0:  MOVF   5E,W
017A2:  MOVWF  02
017A4:  MOVLB  2
017A6:  BRA    1BEE
017A8:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
017AA:  MOVLW  02
017AC:  MOVLB  2
017AE:  MOVWF  xDA
017B0:  MOVLB  0
017B2:  RCALL  1142
017B4:  MOVFF  03,2BA
017B8:  MOVFF  02,2B9
017BC:  MOVFF  01,2B8
017C0:  MOVFF  00,2B7
017C4:  MOVLB  2
017C6:  MOVF   xB7,W
017C8:  MOVWF  01
017CA:  MOVF   xB8,W
017CC:  MOVWF  02
017CE:  BRA    1BEE
017D0:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
017D2:  MOVLB  2
017D4:  MOVF   xB9,W
017D6:  MOVWF  01
017D8:  MOVF   xBA,W
017DA:  MOVWF  02
017DC:  BRA    1BEE
017DE:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
017E0:  CLRF   03
017E2:  MOVLB  1
017E4:  MOVF   x81,W
017E6:  MOVWF  02
017E8:  BCF    FD8.0
017EA:  RLCF   02,F
017EC:  RLCF   03,F
017EE:  MOVF   02,W
017F0:  ADDLW  81
017F2:  MOVWF  FE9
017F4:  MOVLW  00
017F6:  ADDWFC 03,W
017F8:  MOVWF  FEA
017FA:  MOVFF  FEC,03
017FE:  MOVF   FED,F
01800:  MOVF   FEF,W
01802:  MOVWF  01
01804:  MOVF   03,W
01806:  MOVWF  02
01808:  MOVLB  2
0180A:  BRA    1BEE
0180C:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
0180E:  MOVLB  2
01810:  CLRF   xDA
01812:  MOVLB  0
01814:  CALL   0DF8
01818:  MOVF   01,W
0181A:  MOVWF  01
0181C:  MOVF   02,W
0181E:  MOVWF  02
01820:  MOVLB  2
01822:  BRA    1BEE
01824:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01826:  MOVF   x71,W
01828:  MOVWF  01
0182A:  MOVF   x72,W
0182C:  MOVWF  02
0182E:  MOVLB  2
01830:  BRA    1BEE
01832:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01834:  CLRF   03
01836:  MOVLB  1
01838:  MOVF   x81,W
0183A:  MOVWF  02
0183C:  BCF    FD8.0
0183E:  RLCF   02,F
01840:  RLCF   03,F
01842:  MOVF   02,W
01844:  ADDLW  A1
01846:  MOVWF  FE9
01848:  MOVLW  00
0184A:  ADDWFC 03,W
0184C:  MOVWF  FEA
0184E:  MOVFF  FEC,03
01852:  MOVF   FED,F
01854:  MOVF   FEF,W
01856:  MOVWF  01
01858:  MOVF   03,W
0185A:  MOVWF  02
0185C:  MOVLB  2
0185E:  BRA    1BEE
01860:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01862:  MOVLW  01
01864:  MOVLB  2
01866:  MOVWF  xDA
01868:  MOVLB  0
0186A:  CALL   0DF8
0186E:  MOVF   01,W
01870:  MOVWF  01
01872:  MOVF   02,W
01874:  MOVWF  02
01876:  MOVLB  2
01878:  BRA    1BEE
0187A:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0187C:  MOVF   x73,W
0187E:  MOVWF  01
01880:  MOVF   x74,W
01882:  MOVWF  02
01884:  MOVLB  2
01886:  BRA    1BEE
01888:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0188A:  CLRF   03
0188C:  MOVLB  1
0188E:  MOVF   x81,W
01890:  MOVWF  02
01892:  BCF    FD8.0
01894:  RLCF   02,F
01896:  RLCF   03,F
01898:  MOVF   02,W
0189A:  ADDLW  C1
0189C:  MOVWF  FE9
0189E:  MOVLW  00
018A0:  ADDWFC 03,W
018A2:  MOVWF  FEA
018A4:  MOVFF  FEC,03
018A8:  MOVF   FED,F
018AA:  MOVF   FEF,W
018AC:  MOVWF  01
018AE:  MOVF   03,W
018B0:  MOVWF  02
018B2:  MOVLB  2
018B4:  BRA    1BEE
018B6:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
018B8:  MOVLW  02
018BA:  MOVLB  2
018BC:  MOVWF  xDA
018BE:  MOVLB  0
018C0:  CALL   0DF8
018C4:  MOVF   01,W
018C6:  MOVWF  01
018C8:  MOVF   02,W
018CA:  MOVWF  02
018CC:  MOVLB  2
018CE:  BRA    1BEE
018D0:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
018D2:  MOVF   x75,W
018D4:  MOVWF  01
018D6:  MOVF   x76,W
018D8:  MOVWF  02
018DA:  MOVLB  2
018DC:  BRA    1BEE
018DE:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
018E0:  CLRF   03
018E2:  MOVLB  1
018E4:  MOVF   x81,W
018E6:  MOVWF  02
018E8:  BCF    FD8.0
018EA:  RLCF   02,F
018EC:  RLCF   03,F
018EE:  MOVF   02,W
018F0:  ADDLW  E1
018F2:  MOVWF  FE9
018F4:  MOVLW  00
018F6:  ADDWFC 03,W
018F8:  MOVWF  FEA
018FA:  MOVFF  FEC,03
018FE:  MOVF   FED,F
01900:  MOVF   FEF,W
01902:  MOVWF  01
01904:  MOVF   03,W
01906:  MOVWF  02
01908:  MOVLB  2
0190A:  BRA    1BEE
0190C:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
0190E:  MOVLW  03
01910:  MOVLB  2
01912:  MOVWF  xDA
01914:  MOVLB  0
01916:  CALL   0DF8
0191A:  MOVF   01,W
0191C:  MOVWF  01
0191E:  MOVF   02,W
01920:  MOVWF  02
01922:  MOVLB  2
01924:  BRA    1BEE
01926:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01928:  MOVF   x77,W
0192A:  MOVWF  01
0192C:  MOVF   x78,W
0192E:  MOVWF  02
01930:  MOVLB  2
01932:  BRA    1BEE
01934:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01936:  CLRF   03
01938:  MOVLB  1
0193A:  MOVF   x81,W
0193C:  MOVWF  02
0193E:  BCF    FD8.0
01940:  RLCF   02,F
01942:  RLCF   03,F
01944:  MOVF   02,W
01946:  ADDLW  01
01948:  MOVWF  FE9
0194A:  MOVLW  01
0194C:  ADDWFC 03,W
0194E:  MOVWF  FEA
01950:  MOVFF  FEC,03
01954:  MOVF   FED,F
01956:  MOVF   FEF,W
01958:  MOVWF  01
0195A:  MOVF   03,W
0195C:  MOVWF  02
0195E:  MOVLB  2
01960:  BRA    1BEE
01962:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01964:  MOVLW  04
01966:  MOVLB  2
01968:  MOVWF  xDA
0196A:  MOVLB  0
0196C:  CALL   0DF8
01970:  MOVF   01,W
01972:  MOVWF  01
01974:  MOVF   02,W
01976:  MOVWF  02
01978:  MOVLB  2
0197A:  BRA    1BEE
0197C:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
0197E:  MOVF   x79,W
01980:  MOVWF  01
01982:  MOVF   x7A,W
01984:  MOVWF  02
01986:  MOVLB  2
01988:  BRA    1BEE
0198A:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
0198C:  CLRF   03
0198E:  MOVLB  1
01990:  MOVF   x81,W
01992:  MOVWF  02
01994:  BCF    FD8.0
01996:  RLCF   02,F
01998:  RLCF   03,F
0199A:  MOVF   02,W
0199C:  ADDLW  21
0199E:  MOVWF  FE9
019A0:  MOVLW  01
019A2:  ADDWFC 03,W
019A4:  MOVWF  FEA
019A6:  MOVFF  FEC,03
019AA:  MOVF   FED,F
019AC:  MOVF   FEF,W
019AE:  MOVWF  01
019B0:  MOVF   03,W
019B2:  MOVWF  02
019B4:  MOVLB  2
019B6:  BRA    1BEE
019B8:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
019BA:  MOVLW  05
019BC:  MOVLB  2
019BE:  MOVWF  xDA
019C0:  MOVLB  0
019C2:  CALL   0DF8
019C6:  MOVF   01,W
019C8:  MOVWF  01
019CA:  MOVF   02,W
019CC:  MOVWF  02
019CE:  MOVLB  2
019D0:  BRA    1BEE
019D2:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
019D4:  MOVF   x7B,W
019D6:  MOVWF  01
019D8:  MOVF   x7C,W
019DA:  MOVWF  02
019DC:  MOVLB  2
019DE:  BRA    1BEE
019E0:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
019E2:  CLRF   03
019E4:  MOVLB  1
019E6:  MOVF   x81,W
019E8:  MOVWF  02
019EA:  BCF    FD8.0
019EC:  RLCF   02,F
019EE:  RLCF   03,F
019F0:  MOVF   02,W
019F2:  ADDLW  41
019F4:  MOVWF  FE9
019F6:  MOVLW  01
019F8:  ADDWFC 03,W
019FA:  MOVWF  FEA
019FC:  MOVFF  FEC,03
01A00:  MOVF   FED,F
01A02:  MOVF   FEF,W
01A04:  MOVWF  01
01A06:  MOVF   03,W
01A08:  MOVWF  02
01A0A:  MOVLB  2
01A0C:  BRA    1BEE
01A0E:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01A10:  MOVLW  06
01A12:  MOVLB  2
01A14:  MOVWF  xDA
01A16:  MOVLB  0
01A18:  CALL   0DF8
01A1C:  MOVF   01,W
01A1E:  MOVWF  01
01A20:  MOVF   02,W
01A22:  MOVWF  02
01A24:  MOVLB  2
01A26:  BRA    1BEE
01A28:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01A2A:  MOVF   x7D,W
01A2C:  MOVWF  01
01A2E:  MOVF   x7E,W
01A30:  MOVWF  02
01A32:  MOVLB  2
01A34:  BRA    1BEE
01A36:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01A38:  CLRF   03
01A3A:  MOVLB  1
01A3C:  MOVF   x81,W
01A3E:  MOVWF  02
01A40:  BCF    FD8.0
01A42:  RLCF   02,F
01A44:  RLCF   03,F
01A46:  MOVF   02,W
01A48:  ADDLW  61
01A4A:  MOVWF  FE9
01A4C:  MOVLW  01
01A4E:  ADDWFC 03,W
01A50:  MOVWF  FEA
01A52:  MOVFF  FEC,03
01A56:  MOVF   FED,F
01A58:  MOVF   FEF,W
01A5A:  MOVWF  01
01A5C:  MOVF   03,W
01A5E:  MOVWF  02
01A60:  MOVLB  2
01A62:  BRA    1BEE
01A64:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01A66:  MOVLW  07
01A68:  MOVLB  2
01A6A:  MOVWF  xDA
01A6C:  MOVLB  0
01A6E:  CALL   0DF8
01A72:  MOVF   01,W
01A74:  MOVWF  01
01A76:  MOVF   02,W
01A78:  MOVWF  02
01A7A:  MOVLB  2
01A7C:  BRA    1BEE
01A7E:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01A80:  MOVF   x7F,W
01A82:  MOVWF  01
01A84:  MOVF   x80,W
01A86:  MOVWF  02
01A88:  MOVLB  2
01A8A:  BRA    1BEE
01A8C:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01A8E:  MOVLB  1
01A90:  MOVF   x89,W
01A92:  MOVWF  03
01A94:  MOVF   x88,W
01A96:  INCF   x88,F
01A98:  BTFSC  FD8.2
01A9A:  INCF   x89,F
01A9C:  MOVWF  01
01A9E:  MOVF   03,W
01AA0:  MOVWF  02
01AA2:  MOVLB  2
01AA4:  BRA    1BEE
01AA6:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01AA8:  MOVLB  1
01AAA:  MOVF   x8C,W
01AAC:  MOVWF  01
01AAE:  MOVF   x8D,W
01AB0:  MOVWF  02
01AB2:  MOVLB  2
01AB4:  BRA    1BEE
01AB6:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01AB8:  MOVLB  1
01ABA:  MOVF   x8A,W
01ABC:  MOVWF  01
01ABE:  MOVF   x8B,W
01AC0:  MOVWF  02
01AC2:  MOVLB  2
01AC4:  BRA    1BEE
01AC6:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01AC8:  MOVLB  1
01ACA:  MOVF   x90,W
01ACC:  MOVWF  01
01ACE:  MOVF   x91,W
01AD0:  MOVWF  02
01AD2:  MOVLB  2
01AD4:  BRA    1BEE
01AD6:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01AD8:  GOTO   11A4
01ADC:  MOVLW  00
01ADE:  MOVWF  01
01AE0:  MOVWF  02
01AE2:  MOVLB  2
01AE4:  BRA    1BEE
01AE6:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01AE8:  GOTO   11E0
01AEC:  MOVLW  00
01AEE:  MOVWF  01
01AF0:  MOVWF  02
01AF2:  MOVLB  2
01AF4:  BRA    1BEE
01AF6:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01AF8:  MOVLB  1
01AFA:  MOVF   x82,W
01AFC:  MOVWF  01
01AFE:  MOVF   x83,W
01B00:  MOVWF  02
01B02:  MOVLB  2
01B04:  BRA    1BEE
01B06:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01B08:  MOVLB  1
01B0A:  MOVF   x84,W
01B0C:  MOVWF  01
01B0E:  MOVF   x85,W
01B10:  MOVWF  02
01B12:  MOVLB  2
01B14:  BRA    1BEE
01B16:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01B18:  MOVLB  1
01B1A:  MOVF   x86,W
01B1C:  MOVWF  01
01B1E:  MOVF   x87,W
01B20:  MOVWF  02
01B22:  MOVLB  2
01B24:  BRA    1BEE
01B26:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01B28:  GOTO   1208
01B2C:  MOVLW  00
01B2E:  MOVWF  01
01B30:  MOVWF  02
01B32:  MOVLB  2
01B34:  BRA    1BEE
01B36:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01B38:  CLRF   03
01B3A:  MOVF   38,W
01B3C:  MOVWF  01
01B3E:  MOVF   03,W
01B40:  MOVWF  02
01B42:  MOVLB  2
01B44:  BRA    1BEE
01B46:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01B48:  MOVF   39,W
01B4A:  MOVWF  01
01B4C:  MOVF   3A,W
01B4E:  MOVWF  02
01B50:  MOVLB  2
01B52:  BRA    1BEE
01B54:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01B56:  MOVLW  50
01B58:  MOVWF  01
01B5A:  MOVLW  00
01B5C:  MOVWF  02
01B5E:  MOVLB  2
01B60:  BRA    1BEE
01B62:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01B64:  MOVLW  57
01B66:  MOVWF  01
01B68:  MOVLW  00
01B6A:  MOVWF  02
01B6C:  MOVLB  2
01B6E:  BRA    1BEE
01B70:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01B72:  MOVLW  58
01B74:  MOVWF  01
01B76:  MOVLW  00
01B78:  MOVWF  02
01B7A:  MOVLB  2
01B7C:  BRA    1BEE
01B7E:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01B80:  MOVLW  01
01B82:  MOVWF  01
01B84:  MOVLW  00
01B86:  MOVWF  02
01B88:  MOVLB  2
01B8A:  BRA    1BEE
01B8C:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01B8E:  CLRF   03
01B90:  MOVF   36,W
01B92:  MOVWF  01
01B94:  MOVF   03,W
01B96:  MOVWF  02
01B98:  MOVLB  2
01B9A:  BRA    1BEE
01B9C:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01B9E:  MOVF   3B,W
01BA0:  MOVWF  01
01BA2:  MOVF   3C,W
01BA4:  MOVWF  02
01BA6:  MOVLB  2
01BA8:  BRA    1BEE
01BAA:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01BAC:  CLRF   03
01BAE:  MOVF   3D,W
01BB0:  MOVWF  01
01BB2:  MOVF   03,W
01BB4:  MOVWF  02
01BB6:  MOVLB  2
01BB8:  BRA    1BEE
01BBA:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01BBC:  MOVF   3E,W
01BBE:  MOVWF  01
01BC0:  MOVF   3F,W
01BC2:  MOVWF  02
01BC4:  MOVLB  2
01BC6:  BRA    1BEE
01BC8:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01BCA:  MOVF   40,W
01BCC:  MOVWF  01
01BCE:  MOVF   41,W
01BD0:  MOVWF  02
01BD2:  MOVLB  2
01BD4:  BRA    1BEE
01BD6:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01BD8:  CLRF   03
01BDA:  MOVF   42,W
01BDC:  MOVWF  01
01BDE:  MOVF   03,W
01BE0:  MOVWF  02
01BE2:  MOVLB  2
01BE4:  BRA    1BEE
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01BE6:  MOVLW  FF
01BE8:  MOVWF  01
01BEA:  MOVWF  02
01BEC:  BRA    1BEE
.................... 	} 
....................  
.................... } 
01BEE:  MOVLB  0
01BF0:  GOTO   1C42 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01006:  MOVLB  2
01008:  MOVF   xCE,W
0100A:  SUBLW  1F
0100C:  BNZ   1026
0100E:  MOVF   xCF,W
01010:  SUBLW  4E
01012:  BNZ   1026
01014:  MOVF   xD0,W
01016:  SUBLW  20
01018:  BNZ   1026
0101A:  MOVF   xD1,W
0101C:  SUBLW  4E
0101E:  BNZ   1026
.................... 		return 1; 
01020:  MOVLW  01
01022:  MOVWF  01
01024:  BRA    1082
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
01026:  MOVF   xCF,W
01028:  SUBLW  02
0102A:  BC    104A
0102C:  XORLW  FF
0102E:  BNZ   1036
01030:  MOVF   xCE,W
01032:  SUBLW  E7
01034:  BC    104A
01036:  MOVF   xD1,W
01038:  SUBLW  03
0103A:  BNC   104A
0103C:  BNZ   1044
0103E:  MOVF   xD0,W
01040:  SUBLW  F4
01042:  BNC   104A
.................... 		return 1; 
01044:  MOVLW  01
01046:  MOVWF  01
01048:  BRA    1082
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
0104A:  MOVF   xCF,W
0104C:  SUBLW  06
0104E:  BC    106E
01050:  XORLW  FF
01052:  BNZ   105A
01054:  MOVF   xCE,W
01056:  SUBLW  CF
01058:  BC    106E
0105A:  MOVF   xD1,W
0105C:  SUBLW  09
0105E:  BNC   106E
01060:  BNZ   1068
01062:  MOVF   xD0,W
01064:  SUBLW  D1
01066:  BNC   106E
.................... 		return 1; 
01068:  MOVLW  01
0106A:  MOVWF  01
0106C:  BRA    1082
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
0106E:  MOVF   xD1,F
01070:  BNZ   107E
01072:  MOVF   xD0,W
01074:  SUBLW  34
01076:  BNC   107E
.................... 		return 1; 
01078:  MOVLW  01
0107A:  MOVWF  01
0107C:  BRA    1082
....................  
.................... 	return 0; 
0107E:  MOVLW  00
01080:  MOVWF  01
.................... } 
01082:  MOVLB  0
01084:  GOTO   1FC2 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01BF4:  MOVFF  2CD,2D6
01BF8:  MOVFF  2CC,2D7
01BFC:  CALL   10C6
.................... 	modbus_serial_putc(register_count*2); 
01C00:  BCF    FD8.0
01C02:  MOVLB  2
01C04:  RLCF   xD0,W
01C06:  MOVWF  xD6
01C08:  RLCF   xD1,W
01C0A:  MOVWF  xD7
01C0C:  MOVFF  2D6,2D8
01C10:  MOVLB  0
01C12:  CALL   1092
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01C16:  MOVLB  2
01C18:  CLRF   xD3
01C1A:  CLRF   xD2
01C1C:  MOVF   xD3,W
01C1E:  SUBWF  xD1,W
01C20:  BNC   1C6C
01C22:  BNZ   1C2A
01C24:  MOVF   xD0,W
01C26:  SUBWF  xD2,W
01C28:  BC    1C6C
.................... 		l=map_modbus(start_address+i); 
01C2A:  MOVF   xD2,W
01C2C:  ADDWF  xCE,W
01C2E:  MOVWF  xD6
01C30:  MOVF   xD3,W
01C32:  ADDWFC xCF,W
01C34:  MOVWF  xD7
01C36:  MOVWF  xD9
01C38:  MOVFF  2D6,2D8
01C3C:  MOVLB  0
01C3E:  GOTO   121C
01C42:  MOVFF  02,2D5
01C46:  MOVFF  01,2D4
.................... 		modbus_serial_putc(make8(l,1)); 
01C4A:  MOVFF  2D5,2D6
01C4E:  MOVFF  2D5,2D8
01C52:  CALL   1092
....................   		modbus_serial_putc(make8(l,0)); 
01C56:  MOVFF  2D4,2D6
01C5A:  MOVFF  2D4,2D8
01C5E:  CALL   1092
.................... 	} 
01C62:  MOVLB  2
01C64:  INCF   xD2,F
01C66:  BTFSC  FD8.2
01C68:  INCF   xD3,F
01C6A:  BRA    1C1C
....................  
.................... 	modbus_serial_send_stop(); 
01C6C:  MOVLB  0
01C6E:  CALL   10F4
.................... } 
01C72:  GOTO   2004 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01C76:  MOVLB  2
01C78:  MOVF   xD3,W
01C7A:  SUBLW  06
01C7C:  BC    1CF4
01C7E:  XORLW  FF
01C80:  BNZ   1C88
01C82:  MOVF   xD2,W
01C84:  SUBLW  CF
01C86:  BC    1CF4
01C88:  MOVF   xD3,W
01C8A:  SUBLW  09
01C8C:  BNC   1CF4
01C8E:  BNZ   1C96
01C90:  MOVF   xD2,W
01C92:  SUBLW  CF
01C94:  BNC   1CF4
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01C96:  MOVF   xD5,W
01C98:  SUBLW  00
01C9A:  BC    1CAC
01C9C:  XORLW  FF
01C9E:  BNZ   1CA6
01CA0:  MOVF   xD4,W
01CA2:  SUBLW  00
01CA4:  BC    1CAC
01CA6:  MOVLW  03
01CA8:  MOVWF  01
01CAA:  BRA    1EB2
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01CAC:  MOVLW  D0
01CAE:  SUBWF  xD2,W
01CB0:  MOVWF  xD6
01CB2:  MOVLW  07
01CB4:  SUBWFB xD3,W
01CB6:  MOVWF  xD7
01CB8:  MOVLW  02
01CBA:  ADDWF  xD7,F
01CBC:  MOVFF  2D7,FAA
01CC0:  MOVFF  2D6,FA9
01CC4:  MOVFF  2D4,FA8
01CC8:  BCF    FA6.6
01CCA:  BCF    FA6.7
01CCC:  BSF    FA6.2
01CCE:  MOVF   FF2,W
01CD0:  MOVWF  00
01CD2:  BCF    FF2.6
01CD4:  BCF    FF2.7
01CD6:  MOVLB  F
01CD8:  MOVLW  55
01CDA:  MOVWF  FA7
01CDC:  MOVLW  AA
01CDE:  MOVWF  FA7
01CE0:  BSF    FA6.1
01CE2:  BTFSC  FA6.1
01CE4:  BRA    1CE2
01CE6:  BCF    FA6.2
01CE8:  MOVF   00,W
01CEA:  IORWF  FF2,F
.................... 		return 0; 
01CEC:  MOVLW  00
01CEE:  MOVWF  01
01CF0:  MOVLB  2
01CF2:  BRA    1EB2
.................... 	} 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01CF4:  MOVLB  1
01CF6:  MOVF   x8E,F
01CF8:  BZ    1D30
.................... 		if ( 1000 == address ) { 
01CFA:  MOVLB  2
01CFC:  MOVF   xD2,W
01CFE:  SUBLW  E8
01D00:  BNZ   1D14
01D02:  MOVF   xD3,W
01D04:  SUBLW  03
01D06:  BNZ   1D14
.................... 			config.serial_prefix=value; 
01D08:  MOVFF  2D4,38
.................... 			return 0; 
01D0C:  MOVLW  00
01D0E:  MOVWF  01
01D10:  BRA    1EB2
.................... 		} else if ( 1001 == address ) { 
01D12:  BRA    1D2E
01D14:  MOVF   xD2,W
01D16:  SUBLW  E9
01D18:  BNZ   1D2E
01D1A:  MOVF   xD3,W
01D1C:  SUBLW  03
01D1E:  BNZ   1D2E
.................... 			config.serial_number=value; 
01D20:  MOVFF  2D5,3A
01D24:  MOVFF  2D4,39
.................... 			return 0; 
01D28:  MOVLW  00
01D2A:  MOVWF  01
01D2C:  BRA    1EB2
01D2E:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01D30:  MOVLB  2
01D32:  MOVF   xD2,W
01D34:  MOVWF  00
01D36:  MOVF   xD3,W
01D38:  MOVWF  03
01D3A:  MOVLW  03
01D3C:  SUBWF  03,W
01D3E:  BNZ   1D4A
01D40:  MOVLW  EE
01D42:  SUBWF  00,W
01D44:  MOVLB  0
01D46:  BZ    1DCE
01D48:  MOVLB  2
01D4A:  MOVLW  03
01D4C:  SUBWF  03,W
01D4E:  BNZ   1D5A
01D50:  MOVLW  EF
01D52:  SUBWF  00,W
01D54:  MOVLB  0
01D56:  BZ    1DE6
01D58:  MOVLB  2
01D5A:  MOVLW  03
01D5C:  SUBWF  03,W
01D5E:  BNZ   1D6A
01D60:  MOVLW  F0
01D62:  SUBWF  00,W
01D64:  MOVLB  0
01D66:  BZ    1DF6
01D68:  MOVLB  2
01D6A:  MOVLW  03
01D6C:  SUBWF  03,W
01D6E:  BNZ   1D7A
01D70:  MOVLW  F1
01D72:  SUBWF  00,W
01D74:  MOVLB  0
01D76:  BZ    1E0E
01D78:  MOVLB  2
01D7A:  MOVLW  03
01D7C:  SUBWF  03,W
01D7E:  BNZ   1D8A
01D80:  MOVLW  F2
01D82:  SUBWF  00,W
01D84:  MOVLB  0
01D86:  BZ    1E1A
01D88:  MOVLB  2
01D8A:  MOVLW  03
01D8C:  SUBWF  03,W
01D8E:  BNZ   1D9A
01D90:  MOVLW  F3
01D92:  SUBWF  00,W
01D94:  MOVLB  0
01D96:  BZ    1E34
01D98:  MOVLB  2
01D9A:  MOVLW  07
01D9C:  SUBWF  03,W
01D9E:  BNZ   1DAA
01DA0:  MOVLW  CE
01DA2:  SUBWF  00,W
01DA4:  MOVLB  0
01DA6:  BZ    1E4C
01DA8:  MOVLB  2
01DAA:  MOVLW  07
01DAC:  SUBWF  03,W
01DAE:  BNZ   1DBA
01DB0:  MOVLW  CF
01DB2:  SUBWF  00,W
01DB4:  MOVLB  0
01DB6:  BZ    1E66
01DB8:  MOVLB  2
01DBA:  MOVLW  4E
01DBC:  SUBWF  03,W
01DBE:  BNZ   1DCC
01DC0:  MOVLW  1F
01DC2:  SUBWF  00,W
01DC4:  MOVLB  0
01DC6:  BTFSC  FD8.2
01DC8:  BRA    1E80
01DCA:  MOVLB  2
01DCC:  BRA    1EA8
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01DCE:  MOVLB  2
01DD0:  MOVF   xD5,F
01DD2:  BNZ   1DDA
01DD4:  MOVF   xD4,W
01DD6:  SUBLW  80
01DD8:  BC    1DE0
01DDA:  MOVLW  03
01DDC:  MOVWF  01
01DDE:  BRA    1EB2
.................... 			config.modbus_address=value; 
01DE0:  MOVFF  2D4,36
.................... 			break; 
01DE4:  BRA    1EAE
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01DE6:  MOVLB  1
01DE8:  BSF    xAD.1
.................... 			config.adc_sample_ticks=value; 
01DEA:  MOVFF  2D5,3C
01DEE:  MOVFF  2D4,3B
.................... 			break; 
01DF2:  MOVLB  2
01DF4:  BRA    1EAE
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01DF6:  MOVLB  2
01DF8:  MOVF   xD5,F
01DFA:  BNZ   1E02
01DFC:  MOVF   xD4,W
01DFE:  SUBLW  01
01E00:  BC    1E08
01E02:  MOVLW  03
01E04:  MOVWF  01
01E06:  BRA    1EB2
.................... 			config.allow_bootload_request=value; 
01E08:  MOVFF  2D4,3D
.................... 			break; 
01E0C:  BRA    1EAE
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01E0E:  MOVFF  2D5,3F
01E12:  MOVFF  2D4,3E
.................... 			break; 
01E16:  MOVLB  2
01E18:  BRA    1EAE
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01E1A:  MOVLB  2
01E1C:  MOVF   xD4,F
01E1E:  BNZ   1E2A
01E20:  MOVF   xD5,F
01E22:  BNZ   1E2A
01E24:  MOVLW  03
01E26:  MOVWF  01
01E28:  BRA    1EB2
.................... 			config.pi_offtime_seconds=value; 
01E2A:  MOVFF  2D5,41
01E2E:  MOVFF  2D4,40
.................... 			break; 
01E32:  BRA    1EAE
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01E34:  MOVLB  2
01E36:  MOVF   xD5,F
01E38:  BNZ   1E40
01E3A:  MOVF   xD4,W
01E3C:  SUBLW  01
01E3E:  BC    1E46
01E40:  MOVLW  03
01E42:  MOVWF  01
01E44:  BRA    1EB2
.................... 			config.power_startup=value; 
01E46:  MOVFF  2D4,42
.................... 			break; 
01E4A:  BRA    1EAE
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01E4C:  MOVLB  2
01E4E:  DECFSZ xD4,W
01E50:  BRA    1E56
01E52:  MOVF   xD5,F
01E54:  BZ    1E5C
01E56:  MOVLW  03
01E58:  MOVWF  01
01E5A:  BRA    1EB2
.................... 			write_default_param_file(); 
01E5C:  MOVLB  0
01E5E:  CALL   0C02
.................... 			break; 
01E62:  MOVLB  2
01E64:  BRA    1EAE
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01E66:  MOVLB  2
01E68:  DECFSZ xD4,W
01E6A:  BRA    1E70
01E6C:  MOVF   xD5,F
01E6E:  BZ    1E76
01E70:  MOVLW  03
01E72:  MOVWF  01
01E74:  BRA    1EB2
.................... 			write_param_file(); 
01E76:  MOVLB  0
01E78:  CALL   0BAE
.................... 			break; 
01E7C:  MOVLB  2
01E7E:  BRA    1EAE
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01E80:  MOVLB  2
01E82:  MOVF   xD4,W
01E84:  SUBLW  0A
01E86:  BNZ   1E8E
01E88:  MOVF   xD5,W
01E8A:  SUBLW  07
01E8C:  BZ    1E9A
.................... 				current.factory_unlocked=0; 
01E8E:  MOVLB  1
01E90:  CLRF   x8E
.................... 				return ILLEGAL_DATA_VALUE; 
01E92:  MOVLW  03
01E94:  MOVWF  01
01E96:  MOVLB  2
01E98:  BRA    1EB2
.................... 			} 
.................... 			current.factory_unlocked=1; 
01E9A:  MOVLW  01
01E9C:  MOVLB  1
01E9E:  MOVWF  x8E
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01EA0:  MOVLW  C8
01EA2:  MOVWF  xAA
.................... 			break; 
01EA4:  MOVLB  2
01EA6:  BRA    1EAE
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01EA8:  MOVLW  02
01EAA:  MOVWF  01
01EAC:  BRA    1EB2
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01EAE:  MOVLW  00
01EB0:  MOVWF  01
.................... } 
01EB2:  MOVLB  0
01EB4:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
01F46:  GOTO   0FE0
01F4A:  MOVF   01,F
01F4C:  BTFSC  FD8.2
01F4E:  BRA    2176
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
01F50:  MOVF   36,W
01F52:  SUBLW  80
01F54:  BZ    1F62
01F56:  MOVF   36,W
01F58:  MOVLB  1
01F5A:  SUBWF  xB4,W
01F5C:  BTFSS  FD8.2
01F5E:  BRA    2162
01F60:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
01F62:  MOVLB  1
01F64:  INCFSZ x82,W
01F66:  BRA    1F6E
01F68:  INCFSZ x83,W
01F6A:  BRA    1F6E
01F6C:  BRA    1F74
.................... 				current.modbus_our_packets++; 
01F6E:  INCF   x82,F
01F70:  BTFSC  FD8.2
01F72:  INCF   x83,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
01F74:  MOVLW  14
01F76:  MOVWF  xAA
....................  
.................... 			switch(modbus_rx.func) { 
01F78:  MOVF   xB6,W
01F7A:  XORLW  03
01F7C:  MOVLB  0
01F7E:  BZ    1F90
01F80:  XORLW  07
01F82:  BZ    1F90
01F84:  XORLW  02
01F86:  BZ    2008
01F88:  XORLW  16
01F8A:  BTFSC  FD8.2
01F8C:  BRA    207A
01F8E:  BRA    213C
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01F90:  MOVFF  1B8,2C7
01F94:  MOVFF  1B9,2C6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01F98:  MOVFF  1BA,2C9
01F9C:  MOVFF  1BB,2C8
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
01FA0:  MOVLB  2
01FA2:  MOVF   xC8,W
01FA4:  ADDWF  xC6,W
01FA6:  MOVWF  xCC
01FA8:  MOVF   xC9,W
01FAA:  ADDWFC xC7,W
01FAC:  MOVWF  xCD
01FAE:  MOVFF  2C7,2CF
01FB2:  MOVFF  2C6,2CE
01FB6:  MOVWF  xD1
01FB8:  MOVFF  2CC,2D0
01FBC:  MOVLB  0
01FBE:  GOTO   1006
01FC2:  MOVF   01,F
01FC4:  BNZ   1FEA
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
01FC6:  MOVFF  1B4,2CC
01FCA:  MOVLB  2
01FCC:  CLRF   xCE
01FCE:  MOVFF  1B6,2CD
01FD2:  MOVLW  02
01FD4:  MOVWF  xCF
01FD6:  MOVLB  0
01FD8:  CALL   1122
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
01FDC:  MOVLB  1
01FDE:  CLRF   x87
01FE0:  MOVLW  02
01FE2:  MOVWF  x86
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
01FE4:  CLRF   xAA
.................... 					} else { 
01FE6:  BRA    2006
01FE8:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
01FEA:  MOVFF  1B6,2CC
01FEE:  MOVFF  1B4,2CD
01FF2:  MOVFF  2C7,2CF
01FF6:  MOVFF  2C6,2CE
01FFA:  MOVFF  2C9,2D1
01FFE:  MOVFF  2C8,2D0
02002:  BRA    1BF4
02004:  MOVLB  1
.................... 					} 
.................... 					break; 
02006:  BRA    215C
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02008:  MOVFF  1B8,2C7
0200C:  MOVFF  1B9,2C6
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02010:  MOVFF  1BA,2CD
02014:  MOVFF  1BB,2CC
02018:  MOVFF  2C7,2D3
0201C:  MOVFF  2C6,2D2
02020:  MOVFF  1BA,2D5
02024:  MOVFF  1BB,2D4
02028:  RCALL  1C76
0202A:  MOVFF  01,2CA
....................  
.................... 					if ( result ) { 
0202E:  MOVLB  2
02030:  MOVF   xCA,F
02032:  BZ    2056
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02034:  MOVFF  1B4,2CC
02038:  CLRF   xCE
0203A:  MOVFF  1B6,2CD
0203E:  MOVFF  2CA,2CF
02042:  MOVLB  0
02044:  CALL   1122
.................... 						current.modbus_last_error=result; 
02048:  MOVLB  1
0204A:  CLRF   x87
0204C:  MOVFF  2CA,186
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02050:  CLRF   xAA
.................... 					}  else { 
02052:  BRA    2078
02054:  MOVLB  2
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02056:  MOVFF  1BA,2CD
0205A:  MOVFF  1BB,2CC
0205E:  MOVFF  1B4,2CE
02062:  MOVFF  2C7,2D0
02066:  MOVFF  2C6,2CF
0206A:  MOVFF  1BA,2D2
0206E:  MOVFF  1BB,2D1
02072:  MOVLB  0
02074:  BRA    1EB6
02076:  MOVLB  1
.................... 					} 
.................... 					break; 
02078:  BRA    215C
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0207A:  MOVFF  1B8,2C7
0207E:  MOVFF  1B9,2C6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02082:  MOVFF  1BA,2C9
02086:  MOVFF  1BB,2C8
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
0208A:  MOVLB  2
0208C:  CLRF   xCB
0208E:  MOVF   xC9,F
02090:  BNZ   2098
02092:  MOVF   xC8,W
02094:  SUBWF  xCB,W
02096:  BC    211C
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02098:  MOVF   xCB,W
0209A:  ADDWF  xC6,W
0209C:  MOVWF  xCC
0209E:  MOVLW  00
020A0:  ADDWFC xC7,W
020A2:  MOVWF  xCD
020A4:  BCF    FD8.0
020A6:  RLCF   xCB,W
020A8:  ADDLW  05
020AA:  ADDLW  B8
020AC:  MOVWF  FE9
020AE:  MOVLW  01
020B0:  MOVWF  FEA
020B2:  BTFSC  FD8.0
020B4:  INCF   FEA,F
020B6:  MOVFF  FEF,2CE
020BA:  BCF    FD8.0
020BC:  RLCF   xCB,W
020BE:  ADDLW  06
020C0:  ADDLW  B8
020C2:  MOVWF  FE9
020C4:  MOVLW  01
020C6:  MOVWF  FEA
020C8:  BTFSC  FD8.0
020CA:  INCF   FEA,F
020CC:  MOVFF  FEF,2CF
020D0:  MOVFF  2CE,2D1
020D4:  MOVFF  2CF,2D0
020D8:  MOVFF  2CD,2D3
020DC:  MOVFF  2CC,2D2
020E0:  MOVFF  2CE,2D5
020E4:  MOVFF  2CF,2D4
020E8:  MOVLB  0
020EA:  RCALL  1C76
020EC:  MOVFF  01,2CA
....................  
.................... 						if ( result ) { 
020F0:  MOVLB  2
020F2:  MOVF   xCA,F
020F4:  BZ    2118
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
020F6:  MOVFF  1B4,2CC
020FA:  CLRF   xCE
020FC:  MOVFF  1B6,2CD
02100:  MOVFF  2CA,2CF
02104:  MOVLB  0
02106:  CALL   1122
.................... 							current.modbus_last_error=result; 
0210A:  MOVLB  1
0210C:  CLRF   x87
0210E:  MOVFF  2CA,186
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02112:  CLRF   xAA
.................... 			 
.................... 							break; 
02114:  MOVLB  2
02116:  BRA    211C
.................... 						} 
.................... 					} 
02118:  INCF   xCB,F
0211A:  BRA    208E
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
0211C:  MOVF   xCA,F
0211E:  BNZ   2138
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02120:  MOVFF  1B4,2CC
02124:  MOVFF  2C7,2CE
02128:  MOVFF  2C6,2CD
0212C:  MOVFF  2C9,2D0
02130:  MOVFF  2C8,2CF
02134:  MOVLB  0
02136:  BRA    1EFE
.................... 					} 
....................  
.................... 					break;   
02138:  MOVLB  1
0213A:  BRA    215C
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
0213C:  MOVFF  1B4,2CC
02140:  MOVLB  2
02142:  CLRF   xCE
02144:  MOVFF  1B6,2CD
02148:  MOVLW  01
0214A:  MOVWF  xCF
0214C:  MOVLB  0
0214E:  CALL   1122
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02152:  MOVLB  1
02154:  CLRF   x87
02156:  MOVLW  01
02158:  MOVWF  x86
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
0215A:  CLRF   xAA
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
0215C:  CLRF   x91
0215E:  CLRF   x90
....................  
.................... 		} else { 
02160:  BRA    2176
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02162:  INCFSZ x84,W
02164:  BRA    216C
02166:  INCFSZ x85,W
02168:  BRA    216C
0216A:  BRA    2172
.................... 				current.modbus_other_packets++; 
0216C:  INCF   x84,F
0216E:  BTFSC  FD8.2
02170:  INCF   x85,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02172:  MOVLW  14
02174:  MOVWF  xAA
02176:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02178:  GOTO   23F8 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003D6:  MOVLB  2
003D8:  BTFSS  xE8.0
003DA:  BRA    03F4
003DC:  MOVLB  1
003DE:  INCFSZ x99,W
003E0:  BRA    03EC
003E2:  INCFSZ x9A,W
003E4:  BRA    03EC
003E6:  MOVLB  2
003E8:  BRA    03F4
003EA:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
003EC:  INCF   x99,F
003EE:  BTFSC  FD8.2
003F0:  INCF   x9A,F
003F2:  MOVLB  2
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
003F4:  BTFSS  xE8.2
003F6:  BRA    0410
003F8:  MOVLB  1
003FA:  INCFSZ x9B,W
003FC:  BRA    0408
003FE:  INCFSZ x9C,W
00400:  BRA    0408
00402:  MOVLB  2
00404:  BRA    0410
00406:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00408:  INCF   x9B,F
0040A:  BTFSC  FD8.2
0040C:  INCF   x9C,F
0040E:  MOVLB  2
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
00410:  BTFSS  xE8.4
00412:  BRA    042C
00414:  MOVLB  1
00416:  INCFSZ x9D,W
00418:  BRA    0424
0041A:  INCFSZ x9E,W
0041C:  BRA    0424
0041E:  MOVLB  2
00420:  BRA    042C
00422:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00424:  INCF   x9D,F
00426:  BTFSC  FD8.2
00428:  INCF   x9E,F
0042A:  MOVLB  2
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
0042C:  BCF    xE8.1
0042E:  BTFSC  F81.0
00430:  BSF    xE8.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
00432:  BTFSC  xE8.1
00434:  BRA    04BA
00436:  MOVLB  1
00438:  BTFSC  xB0.1
0043A:  BRA    0440
0043C:  MOVLB  2
0043E:  BRA    04BA
.................... 		current.pulse_count[0]++; 
00440:  INCF   5F,F
00442:  BTFSS  FD8.2
00444:  BRA    044C
00446:  MOVLB  0
00448:  INCF   x60,F
0044A:  MOVLB  1
.................... 		current.pulse_sum[0]++; 
0044C:  MOVLW  01
0044E:  MOVLB  0
00450:  ADDWF  x65,F
00452:  BTFSC  FD8.0
00454:  INCF   x66,F
00456:  BTFSC  FD8.2
00458:  INCF   x67,F
0045A:  BTFSC  FD8.2
0045C:  INCF   x68,F
.................... 		if ( 1 == ext0_state ) { 
0045E:  MOVLB  1
00460:  BTFSS  xB0.2
00462:  BRA    04AA
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
00464:  MOVLB  2
00466:  BCF    xE8.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
00468:  MOVFF  19A,4E
0046C:  MOVFF  199,4D
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
00470:  MOVF   4E,W
00472:  SUBWF  54,W
00474:  BNC   0486
00476:  BNZ   047E
00478:  MOVF   53,W
0047A:  SUBWF  4D,W
0047C:  BC    0486
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
0047E:  MOVFF  4E,54
00482:  MOVFF  4D,53
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
00486:  MOVF   5A,W
00488:  SUBWF  4E,W
0048A:  BNC   04A6
0048C:  BNZ   0494
0048E:  MOVF   4D,W
00490:  SUBWF  59,W
00492:  BC    04A6
00494:  INCFSZ 4D,W
00496:  BRA    049E
00498:  INCFSZ 4E,W
0049A:  BRA    049E
0049C:  BRA    04A6
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
0049E:  MOVFF  4E,5A
004A2:  MOVFF  4D,59
.................... 			} 
.................... 			ext0_state=0; 
004A6:  MOVLB  1
004A8:  BCF    xB0.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004AA:  BTFSC  xB0.2
004AC:  BRA    04BA
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004AE:  CLRF   x9A
004B0:  CLRF   x99
.................... 			ext0_count=1; 
004B2:  MOVLB  2
004B4:  BSF    xE8.0
.................... 			ext0_state=1; 
004B6:  MOVLB  1
004B8:  BSF    xB0.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004BA:  MOVLB  1
004BC:  BCF    xB0.1
004BE:  MOVLB  2
004C0:  BTFSS  xE8.1
004C2:  BRA    04CA
004C4:  MOVLB  1
004C6:  BSF    xB0.1
004C8:  MOVLB  2
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004CA:  BCF    xE8.3
004CC:  BTFSC  F81.1
004CE:  BSF    xE8.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004D0:  BTFSC  xE8.3
004D2:  BRA    0552
004D4:  MOVLB  1
004D6:  BTFSC  xB0.3
004D8:  BRA    04DE
004DA:  MOVLB  2
004DC:  BRA    0552
.................... 		current.pulse_count[1]++; 
004DE:  MOVLB  0
004E0:  INCF   x61,F
004E2:  BTFSC  FD8.2
004E4:  INCF   x62,F
.................... 		current.pulse_sum[1]++; 
004E6:  MOVLW  01
004E8:  ADDWF  x69,F
004EA:  BTFSC  FD8.0
004EC:  INCF   x6A,F
004EE:  BTFSC  FD8.2
004F0:  INCF   x6B,F
004F2:  BTFSC  FD8.2
004F4:  INCF   x6C,F
.................... 		if ( 1 == ext1_state ) { 
004F6:  MOVLB  1
004F8:  BTFSS  xB0.4
004FA:  BRA    0542
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
004FC:  MOVLB  2
004FE:  BCF    xE8.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00500:  MOVFF  19C,50
00504:  MOVFF  19B,4F
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00508:  MOVF   50,W
0050A:  SUBWF  56,W
0050C:  BNC   051E
0050E:  BNZ   0516
00510:  MOVF   55,W
00512:  SUBWF  4F,W
00514:  BC    051E
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00516:  MOVFF  50,56
0051A:  MOVFF  4F,55
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0051E:  MOVF   5C,W
00520:  SUBWF  50,W
00522:  BNC   053E
00524:  BNZ   052C
00526:  MOVF   4F,W
00528:  SUBWF  5B,W
0052A:  BC    053E
0052C:  INCFSZ 4F,W
0052E:  BRA    0536
00530:  INCFSZ 50,W
00532:  BRA    0536
00534:  BRA    053E
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
00536:  MOVFF  50,5C
0053A:  MOVFF  4F,5B
.................... 			} 
.................... 			ext1_state=0; 
0053E:  MOVLB  1
00540:  BCF    xB0.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
00542:  BTFSC  xB0.4
00544:  BRA    0552
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
00546:  CLRF   x9C
00548:  CLRF   x9B
.................... 			ext1_count=1; 
0054A:  MOVLB  2
0054C:  BSF    xE8.2
.................... 			ext1_state=1; 
0054E:  MOVLB  1
00550:  BSF    xB0.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
00552:  MOVLB  1
00554:  BCF    xB0.3
00556:  MOVLB  2
00558:  BTFSS  xE8.3
0055A:  BRA    0562
0055C:  MOVLB  1
0055E:  BSF    xB0.3
00560:  MOVLB  2
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
00562:  BCF    xE8.5
00564:  BTFSC  F81.2
00566:  BSF    xE8.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00568:  BTFSC  xE8.5
0056A:  BRA    05EA
0056C:  MOVLB  1
0056E:  BTFSC  xB0.5
00570:  BRA    0576
00572:  MOVLB  2
00574:  BRA    05EA
.................... 		current.pulse_count[2]++; 
00576:  MOVLB  0
00578:  INCF   x63,F
0057A:  BTFSC  FD8.2
0057C:  INCF   x64,F
.................... 		current.pulse_sum[2]++; 
0057E:  MOVLW  01
00580:  ADDWF  x6D,F
00582:  BTFSC  FD8.0
00584:  INCF   x6E,F
00586:  BTFSC  FD8.2
00588:  INCF   x6F,F
0058A:  BTFSC  FD8.2
0058C:  INCF   x70,F
.................... 		if ( 1 == ext2_state ) { 
0058E:  MOVLB  1
00590:  BTFSS  xB0.6
00592:  BRA    05DA
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
00594:  MOVLB  2
00596:  BCF    xE8.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00598:  MOVFF  19E,52
0059C:  MOVFF  19D,51
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005A0:  MOVF   52,W
005A2:  SUBWF  58,W
005A4:  BNC   05B6
005A6:  BNZ   05AE
005A8:  MOVF   57,W
005AA:  SUBWF  51,W
005AC:  BC    05B6
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005AE:  MOVFF  52,58
005B2:  MOVFF  51,57
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005B6:  MOVF   5E,W
005B8:  SUBWF  52,W
005BA:  BNC   05D6
005BC:  BNZ   05C4
005BE:  MOVF   51,W
005C0:  SUBWF  5D,W
005C2:  BC    05D6
005C4:  INCFSZ 51,W
005C6:  BRA    05CE
005C8:  INCFSZ 52,W
005CA:  BRA    05CE
005CC:  BRA    05D6
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005CE:  MOVFF  52,5E
005D2:  MOVFF  51,5D
.................... 			} 
.................... 			ext2_state=0; 
005D6:  MOVLB  1
005D8:  BCF    xB0.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005DA:  BTFSC  xB0.6
005DC:  BRA    05EA
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005DE:  CLRF   x9E
005E0:  CLRF   x9D
.................... 			ext2_count=1; 
005E2:  MOVLB  2
005E4:  BSF    xE8.4
.................... 			ext2_state=1; 
005E6:  MOVLB  1
005E8:  BSF    xB0.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
005EA:  MOVLB  1
005EC:  BCF    xB0.5
005EE:  MOVLB  2
005F0:  BTFSS  xE8.5
005F2:  BRA    05FA
005F4:  MOVLB  1
005F6:  BSF    xB0.5
005F8:  MOVLB  2
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
005FA:  INCF   xBB,F
.................... 	if ( 10 == tick ) { 
005FC:  MOVF   xBB,W
005FE:  SUBLW  0A
00600:  BNZ   060A
.................... 		tick=0; 
00602:  CLRF   xBB
.................... 		timers.now_millisecond=1; 
00604:  MOVLB  1
00606:  BSF    xAD.2
00608:  MOVLB  2
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
0060A:  BCF    F9E.1
0060C:  MOVLB  0
0060E:  GOTO   0122
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(MODBUS_SERIAL); 
*
0065E:  RCALL  0612
00660:  MOVFF  01,2E5
....................  
.................... 	if ( current.bridged_uarts ) { 
00664:  MOVLB  1
00666:  BTFSS  x8F.0
00668:  BRA    0676
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,DEBUG); 
0066A:  MOVLB  2
0066C:  MOVF   xE5,W
0066E:  MOVLB  0
00670:  BRA    0628
.................... 		return; 
00672:  BRA    06CE
00674:  MOVLB  1
.................... 	}  
....................  
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
00676:  BTFSC  xB0.0
00678:  BRA    06D0
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
0067A:  MOVF   xB1,F
0067C:  BNZ   068E
.................... 			modbus_serial_crc.d = 0xFFFF; 
0067E:  SETF   xB3
00680:  SETF   xB2
.................... 			modbus_rx.address = c; 
00682:  MOVFF  2E5,1B4
.................... 			modbus_serial_state++; 
00686:  INCF   xB1,F
.................... 			modbus_rx.len = 0; 
00688:  CLRF   xB5
.................... 			modbus_rx.error=0; 
0068A:  CLRF   xB7
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
0068C:  BRA    06BC
0068E:  DECFSZ xB1,W
00690:  BRA    069A
.................... 			modbus_rx.func = c; 
00692:  MOVFF  2E5,1B6
.................... 			modbus_serial_state++; 
00696:  INCF   xB1,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00698:  BRA    06BC
0069A:  MOVF   xB1,W
0069C:  SUBLW  02
0069E:  BNZ   06BC
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
006A0:  INCFSZ xB5,W
006A2:  BRA    06A8
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
006A4:  MOVLW  FE
006A6:  MOVWF  xB5
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
006A8:  MOVLW  B8
006AA:  ADDWF  xB5,W
006AC:  MOVWF  FE9
006AE:  MOVLW  01
006B0:  MOVWF  FEA
006B2:  BTFSC  FD8.0
006B4:  INCF   FEA,F
006B6:  MOVFF  2E5,FEF
.................... 			modbus_rx.len++; 
006BA:  INCF   xB5,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
006BC:  MOVFF  2E5,2E6
006C0:  MOVLB  0
006C2:  RCALL  0632
.................... 		modbus_enable_timeout(TRUE); 
006C4:  MOVLW  01
006C6:  MOVLB  2
006C8:  MOVWF  xE6
006CA:  MOVLB  0
006CC:  RCALL  0390
006CE:  MOVLB  1
.................... 	} 
.................... } 
....................  
....................  
....................  
006D0:  BCF    F9E.5
006D2:  MOVLB  0
006D4:  GOTO   007C
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00846:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00848:  MOVLW  08
0084A:  MOVWF  F61
0084C:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
0084E:  MOVLW  00
00850:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
00852:  MOVLW  FF
00854:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00856:  MOVLW  92
00858:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
0085A:  MOVLW  80
0085C:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
0085E:  BCF    F96.0
00860:  BCF    F96.1
00862:  BCF    F96.2
00864:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00866:  MOVLB  1
00868:  CLRF   xAA
.................... 	timers.load_off_seconds=2; 
0086A:  CLRF   xAC
0086C:  MOVLW  02
0086E:  MOVWF  xAB
.................... 	timers.now_adc_sample=0; 
00870:  BCF    xAD.0
.................... 	timers.now_adc_reset_count=0; 
00872:  BCF    xAD.1
.................... 	timers.now_millisecond=0; 
00874:  BCF    xAD.2
.................... 	timers.port_b=0b11111111; 
00876:  SETF   xAE
.................... 	timers.port_c=0b11111111; 
00878:  SETF   xAF
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
0087A:  MOVLB  2
0087C:  CLRF   xC6
0087E:  MOVF   xC6,W
00880:  SUBLW  02
00882:  BNC   0930
.................... 		current.pulse_period[i]=0; 
00884:  CLRF   03
00886:  MOVFF  2C6,02
0088A:  BCF    FD8.0
0088C:  RLCF   02,F
0088E:  RLCF   03,F
00890:  MOVF   02,W
00892:  ADDLW  4D
00894:  MOVWF  FE9
00896:  MOVLW  00
00898:  ADDWFC 03,W
0089A:  MOVWF  FEA
0089C:  CLRF   FEC
0089E:  MOVF   FED,F
008A0:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
008A2:  CLRF   03
008A4:  MOVFF  2C6,02
008A8:  BCF    FD8.0
008AA:  RLCF   02,F
008AC:  RLCF   03,F
008AE:  MOVF   02,W
008B0:  ADDLW  53
008B2:  MOVWF  FE9
008B4:  MOVLW  00
008B6:  ADDWFC 03,W
008B8:  MOVWF  FEA
008BA:  SETF   FEC
008BC:  MOVF   FED,F
008BE:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
008C0:  CLRF   03
008C2:  MOVFF  2C6,02
008C6:  BCF    FD8.0
008C8:  RLCF   02,F
008CA:  RLCF   03,F
008CC:  MOVF   02,W
008CE:  ADDLW  59
008D0:  MOVWF  FE9
008D2:  MOVLW  00
008D4:  ADDWFC 03,W
008D6:  MOVWF  FEA
008D8:  CLRF   FEC
008DA:  MOVF   FED,F
008DC:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
008DE:  CLRF   03
008E0:  MOVFF  2C6,02
008E4:  BCF    FD8.0
008E6:  RLCF   02,F
008E8:  RLCF   03,F
008EA:  MOVF   02,W
008EC:  ADDLW  5F
008EE:  MOVWF  FE9
008F0:  MOVLW  00
008F2:  ADDWFC 03,W
008F4:  MOVWF  FEA
008F6:  CLRF   FEC
008F8:  MOVF   FED,F
008FA:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
008FC:  CLRF   xE1
008FE:  MOVFF  2C6,2E0
00902:  CLRF   xE3
00904:  MOVLW  04
00906:  MOVWF  xE2
00908:  MOVLB  0
0090A:  RCALL  0824
0090C:  MOVF   01,W
0090E:  ADDLW  65
00910:  MOVWF  FE9
00912:  MOVLW  00
00914:  ADDWFC 02,W
00916:  MOVWF  FEA
00918:  MOVF   FEE,F
0091A:  MOVF   FEE,F
0091C:  CLRF   FEC
0091E:  MOVF   FED,F
00920:  CLRF   FEF
00922:  MOVF   FED,F
00924:  CLRF   FEF
00926:  MOVF   FED,F
00928:  CLRF   FEF
.................... 	} 
0092A:  MOVLB  2
0092C:  INCF   xC6,F
0092E:  BRA    087E
....................  
.................... 	current.modbus_our_packets=0; 
00930:  MOVLB  1
00932:  CLRF   x83
00934:  CLRF   x82
.................... 	current.modbus_other_packets=0; 
00936:  CLRF   x85
00938:  CLRF   x84
.................... 	current.modbus_last_error=0; 
0093A:  CLRF   x87
0093C:  CLRF   x86
.................... 	current.sequence_number=0; 
0093E:  CLRF   x89
00940:  CLRF   x88
.................... 	current.uptime_minutes=0; 
00942:  CLRF   x8B
00944:  CLRF   x8A
.................... 	current.interval_milliseconds=0; 
00946:  CLRF   x8D
00948:  CLRF   x8C
.................... 	current.adc_buffer_index=0; 
0094A:  CLRF   x81
.................... 	current.factory_unlocked=0; 
0094C:  CLRF   x8E
.................... 	current.bridged_uarts=0; 
0094E:  BCF    x8F.0
.................... 	current.watchdog_seconds=0; 
00950:  CLRF   x91
00952:  CLRF   x90
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00954:  MOVFF  4A,194
00958:  MOVFF  49,193
.................... 	current.power_off_delay=config.power_off_below_delay; 
0095C:  MOVFF  46,196
00960:  MOVFF  45,195
.................... 	current.power_override_timeout=0; 
00964:  CLRF   x98
00966:  CLRF   x97
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
00968:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
0096A:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
0096C:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
0096E:  MOVLW  00
00970:  IORLW  05
00972:  MOVWF  FBA
00974:  MOVLW  4A
00976:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00978:  BSF    F9D.1
.................... //	enable_interrupts(INT_RDA2); /* debug cable */ 
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
0097A:  MOVLB  0
0097C:  GOTO   221C (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00E80:  MOVLB  1
00E82:  BCF    xAD.2
....................  
.................... //	fputc('.',DEBUG); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(DEBUG,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00E84:  BCF    FD8.0
00E86:  MOVLB  2
00E88:  RLCF   xC1,W
00E8A:  MOVWF  xC6
00E8C:  RLCF   xC2,W
00E8E:  MOVWF  xC7
00E90:  MOVLW  00
00E92:  MOVLB  1
00E94:  BTFSS  xAF.5
00E96:  MOVLW  01
00E98:  MOVLB  2
00E9A:  IORWF  xC6,F
00E9C:  MOVFF  2C6,2C1
00EA0:  MOVF   xC7,W
00EA2:  IORLW  E0
00EA4:  MOVWF  xC2
.................... 	if ( b2_state==0xf000) { 
00EA6:  MOVF   xC1,F
00EA8:  BNZ   0EB0
00EAA:  MOVF   xC2,W
00EAC:  SUBLW  F0
00EAE:  BNZ   0EB0
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00EB0:  MOVLB  1
00EB2:  INCFSZ x99,W
00EB4:  BRA    0EBE
00EB6:  INCFSZ x9A,W
00EB8:  BRA    0EBE
.................... 				current.pulse_period[0]=0; 
00EBA:  CLRF   4E
00EBC:  CLRF   4D
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00EBE:  INCFSZ x9B,W
00EC0:  BRA    0ECA
00EC2:  INCFSZ x9C,W
00EC4:  BRA    0ECA
.................... 				current.pulse_period[1]=0; 
00EC6:  CLRF   50
00EC8:  CLRF   4F
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00ECA:  INCFSZ x9D,W
00ECC:  BRA    0ED6
00ECE:  INCFSZ x9E,W
00ED0:  BRA    0ED6
.................... 				current.pulse_period[2]=0; 
00ED2:  CLRF   52
00ED4:  CLRF   51
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00ED6:  MOVFF  F81,1AE
.................... 	timers.port_c=port_c; 
00EDA:  MOVFF  F82,1AF
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00EDE:  BTFSS  x8F.0
00EE0:  BRA    0EE6
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00EE2:  BSF    F89.3
.................... 	} else { 
00EE4:  BRA    0EF2
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00EE6:  MOVF   xAA,F
00EE8:  BNZ   0EEE
.................... 			output_low(LED_GREEN); 
00EEA:  BCF    F89.3
.................... 		} else { 
00EEC:  BRA    0EF2
.................... 			output_high(LED_GREEN); 
00EEE:  BSF    F89.3
.................... 			timers.led_on_green--; 
00EF0:  DECF   xAA,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00EF2:  INCFSZ x8C,W
00EF4:  BRA    0EFC
00EF6:  INCFSZ x8D,W
00EF8:  BRA    0EFC
00EFA:  BRA    0F02
.................... 		current.interval_milliseconds++; 
00EFC:  INCF   x8C,F
00EFE:  BTFSC  FD8.2
00F00:  INCF   x8D,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00F02:  MOVLB  2
00F04:  INCF   xBF,F
00F06:  BTFSC  FD8.2
00F08:  INCF   xC0,F
.................... 	if ( 1000 == ticks ) { 
00F0A:  MOVF   xBF,W
00F0C:  SUBLW  E8
00F0E:  BNZ   0F94
00F10:  MOVF   xC0,W
00F12:  SUBLW  03
00F14:  BNZ   0F94
.................... 		ticks=0; 
00F16:  CLRF   xC0
00F18:  CLRF   xBF
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00F1A:  MOVLB  1
00F1C:  INCFSZ x90,W
00F1E:  BRA    0F26
00F20:  INCFSZ x91,W
00F22:  BRA    0F26
00F24:  BRA    0F2C
.................... 			current.watchdog_seconds++; 
00F26:  INCF   x90,F
00F28:  BTFSC  FD8.2
00F2A:  INCF   x91,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00F2C:  MOVF   3E,F
00F2E:  BNZ   0F34
00F30:  MOVF   3F,F
00F32:  BZ    0F52
00F34:  MOVF   3F,W
00F36:  SUBWF  x91,W
00F38:  BNC   0F52
00F3A:  BNZ   0F42
00F3C:  MOVF   x90,W
00F3E:  SUBWF  3E,W
00F40:  BC    0F52
00F42:  MOVF   xAB,F
00F44:  BNZ   0F52
00F46:  MOVF   xAC,F
00F48:  BNZ   0F52
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00F4A:  MOVFF  41,1AC
00F4E:  MOVFF  40,1AB
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00F52:  MOVF   xAB,F
00F54:  BNZ   0F5E
00F56:  MOVF   xAC,F
00F58:  BNZ   0F5E
.................... 			output_high(PI_POWER_EN); 
00F5A:  BSF    F8B.0
.................... 		} else { 
00F5C:  BRA    0F74
.................... 			output_low(PI_POWER_EN); 
00F5E:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00F60:  MOVF   xAB,W
00F62:  BTFSC  FD8.2
00F64:  DECF   xAC,F
00F66:  DECF   xAB,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00F68:  MOVF   xAB,F
00F6A:  BNZ   0F74
00F6C:  MOVF   xAC,F
00F6E:  BNZ   0F74
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00F70:  CLRF   x91
00F72:  CLRF   x90
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00F74:  MOVLB  2
00F76:  INCF   xBC,F
.................... 		if ( 60 == uptimeTicks ) { 
00F78:  MOVF   xBC,W
00F7A:  SUBLW  3C
00F7C:  BNZ   0F94
.................... 			uptimeTicks=0; 
00F7E:  CLRF   xBC
.................... 			if ( current.uptime_minutes < 65535 )  
00F80:  MOVLB  1
00F82:  INCFSZ x8A,W
00F84:  BRA    0F8C
00F86:  INCFSZ x8B,W
00F88:  BRA    0F8C
00F8A:  BRA    0F92
.................... 				current.uptime_minutes++; 
00F8C:  INCF   x8A,F
00F8E:  BTFSC  FD8.2
00F90:  INCF   x8B,F
00F92:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00F94:  INCFSZ xC3,W
00F96:  BRA    0FAA
00F98:  INCFSZ xC4,W
00F9A:  BRA    0FAA
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00F9C:  CLRF   xDA
00F9E:  MOVLB  0
00FA0:  RCALL  0DF8
00FA2:  MOVFF  02,2C4
00FA6:  MOVFF  01,2C3
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00FAA:  MOVLB  1
00FAC:  BTFSS  xAD.1
00FAE:  BRA    0FB8
.................... 		timers.now_adc_reset_count=0; 
00FB0:  BCF    xAD.1
.................... 		adcTicks=0; 
00FB2:  MOVLB  2
00FB4:  CLRF   xBE
00FB6:  CLRF   xBD
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00FB8:  MOVLB  2
00FBA:  INCF   xBD,F
00FBC:  BTFSC  FD8.2
00FBE:  INCF   xBE,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00FC0:  MOVF   3B,W
00FC2:  SUBWF  xBD,W
00FC4:  BNZ   0FDA
00FC6:  MOVF   3C,W
00FC8:  SUBWF  xBE,W
00FCA:  BNZ   0FDA
.................... 		adcTicks=0; 
00FCC:  CLRF   xBE
00FCE:  CLRF   xBD
.................... 		timers.now_adc_sample=1; 
00FD0:  MOVLB  1
00FD2:  BSF    xAD.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00FD4:  MOVLB  2
00FD6:  SETF   xC4
00FD8:  SETF   xC3
.................... 	} 
....................  
....................  
....................  
.................... } 
00FDA:  MOVLB  0
00FDC:  GOTO   23E6 (RETURN)
....................  
....................  
.................... void main(void) { 
*
0217C:  CLRF   FF8
0217E:  BCF    FF1.2
02180:  BSF    F9F.1
02182:  BCF    F9F.5
02184:  BSF    FD0.7
02186:  BSF    07.7
02188:  CLRF   FEA
0218A:  CLRF   FE9
0218C:  CLRF   35
0218E:  BCF    FB8.3
02190:  MOVLW  0C
02192:  MOVWF  FAF
02194:  MOVLW  A6
02196:  MOVWF  FAC
02198:  MOVLW  90
0219A:  MOVWF  FAB
0219C:  BCF    F70.3
0219E:  MOVLW  4D
021A0:  MOVWF  F75
021A2:  MOVLW  A6
021A4:  MOVWF  F72
021A6:  MOVLW  90
021A8:  MOVWF  F71
021AA:  MOVLB  1
021AC:  BCF    xB0.0
021AE:  CLRF   xB1
021B0:  MOVLB  2
021B2:  CLRF   xBB
021B4:  MOVLB  1
021B6:  BCF    xB0.1
021B8:  BCF    xB0.2
021BA:  BCF    xB0.3
021BC:  BCF    xB0.4
021BE:  BCF    xB0.5
021C0:  BCF    xB0.6
021C2:  MOVLB  2
021C4:  CLRF   xBC
021C6:  CLRF   xBE
021C8:  CLRF   xBD
021CA:  CLRF   xC0
021CC:  CLRF   xBF
021CE:  CLRF   xC2
021D0:  CLRF   xC1
021D2:  MOVF   FC1,W
021D4:  ANDLW  F0
021D6:  MOVWF  FC1
021D8:  MOVLW  00
021DA:  MOVLB  F
021DC:  MOVWF  x38
021DE:  MOVWF  x3C
021E0:  MOVWF  x39
021E2:  MOVWF  x3A
021E4:  MOVWF  x3B
021E6:  MOVLB  1
021E8:  CLRF   x88
021EA:  CLRF   F77
021EC:  CLRF   F78
021EE:  CLRF   F79
021F0:  CLRF   2F
021F2:  CLRF   30
021F4:  MOVLB  2
021F6:  CLRF   xB7
021F8:  CLRF   xB8
021FA:  CLRF   xB9
021FC:  CLRF   xBA
021FE:  CLRF   xC3
02200:  CLRF   xC4
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02202:  MOVF   FD0,W
02204:  ANDLW  0F
02206:  BTFSS  FD0.4
02208:  MOVLW  00
0220A:  BSF    FD0.0
0220C:  BSF    FD0.1
0220E:  BSF    FD0.4
02210:  BSF    FD8.3
02212:  BSF    FD8.4
02214:  MOVWF  xC5
....................  
.................... 	init(); 
02216:  MOVLB  0
02218:  GOTO   0846
....................  
....................  
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
0221C:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
0221E:  BSF    F8C.0
....................  
.................... 	fprintf(DEBUG,"# pcwx %s\r\n",__DATE__); 
02220:  MOVLW  D8
02222:  MOVWF  FF6
02224:  MOVLW  06
02226:  MOVWF  FF7
02228:  MOVLW  07
0222A:  MOVLB  2
0222C:  MOVWF  xC7
0222E:  MOVLB  0
02230:  CALL   0980
02234:  MOVLW  E4
02236:  MOVWF  FF6
02238:  MOVLW  06
0223A:  MOVWF  FF7
0223C:  CALL   09AA
02240:  MOVLW  0D
02242:  BTFSS  FA4.4
02244:  BRA    2242
02246:  MOVWF  F73
02248:  MOVLW  0A
0224A:  BTFSS  FA4.4
0224C:  BRA    224A
0224E:  MOVWF  F73
.................... 	fprintf(DEBUG,"# restart_cause()=%u ",i); 
02250:  MOVLW  EE
02252:  MOVWF  FF6
02254:  MOVLW  06
02256:  MOVWF  FF7
02258:  MOVLW  12
0225A:  MOVLB  2
0225C:  MOVWF  xC7
0225E:  MOVLB  0
02260:  CALL   0980
02264:  MOVFF  2C5,2C7
02268:  MOVLW  1B
0226A:  MOVLB  2
0226C:  MOVWF  xC8
0226E:  MOVLB  0
02270:  CALL   09F8
02274:  MOVLW  20
02276:  BTFSS  FA4.4
02278:  BRA    2276
0227A:  MOVWF  F73
.................... 	switch ( i ) { 
0227C:  MOVLB  2
0227E:  MOVF   xC5,W
02280:  XORLW  07
02282:  MOVLB  0
02284:  BZ    22A0
02286:  XORLW  0C
02288:  BZ    22AE
0228A:  XORLW  04
0228C:  BZ    22BC
0228E:  XORLW  03
02290:  BZ    22CA
02292:  XORLW  02
02294:  BZ    22D8
02296:  XORLW  0D
02298:  BZ    22E6
0229A:  XORLW  03
0229C:  BZ    22F4
0229E:  BRA    2302
.................... 		case WDT_TIMEOUT: fprintf(DEBUG,"WDT_TIMEOUT"); break; 
022A0:  MOVLW  04
022A2:  MOVWF  FF6
022A4:  MOVLW  07
022A6:  MOVWF  FF7
022A8:  CALL   09AA
022AC:  BRA    230E
.................... 		case MCLR_FROM_SLEEP: fprintf(DEBUG,"MCLR_FROM_SLEEP"); break; 
022AE:  MOVLW  10
022B0:  MOVWF  FF6
022B2:  MOVLW  07
022B4:  MOVWF  FF7
022B6:  CALL   09AA
022BA:  BRA    230E
.................... 		case MCLR_FROM_RUN: fprintf(DEBUG,"MCLR_FROM_RUN"); break; 
022BC:  MOVLW  20
022BE:  MOVWF  FF6
022C0:  MOVLW  07
022C2:  MOVWF  FF7
022C4:  CALL   09AA
022C8:  BRA    230E
.................... 		case NORMAL_POWER_UP: fprintf(DEBUG,"NORMAL_POWER_UP"); break; 
022CA:  MOVLW  2E
022CC:  MOVWF  FF6
022CE:  MOVLW  07
022D0:  MOVWF  FF7
022D2:  CALL   09AA
022D6:  BRA    230E
.................... 		case BROWNOUT_RESTART: fprintf(DEBUG,"BROWNOUT_RESTART"); break; 
022D8:  MOVLW  3E
022DA:  MOVWF  FF6
022DC:  MOVLW  07
022DE:  MOVWF  FF7
022E0:  CALL   09AA
022E4:  BRA    230E
.................... 		case WDT_FROM_SLEEP: fprintf(DEBUG,"WDT_FROM_SLEEP"); break; 
022E6:  MOVLW  50
022E8:  MOVWF  FF6
022EA:  MOVLW  07
022EC:  MOVWF  FF7
022EE:  CALL   09AA
022F2:  BRA    230E
.................... 		case RESET_INSTRUCTION: fprintf(DEBUG,"RESET_INSTRUCTION"); break; 
022F4:  MOVLW  60
022F6:  MOVWF  FF6
022F8:  MOVLW  07
022FA:  MOVWF  FF7
022FC:  CALL   09AA
02300:  BRA    230E
.................... 		default: fprintf(DEBUG,"unknown!"); 
02302:  MOVLW  72
02304:  MOVWF  FF6
02306:  MOVLW  07
02308:  MOVWF  FF7
0230A:  CALL   09AA
.................... 	} 
.................... 	fprintf(DEBUG,"\r\n"); 
0230E:  MOVLW  7C
02310:  MOVWF  FF6
02312:  MOVLW  07
02314:  MOVWF  FF7
02316:  CALL   09AA
....................  
.................... 	fprintf(DEBUG,"# read_param_file() starting ..."); 
0231A:  MOVLW  80
0231C:  MOVWF  FF6
0231E:  MOVLW  07
02320:  MOVWF  FF7
02322:  CALL   09AA
.................... 	read_param_file(); 
02326:  GOTO   0C36
.................... 	fprintf(DEBUG," complete\r\n"); 
0232A:  MOVLW  A2
0232C:  MOVWF  FF6
0232E:  MOVLW  07
02330:  MOVWF  FF7
02332:  CALL   09AA
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02336:  MOVF   36,W
02338:  SUBLW  80
0233A:  BC    2358
.................... 		fprintf(DEBUG,"# write_default_param_file() starting ..."); 
0233C:  MOVLW  AE
0233E:  MOVWF  FF6
02340:  MOVLW  07
02342:  MOVWF  FF7
02344:  CALL   09AA
.................... 		write_default_param_file(); 
02348:  CALL   0C02
.................... 		fprintf(DEBUG," complete\r\n"); 
0234C:  MOVLW  D8
0234E:  MOVWF  FF6
02350:  MOVLW  07
02352:  MOVWF  FF7
02354:  CALL   09AA
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02358:  BSF    FAB.7
0235A:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	fprintf(DEBUG,"# modbus_init() starting ..."); 
0235C:  MOVLW  E4
0235E:  MOVWF  FF6
02360:  MOVLW  07
02362:  MOVWF  FF7
02364:  CALL   09AA
.................... 	modbus_init(); 
02368:  GOTO   0C94
.................... 	fprintf(DEBUG," complete\r\n"); 
0236C:  MOVLW  02
0236E:  MOVWF  FF6
02370:  MOVLW  08
02372:  MOVWF  FF7
02374:  CALL   09AA
....................  
.................... 	fprintf(DEBUG,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
02378:  MOVLW  00
0237A:  MOVLB  1
0237C:  BTFSC  x8F.0
0237E:  MOVLW  01
02380:  MOVLB  2
02382:  MOVWF  xC6
02384:  MOVLW  0E
02386:  MOVWF  FF6
02388:  MOVLW  08
0238A:  MOVWF  FF7
0238C:  MOVLW  10
0238E:  MOVWF  xC7
02390:  MOVLB  0
02392:  CALL   0980
02396:  MOVFF  2C6,2C7
0239A:  MOVLW  1B
0239C:  MOVLB  2
0239E:  MOVWF  xC8
023A0:  MOVLB  0
023A2:  CALL   09F8
023A6:  MOVLW  0D
023A8:  BTFSS  FA4.4
023AA:  BRA    23A8
023AC:  MOVWF  F73
023AE:  MOVLW  0A
023B0:  BTFSS  FA4.4
023B2:  BRA    23B0
023B4:  MOVWF  F73
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
023B6:  MOVLB  2
023B8:  CLRF   xC5
023BA:  MOVF   xC5,W
023BC:  SUBLW  1D
023BE:  BNC   23CC
.................... 		adc_update(); 
023C0:  MOVLB  0
023C2:  CALL   0D52
.................... 	} 
023C6:  MOVLB  2
023C8:  INCF   xC5,F
023CA:  BRA    23BA
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
023CC:  MOVFF  42,192
....................  
....................  
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
023D0:  BTFSS  F72.1
023D2:  BRA    23D0
.................... 	output_low(RS485_DE); 
023D4:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
023D6:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
....................  
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
023D8:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(DEBUG) ) { 
.................... 				fputc(fgetc(DEBUG),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
023DA:  MOVLB  1
023DC:  BTFSS  xAD.2
023DE:  BRA    23E8
.................... 			periodic_millisecond(); 
023E0:  MOVLB  0
023E2:  GOTO   0E80
023E6:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
023E8:  BTFSS  xAD.0
023EA:  BRA    23F4
.................... 			timers.now_adc_sample=0; 
023EC:  BCF    xAD.0
.................... 			adc_update(); 
023EE:  MOVLB  0
023F0:  CALL   0D52
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
023F4:  MOVLB  0
023F6:  BRA    1F46
.................... //		} 
....................  
.................... 	} 
023F8:  MOVLB  2
023FA:  BRA    23D8
.................... } 
023FC:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
