CCS PCH C Compiler, Version 4.135, 4375               20-Nov-15 16:54

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 9664 bytes (15%)
                         Largest free fragment is 55868
               RAM used: 2002 (51%) at main() level
                         2266 (58%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   2490
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03E0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   06E8
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   066E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0412
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
00F5C:  MOVLW  05
00F5E:  MOVLB  7
00F60:  SUBWF  xD9,F
00F62:  BNC   0F78
00F64:  MOVLW  07
00F66:  MOVWF  FEA
00F68:  MOVLW  D9
00F6A:  MOVWF  FE9
00F6C:  MOVF   FEF,W
00F6E:  BZ    0F78
00F70:  BRA    0F74
00F72:  CLRWDT
00F74:  DECFSZ FEF,F
00F76:  BRA    0F72
00F78:  MOVLB  0
00F7A:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0069E:  BTFSS  F9E.5
006A0:  BRA    069E
006A2:  MOVFF  FAB,35
006A6:  MOVFF  FAE,01
006AA:  BTFSS  35.1
006AC:  BRA    06B2
006AE:  BCF    FAB.4
006B0:  BSF    FAB.4
006B2:  RETURN 0
*
01022:  BTFSS  F9E.4
01024:  BRA    1022
01026:  MOVWF  FAD
01028:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00656:  BTFSS  FA4.5
00658:  BRA    0656
0065A:  MOVFF  F71,35
0065E:  MOVFF  F74,01
00662:  BTFSS  35.1
00664:  BRA    066A
00666:  BCF    F71.4
00668:  BSF    F71.4
0066A:  GOTO   0670 (RETURN)
*
006B4:  BTFSS  FA4.4
006B6:  BRA    06B4
006B8:  MOVWF  F73
006BA:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00C22:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00B82:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00B84:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00B86:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00B88:  MOVLB  7
00B8A:  MOVF   xD5,F
00B8C:  BNZ   0B94
.................... 		c=0b00011; 
00B8E:  MOVLW  03
00B90:  MOVWF  xD9
.................... 	else if ( 1 == ch )  
00B92:  BRA    0BDE
00B94:  DECFSZ xD5,W
00B96:  BRA    0B9E
.................... 		c=0b10011; 
00B98:  MOVLW  13
00B9A:  MOVWF  xD9
.................... 	else if ( 2 == ch )  
00B9C:  BRA    0BDE
00B9E:  MOVF   xD5,W
00BA0:  SUBLW  02
00BA2:  BNZ   0BAA
.................... 		c=0b01011; 
00BA4:  MOVLW  0B
00BA6:  MOVWF  xD9
.................... 	else if ( 3 == ch )  
00BA8:  BRA    0BDE
00BAA:  MOVF   xD5,W
00BAC:  SUBLW  03
00BAE:  BNZ   0BB6
.................... 		c=0b11011; 
00BB0:  MOVLW  1B
00BB2:  MOVWF  xD9
.................... 	else if ( 4 == ch ) 
00BB4:  BRA    0BDE
00BB6:  MOVF   xD5,W
00BB8:  SUBLW  04
00BBA:  BNZ   0BC2
.................... 		c=0b00111; 
00BBC:  MOVLW  07
00BBE:  MOVWF  xD9
.................... 	else if ( 5 == ch )  
00BC0:  BRA    0BDE
00BC2:  MOVF   xD5,W
00BC4:  SUBLW  05
00BC6:  BNZ   0BCE
.................... 		c=0b10111; 
00BC8:  MOVLW  17
00BCA:  MOVWF  xD9
.................... 	else if ( 6 == ch ) 
00BCC:  BRA    0BDE
00BCE:  MOVF   xD5,W
00BD0:  SUBLW  06
00BD2:  BNZ   0BDA
.................... 		c=0b01111; 
00BD4:  MOVLW  0F
00BD6:  MOVWF  xD9
.................... 	else 
00BD8:  BRA    0BDE
.................... 		c=0b11111; 
00BDA:  MOVLW  1F
00BDC:  MOVWF  xD9
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00BDE:  CLRF   xD8
00BE0:  MOVF   xD8,W
00BE2:  SUBLW  04
00BE4:  BNC   0BFC
.................... 		output_low(MCP3208_CLK); 
00BE6:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00BE8:  BTFSC  xD9.0
00BEA:  BRA    0BF0
00BEC:  BCF    F8B.5
00BEE:  BRA    0BF2
00BF0:  BSF    F8B.5
.................... 		c=c>>1; 
00BF2:  BCF    FD8.0
00BF4:  RRCF   xD9,F
.................... 		output_high(MCP3208_CLK); 
00BF6:  BSF    F8B.3
.................... 	} 
00BF8:  INCF   xD8,F
00BFA:  BRA    0BE0
....................  
....................  
.................... 	value=0; 
00BFC:  CLRF   xD7
00BFE:  CLRF   xD6
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00C00:  CLRF   xD8
00C02:  MOVF   xD8,W
00C04:  SUBLW  0D
00C06:  BNC   0C1E
.................... 		output_low(MCP3208_CLK); 
00C08:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00C0A:  BTFSC  F82.4
00C0C:  BRA    0C12
00C0E:  BCF    FD8.0
00C10:  BRA    0C14
00C12:  BSF    FD8.0
00C14:  RLCF   xD6,F
00C16:  RLCF   xD7,F
.................... 		output_high(MCP3208_CLK); 
00C18:  BSF    F8B.3
.................... 	} 
00C1A:  INCF   xD8,F
00C1C:  BRA    0C02
....................  
.................... 	bit_clear(value,13); 
00C1E:  BCF    xD7.5
.................... 	bit_clear(value,12); 
00C20:  BCF    xD7.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00C24:  MOVFF  7D6,01
00C28:  MOVFF  7D7,02
.................... } 
00C2C:  MOVLB  0
00C2E:  GOTO   0C9E (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00D28:  MOVLB  7
00D2A:  CLRF   xF1
00D2C:  MOVFF  7EA,7F0
00D30:  CLRF   xF3
00D32:  MOVLW  20
00D34:  MOVWF  xF2
00D36:  MOVLB  0
00D38:  RCALL  0778
00D3A:  MOVFF  02,03
00D3E:  MOVF   01,W
00D40:  ADDLW  CA
00D42:  MOVWF  01
00D44:  MOVLW  00
00D46:  ADDWFC 03,F
00D48:  MOVFF  01,7EE
00D4C:  MOVLB  7
00D4E:  MOVFF  03,7EF
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00D52:  CLRF   xEC
00D54:  CLRF   xEB
.................... 	for( i = 0; i < 16 ; i++ ) { 
00D56:  CLRF   xED
00D58:  MOVF   xED,W
00D5A:  SUBLW  0F
00D5C:  BNC   0D80
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00D5E:  BCF    FD8.0
00D60:  RLCF   xED,W
00D62:  CLRF   03
00D64:  ADDWF  xEE,W
00D66:  MOVWF  FE9
00D68:  MOVF   xEF,W
00D6A:  ADDWFC 03,W
00D6C:  MOVWF  FEA
00D6E:  MOVFF  FEC,03
00D72:  MOVF   FED,F
00D74:  MOVF   FEF,W
00D76:  ADDWF  xEB,F
00D78:  MOVF   03,W
00D7A:  ADDWFC xEC,F
.................... 	} 
00D7C:  INCF   xED,F
00D7E:  BRA    0D58
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00D80:  MOVLW  08
00D82:  ADDWF  xEB,W
00D84:  MOVWF  xF0
00D86:  MOVLW  00
00D88:  ADDWFC xEC,W
00D8A:  MOVWF  xF1
00D8C:  RRCF   xF1,W
00D8E:  MOVWF  03
00D90:  RRCF   xF0,W
00D92:  MOVWF  02
00D94:  RRCF   03,F
00D96:  RRCF   02,F
00D98:  RRCF   03,F
00D9A:  RRCF   02,F
00D9C:  RRCF   03,F
00D9E:  RRCF   02,F
00DA0:  MOVLW  0F
00DA2:  ANDWF  03,F
00DA4:  MOVFF  02,01
00DA8:  MOVFF  03,02
.................... } 
00DAC:  MOVLB  0
00DAE:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00C32:  MOVLB  1
00C34:  INCF   xCA,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00C36:  MOVF   xCA,W
00C38:  SUBLW  0F
00C3A:  BC    0C3E
.................... 		current.adc_buffer_index=0; 
00C3C:  CLRF   xCA
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00C3E:  MOVLB  7
00C40:  CLRF   xD2
00C42:  MOVF   xD2,W
00C44:  SUBLW  07
00C46:  BNC   0CD4
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00C48:  CLRF   xF1
00C4A:  MOVFF  7D2,7F0
00C4E:  CLRF   xF3
00C50:  MOVLW  20
00C52:  MOVWF  xF2
00C54:  MOVLB  0
00C56:  RCALL  0778
00C58:  MOVFF  02,03
00C5C:  MOVF   01,W
00C5E:  ADDLW  34
00C60:  MOVLB  7
00C62:  MOVWF  xD3
00C64:  MOVLW  00
00C66:  ADDWFC 02,W
00C68:  MOVWF  xD4
00C6A:  CLRF   03
00C6C:  MOVLB  1
00C6E:  MOVFF  1CA,02
00C72:  BCF    FD8.0
00C74:  RLCF   02,F
00C76:  RLCF   03,F
00C78:  MOVF   02,W
00C7A:  MOVLB  7
00C7C:  ADDWF  xD3,W
00C7E:  MOVWF  01
00C80:  MOVF   xD4,W
00C82:  ADDWFC 03,F
00C84:  MOVF   01,W
00C86:  ADDLW  96
00C88:  MOVWF  01
00C8A:  MOVLW  00
00C8C:  ADDWFC 03,F
00C8E:  MOVFF  01,7D3
00C92:  MOVFF  03,7D4
00C96:  MOVFF  7D2,7D5
00C9A:  MOVLB  0
00C9C:  BRA    0B82
00C9E:  MOVFF  7D4,FEA
00CA2:  MOVFF  7D3,FE9
00CA6:  MOVFF  02,FEC
00CAA:  MOVF   FED,F
00CAC:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00CB0:  CLRF   03
00CB2:  MOVLB  7
00CB4:  MOVFF  7D2,02
00CB8:  BCF    FD8.0
00CBA:  RLCF   02,F
00CBC:  RLCF   03,F
00CBE:  MOVF   02,W
00CC0:  ADDLW  BA
00CC2:  MOVWF  FE9
00CC4:  MOVLW  00
00CC6:  ADDWFC 03,W
00CC8:  MOVWF  FEA
00CCA:  CLRF   FEC
00CCC:  MOVF   FED,F
00CCE:  CLRF   FEF
....................  
.................... 	} 
00CD0:  INCF   xD2,F
00CD2:  BRA    0C42
.................... } 
00CD4:  MOVLB  0
00CD6:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00988:  MOVF   xEF,W
0098A:  XORWF  xF0,W
0098C:  MOVWF  01
*
009DA:  MOVF   xEF,W
009DC:  XORWF  xF0,W
009DE:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00912:  MOVLB  7
00914:  CLRF   xDB
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00916:  MOVFF  7DA,03
0091A:  MOVF   xD9,W
0091C:  BTFSC  FD8.2
0091E:  DECF   xDA,F
00920:  DECF   xD9,F
00922:  MOVWF  xDC
00924:  MOVFF  03,7DD
00928:  MOVF   xDC,F
0092A:  BNZ   0930
0092C:  MOVF   xDD,F
0092E:  BZ    099A
.................... 		*data = read_eeprom( address++ ); 
00930:  MOVFF  7D8,03
00934:  MOVF   xD7,W
00936:  MOVWF  FE9
00938:  MOVFF  03,FEA
0093C:  MOVF   xD6,W
0093E:  MOVWF  03
00940:  MOVF   xD5,W
00942:  INCF   xD5,F
00944:  BTFSC  FD8.2
00946:  INCF   xD6,F
00948:  MOVWF  xDE
0094A:  MOVFF  03,7DF
0094E:  MOVFF  FF2,7E0
00952:  BCF    FF2.6
00954:  BCF    FF2.7
00956:  MOVFF  7DF,FAA
0095A:  MOVFF  7DE,FA9
0095E:  BCF    FA6.6
00960:  BCF    FA6.7
00962:  BSF    FA6.0
00964:  MOVF   FA8,W
00966:  BTFSC  xE0.6
00968:  BSF    FF2.6
0096A:  BTFSC  xE0.7
0096C:  BSF    FF2.7
0096E:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00970:  MOVFF  7D8,03
00974:  MOVF   xD7,W
00976:  MOVWF  FE9
00978:  MOVFF  03,FEA
0097C:  MOVFF  FEF,7DC
00980:  MOVFF  7DB,7EF
00984:  MOVFF  7DC,7F0
*
0098E:  MOVFF  01,7DB
.................... 		data++; 
00992:  INCF   xD7,F
00994:  BTFSC  FD8.2
00996:  INCF   xD8,F
.................... 	} 
00998:  BRA    0916
.................... 	return crc; 
0099A:  MOVFF  7DB,01
.................... } 
0099E:  MOVLB  0
009A0:  GOTO   0B36 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
009A4:  MOVLB  7
009A6:  CLRF   xED
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
009A8:  MOVFF  7EC,03
009AC:  MOVF   xEB,W
009AE:  BTFSC  FD8.2
009B0:  DECF   xEC,F
009B2:  DECF   xEB,F
009B4:  MOVWF  xEE
009B6:  MOVFF  03,7EF
009BA:  MOVF   xEE,F
009BC:  BNZ   09C2
009BE:  MOVF   xEF,F
009C0:  BZ    0A40
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
009C2:  MOVFF  7EA,03
009C6:  MOVF   xE9,W
009C8:  MOVWF  FE9
009CA:  MOVFF  03,FEA
009CE:  MOVFF  FEF,7EE
009D2:  MOVFF  7ED,7EF
009D6:  MOVFF  7EE,7F0
*
009E0:  MOVFF  01,7ED
.................... 		write_eeprom( address++, *data++ ); 
009E4:  MOVF   xE8,W
009E6:  MOVWF  03
009E8:  MOVF   xE7,W
009EA:  INCF   xE7,F
009EC:  BTFSC  FD8.2
009EE:  INCF   xE8,F
009F0:  MOVWF  xEE
009F2:  MOVFF  03,7EF
009F6:  MOVF   xEA,W
009F8:  MOVWF  03
009FA:  MOVF   xE9,W
009FC:  INCF   xE9,F
009FE:  BTFSC  FD8.2
00A00:  INCF   xEA,F
00A02:  MOVWF  FE9
00A04:  MOVFF  03,FEA
00A08:  MOVFF  FEF,7F0
00A0C:  MOVFF  7EF,FAA
00A10:  MOVFF  7EE,FA9
00A14:  MOVFF  7F0,FA8
00A18:  BCF    FA6.6
00A1A:  BCF    FA6.7
00A1C:  BSF    FA6.2
00A1E:  MOVF   FF2,W
00A20:  MOVWF  00
00A22:  BCF    FF2.6
00A24:  BCF    FF2.7
00A26:  MOVLB  F
00A28:  MOVLW  55
00A2A:  MOVWF  FA7
00A2C:  MOVLW  AA
00A2E:  MOVWF  FA7
00A30:  BSF    FA6.1
00A32:  BTFSC  FA6.1
00A34:  BRA    0A32
00A36:  BCF    FA6.2
00A38:  MOVF   00,W
00A3A:  IORWF  FF2,F
.................... 	} 
00A3C:  MOVLB  7
00A3E:  BRA    09A8
....................  
.................... 	return crc; 
00A40:  MOVFF  7ED,01
.................... } 
00A44:  MOVLB  0
00A46:  GOTO   0A6A (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00A4A:  MOVLB  7
00A4C:  CLRF   xE6
00A4E:  MOVLW  36
00A50:  MOVWF  xE5
00A52:  CLRF   xE8
00A54:  MOVLW  02
00A56:  MOVWF  xE7
00A58:  MOVFF  7E6,7EA
00A5C:  MOVFF  7E5,7E9
00A60:  CLRF   xEC
00A62:  MOVLW  60
00A64:  MOVWF  xEB
00A66:  MOVLB  0
00A68:  BRA    09A4
00A6A:  MOVFF  01,7E4
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00A6E:  CLRF   FAA
00A70:  CLRF   FA9
00A72:  MOVFF  7E4,FA8
00A76:  BCF    FA6.6
00A78:  BCF    FA6.7
00A7A:  BSF    FA6.2
00A7C:  MOVF   FF2,W
00A7E:  MOVWF  00
00A80:  BCF    FF2.6
00A82:  BCF    FF2.7
00A84:  MOVLB  F
00A86:  MOVLW  55
00A88:  MOVWF  FA7
00A8A:  MOVLW  AA
00A8C:  MOVWF  FA7
00A8E:  BSF    FA6.1
00A90:  BTFSC  FA6.1
00A92:  BRA    0A90
00A94:  BCF    FA6.2
00A96:  MOVF   00,W
00A98:  IORWF  FF2,F
.................... } 
00A9A:  MOVLB  0
00A9C:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00A9E:  MOVLW  96
00AA0:  MOVLB  1
00AA2:  MOVWF  xF3
....................  
.................... 	config.modbus_address=38; 
00AA4:  MOVLW  26
00AA6:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_MODBUS_BRIDGE; 
00AA8:  MOVLW  01
00AAA:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00AAC:  MOVLW  50
00AAE:  MOVWF  39
.................... 	config.serial_number=9876; 
00AB0:  MOVLW  26
00AB2:  MOVWF  3B
00AB4:  MOVLW  94
00AB6:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00AB8:  CLRF   3D
00ABA:  MOVLW  14
00ABC:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00ABE:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00AC0:  MOVLW  02
00AC2:  MOVWF  40
00AC4:  MOVLW  76
00AC6:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00AC8:  CLRF   42
00ACA:  MOVLW  02
00ACC:  MOVWF  41
.................... 	config.power_startup=0; 
00ACE:  CLRF   43
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00AD0:  CLRF   FEA
00AD2:  MOVLW  4E
00AD4:  MOVWF  FE9
00AD6:  CLRF   00
00AD8:  CLRF   02
00ADA:  MOVLW  48
00ADC:  MOVWF  01
00ADE:  MOVLB  0
00AE0:  RCALL  079A
.................... 	/* set defaults. Can set the first 11 this way. Have to do them in order. 
.................... 	 12th would overrun end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00AE2:  CLRF   FEA
00AE4:  MOVLW  4E
00AE6:  MOVWF  FE9
00AE8:  MOVLW  00
00AEA:  CALL   017C
00AEE:  TBLRD*-
00AF0:  TBLRD*+
00AF2:  MOVF   FF5,W
00AF4:  MOVWF  FEE
00AF6:  IORLW  00
00AF8:  BNZ   0AF0
.................... 	strcpy(config.nmea0183_sentence[1],"$WIMDA"); 
00AFA:  CLRF   FEA
00AFC:  MOVLW  54
00AFE:  MOVWF  FE9
00B00:  MOVLW  00
00B02:  CALL   0194
00B06:  TBLRD*-
00B08:  TBLRD*+
00B0A:  MOVF   FF5,W
00B0C:  MOVWF  FEE
00B0E:  IORLW  00
00B10:  BNZ   0B08
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00B12:  RCALL  0A4A
....................  
.................... } 
00B14:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00B16:  MOVLB  7
00B18:  CLRF   xD4
00B1A:  MOVLW  36
00B1C:  MOVWF  xD3
00B1E:  CLRF   xD6
00B20:  MOVLW  02
00B22:  MOVWF  xD5
00B24:  MOVFF  7D4,7D8
00B28:  MOVFF  7D3,7D7
00B2C:  CLRF   xDA
00B2E:  MOVLW  60
00B30:  MOVWF  xD9
00B32:  MOVLB  0
00B34:  BRA    0912
00B36:  MOVFF  01,7D2
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00B3A:  MOVFF  FF2,7D3
00B3E:  BCF    FF2.6
00B40:  BCF    FF2.7
00B42:  CLRF   FAA
00B44:  CLRF   FA9
00B46:  BCF    FA6.6
00B48:  BCF    FA6.7
00B4A:  BSF    FA6.0
00B4C:  MOVF   FA8,W
00B4E:  MOVLB  7
00B50:  BTFSC  xD3.6
00B52:  BSF    FF2.6
00B54:  BTFSC  xD3.7
00B56:  BSF    FF2.7
00B58:  SUBWF  xD2,W
00B5A:  BZ    0B62
.................... 		write_default_param_file(); 
00B5C:  MOVLB  0
00B5E:  RCALL  0A9E
00B60:  MOVLB  7
.................... 	} 
.................... } 
00B62:  MOVLB  0
00B64:  GOTO   2536 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
01084:  BTFSS  FAC.1
01086:  BRA    1084
.................... } 
01088:  GOTO   10A2 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00B68:  BTFSS  F9E.5
00B6A:  BRA    0B70
.................... 		fgetc(STREAM_PI); 
00B6C:  RCALL  069E
.................... 	} 
00B6E:  BRA    0B68
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00B70:  BSF    F9D.5
.................... } 
00B72:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00B74:  RCALL  0B68
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00B76:  MOVLW  C6
00B78:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00B7A:  MOVLW  C0
00B7C:  IORWF  FF2,F
.................... } 
00B7E:  GOTO   2548 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003CC:  BCF    FF2.5
.................... 	if (enable) { 
003CE:  MOVLB  8
003D0:  MOVF   xD7,F
003D2:  BZ    03DC
.................... 		set_timer0(0); 
003D4:  CLRF   FD7
003D6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003D8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003DA:  BSF    FF2.5
.................... 	} 
.................... } 
003DC:  MOVLB  0
003DE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003E0:  MOVLB  6
003E2:  MOVF   xBD,W
003E4:  SUBLW  02
003E6:  BNZ   03FC
003E8:  MOVF   xBE,F
003EA:  BNZ   03FC
003EC:  MOVF   xBF,F
003EE:  BNZ   03FC
003F0:  BTFSC  xBC.0
003F2:  BRA    03FC
....................    { 
....................       modbus_rx.len-=2; 
003F4:  MOVLW  02
003F6:  SUBWF  xC1,F
....................       modbus_serial_new=TRUE; 
003F8:  BSF    xBC.0
....................    } 
....................    else 
003FA:  BRA    03FE
....................       modbus_serial_new=FALSE; 
003FC:  BCF    xBC.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003FE:  SETF   xBF
00400:  SETF   xBE
....................    modbus_serial_state=MODBUS_GETADDY; 
00402:  CLRF   xBD
....................    modbus_enable_timeout(FALSE); 
00404:  MOVLB  8
00406:  CLRF   xD7
00408:  MOVLB  0
0040A:  RCALL  03CC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0040C:  BCF    FF2.2
0040E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
006BC:  MOVLB  6
006BE:  MOVF   xBF,W
006C0:  MOVLB  8
006C2:  XORWF  xD7,W
006C4:  MOVWF  xD8
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
006C6:  CLRF   03
006C8:  MOVF   xD8,W
006CA:  MOVLB  0
006CC:  RCALL  01AC
006CE:  MOVWF  01
006D0:  MOVLB  6
006D2:  MOVF   xBE,W
006D4:  XORWF  01,W
006D6:  MOVWF  xBF
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006D8:  CLRF   03
006DA:  MOVLB  8
006DC:  MOVF   xD8,W
006DE:  MOVLB  0
006E0:  RCALL  02BC
006E2:  MOVFF  FE8,6BE
.................... } 
006E6:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
0102A:  MOVLB  7
0102C:  MOVF   xE4,W
0102E:  MOVLB  0
01030:  RCALL  1022
01032:  CLRF   19
01034:  BTFSC  FF2.6
01036:  BSF    19.6
01038:  BCF    FF2.6
0103A:  BTFSC  FF2.7
0103C:  BSF    19.7
0103E:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
01040:  MOVFF  7E4,8D7
01044:  CALL   06BC
01048:  BTFSC  19.6
0104A:  BSF    FF2.6
0104C:  BTFSC  19.7
0104E:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
01050:  CLRWDT
01052:  MOVLW  08
01054:  MOVWF  00
01056:  DECFSZ 00,F
01058:  BRA    1056
0105A:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
0105C:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
0105E:  MOVLB  6
01060:  SETF   xBF
01062:  SETF   xBE
....................    modbus_serial_new=FALSE; 
01064:  BCF    xBC.0
....................  
....................    RCV_OFF(); 
01066:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
01068:  CLRWDT
0106A:  MOVLW  3C
0106C:  MOVWF  00
0106E:  DECFSZ 00,F
01070:  BRA    106E
01072:  NOP   
....................  
....................    modbus_serial_putc(to); 
01074:  MOVFF  7E2,7E4
01078:  MOVLB  0
0107A:  RCALL  102A
....................    modbus_serial_putc(func); 
0107C:  MOVFF  7E3,7E4
01080:  RCALL  102A
.................... } 
01082:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
0108C:  MOVFF  6BF,7E3
....................    crc_low=modbus_serial_crc.b[0]; 
01090:  MOVFF  6BE,7E2
....................  
....................    modbus_serial_putc(crc_high); 
01094:  MOVFF  7E3,7E4
01098:  RCALL  102A
....................    modbus_serial_putc(crc_low); 
0109A:  MOVFF  7E2,7E4
0109E:  RCALL  102A
....................  
....................    WAIT_FOR_HW_BUFFER(); 
010A0:  BRA    1084
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
010A2:  CLRWDT
010A4:  MOVLW  3C
010A6:  MOVWF  00
010A8:  DECFSZ 00,F
010AA:  BRA    10A8
010AC:  NOP   
....................  
....................  
....................    RCV_ON(); 
010AE:  RCALL  0B68
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
010B0:  MOVLB  6
010B2:  SETF   xBF
010B4:  SETF   xBE
.................... } 
010B6:  MOVLB  0
010B8:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00F36:  MOVLB  6
00F38:  BTFSC  xBC.0
00F3A:  BRA    0F44
....................       return FALSE; 
00F3C:  MOVLW  00
00F3E:  MOVWF  01
00F40:  BRA    0F56
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00F42:  BRA    0F50
00F44:  BTFSS  xC2.7
00F46:  BRA    0F50
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00F48:  MOVFF  6C4,6C3
....................       modbus_rx.len = 1; 
00F4C:  MOVLW  01
00F4E:  MOVWF  xC1
....................    } 
....................    modbus_serial_new=FALSE; 
00F50:  BCF    xBC.0
....................    return TRUE; 
00F52:  MOVLW  01
00F54:  MOVWF  01
.................... } 
00F56:  MOVLB  0
00F58:  GOTO   212C (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02098:  MOVFF  7DA,7E2
0209C:  MOVLW  06
0209E:  MOVLB  7
020A0:  MOVWF  xE3
020A2:  MOVLB  0
020A4:  CALL   105E
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
020A8:  MOVFF  7DC,7DF
020AC:  MOVFF  7DC,7E4
020B0:  CALL   102A
....................    modbus_serial_putc(make8(reg_address,0)); 
020B4:  MOVFF  7DB,7DF
020B8:  MOVFF  7DB,7E4
020BC:  CALL   102A
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
020C0:  MOVFF  7DE,7DF
020C4:  MOVFF  7DE,7E4
020C8:  CALL   102A
....................    modbus_serial_putc(make8(reg_value,0)); 
020CC:  MOVFF  7DD,7DF
020D0:  MOVFF  7DD,7E4
020D4:  CALL   102A
....................  
....................    modbus_serial_send_stop(); 
020D8:  CALL   108C
.................... } 
020DC:  GOTO   2310 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
020E0:  MOVFF  7D8,7E2
020E4:  MOVLW  10
020E6:  MOVLB  7
020E8:  MOVWF  xE3
020EA:  MOVLB  0
020EC:  CALL   105E
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
020F0:  MOVFF  7DA,7DD
020F4:  MOVFF  7DA,7E4
020F8:  CALL   102A
....................    modbus_serial_putc(make8(start_address,0)); 
020FC:  MOVFF  7D9,7DD
02100:  MOVFF  7D9,7E4
02104:  CALL   102A
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02108:  MOVFF  7DC,7DD
0210C:  MOVFF  7DC,7E4
02110:  CALL   102A
....................    modbus_serial_putc(make8(quantity,0)); 
02114:  MOVFF  7DB,7DD
02118:  MOVFF  7DB,7E4
0211C:  CALL   102A
....................  
....................    modbus_serial_send_stop(); 
02120:  CALL   108C
.................... } 
02124:  GOTO   23D2 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
010BA:  MOVLB  7
010BC:  MOVF   xD9,W
010BE:  IORLW  80
010C0:  MOVWF  xDC
010C2:  MOVFF  7DA,7DD
010C6:  MOVFF  7D8,7E2
010CA:  MOVWF  xE3
010CC:  MOVLB  0
010CE:  RCALL  105E
....................    modbus_serial_putc(error); 
010D0:  MOVFF  7DB,7E4
010D4:  RCALL  102A
....................    modbus_serial_send_stop(); 
010D6:  RCALL  108C
.................... } 
010D8:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          51 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1012 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
011CC:  MOVLB  1
011CE:  CLRF   xCC
011D0:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
011D2:  CLRF   xCE
011D4:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
011D6:  CLRF   xD0
011D8:  CLRF   xCF
.................... } 
011DA:  MOVLB  0
011DC:  GOTO   1C3A (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
01168:  BCF    FF2.6
0116A:  BCF    FF2.7
0116C:  BTFSC  FF2.7
0116E:  BRA    116A
....................  
.................... 	current.pulse_count[0]=0; 
01170:  CLRF   xA9
01172:  CLRF   xA8
.................... 	current.pulse_count[1]=0; 
01174:  CLRF   xAB
01176:  CLRF   xAA
.................... 	current.pulse_count[2]=0; 
01178:  CLRF   xAD
0117A:  CLRF   xAC
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
0117C:  SETF   x9D
0117E:  SETF   x9C
.................... 	current.pulse_min_period[1]=65535; 
01180:  SETF   x9F
01182:  SETF   x9E
.................... 	current.pulse_min_period[2]=65535; 
01184:  SETF   xA1
01186:  SETF   xA0
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
01188:  CLRF   xA3
0118A:  CLRF   xA2
.................... 	current.pulse_max_period[1]=0; 
0118C:  CLRF   xA5
0118E:  CLRF   xA4
.................... 	current.pulse_max_period[2]=0; 
01190:  CLRF   xA7
01192:  CLRF   xA6
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01194:  MOVLB  1
01196:  CLRF   xD6
01198:  CLRF   xD5
....................  
.................... 	enable_interrupts(GLOBAL); 
0119A:  MOVLW  C0
0119C:  IORWF  FF2,F
.................... } 
0119E:  MOVLB  0
011A0:  GOTO   1BEA (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
011A4:  BCF    FF2.6
011A6:  BCF    FF2.7
011A8:  BTFSC  FF2.7
011AA:  BRA    11A6
.................... 	current.pulse_sum[0]=0; 
011AC:  CLRF   xB1
011AE:  CLRF   xB0
011B0:  CLRF   xAF
011B2:  CLRF   xAE
.................... 	current.pulse_sum[1]=0; 
011B4:  CLRF   xB5
011B6:  CLRF   xB4
011B8:  CLRF   xB3
011BA:  CLRF   xB2
.................... 	current.pulse_sum[2]=0; 
011BC:  CLRF   xB9
011BE:  CLRF   xB8
011C0:  CLRF   xB7
011C2:  CLRF   xB6
.................... 	enable_interrupts(GLOBAL); 
011C4:  MOVLW  C0
011C6:  IORWF  FF2,F
.................... } 
011C8:  GOTO   1BFA (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01106:  BCF    FF2.6
01108:  BCF    FF2.7
0110A:  BTFSC  FF2.7
0110C:  BRA    1108
.................... 	l=current.pulse_sum[ch]; 
0110E:  MOVLB  7
01110:  CLRF   xF1
01112:  MOVFF  7EA,7F0
01116:  CLRF   xF3
01118:  MOVLW  04
0111A:  MOVWF  xF2
0111C:  MOVLB  0
0111E:  CALL   0778
01122:  MOVFF  02,03
01126:  MOVF   01,W
01128:  ADDLW  AE
0112A:  MOVWF  FE9
0112C:  MOVLW  00
0112E:  ADDWFC 02,W
01130:  MOVWF  FEA
01132:  MOVFF  FEF,00
01136:  MOVFF  FEC,01
0113A:  MOVFF  FEC,02
0113E:  MOVFF  FEC,03
01142:  MOVFF  03,7EE
01146:  MOVFF  02,7ED
0114A:  MOVFF  01,7EC
0114E:  MOVFF  00,7EB
.................... 	enable_interrupts(GLOBAL); 
01152:  MOVLW  C0
01154:  IORWF  FF2,F
....................  
.................... 	return l; 
01156:  MOVFF  7EB,00
0115A:  MOVFF  7EC,01
0115E:  MOVFF  7ED,02
01162:  MOVFF  7EE,03
.................... } 
01166:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
011E0:  MOVLB  7
011E2:  MOVF   xE5,W
011E4:  SUBLW  06
011E6:  BC    123C
011E8:  XORLW  FF
011EA:  BNZ   11F2
011EC:  MOVF   xE4,W
011EE:  SUBLW  CF
011F0:  BC    123C
011F2:  MOVF   xE5,W
011F4:  SUBLW  09
011F6:  BNC   123C
011F8:  BNZ   1200
011FA:  MOVF   xE4,W
011FC:  SUBLW  CF
011FE:  BNC   123C
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01200:  MOVLW  D0
01202:  SUBWF  xE4,W
01204:  MOVWF  xEA
01206:  MOVLW  07
01208:  SUBWFB xE5,W
0120A:  MOVWF  xEB
0120C:  MOVLW  02
0120E:  ADDWF  xEB,F
01210:  MOVFF  FF2,7EC
01214:  BCF    FF2.6
01216:  BCF    FF2.7
01218:  MOVFF  7EB,FAA
0121C:  MOVFF  7EA,FA9
01220:  BCF    FA6.6
01222:  BCF    FA6.7
01224:  BSF    FA6.0
01226:  MOVF   FA8,W
01228:  BTFSC  xEC.6
0122A:  BSF    FF2.6
0122C:  BTFSC  xEC.7
0122E:  BSF    FF2.7
01230:  CLRF   03
01232:  MOVWF  01
01234:  MOVF   03,W
01236:  MOVWF  02
01238:  GOTO   1D0C
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
0123C:  MOVF   xE5,W
0123E:  SUBLW  03
01240:  BC    12BC
01242:  XORLW  FF
01244:  BNZ   124C
01246:  MOVF   xE4,W
01248:  SUBLW  4B
0124A:  BC    12BC
0124C:  MOVF   xE5,W
0124E:  SUBLW  04
01250:  BNC   12BC
01252:  BNZ   125A
01254:  MOVF   xE4,W
01256:  SUBLW  93
01258:  BNC   12BC
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0125A:  MOVLW  4C
0125C:  SUBWF  xE4,W
0125E:  MOVWF  xE6
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01260:  MOVFF  7E6,7EA
01264:  MOVLW  06
01266:  MOVWF  xEB
01268:  MOVLB  0
0126A:  RCALL  10DA
0126C:  MOVFF  00,7E7
.................... 		n = n / 6; /* number of sentence */ 
01270:  MOVFF  7E6,7EA
01274:  MOVLW  06
01276:  MOVLB  7
01278:  MOVWF  xEB
0127A:  MOVLB  0
0127C:  RCALL  10DA
0127E:  MOVFF  01,7E6
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
01282:  MOVLB  7
01284:  MOVF   xE6,W
01286:  MULLW  06
01288:  MOVF   FF3,W
0128A:  CLRF   03
0128C:  ADDLW  18
0128E:  MOVWF  xEA
01290:  MOVLW  00
01292:  ADDWFC 03,W
01294:  MOVWF  xEB
01296:  CLRF   03
01298:  MOVF   xE7,W
0129A:  ADDWF  xEA,W
0129C:  MOVWF  01
0129E:  MOVF   xEB,W
012A0:  ADDWFC 03,F
012A2:  MOVF   01,W
012A4:  ADDLW  36
012A6:  MOVWF  FE9
012A8:  MOVLW  00
012AA:  ADDWFC 03,W
012AC:  MOVWF  FEA
012AE:  MOVF   FEF,W
012B0:  CLRF   03
012B2:  MOVWF  01
012B4:  MOVFF  03,02
012B8:  GOTO   1D0C
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
012BC:  MOVF   xE5,W
012BE:  SUBLW  12
012C0:  BC    1304
012C2:  XORLW  FF
012C4:  BNZ   12CC
012C6:  MOVF   xE4,W
012C8:  SUBLW  87
012CA:  BC    1304
012CC:  MOVF   xE5,W
012CE:  SUBLW  17
012D0:  BNC   1304
012D2:  BNZ   12DA
012D4:  MOVF   xE4,W
012D6:  SUBLW  47
012D8:  BNC   1304
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
012DA:  MOVLW  88
012DC:  SUBWF  xE4,F
012DE:  MOVLW  13
012E0:  SUBWFB xE5,F
....................  
....................  		p  = nmea.sentence[0]; 
012E2:  MOVLW  02
012E4:  MOVWF  xE9
012E6:  MOVLW  FC
012E8:  MOVWF  xE8
.................... 		return (int16) p[addr]; 
012EA:  MOVF   xE8,W
012EC:  ADDWF  xE4,W
012EE:  MOVWF  FE9
012F0:  MOVF   xE9,W
012F2:  ADDWFC xE5,W
012F4:  MOVWF  FEA
012F6:  MOVF   FEF,W
012F8:  CLRF   03
012FA:  MOVWF  01
012FC:  MOVFF  03,02
01300:  GOTO   1D0C
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
01304:  MOVF   xE5,W
01306:  SUBLW  16
01308:  BC    1374
0130A:  XORLW  FF
0130C:  BNZ   1314
0130E:  MOVF   xE4,W
01310:  SUBLW  6F
01312:  BC    1374
01314:  MOVF   xE5,W
01316:  SUBLW  19
01318:  BNC   1374
0131A:  BNZ   1322
0131C:  MOVF   xE4,W
0131E:  SUBLW  4F
01320:  BNC   1374
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01322:  MOVLW  70
01324:  SUBWF  xE4,F
01326:  MOVLW  17
01328:  SUBWFB xE5,F
.................... 		addr = addr * 2; 
0132A:  BCF    FD8.0
0132C:  RLCF   xE4,F
0132E:  RLCF   xE5,F
....................  
....................  		p  = nmea.sentence[0]; 
01330:  MOVLW  02
01332:  MOVWF  xE9
01334:  MOVLW  FC
01336:  MOVWF  xE8
.................... 		return (int16) make16(p[addr+1],p[addr]); 
01338:  MOVLW  01
0133A:  ADDWF  xE4,W
0133C:  MOVWF  xEA
0133E:  MOVLW  00
01340:  ADDWFC xE5,W
01342:  MOVWF  xEB
01344:  MOVF   xE8,W
01346:  ADDWF  xEA,W
01348:  MOVWF  FE9
0134A:  MOVF   xE9,W
0134C:  ADDWFC xEB,W
0134E:  MOVWF  FEA
01350:  MOVFF  FEF,7EC
01354:  MOVF   xE8,W
01356:  ADDWF  xE4,W
01358:  MOVWF  FE9
0135A:  MOVF   xE9,W
0135C:  ADDWFC xE5,W
0135E:  MOVWF  FEA
01360:  MOVFF  FEF,7ED
01364:  MOVFF  7EC,03
01368:  MOVFF  7ED,01
0136C:  MOVFF  7EC,02
01370:  GOTO   1D0C
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
01374:  MOVF   xE4,W
01376:  MOVWF  00
01378:  MOVF   xE5,W
0137A:  MOVWF  03
0137C:  MOVF   03,W
0137E:  BNZ   138A
01380:  MOVF   00,F
01382:  MOVLB  0
01384:  BTFSC  FD8.2
01386:  BRA    17A6
01388:  MOVLB  7
0138A:  MOVF   03,W
0138C:  BNZ   139A
0138E:  MOVLW  01
01390:  SUBWF  00,W
01392:  MOVLB  0
01394:  BTFSC  FD8.2
01396:  BRA    17B4
01398:  MOVLB  7
0139A:  MOVF   03,W
0139C:  BNZ   13AA
0139E:  MOVLW  02
013A0:  SUBWF  00,W
013A2:  MOVLB  0
013A4:  BTFSC  FD8.2
013A6:  BRA    17C2
013A8:  MOVLB  7
013AA:  MOVF   03,W
013AC:  BNZ   13BA
013AE:  MOVLW  03
013B0:  SUBWF  00,W
013B2:  MOVLB  0
013B4:  BTFSC  FD8.2
013B6:  BRA    17D0
013B8:  MOVLB  7
013BA:  MOVF   03,W
013BC:  BNZ   13CA
013BE:  MOVLW  04
013C0:  SUBWF  00,W
013C2:  MOVLB  0
013C4:  BTFSC  FD8.2
013C6:  BRA    17DE
013C8:  MOVLB  7
013CA:  MOVF   03,W
013CC:  BNZ   13DA
013CE:  MOVLW  05
013D0:  SUBWF  00,W
013D2:  MOVLB  0
013D4:  BTFSC  FD8.2
013D6:  BRA    1804
013D8:  MOVLB  7
013DA:  MOVF   03,W
013DC:  BNZ   13EA
013DE:  MOVLW  06
013E0:  SUBWF  00,W
013E2:  MOVLB  0
013E4:  BTFSC  FD8.2
013E6:  BRA    1812
013E8:  MOVLB  7
013EA:  MOVF   03,W
013EC:  BNZ   13FA
013EE:  MOVLW  07
013F0:  SUBWF  00,W
013F2:  MOVLB  0
013F4:  BTFSC  FD8.2
013F6:  BRA    1820
013F8:  MOVLB  7
013FA:  MOVF   03,W
013FC:  BNZ   140A
013FE:  MOVLW  08
01400:  SUBWF  00,W
01402:  MOVLB  0
01404:  BTFSC  FD8.2
01406:  BRA    182E
01408:  MOVLB  7
0140A:  MOVF   03,W
0140C:  BNZ   141A
0140E:  MOVLW  09
01410:  SUBWF  00,W
01412:  MOVLB  0
01414:  BTFSC  FD8.2
01416:  BRA    183C
01418:  MOVLB  7
0141A:  MOVF   03,W
0141C:  BNZ   142A
0141E:  MOVLW  0A
01420:  SUBWF  00,W
01422:  MOVLB  0
01424:  BTFSC  FD8.2
01426:  BRA    184A
01428:  MOVLB  7
0142A:  MOVF   03,W
0142C:  BNZ   143A
0142E:  MOVLW  0B
01430:  SUBWF  00,W
01432:  MOVLB  0
01434:  BTFSC  FD8.2
01436:  BRA    1872
01438:  MOVLB  7
0143A:  MOVF   03,W
0143C:  BNZ   144A
0143E:  MOVLW  0C
01440:  SUBWF  00,W
01442:  MOVLB  0
01444:  BTFSC  FD8.2
01446:  BRA    1880
01448:  MOVLB  7
0144A:  MOVF   03,W
0144C:  BNZ   145A
0144E:  MOVLW  0D
01450:  SUBWF  00,W
01452:  MOVLB  0
01454:  BTFSC  FD8.2
01456:  BRA    188E
01458:  MOVLB  7
0145A:  MOVF   03,W
0145C:  BNZ   146A
0145E:  MOVLW  0E
01460:  SUBWF  00,W
01462:  MOVLB  0
01464:  BTFSC  FD8.2
01466:  BRA    189C
01468:  MOVLB  7
0146A:  MOVF   03,W
0146C:  BNZ   147A
0146E:  MOVLW  0F
01470:  SUBWF  00,W
01472:  MOVLB  0
01474:  BTFSC  FD8.2
01476:  BRA    18AA
01478:  MOVLB  7
0147A:  MOVF   03,W
0147C:  BNZ   148A
0147E:  MOVLW  10
01480:  SUBWF  00,W
01482:  MOVLB  0
01484:  BTFSC  FD8.2
01486:  BRA    18B8
01488:  MOVLB  7
0148A:  MOVF   03,W
0148C:  BNZ   149A
0148E:  MOVLW  11
01490:  SUBWF  00,W
01492:  MOVLB  0
01494:  BTFSC  FD8.2
01496:  BRA    18E0
01498:  MOVLB  7
0149A:  MOVF   03,W
0149C:  BNZ   14AA
0149E:  MOVLW  12
014A0:  SUBWF  00,W
014A2:  MOVLB  0
014A4:  BTFSC  FD8.2
014A6:  BRA    18EE
014A8:  MOVLB  7
014AA:  MOVF   03,W
014AC:  BNZ   14BA
014AE:  MOVLW  13
014B0:  SUBWF  00,W
014B2:  MOVLB  0
014B4:  BTFSC  FD8.2
014B6:  BRA    191C
014B8:  MOVLB  7
014BA:  MOVF   03,W
014BC:  BNZ   14CA
014BE:  MOVLW  14
014C0:  SUBWF  00,W
014C2:  MOVLB  0
014C4:  BTFSC  FD8.2
014C6:  BRA    1934
014C8:  MOVLB  7
014CA:  MOVF   03,W
014CC:  BNZ   14DA
014CE:  MOVLW  15
014D0:  SUBWF  00,W
014D2:  MOVLB  0
014D4:  BTFSC  FD8.2
014D6:  BRA    1942
014D8:  MOVLB  7
014DA:  MOVF   03,W
014DC:  BNZ   14EA
014DE:  MOVLW  16
014E0:  SUBWF  00,W
014E2:  MOVLB  0
014E4:  BTFSC  FD8.2
014E6:  BRA    1970
014E8:  MOVLB  7
014EA:  MOVF   03,W
014EC:  BNZ   14FA
014EE:  MOVLW  17
014F0:  SUBWF  00,W
014F2:  MOVLB  0
014F4:  BTFSC  FD8.2
014F6:  BRA    198A
014F8:  MOVLB  7
014FA:  MOVF   03,W
014FC:  BNZ   150A
014FE:  MOVLW  18
01500:  SUBWF  00,W
01502:  MOVLB  0
01504:  BTFSC  FD8.2
01506:  BRA    1998
01508:  MOVLB  7
0150A:  MOVF   03,W
0150C:  BNZ   151A
0150E:  MOVLW  19
01510:  SUBWF  00,W
01512:  MOVLB  0
01514:  BTFSC  FD8.2
01516:  BRA    19C6
01518:  MOVLB  7
0151A:  MOVF   03,W
0151C:  BNZ   152A
0151E:  MOVLW  1A
01520:  SUBWF  00,W
01522:  MOVLB  0
01524:  BTFSC  FD8.2
01526:  BRA    19E0
01528:  MOVLB  7
0152A:  MOVF   03,W
0152C:  BNZ   153A
0152E:  MOVLW  1B
01530:  SUBWF  00,W
01532:  MOVLB  0
01534:  BTFSC  FD8.2
01536:  BRA    19EE
01538:  MOVLB  7
0153A:  MOVF   03,W
0153C:  BNZ   154A
0153E:  MOVLW  1C
01540:  SUBWF  00,W
01542:  MOVLB  0
01544:  BTFSC  FD8.2
01546:  BRA    1A1C
01548:  MOVLB  7
0154A:  MOVF   03,W
0154C:  BNZ   155A
0154E:  MOVLW  1D
01550:  SUBWF  00,W
01552:  MOVLB  0
01554:  BTFSC  FD8.2
01556:  BRA    1A36
01558:  MOVLB  7
0155A:  MOVF   03,W
0155C:  BNZ   156A
0155E:  MOVLW  1E
01560:  SUBWF  00,W
01562:  MOVLB  0
01564:  BTFSC  FD8.2
01566:  BRA    1A44
01568:  MOVLB  7
0156A:  MOVF   03,W
0156C:  BNZ   157A
0156E:  MOVLW  1F
01570:  SUBWF  00,W
01572:  MOVLB  0
01574:  BTFSC  FD8.2
01576:  BRA    1A72
01578:  MOVLB  7
0157A:  MOVF   03,W
0157C:  BNZ   158A
0157E:  MOVLW  20
01580:  SUBWF  00,W
01582:  MOVLB  0
01584:  BTFSC  FD8.2
01586:  BRA    1A8C
01588:  MOVLB  7
0158A:  MOVF   03,W
0158C:  BNZ   159A
0158E:  MOVLW  21
01590:  SUBWF  00,W
01592:  MOVLB  0
01594:  BTFSC  FD8.2
01596:  BRA    1A9A
01598:  MOVLB  7
0159A:  MOVF   03,W
0159C:  BNZ   15AA
0159E:  MOVLW  22
015A0:  SUBWF  00,W
015A2:  MOVLB  0
015A4:  BTFSC  FD8.2
015A6:  BRA    1AC8
015A8:  MOVLB  7
015AA:  MOVF   03,W
015AC:  BNZ   15BA
015AE:  MOVLW  23
015B0:  SUBWF  00,W
015B2:  MOVLB  0
015B4:  BTFSC  FD8.2
015B6:  BRA    1AE2
015B8:  MOVLB  7
015BA:  MOVF   03,W
015BC:  BNZ   15CA
015BE:  MOVLW  24
015C0:  SUBWF  00,W
015C2:  MOVLB  0
015C4:  BTFSC  FD8.2
015C6:  BRA    1AF0
015C8:  MOVLB  7
015CA:  MOVF   03,W
015CC:  BNZ   15DA
015CE:  MOVLW  25
015D0:  SUBWF  00,W
015D2:  MOVLB  0
015D4:  BTFSC  FD8.2
015D6:  BRA    1B1E
015D8:  MOVLB  7
015DA:  MOVF   03,W
015DC:  BNZ   15EA
015DE:  MOVLW  26
015E0:  SUBWF  00,W
015E2:  MOVLB  0
015E4:  BTFSC  FD8.2
015E6:  BRA    1B38
015E8:  MOVLB  7
015EA:  MOVF   03,W
015EC:  BNZ   15FA
015EE:  MOVLW  27
015F0:  SUBWF  00,W
015F2:  MOVLB  0
015F4:  BTFSC  FD8.2
015F6:  BRA    1B46
015F8:  MOVLB  7
015FA:  MOVF   03,W
015FC:  BNZ   160A
015FE:  MOVLW  28
01600:  SUBWF  00,W
01602:  MOVLB  0
01604:  BTFSC  FD8.2
01606:  BRA    1B74
01608:  MOVLB  7
0160A:  MOVF   03,W
0160C:  BNZ   161A
0160E:  MOVLW  29
01610:  SUBWF  00,W
01612:  MOVLB  0
01614:  BTFSC  FD8.2
01616:  BRA    1B8E
01618:  MOVLB  7
0161A:  MOVF   03,W
0161C:  BNZ   162A
0161E:  MOVLW  2A
01620:  SUBWF  00,W
01622:  MOVLB  0
01624:  BTFSC  FD8.2
01626:  BRA    1B9C
01628:  MOVLB  7
0162A:  MOVF   03,W
0162C:  BNZ   163A
0162E:  MOVLW  2B
01630:  SUBWF  00,W
01632:  MOVLB  0
01634:  BTFSC  FD8.2
01636:  BRA    1BB6
01638:  MOVLB  7
0163A:  MOVF   03,W
0163C:  BNZ   164A
0163E:  MOVLW  2C
01640:  SUBWF  00,W
01642:  MOVLB  0
01644:  BTFSC  FD8.2
01646:  BRA    1BC6
01648:  MOVLB  7
0164A:  MOVF   03,W
0164C:  BNZ   165A
0164E:  MOVLW  2D
01650:  SUBWF  00,W
01652:  MOVLB  0
01654:  BTFSC  FD8.2
01656:  BRA    1BD6
01658:  MOVLB  7
0165A:  MOVF   03,W
0165C:  BNZ   166A
0165E:  MOVLW  2E
01660:  SUBWF  00,W
01662:  MOVLB  0
01664:  BTFSC  FD8.2
01666:  BRA    1BE6
01668:  MOVLB  7
0166A:  MOVF   03,W
0166C:  BNZ   167A
0166E:  MOVLW  2F
01670:  SUBWF  00,W
01672:  MOVLB  0
01674:  BTFSC  FD8.2
01676:  BRA    1BF6
01678:  MOVLB  7
0167A:  MOVF   03,W
0167C:  BNZ   168A
0167E:  MOVLW  30
01680:  SUBWF  00,W
01682:  MOVLB  0
01684:  BTFSC  FD8.2
01686:  BRA    1C06
01688:  MOVLB  7
0168A:  MOVF   03,W
0168C:  BNZ   169A
0168E:  MOVLW  31
01690:  SUBWF  00,W
01692:  MOVLB  0
01694:  BTFSC  FD8.2
01696:  BRA    1C16
01698:  MOVLB  7
0169A:  MOVF   03,W
0169C:  BNZ   16AA
0169E:  MOVLW  32
016A0:  SUBWF  00,W
016A2:  MOVLB  0
016A4:  BTFSC  FD8.2
016A6:  BRA    1C26
016A8:  MOVLB  7
016AA:  MOVF   03,W
016AC:  BNZ   16BA
016AE:  MOVLW  33
016B0:  SUBWF  00,W
016B2:  MOVLB  0
016B4:  BTFSC  FD8.2
016B6:  BRA    1C36
016B8:  MOVLB  7
016BA:  MOVLW  03
016BC:  SUBWF  03,W
016BE:  BNZ   16CC
016C0:  MOVLW  E8
016C2:  SUBWF  00,W
016C4:  MOVLB  0
016C6:  BTFSC  FD8.2
016C8:  BRA    1C46
016CA:  MOVLB  7
016CC:  MOVLW  03
016CE:  SUBWF  03,W
016D0:  BNZ   16DE
016D2:  MOVLW  E9
016D4:  SUBWF  00,W
016D6:  MOVLB  0
016D8:  BTFSC  FD8.2
016DA:  BRA    1C56
016DC:  MOVLB  7
016DE:  MOVLW  03
016E0:  SUBWF  03,W
016E2:  BNZ   16F0
016E4:  MOVLW  EA
016E6:  SUBWF  00,W
016E8:  MOVLB  0
016EA:  BTFSC  FD8.2
016EC:  BRA    1C64
016EE:  MOVLB  7
016F0:  MOVLW  03
016F2:  SUBWF  03,W
016F4:  BNZ   1702
016F6:  MOVLW  EB
016F8:  SUBWF  00,W
016FA:  MOVLB  0
016FC:  BTFSC  FD8.2
016FE:  BRA    1C72
01700:  MOVLB  7
01702:  MOVLW  03
01704:  SUBWF  03,W
01706:  BNZ   1714
01708:  MOVLW  EC
0170A:  SUBWF  00,W
0170C:  MOVLB  0
0170E:  BTFSC  FD8.2
01710:  BRA    1C80
01712:  MOVLB  7
01714:  MOVLW  03
01716:  SUBWF  03,W
01718:  BNZ   1726
0171A:  MOVLW  ED
0171C:  SUBWF  00,W
0171E:  MOVLB  0
01720:  BTFSC  FD8.2
01722:  BRA    1C8E
01724:  MOVLB  7
01726:  MOVLW  03
01728:  SUBWF  03,W
0172A:  BNZ   1738
0172C:  MOVLW  EE
0172E:  SUBWF  00,W
01730:  MOVLB  0
01732:  BTFSC  FD8.2
01734:  BRA    1C9C
01736:  MOVLB  7
01738:  MOVLW  03
0173A:  SUBWF  03,W
0173C:  BNZ   174A
0173E:  MOVLW  EF
01740:  SUBWF  00,W
01742:  MOVLB  0
01744:  BTFSC  FD8.2
01746:  BRA    1CAC
01748:  MOVLB  7
0174A:  MOVLW  03
0174C:  SUBWF  03,W
0174E:  BNZ   175C
01750:  MOVLW  F0
01752:  SUBWF  00,W
01754:  MOVLB  0
01756:  BTFSC  FD8.2
01758:  BRA    1CBA
0175A:  MOVLB  7
0175C:  MOVLW  03
0175E:  SUBWF  03,W
01760:  BNZ   176E
01762:  MOVLW  F1
01764:  SUBWF  00,W
01766:  MOVLB  0
01768:  BTFSC  FD8.2
0176A:  BRA    1CCA
0176C:  MOVLB  7
0176E:  MOVLW  03
01770:  SUBWF  03,W
01772:  BNZ   1780
01774:  MOVLW  F2
01776:  SUBWF  00,W
01778:  MOVLB  0
0177A:  BTFSC  FD8.2
0177C:  BRA    1CD8
0177E:  MOVLB  7
01780:  MOVLW  03
01782:  SUBWF  03,W
01784:  BNZ   1792
01786:  MOVLW  F3
01788:  SUBWF  00,W
0178A:  MOVLB  0
0178C:  BTFSC  FD8.2
0178E:  BRA    1CE6
01790:  MOVLB  7
01792:  MOVLW  03
01794:  SUBWF  03,W
01796:  BNZ   17A4
01798:  MOVLW  F4
0179A:  SUBWF  00,W
0179C:  MOVLB  0
0179E:  BTFSC  FD8.2
017A0:  BRA    1CF6
017A2:  MOVLB  7
017A4:  BRA    1D04
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
017A6:  MOVFF  A8,01
017AA:  MOVFF  A9,02
017AE:  MOVLB  7
017B0:  BRA    1D0C
017B2:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
017B4:  MOVF   x96,W
017B6:  MOVWF  01
017B8:  MOVF   x97,W
017BA:  MOVWF  02
017BC:  MOVLB  7
017BE:  BRA    1D0C
017C0:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
017C2:  MOVF   x9C,W
017C4:  MOVWF  01
017C6:  MOVF   x9D,W
017C8:  MOVWF  02
017CA:  MOVLB  7
017CC:  BRA    1D0C
017CE:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
017D0:  MOVF   xA2,W
017D2:  MOVWF  01
017D4:  MOVF   xA3,W
017D6:  MOVWF  02
017D8:  MOVLB  7
017DA:  BRA    1D0C
017DC:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
017DE:  MOVLB  7
017E0:  CLRF   xEA
017E2:  MOVLB  0
017E4:  RCALL  1106
017E6:  MOVFF  03,7C6
017EA:  MOVFF  02,7C5
017EE:  MOVFF  01,7C4
017F2:  MOVFF  00,7C3
017F6:  MOVLB  7
017F8:  MOVF   xC3,W
017FA:  MOVWF  01
017FC:  MOVF   xC4,W
017FE:  MOVWF  02
01800:  BRA    1D0C
01802:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01804:  MOVLB  7
01806:  MOVF   xC5,W
01808:  MOVWF  01
0180A:  MOVF   xC6,W
0180C:  MOVWF  02
0180E:  BRA    1D0C
01810:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01812:  MOVF   xAA,W
01814:  MOVWF  01
01816:  MOVF   xAB,W
01818:  MOVWF  02
0181A:  MOVLB  7
0181C:  BRA    1D0C
0181E:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01820:  MOVF   x98,W
01822:  MOVWF  01
01824:  MOVF   x99,W
01826:  MOVWF  02
01828:  MOVLB  7
0182A:  BRA    1D0C
0182C:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
0182E:  MOVF   x9E,W
01830:  MOVWF  01
01832:  MOVF   x9F,W
01834:  MOVWF  02
01836:  MOVLB  7
01838:  BRA    1D0C
0183A:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
0183C:  MOVF   xA4,W
0183E:  MOVWF  01
01840:  MOVF   xA5,W
01842:  MOVWF  02
01844:  MOVLB  7
01846:  BRA    1D0C
01848:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
0184A:  MOVLW  01
0184C:  MOVLB  7
0184E:  MOVWF  xEA
01850:  MOVLB  0
01852:  RCALL  1106
01854:  MOVFF  03,7C6
01858:  MOVFF  02,7C5
0185C:  MOVFF  01,7C4
01860:  MOVFF  00,7C3
01864:  MOVLB  7
01866:  MOVF   xC3,W
01868:  MOVWF  01
0186A:  MOVF   xC4,W
0186C:  MOVWF  02
0186E:  BRA    1D0C
01870:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01872:  MOVLB  7
01874:  MOVF   xC5,W
01876:  MOVWF  01
01878:  MOVF   xC6,W
0187A:  MOVWF  02
0187C:  BRA    1D0C
0187E:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01880:  MOVF   xAC,W
01882:  MOVWF  01
01884:  MOVF   xAD,W
01886:  MOVWF  02
01888:  MOVLB  7
0188A:  BRA    1D0C
0188C:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
0188E:  MOVF   x9A,W
01890:  MOVWF  01
01892:  MOVF   x9B,W
01894:  MOVWF  02
01896:  MOVLB  7
01898:  BRA    1D0C
0189A:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
0189C:  MOVF   xA0,W
0189E:  MOVWF  01
018A0:  MOVF   xA1,W
018A2:  MOVWF  02
018A4:  MOVLB  7
018A6:  BRA    1D0C
018A8:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
018AA:  MOVF   xA6,W
018AC:  MOVWF  01
018AE:  MOVF   xA7,W
018B0:  MOVWF  02
018B2:  MOVLB  7
018B4:  BRA    1D0C
018B6:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
018B8:  MOVLW  02
018BA:  MOVLB  7
018BC:  MOVWF  xEA
018BE:  MOVLB  0
018C0:  RCALL  1106
018C2:  MOVFF  03,7C6
018C6:  MOVFF  02,7C5
018CA:  MOVFF  01,7C4
018CE:  MOVFF  00,7C3
018D2:  MOVLB  7
018D4:  MOVF   xC3,W
018D6:  MOVWF  01
018D8:  MOVF   xC4,W
018DA:  MOVWF  02
018DC:  BRA    1D0C
018DE:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
018E0:  MOVLB  7
018E2:  MOVF   xC5,W
018E4:  MOVWF  01
018E6:  MOVF   xC6,W
018E8:  MOVWF  02
018EA:  BRA    1D0C
018EC:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
018EE:  CLRF   03
018F0:  MOVLB  1
018F2:  MOVF   xCA,W
018F4:  MOVWF  02
018F6:  BCF    FD8.0
018F8:  RLCF   02,F
018FA:  RLCF   03,F
018FC:  MOVF   02,W
018FE:  ADDLW  CA
01900:  MOVWF  FE9
01902:  MOVLW  00
01904:  ADDWFC 03,W
01906:  MOVWF  FEA
01908:  MOVFF  FEC,03
0190C:  MOVF   FED,F
0190E:  MOVF   FEF,W
01910:  MOVWF  01
01912:  MOVF   03,W
01914:  MOVWF  02
01916:  MOVLB  7
01918:  BRA    1D0C
0191A:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
0191C:  MOVLB  7
0191E:  CLRF   xEA
01920:  MOVLB  0
01922:  CALL   0D28
01926:  MOVF   01,W
01928:  MOVWF  01
0192A:  MOVF   02,W
0192C:  MOVWF  02
0192E:  MOVLB  7
01930:  BRA    1D0C
01932:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01934:  MOVF   xBA,W
01936:  MOVWF  01
01938:  MOVF   xBB,W
0193A:  MOVWF  02
0193C:  MOVLB  7
0193E:  BRA    1D0C
01940:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01942:  CLRF   03
01944:  MOVLB  1
01946:  MOVF   xCA,W
01948:  MOVWF  02
0194A:  BCF    FD8.0
0194C:  RLCF   02,F
0194E:  RLCF   03,F
01950:  MOVF   02,W
01952:  ADDLW  EA
01954:  MOVWF  FE9
01956:  MOVLW  00
01958:  ADDWFC 03,W
0195A:  MOVWF  FEA
0195C:  MOVFF  FEC,03
01960:  MOVF   FED,F
01962:  MOVF   FEF,W
01964:  MOVWF  01
01966:  MOVF   03,W
01968:  MOVWF  02
0196A:  MOVLB  7
0196C:  BRA    1D0C
0196E:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01970:  MOVLW  01
01972:  MOVLB  7
01974:  MOVWF  xEA
01976:  MOVLB  0
01978:  CALL   0D28
0197C:  MOVF   01,W
0197E:  MOVWF  01
01980:  MOVF   02,W
01982:  MOVWF  02
01984:  MOVLB  7
01986:  BRA    1D0C
01988:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0198A:  MOVF   xBC,W
0198C:  MOVWF  01
0198E:  MOVF   xBD,W
01990:  MOVWF  02
01992:  MOVLB  7
01994:  BRA    1D0C
01996:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01998:  CLRF   03
0199A:  MOVLB  1
0199C:  MOVF   xCA,W
0199E:  MOVWF  02
019A0:  BCF    FD8.0
019A2:  RLCF   02,F
019A4:  RLCF   03,F
019A6:  MOVF   02,W
019A8:  ADDLW  0A
019AA:  MOVWF  FE9
019AC:  MOVLW  01
019AE:  ADDWFC 03,W
019B0:  MOVWF  FEA
019B2:  MOVFF  FEC,03
019B6:  MOVF   FED,F
019B8:  MOVF   FEF,W
019BA:  MOVWF  01
019BC:  MOVF   03,W
019BE:  MOVWF  02
019C0:  MOVLB  7
019C2:  BRA    1D0C
019C4:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
019C6:  MOVLW  02
019C8:  MOVLB  7
019CA:  MOVWF  xEA
019CC:  MOVLB  0
019CE:  CALL   0D28
019D2:  MOVF   01,W
019D4:  MOVWF  01
019D6:  MOVF   02,W
019D8:  MOVWF  02
019DA:  MOVLB  7
019DC:  BRA    1D0C
019DE:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
019E0:  MOVF   xBE,W
019E2:  MOVWF  01
019E4:  MOVF   xBF,W
019E6:  MOVWF  02
019E8:  MOVLB  7
019EA:  BRA    1D0C
019EC:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
019EE:  CLRF   03
019F0:  MOVLB  1
019F2:  MOVF   xCA,W
019F4:  MOVWF  02
019F6:  BCF    FD8.0
019F8:  RLCF   02,F
019FA:  RLCF   03,F
019FC:  MOVF   02,W
019FE:  ADDLW  2A
01A00:  MOVWF  FE9
01A02:  MOVLW  01
01A04:  ADDWFC 03,W
01A06:  MOVWF  FEA
01A08:  MOVFF  FEC,03
01A0C:  MOVF   FED,F
01A0E:  MOVF   FEF,W
01A10:  MOVWF  01
01A12:  MOVF   03,W
01A14:  MOVWF  02
01A16:  MOVLB  7
01A18:  BRA    1D0C
01A1A:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01A1C:  MOVLW  03
01A1E:  MOVLB  7
01A20:  MOVWF  xEA
01A22:  MOVLB  0
01A24:  CALL   0D28
01A28:  MOVF   01,W
01A2A:  MOVWF  01
01A2C:  MOVF   02,W
01A2E:  MOVWF  02
01A30:  MOVLB  7
01A32:  BRA    1D0C
01A34:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01A36:  MOVF   xC0,W
01A38:  MOVWF  01
01A3A:  MOVF   xC1,W
01A3C:  MOVWF  02
01A3E:  MOVLB  7
01A40:  BRA    1D0C
01A42:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01A44:  CLRF   03
01A46:  MOVLB  1
01A48:  MOVF   xCA,W
01A4A:  MOVWF  02
01A4C:  BCF    FD8.0
01A4E:  RLCF   02,F
01A50:  RLCF   03,F
01A52:  MOVF   02,W
01A54:  ADDLW  4A
01A56:  MOVWF  FE9
01A58:  MOVLW  01
01A5A:  ADDWFC 03,W
01A5C:  MOVWF  FEA
01A5E:  MOVFF  FEC,03
01A62:  MOVF   FED,F
01A64:  MOVF   FEF,W
01A66:  MOVWF  01
01A68:  MOVF   03,W
01A6A:  MOVWF  02
01A6C:  MOVLB  7
01A6E:  BRA    1D0C
01A70:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01A72:  MOVLW  04
01A74:  MOVLB  7
01A76:  MOVWF  xEA
01A78:  MOVLB  0
01A7A:  CALL   0D28
01A7E:  MOVF   01,W
01A80:  MOVWF  01
01A82:  MOVF   02,W
01A84:  MOVWF  02
01A86:  MOVLB  7
01A88:  BRA    1D0C
01A8A:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01A8C:  MOVF   xC2,W
01A8E:  MOVWF  01
01A90:  MOVF   xC3,W
01A92:  MOVWF  02
01A94:  MOVLB  7
01A96:  BRA    1D0C
01A98:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01A9A:  CLRF   03
01A9C:  MOVLB  1
01A9E:  MOVF   xCA,W
01AA0:  MOVWF  02
01AA2:  BCF    FD8.0
01AA4:  RLCF   02,F
01AA6:  RLCF   03,F
01AA8:  MOVF   02,W
01AAA:  ADDLW  6A
01AAC:  MOVWF  FE9
01AAE:  MOVLW  01
01AB0:  ADDWFC 03,W
01AB2:  MOVWF  FEA
01AB4:  MOVFF  FEC,03
01AB8:  MOVF   FED,F
01ABA:  MOVF   FEF,W
01ABC:  MOVWF  01
01ABE:  MOVF   03,W
01AC0:  MOVWF  02
01AC2:  MOVLB  7
01AC4:  BRA    1D0C
01AC6:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01AC8:  MOVLW  05
01ACA:  MOVLB  7
01ACC:  MOVWF  xEA
01ACE:  MOVLB  0
01AD0:  CALL   0D28
01AD4:  MOVF   01,W
01AD6:  MOVWF  01
01AD8:  MOVF   02,W
01ADA:  MOVWF  02
01ADC:  MOVLB  7
01ADE:  BRA    1D0C
01AE0:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01AE2:  MOVF   xC4,W
01AE4:  MOVWF  01
01AE6:  MOVF   xC5,W
01AE8:  MOVWF  02
01AEA:  MOVLB  7
01AEC:  BRA    1D0C
01AEE:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01AF0:  CLRF   03
01AF2:  MOVLB  1
01AF4:  MOVF   xCA,W
01AF6:  MOVWF  02
01AF8:  BCF    FD8.0
01AFA:  RLCF   02,F
01AFC:  RLCF   03,F
01AFE:  MOVF   02,W
01B00:  ADDLW  8A
01B02:  MOVWF  FE9
01B04:  MOVLW  01
01B06:  ADDWFC 03,W
01B08:  MOVWF  FEA
01B0A:  MOVFF  FEC,03
01B0E:  MOVF   FED,F
01B10:  MOVF   FEF,W
01B12:  MOVWF  01
01B14:  MOVF   03,W
01B16:  MOVWF  02
01B18:  MOVLB  7
01B1A:  BRA    1D0C
01B1C:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01B1E:  MOVLW  06
01B20:  MOVLB  7
01B22:  MOVWF  xEA
01B24:  MOVLB  0
01B26:  CALL   0D28
01B2A:  MOVF   01,W
01B2C:  MOVWF  01
01B2E:  MOVF   02,W
01B30:  MOVWF  02
01B32:  MOVLB  7
01B34:  BRA    1D0C
01B36:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01B38:  MOVF   xC6,W
01B3A:  MOVWF  01
01B3C:  MOVF   xC7,W
01B3E:  MOVWF  02
01B40:  MOVLB  7
01B42:  BRA    1D0C
01B44:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01B46:  CLRF   03
01B48:  MOVLB  1
01B4A:  MOVF   xCA,W
01B4C:  MOVWF  02
01B4E:  BCF    FD8.0
01B50:  RLCF   02,F
01B52:  RLCF   03,F
01B54:  MOVF   02,W
01B56:  ADDLW  AA
01B58:  MOVWF  FE9
01B5A:  MOVLW  01
01B5C:  ADDWFC 03,W
01B5E:  MOVWF  FEA
01B60:  MOVFF  FEC,03
01B64:  MOVF   FED,F
01B66:  MOVF   FEF,W
01B68:  MOVWF  01
01B6A:  MOVF   03,W
01B6C:  MOVWF  02
01B6E:  MOVLB  7
01B70:  BRA    1D0C
01B72:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01B74:  MOVLW  07
01B76:  MOVLB  7
01B78:  MOVWF  xEA
01B7A:  MOVLB  0
01B7C:  CALL   0D28
01B80:  MOVF   01,W
01B82:  MOVWF  01
01B84:  MOVF   02,W
01B86:  MOVWF  02
01B88:  MOVLB  7
01B8A:  BRA    1D0C
01B8C:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01B8E:  MOVF   xC8,W
01B90:  MOVWF  01
01B92:  MOVF   xC9,W
01B94:  MOVWF  02
01B96:  MOVLB  7
01B98:  BRA    1D0C
01B9A:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01B9C:  MOVLB  1
01B9E:  MOVF   xD2,W
01BA0:  MOVWF  03
01BA2:  MOVF   xD1,W
01BA4:  INCF   xD1,F
01BA6:  BTFSC  FD8.2
01BA8:  INCF   xD2,F
01BAA:  MOVWF  01
01BAC:  MOVF   03,W
01BAE:  MOVWF  02
01BB0:  MOVLB  7
01BB2:  BRA    1D0C
01BB4:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01BB6:  MOVLB  1
01BB8:  MOVF   xD5,W
01BBA:  MOVWF  01
01BBC:  MOVF   xD6,W
01BBE:  MOVWF  02
01BC0:  MOVLB  7
01BC2:  BRA    1D0C
01BC4:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01BC6:  MOVLB  1
01BC8:  MOVF   xD3,W
01BCA:  MOVWF  01
01BCC:  MOVF   xD4,W
01BCE:  MOVWF  02
01BD0:  MOVLB  7
01BD2:  BRA    1D0C
01BD4:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01BD6:  MOVLB  1
01BD8:  MOVF   xD9,W
01BDA:  MOVWF  01
01BDC:  MOVF   xDA,W
01BDE:  MOVWF  02
01BE0:  MOVLB  7
01BE2:  BRA    1D0C
01BE4:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01BE6:  GOTO   1168
01BEA:  MOVLW  00
01BEC:  MOVWF  01
01BEE:  MOVWF  02
01BF0:  MOVLB  7
01BF2:  BRA    1D0C
01BF4:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01BF6:  GOTO   11A4
01BFA:  MOVLW  00
01BFC:  MOVWF  01
01BFE:  MOVWF  02
01C00:  MOVLB  7
01C02:  BRA    1D0C
01C04:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01C06:  MOVLB  1
01C08:  MOVF   xCB,W
01C0A:  MOVWF  01
01C0C:  MOVF   xCC,W
01C0E:  MOVWF  02
01C10:  MOVLB  7
01C12:  BRA    1D0C
01C14:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01C16:  MOVLB  1
01C18:  MOVF   xCD,W
01C1A:  MOVWF  01
01C1C:  MOVF   xCE,W
01C1E:  MOVWF  02
01C20:  MOVLB  7
01C22:  BRA    1D0C
01C24:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01C26:  MOVLB  1
01C28:  MOVF   xCF,W
01C2A:  MOVWF  01
01C2C:  MOVF   xD0,W
01C2E:  MOVWF  02
01C30:  MOVLB  7
01C32:  BRA    1D0C
01C34:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01C36:  GOTO   11CC
01C3A:  MOVLW  00
01C3C:  MOVWF  01
01C3E:  MOVWF  02
01C40:  MOVLB  7
01C42:  BRA    1D0C
01C44:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01C46:  CLRF   03
01C48:  MOVF   39,W
01C4A:  MOVWF  01
01C4C:  MOVF   03,W
01C4E:  MOVWF  02
01C50:  MOVLB  7
01C52:  BRA    1D0C
01C54:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01C56:  MOVF   3A,W
01C58:  MOVWF  01
01C5A:  MOVF   3B,W
01C5C:  MOVWF  02
01C5E:  MOVLB  7
01C60:  BRA    1D0C
01C62:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01C64:  MOVLW  50
01C66:  MOVWF  01
01C68:  MOVLW  00
01C6A:  MOVWF  02
01C6C:  MOVLB  7
01C6E:  BRA    1D0C
01C70:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01C72:  MOVLW  57
01C74:  MOVWF  01
01C76:  MOVLW  00
01C78:  MOVWF  02
01C7A:  MOVLB  7
01C7C:  BRA    1D0C
01C7E:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01C80:  MOVLW  58
01C82:  MOVWF  01
01C84:  MOVLW  00
01C86:  MOVWF  02
01C88:  MOVLB  7
01C8A:  BRA    1D0C
01C8C:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01C8E:  MOVLW  01
01C90:  MOVWF  01
01C92:  MOVLW  00
01C94:  MOVWF  02
01C96:  MOVLB  7
01C98:  BRA    1D0C
01C9A:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01C9C:  CLRF   03
01C9E:  MOVF   36,W
01CA0:  MOVWF  01
01CA2:  MOVF   03,W
01CA4:  MOVWF  02
01CA6:  MOVLB  7
01CA8:  BRA    1D0C
01CAA:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01CAC:  MOVF   3C,W
01CAE:  MOVWF  01
01CB0:  MOVF   3D,W
01CB2:  MOVWF  02
01CB4:  MOVLB  7
01CB6:  BRA    1D0C
01CB8:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01CBA:  CLRF   03
01CBC:  MOVF   3E,W
01CBE:  MOVWF  01
01CC0:  MOVF   03,W
01CC2:  MOVWF  02
01CC4:  MOVLB  7
01CC6:  BRA    1D0C
01CC8:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01CCA:  MOVF   3F,W
01CCC:  MOVWF  01
01CCE:  MOVF   40,W
01CD0:  MOVWF  02
01CD2:  MOVLB  7
01CD4:  BRA    1D0C
01CD6:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01CD8:  MOVF   41,W
01CDA:  MOVWF  01
01CDC:  MOVF   42,W
01CDE:  MOVWF  02
01CE0:  MOVLB  7
01CE2:  BRA    1D0C
01CE4:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01CE6:  CLRF   03
01CE8:  MOVF   43,W
01CEA:  MOVWF  01
01CEC:  MOVF   03,W
01CEE:  MOVWF  02
01CF0:  MOVLB  7
01CF2:  BRA    1D0C
01CF4:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01CF6:  CLRF   03
01CF8:  MOVF   38,W
01CFA:  MOVWF  01
01CFC:  MOVF   03,W
01CFE:  MOVWF  02
01D00:  MOVLB  7
01D02:  BRA    1D0C
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01D04:  MOVLW  FF
01D06:  MOVWF  01
01D08:  MOVWF  02
01D0A:  BRA    1D0C
.................... 	} 
....................  
.................... } 
01D0C:  MOVLB  0
01D0E:  GOTO   1D60 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
00F7C:  MOVLB  7
00F7E:  MOVF   xDA,W
00F80:  SUBLW  1F
00F82:  BNZ   0F9C
00F84:  MOVF   xDB,W
00F86:  SUBLW  4E
00F88:  BNZ   0F9C
00F8A:  MOVF   xDC,W
00F8C:  SUBLW  20
00F8E:  BNZ   0F9C
00F90:  MOVF   xDD,W
00F92:  SUBLW  4E
00F94:  BNZ   0F9C
.................... 		return 1; 
00F96:  MOVLW  01
00F98:  MOVWF  01
00F9A:  BRA    101C
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
00F9C:  MOVF   xDB,W
00F9E:  SUBLW  03
00FA0:  BC    0FC0
00FA2:  XORLW  FF
00FA4:  BNZ   0FAC
00FA6:  MOVF   xDA,W
00FA8:  SUBLW  4B
00FAA:  BC    0FC0
00FAC:  MOVF   xDD,W
00FAE:  SUBLW  04
00FB0:  BNC   0FC0
00FB2:  BNZ   0FBA
00FB4:  MOVF   xDC,W
00FB6:  SUBLW  95
00FB8:  BNC   0FC0
.................... 		return 1; 
00FBA:  MOVLW  01
00FBC:  MOVWF  01
00FBE:  BRA    101C
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
00FC0:  MOVF   xDB,W
00FC2:  SUBLW  02
00FC4:  BC    0FE4
00FC6:  XORLW  FF
00FC8:  BNZ   0FD0
00FCA:  MOVF   xDA,W
00FCC:  SUBLW  E7
00FCE:  BC    0FE4
00FD0:  MOVF   xDD,W
00FD2:  SUBLW  03
00FD4:  BNC   0FE4
00FD6:  BNZ   0FDE
00FD8:  MOVF   xDC,W
00FDA:  SUBLW  F5
00FDC:  BNC   0FE4
.................... 		return 1; 
00FDE:  MOVLW  01
00FE0:  MOVWF  01
00FE2:  BRA    101C
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
00FE4:  MOVF   xDB,W
00FE6:  SUBLW  06
00FE8:  BC    1008
00FEA:  XORLW  FF
00FEC:  BNZ   0FF4
00FEE:  MOVF   xDA,W
00FF0:  SUBLW  CF
00FF2:  BC    1008
00FF4:  MOVF   xDD,W
00FF6:  SUBLW  09
00FF8:  BNC   1008
00FFA:  BNZ   1002
00FFC:  MOVF   xDC,W
00FFE:  SUBLW  D1
01000:  BNC   1008
.................... 		return 1; 
01002:  MOVLW  01
01004:  MOVWF  01
01006:  BRA    101C
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01008:  MOVF   xDD,F
0100A:  BNZ   1018
0100C:  MOVF   xDC,W
0100E:  SUBLW  34
01010:  BNC   1018
.................... 		return 1; 
01012:  MOVLW  01
01014:  MOVWF  01
01016:  BRA    101C
....................  
.................... 	return 0; 
01018:  MOVLW  00
0101A:  MOVWF  01
.................... } 
0101C:  MOVLB  0
0101E:  GOTO   225C (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER+1)  
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER+1)  
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01D12:  MOVFF  7D9,7E2
01D16:  MOVFF  7D8,7E3
01D1A:  CALL   105E
.................... 	modbus_serial_putc(register_count*2); 
01D1E:  BCF    FD8.0
01D20:  MOVLB  7
01D22:  RLCF   xDC,W
01D24:  MOVWF  xE2
01D26:  RLCF   xDD,W
01D28:  MOVWF  xE3
01D2A:  MOVFF  7E2,7E4
01D2E:  MOVLB  0
01D30:  CALL   102A
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01D34:  MOVLB  7
01D36:  CLRF   xDF
01D38:  CLRF   xDE
01D3A:  MOVF   xDF,W
01D3C:  SUBWF  xDD,W
01D3E:  BNC   1D8A
01D40:  BNZ   1D48
01D42:  MOVF   xDC,W
01D44:  SUBWF  xDE,W
01D46:  BC    1D8A
.................... 		l=map_modbus(start_address+i); 
01D48:  MOVF   xDE,W
01D4A:  ADDWF  xDA,W
01D4C:  MOVWF  xE2
01D4E:  MOVF   xDF,W
01D50:  ADDWFC xDB,W
01D52:  MOVWF  xE3
01D54:  MOVWF  xE5
01D56:  MOVFF  7E2,7E4
01D5A:  MOVLB  0
01D5C:  GOTO   11E0
01D60:  MOVFF  02,7E1
01D64:  MOVFF  01,7E0
.................... 		modbus_serial_putc(make8(l,1)); 
01D68:  MOVFF  7E1,7E2
01D6C:  MOVFF  7E1,7E4
01D70:  CALL   102A
....................   		modbus_serial_putc(make8(l,0)); 
01D74:  MOVFF  7E0,7E2
01D78:  MOVFF  7E0,7E4
01D7C:  CALL   102A
.................... 	} 
01D80:  MOVLB  7
01D82:  INCF   xDE,F
01D84:  BTFSC  FD8.2
01D86:  INCF   xDF,F
01D88:  BRA    1D3A
....................  
.................... 	modbus_serial_send_stop(); 
01D8A:  MOVLB  0
01D8C:  CALL   108C
.................... } 
01D90:  GOTO   229E (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01D94:  MOVLB  7
01D96:  MOVF   xDF,W
01D98:  SUBLW  06
01D9A:  BC    1E12
01D9C:  XORLW  FF
01D9E:  BNZ   1DA6
01DA0:  MOVF   xDE,W
01DA2:  SUBLW  CF
01DA4:  BC    1E12
01DA6:  MOVF   xDF,W
01DA8:  SUBLW  09
01DAA:  BNC   1E12
01DAC:  BNZ   1DB4
01DAE:  MOVF   xDE,W
01DB0:  SUBLW  CF
01DB2:  BNC   1E12
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01DB4:  MOVF   xE1,W
01DB6:  SUBLW  00
01DB8:  BC    1DCA
01DBA:  XORLW  FF
01DBC:  BNZ   1DC4
01DBE:  MOVF   xE0,W
01DC0:  SUBLW  00
01DC2:  BC    1DCA
01DC4:  MOVLW  03
01DC6:  MOVWF  01
01DC8:  BRA    2094
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01DCA:  MOVLW  D0
01DCC:  SUBWF  xDE,W
01DCE:  MOVWF  xE4
01DD0:  MOVLW  07
01DD2:  SUBWFB xDF,W
01DD4:  MOVWF  xE5
01DD6:  MOVLW  02
01DD8:  ADDWF  xE5,F
01DDA:  MOVFF  7E5,FAA
01DDE:  MOVFF  7E4,FA9
01DE2:  MOVFF  7E0,FA8
01DE6:  BCF    FA6.6
01DE8:  BCF    FA6.7
01DEA:  BSF    FA6.2
01DEC:  MOVF   FF2,W
01DEE:  MOVWF  00
01DF0:  BCF    FF2.6
01DF2:  BCF    FF2.7
01DF4:  MOVLB  F
01DF6:  MOVLW  55
01DF8:  MOVWF  FA7
01DFA:  MOVLW  AA
01DFC:  MOVWF  FA7
01DFE:  BSF    FA6.1
01E00:  BTFSC  FA6.1
01E02:  BRA    1E00
01E04:  BCF    FA6.2
01E06:  MOVF   00,W
01E08:  IORWF  FF2,F
.................... 		return 0; 
01E0A:  MOVLW  00
01E0C:  MOVWF  01
01E0E:  MOVLB  7
01E10:  BRA    2094
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
01E12:  MOVF   xDF,W
01E14:  SUBLW  03
01E16:  BC    1EA8
01E18:  XORLW  FF
01E1A:  BNZ   1E22
01E1C:  MOVF   xDE,W
01E1E:  SUBLW  4B
01E20:  BC    1EA8
01E22:  MOVF   xDF,W
01E24:  SUBLW  04
01E26:  BNC   1EA8
01E28:  BNZ   1E30
01E2A:  MOVF   xDE,W
01E2C:  SUBLW  93
01E2E:  BNC   1EA8
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01E30:  MOVF   xE1,W
01E32:  SUBLW  00
01E34:  BC    1E46
01E36:  XORLW  FF
01E38:  BNZ   1E40
01E3A:  MOVF   xE0,W
01E3C:  SUBLW  00
01E3E:  BC    1E46
01E40:  MOVLW  03
01E42:  MOVWF  01
01E44:  BRA    2094
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
01E46:  MOVLW  4C
01E48:  SUBWF  xDE,W
01E4A:  MOVWF  xE2
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01E4C:  MOVFF  7E2,7EA
01E50:  MOVLW  06
01E52:  MOVWF  xEB
01E54:  MOVLB  0
01E56:  CALL   10DA
01E5A:  MOVFF  00,7E3
.................... 		n = n / 6; /* number of sentence */ 
01E5E:  MOVFF  7E2,7EA
01E62:  MOVLW  06
01E64:  MOVLB  7
01E66:  MOVWF  xEB
01E68:  MOVLB  0
01E6A:  CALL   10DA
01E6E:  MOVFF  01,7E2
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
01E72:  MOVLB  7
01E74:  MOVF   xE2,W
01E76:  MULLW  06
01E78:  MOVF   FF3,W
01E7A:  CLRF   03
01E7C:  ADDLW  18
01E7E:  MOVWF  xE4
01E80:  MOVLW  00
01E82:  ADDWFC 03,W
01E84:  MOVWF  xE5
01E86:  CLRF   03
01E88:  MOVF   xE3,W
01E8A:  ADDWF  xE4,W
01E8C:  MOVWF  01
01E8E:  MOVF   xE5,W
01E90:  ADDWFC 03,F
01E92:  MOVF   01,W
01E94:  ADDLW  36
01E96:  MOVWF  FE9
01E98:  MOVLW  00
01E9A:  ADDWFC 03,W
01E9C:  MOVWF  FEA
01E9E:  MOVFF  7E0,FEF
.................... 		 
.................... 		return 0; 
01EA2:  MOVLW  00
01EA4:  MOVWF  01
01EA6:  BRA    2094
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01EA8:  MOVLB  1
01EAA:  MOVF   xD7,F
01EAC:  BZ    1EE4
.................... 		if ( 1000 == address ) { 
01EAE:  MOVLB  7
01EB0:  MOVF   xDE,W
01EB2:  SUBLW  E8
01EB4:  BNZ   1EC8
01EB6:  MOVF   xDF,W
01EB8:  SUBLW  03
01EBA:  BNZ   1EC8
.................... 			config.serial_prefix=value; 
01EBC:  MOVFF  7E0,39
.................... 			return 0; 
01EC0:  MOVLW  00
01EC2:  MOVWF  01
01EC4:  BRA    2094
.................... 		} else if ( 1001 == address ) { 
01EC6:  BRA    1EE2
01EC8:  MOVF   xDE,W
01ECA:  SUBLW  E9
01ECC:  BNZ   1EE2
01ECE:  MOVF   xDF,W
01ED0:  SUBLW  03
01ED2:  BNZ   1EE2
.................... 			config.serial_number=value; 
01ED4:  MOVFF  7E1,3B
01ED8:  MOVFF  7E0,3A
.................... 			return 0; 
01EDC:  MOVLW  00
01EDE:  MOVWF  01
01EE0:  BRA    2094
01EE2:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01EE4:  MOVLB  7
01EE6:  MOVF   xDE,W
01EE8:  MOVWF  00
01EEA:  MOVF   xDF,W
01EEC:  MOVWF  03
01EEE:  MOVLW  03
01EF0:  SUBWF  03,W
01EF2:  BNZ   1EFE
01EF4:  MOVLW  EE
01EF6:  SUBWF  00,W
01EF8:  MOVLB  0
01EFA:  BZ    1F98
01EFC:  MOVLB  7
01EFE:  MOVLW  03
01F00:  SUBWF  03,W
01F02:  BNZ   1F0E
01F04:  MOVLW  EF
01F06:  SUBWF  00,W
01F08:  MOVLB  0
01F0A:  BZ    1FB0
01F0C:  MOVLB  7
01F0E:  MOVLW  03
01F10:  SUBWF  03,W
01F12:  BNZ   1F1E
01F14:  MOVLW  F0
01F16:  SUBWF  00,W
01F18:  MOVLB  0
01F1A:  BZ    1FC0
01F1C:  MOVLB  7
01F1E:  MOVLW  03
01F20:  SUBWF  03,W
01F22:  BNZ   1F2E
01F24:  MOVLW  F1
01F26:  SUBWF  00,W
01F28:  MOVLB  0
01F2A:  BZ    1FD8
01F2C:  MOVLB  7
01F2E:  MOVLW  03
01F30:  SUBWF  03,W
01F32:  BNZ   1F3E
01F34:  MOVLW  F2
01F36:  SUBWF  00,W
01F38:  MOVLB  0
01F3A:  BZ    1FE4
01F3C:  MOVLB  7
01F3E:  MOVLW  03
01F40:  SUBWF  03,W
01F42:  BNZ   1F4E
01F44:  MOVLW  F3
01F46:  SUBWF  00,W
01F48:  MOVLB  0
01F4A:  BZ    1FFE
01F4C:  MOVLB  7
01F4E:  MOVLW  03
01F50:  SUBWF  03,W
01F52:  BNZ   1F60
01F54:  MOVLW  F4
01F56:  SUBWF  00,W
01F58:  MOVLB  0
01F5A:  BTFSC  FD8.2
01F5C:  BRA    2016
01F5E:  MOVLB  7
01F60:  MOVLW  07
01F62:  SUBWF  03,W
01F64:  BNZ   1F72
01F66:  MOVLW  CE
01F68:  SUBWF  00,W
01F6A:  MOVLB  0
01F6C:  BTFSC  FD8.2
01F6E:  BRA    202E
01F70:  MOVLB  7
01F72:  MOVLW  07
01F74:  SUBWF  03,W
01F76:  BNZ   1F84
01F78:  MOVLW  CF
01F7A:  SUBWF  00,W
01F7C:  MOVLB  0
01F7E:  BTFSC  FD8.2
01F80:  BRA    2048
01F82:  MOVLB  7
01F84:  MOVLW  4E
01F86:  SUBWF  03,W
01F88:  BNZ   1F96
01F8A:  MOVLW  1F
01F8C:  SUBWF  00,W
01F8E:  MOVLB  0
01F90:  BTFSC  FD8.2
01F92:  BRA    2062
01F94:  MOVLB  7
01F96:  BRA    208A
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01F98:  MOVLB  7
01F9A:  MOVF   xE1,F
01F9C:  BNZ   1FA4
01F9E:  MOVF   xE0,W
01FA0:  SUBLW  80
01FA2:  BC    1FAA
01FA4:  MOVLW  03
01FA6:  MOVWF  01
01FA8:  BRA    2094
.................... 			config.modbus_address=value; 
01FAA:  MOVFF  7E0,36
.................... 			break; 
01FAE:  BRA    2090
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01FB0:  MOVLB  1
01FB2:  BSF    xF6.1
.................... 			config.adc_sample_ticks=value; 
01FB4:  MOVFF  7E1,3D
01FB8:  MOVFF  7E0,3C
.................... 			break; 
01FBC:  MOVLB  7
01FBE:  BRA    2090
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01FC0:  MOVLB  7
01FC2:  MOVF   xE1,F
01FC4:  BNZ   1FCC
01FC6:  MOVF   xE0,W
01FC8:  SUBLW  01
01FCA:  BC    1FD2
01FCC:  MOVLW  03
01FCE:  MOVWF  01
01FD0:  BRA    2094
.................... 			config.allow_bootload_request=value; 
01FD2:  MOVFF  7E0,3E
.................... 			break; 
01FD6:  BRA    2090
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01FD8:  MOVFF  7E1,40
01FDC:  MOVFF  7E0,3F
.................... 			break; 
01FE0:  MOVLB  7
01FE2:  BRA    2090
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01FE4:  MOVLB  7
01FE6:  MOVF   xE0,F
01FE8:  BNZ   1FF4
01FEA:  MOVF   xE1,F
01FEC:  BNZ   1FF4
01FEE:  MOVLW  03
01FF0:  MOVWF  01
01FF2:  BRA    2094
.................... 			config.pi_offtime_seconds=value; 
01FF4:  MOVFF  7E1,42
01FF8:  MOVFF  7E0,41
.................... 			break; 
01FFC:  BRA    2090
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01FFE:  MOVLB  7
02000:  MOVF   xE1,F
02002:  BNZ   200A
02004:  MOVF   xE0,W
02006:  SUBLW  01
02008:  BC    2010
0200A:  MOVLW  03
0200C:  MOVWF  01
0200E:  BRA    2094
.................... 			config.power_startup=value; 
02010:  MOVFF  7E0,43
.................... 			break; 
02014:  BRA    2090
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
02016:  MOVLB  7
02018:  MOVF   xE1,F
0201A:  BNZ   2022
0201C:  MOVF   xE0,W
0201E:  SUBLW  02
02020:  BC    2028
02022:  MOVLW  03
02024:  MOVWF  01
02026:  BRA    2094
.................... 			config.rs485_port_mode=value; 
02028:  MOVFF  7E0,38
.................... 			break; 
0202C:  BRA    2090
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
0202E:  MOVLB  7
02030:  DECFSZ xE0,W
02032:  BRA    2038
02034:  MOVF   xE1,F
02036:  BZ    203E
02038:  MOVLW  03
0203A:  MOVWF  01
0203C:  BRA    2094
.................... 			write_default_param_file(); 
0203E:  MOVLB  0
02040:  CALL   0A9E
.................... 			break; 
02044:  MOVLB  7
02046:  BRA    2090
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02048:  MOVLB  7
0204A:  DECFSZ xE0,W
0204C:  BRA    2052
0204E:  MOVF   xE1,F
02050:  BZ    2058
02052:  MOVLW  03
02054:  MOVWF  01
02056:  BRA    2094
.................... 			write_param_file(); 
02058:  MOVLB  0
0205A:  CALL   0A4A
.................... 			break; 
0205E:  MOVLB  7
02060:  BRA    2090
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
02062:  MOVLB  7
02064:  MOVF   xE0,W
02066:  SUBLW  0A
02068:  BNZ   2070
0206A:  MOVF   xE1,W
0206C:  SUBLW  07
0206E:  BZ    207C
.................... 				current.factory_unlocked=0; 
02070:  MOVLB  1
02072:  CLRF   xD7
.................... 				return ILLEGAL_DATA_VALUE; 
02074:  MOVLW  03
02076:  MOVWF  01
02078:  MOVLB  7
0207A:  BRA    2094
.................... 			} 
.................... 			current.factory_unlocked=1; 
0207C:  MOVLW  01
0207E:  MOVLB  1
02080:  MOVWF  xD7
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02082:  MOVLW  C8
02084:  MOVWF  xF3
.................... 			break; 
02086:  MOVLB  7
02088:  BRA    2090
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
0208A:  MOVLW  02
0208C:  MOVWF  01
0208E:  BRA    2094
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02090:  MOVLW  00
02092:  MOVWF  01
.................... } 
02094:  MOVLB  0
02096:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02128:  GOTO   0F36
0212C:  MOVF   01,F
0212E:  BTFSC  FD8.2
02130:  BRA    2414
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02132:  DECFSZ 38,W
02134:  BRA    21E8
02136:  MOVF   36,W
02138:  MOVLB  6
0213A:  SUBWF  xC0,W
0213C:  BTFSS  FD8.2
0213E:  BRA    2144
02140:  MOVLB  0
02142:  BRA    21E8
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02144:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02146:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02148:  CLRWDT
0214A:  MOVLW  02
0214C:  MOVLB  7
0214E:  MOVWF  xD8
02150:  MOVLW  B5
02152:  MOVWF  xD9
02154:  MOVLB  0
02156:  CALL   0F5C
0215A:  MOVLB  7
0215C:  DECFSZ xD8,F
0215E:  BRA    2150
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02160:  MOVLB  6
02162:  MOVF   xC0,W
02164:  MOVLB  0
02166:  CALL   06B4
.................... 			delay_us(104); //one stop bit @ 9600 baud 
0216A:  CLRWDT
0216C:  MOVLW  67
0216E:  MOVWF  00
02170:  DECFSZ 00,F
02172:  BRA    2170
02174:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02176:  MOVLB  6
02178:  MOVF   xC2,W
0217A:  MOVLB  0
0217C:  CALL   06B4
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02180:  CLRWDT
02182:  MOVLW  67
02184:  MOVWF  00
02186:  DECFSZ 00,F
02188:  BRA    2186
0218A:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
0218C:  MOVLB  7
0218E:  CLRF   xD7
02190:  MOVLW  02
02192:  MOVLB  6
02194:  ADDWF  xC1,W
02196:  MOVLB  7
02198:  SUBWF  xD7,W
0219A:  BC    21C8
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
0219C:  MOVLW  C4
0219E:  ADDWF  xD7,W
021A0:  MOVWF  FE9
021A2:  MOVLW  06
021A4:  MOVWF  FEA
021A6:  BTFSC  FD8.0
021A8:  INCF   FEA,F
021AA:  MOVFF  FEF,7D8
021AE:  MOVF   xD8,W
021B0:  MOVLB  0
021B2:  CALL   06B4
.................... 				delay_us(104); //one stop bit @ 9600 baud 
021B6:  CLRWDT
021B8:  MOVLW  67
021BA:  MOVWF  00
021BC:  DECFSZ 00,F
021BE:  BRA    21BC
021C0:  NOP   
.................... 			} 
021C2:  MOVLB  7
021C4:  INCF   xD7,F
021C6:  BRA    2190
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
021C8:  BTFSS  F72.1
021CA:  BRA    21C8
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
021CC:  CLRWDT
021CE:  MOVLW  02
021D0:  MOVWF  xD8
021D2:  MOVLW  B5
021D4:  MOVWF  xD9
021D6:  MOVLB  0
021D8:  CALL   0F5C
021DC:  MOVLB  7
021DE:  DECFSZ xD8,F
021E0:  BRA    21D2
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
021E2:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
021E4:  BCF    F8C.0
021E6:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
021E8:  MOVF   36,W
021EA:  SUBLW  80
021EC:  BZ    21FA
021EE:  MOVF   36,W
021F0:  MOVLB  6
021F2:  SUBWF  xC0,W
021F4:  BTFSS  FD8.2
021F6:  BRA    23FE
021F8:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
021FA:  MOVLB  1
021FC:  INCFSZ xCB,W
021FE:  BRA    2206
02200:  INCFSZ xCC,W
02202:  BRA    2206
02204:  BRA    220C
.................... 				current.modbus_our_packets++; 
02206:  INCF   xCB,F
02208:  BTFSC  FD8.2
0220A:  INCF   xCC,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
0220C:  MOVLW  14
0220E:  MOVWF  xF3
....................  
.................... 			switch(modbus_rx.func) { 
02210:  MOVLB  6
02212:  MOVF   xC2,W
02214:  XORLW  03
02216:  MOVLB  0
02218:  BZ    222A
0221A:  XORLW  07
0221C:  BZ    222A
0221E:  XORLW  02
02220:  BZ    22A2
02222:  XORLW  16
02224:  BTFSC  FD8.2
02226:  BRA    2314
02228:  BRA    23D6
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0222A:  MOVFF  6C4,7D3
0222E:  MOVFF  6C5,7D2
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02232:  MOVFF  6C6,7D5
02236:  MOVFF  6C7,7D4
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
0223A:  MOVLB  7
0223C:  MOVF   xD4,W
0223E:  ADDWF  xD2,W
02240:  MOVWF  xD8
02242:  MOVF   xD5,W
02244:  ADDWFC xD3,W
02246:  MOVWF  xD9
02248:  MOVFF  7D3,7DB
0224C:  MOVFF  7D2,7DA
02250:  MOVWF  xDD
02252:  MOVFF  7D8,7DC
02256:  MOVLB  0
02258:  GOTO   0F7C
0225C:  MOVF   01,F
0225E:  BNZ   2284
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02260:  MOVFF  6C0,7D8
02264:  MOVLB  7
02266:  CLRF   xDA
02268:  MOVFF  6C2,7D9
0226C:  MOVLW  02
0226E:  MOVWF  xDB
02270:  MOVLB  0
02272:  CALL   10BA
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02276:  MOVLB  1
02278:  CLRF   xD0
0227A:  MOVLW  02
0227C:  MOVWF  xCF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0227E:  CLRF   xF3
.................... 					} else { 
02280:  BRA    22A0
02282:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02284:  MOVFF  6C2,7D8
02288:  MOVFF  6C0,7D9
0228C:  MOVFF  7D3,7DB
02290:  MOVFF  7D2,7DA
02294:  MOVFF  7D5,7DD
02298:  MOVFF  7D4,7DC
0229C:  BRA    1D12
0229E:  MOVLB  1
.................... 					} 
.................... 					break; 
022A0:  BRA    23F6
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
022A2:  MOVFF  6C4,7D3
022A6:  MOVFF  6C5,7D2
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
022AA:  MOVFF  6C6,7D9
022AE:  MOVFF  6C7,7D8
022B2:  MOVFF  7D3,7DF
022B6:  MOVFF  7D2,7DE
022BA:  MOVFF  6C6,7E1
022BE:  MOVFF  6C7,7E0
022C2:  RCALL  1D94
022C4:  MOVFF  01,7D6
....................  
.................... 					if ( result ) { 
022C8:  MOVLB  7
022CA:  MOVF   xD6,F
022CC:  BZ    22F0
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
022CE:  MOVFF  6C0,7D8
022D2:  CLRF   xDA
022D4:  MOVFF  6C2,7D9
022D8:  MOVFF  7D6,7DB
022DC:  MOVLB  0
022DE:  CALL   10BA
.................... 						current.modbus_last_error=result; 
022E2:  MOVLB  1
022E4:  CLRF   xD0
022E6:  MOVFF  7D6,1CF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
022EA:  CLRF   xF3
.................... 					}  else { 
022EC:  BRA    2312
022EE:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
022F0:  MOVFF  6C6,7D9
022F4:  MOVFF  6C7,7D8
022F8:  MOVFF  6C0,7DA
022FC:  MOVFF  7D3,7DC
02300:  MOVFF  7D2,7DB
02304:  MOVFF  6C6,7DE
02308:  MOVFF  6C7,7DD
0230C:  MOVLB  0
0230E:  BRA    2098
02310:  MOVLB  1
.................... 					} 
.................... 					break; 
02312:  BRA    23F6
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02314:  MOVFF  6C4,7D3
02318:  MOVFF  6C5,7D2
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
0231C:  MOVFF  6C6,7D5
02320:  MOVFF  6C7,7D4
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02324:  MOVLB  7
02326:  CLRF   xD7
02328:  MOVF   xD5,F
0232A:  BNZ   2332
0232C:  MOVF   xD4,W
0232E:  SUBWF  xD7,W
02330:  BC    23B6
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02332:  MOVF   xD7,W
02334:  ADDWF  xD2,W
02336:  MOVWF  xD8
02338:  MOVLW  00
0233A:  ADDWFC xD3,W
0233C:  MOVWF  xD9
0233E:  BCF    FD8.0
02340:  RLCF   xD7,W
02342:  ADDLW  05
02344:  ADDLW  C4
02346:  MOVWF  FE9
02348:  MOVLW  06
0234A:  MOVWF  FEA
0234C:  BTFSC  FD8.0
0234E:  INCF   FEA,F
02350:  MOVFF  FEF,7DA
02354:  BCF    FD8.0
02356:  RLCF   xD7,W
02358:  ADDLW  06
0235A:  ADDLW  C4
0235C:  MOVWF  FE9
0235E:  MOVLW  06
02360:  MOVWF  FEA
02362:  BTFSC  FD8.0
02364:  INCF   FEA,F
02366:  MOVFF  FEF,7DB
0236A:  MOVFF  7DA,7DD
0236E:  MOVFF  7DB,7DC
02372:  MOVFF  7D9,7DF
02376:  MOVFF  7D8,7DE
0237A:  MOVFF  7DA,7E1
0237E:  MOVFF  7DB,7E0
02382:  MOVLB  0
02384:  RCALL  1D94
02386:  MOVFF  01,7D6
....................  
.................... 						if ( result ) { 
0238A:  MOVLB  7
0238C:  MOVF   xD6,F
0238E:  BZ    23B2
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02390:  MOVFF  6C0,7D8
02394:  CLRF   xDA
02396:  MOVFF  6C2,7D9
0239A:  MOVFF  7D6,7DB
0239E:  MOVLB  0
023A0:  CALL   10BA
.................... 							current.modbus_last_error=result; 
023A4:  MOVLB  1
023A6:  CLRF   xD0
023A8:  MOVFF  7D6,1CF
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
023AC:  CLRF   xF3
.................... 			 
.................... 							break; 
023AE:  MOVLB  7
023B0:  BRA    23B6
.................... 						} 
.................... 					} 
023B2:  INCF   xD7,F
023B4:  BRA    2328
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
023B6:  MOVF   xD6,F
023B8:  BNZ   23D2
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
023BA:  MOVFF  6C0,7D8
023BE:  MOVFF  7D3,7DA
023C2:  MOVFF  7D2,7D9
023C6:  MOVFF  7D5,7DC
023CA:  MOVFF  7D4,7DB
023CE:  MOVLB  0
023D0:  BRA    20E0
.................... 					} 
....................  
.................... 					break;   
023D2:  MOVLB  1
023D4:  BRA    23F6
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
023D6:  MOVFF  6C0,7D8
023DA:  MOVLB  7
023DC:  CLRF   xDA
023DE:  MOVFF  6C2,7D9
023E2:  MOVLW  01
023E4:  MOVWF  xDB
023E6:  MOVLB  0
023E8:  CALL   10BA
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
023EC:  MOVLB  1
023EE:  CLRF   xD0
023F0:  MOVLW  01
023F2:  MOVWF  xCF
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
023F4:  CLRF   xF3
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
023F6:  CLRF   xDA
023F8:  CLRF   xD9
....................  
.................... 		} else { 
023FA:  BRA    2414
023FC:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
023FE:  MOVLB  1
02400:  INCFSZ xCD,W
02402:  BRA    240A
02404:  INCFSZ xCE,W
02406:  BRA    240A
02408:  BRA    2410
.................... 				current.modbus_other_packets++; 
0240A:  INCF   xCD,F
0240C:  BTFSC  FD8.2
0240E:  INCF   xCE,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02410:  MOVLW  0A
02412:  MOVWF  xF3
02414:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02416:  GOTO   25B0 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00412:  MOVLB  8
00414:  BTFSS  xD9.0
00416:  BRA    0430
00418:  MOVLB  1
0041A:  INCFSZ xE2,W
0041C:  BRA    0428
0041E:  INCFSZ xE3,W
00420:  BRA    0428
00422:  MOVLB  8
00424:  BRA    0430
00426:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00428:  INCF   xE2,F
0042A:  BTFSC  FD8.2
0042C:  INCF   xE3,F
0042E:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00430:  BTFSS  xD9.2
00432:  BRA    044C
00434:  MOVLB  1
00436:  INCFSZ xE4,W
00438:  BRA    0444
0043A:  INCFSZ xE5,W
0043C:  BRA    0444
0043E:  MOVLB  8
00440:  BRA    044C
00442:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00444:  INCF   xE4,F
00446:  BTFSC  FD8.2
00448:  INCF   xE5,F
0044A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0044C:  BTFSS  xD9.4
0044E:  BRA    0468
00450:  MOVLB  1
00452:  INCFSZ xE6,W
00454:  BRA    0460
00456:  INCFSZ xE7,W
00458:  BRA    0460
0045A:  MOVLB  8
0045C:  BRA    0468
0045E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00460:  INCF   xE6,F
00462:  BTFSC  FD8.2
00464:  INCF   xE7,F
00466:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00468:  BCF    xD9.1
0046A:  BTFSC  F81.0
0046C:  BSF    xD9.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0046E:  BTFSC  xD9.1
00470:  BRA    04F4
00472:  MOVLB  6
00474:  BTFSC  xBC.1
00476:  BRA    047C
00478:  MOVLB  8
0047A:  BRA    04F4
.................... 		current.pulse_count[0]++; 
0047C:  MOVLB  0
0047E:  INCF   xA8,F
00480:  BTFSC  FD8.2
00482:  INCF   xA9,F
.................... 		current.pulse_sum[0]++; 
00484:  MOVLW  01
00486:  ADDWF  xAE,F
00488:  BTFSC  FD8.0
0048A:  INCF   xAF,F
0048C:  BTFSC  FD8.2
0048E:  INCF   xB0,F
00490:  BTFSC  FD8.2
00492:  INCF   xB1,F
.................... 		if ( 1 == ext0_state ) { 
00494:  MOVLB  6
00496:  BTFSS  xBC.2
00498:  BRA    04E2
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0049A:  MOVLB  8
0049C:  BCF    xD9.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0049E:  MOVFF  1E3,97
004A2:  MOVFF  1E2,96
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004A6:  MOVLB  0
004A8:  MOVF   x97,W
004AA:  SUBWF  x9D,W
004AC:  BNC   04BE
004AE:  BNZ   04B6
004B0:  MOVF   x9C,W
004B2:  SUBWF  x96,W
004B4:  BC    04BE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004B6:  MOVFF  97,9D
004BA:  MOVFF  96,9C
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004BE:  MOVF   xA3,W
004C0:  SUBWF  x97,W
004C2:  BNC   04DE
004C4:  BNZ   04CC
004C6:  MOVF   x96,W
004C8:  SUBWF  xA2,W
004CA:  BC    04DE
004CC:  INCFSZ x96,W
004CE:  BRA    04D6
004D0:  INCFSZ x97,W
004D2:  BRA    04D6
004D4:  BRA    04DE
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004D6:  MOVFF  97,A3
004DA:  MOVFF  96,A2
.................... 			} 
.................... 			ext0_state=0; 
004DE:  MOVLB  6
004E0:  BCF    xBC.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004E2:  BTFSC  xBC.2
004E4:  BRA    04F4
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004E6:  MOVLB  1
004E8:  CLRF   xE3
004EA:  CLRF   xE2
.................... 			ext0_count=1; 
004EC:  MOVLB  8
004EE:  BSF    xD9.0
.................... 			ext0_state=1; 
004F0:  MOVLB  6
004F2:  BSF    xBC.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004F4:  MOVLB  6
004F6:  BCF    xBC.1
004F8:  MOVLB  8
004FA:  BTFSS  xD9.1
004FC:  BRA    0504
004FE:  MOVLB  6
00500:  BSF    xBC.1
00502:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00504:  BCF    xD9.3
00506:  BTFSC  F81.1
00508:  BSF    xD9.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0050A:  BTFSC  xD9.3
0050C:  BRA    0590
0050E:  MOVLB  6
00510:  BTFSC  xBC.3
00512:  BRA    0518
00514:  MOVLB  8
00516:  BRA    0590
.................... 		current.pulse_count[1]++; 
00518:  MOVLB  0
0051A:  INCF   xAA,F
0051C:  BTFSC  FD8.2
0051E:  INCF   xAB,F
.................... 		current.pulse_sum[1]++; 
00520:  MOVLW  01
00522:  ADDWF  xB2,F
00524:  BTFSC  FD8.0
00526:  INCF   xB3,F
00528:  BTFSC  FD8.2
0052A:  INCF   xB4,F
0052C:  BTFSC  FD8.2
0052E:  INCF   xB5,F
.................... 		if ( 1 == ext1_state ) { 
00530:  MOVLB  6
00532:  BTFSS  xBC.4
00534:  BRA    057E
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00536:  MOVLB  8
00538:  BCF    xD9.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0053A:  MOVFF  1E5,99
0053E:  MOVFF  1E4,98
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00542:  MOVLB  0
00544:  MOVF   x99,W
00546:  SUBWF  x9F,W
00548:  BNC   055A
0054A:  BNZ   0552
0054C:  MOVF   x9E,W
0054E:  SUBWF  x98,W
00550:  BC    055A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00552:  MOVFF  99,9F
00556:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0055A:  MOVF   xA5,W
0055C:  SUBWF  x99,W
0055E:  BNC   057A
00560:  BNZ   0568
00562:  MOVF   x98,W
00564:  SUBWF  xA4,W
00566:  BC    057A
00568:  INCFSZ x98,W
0056A:  BRA    0572
0056C:  INCFSZ x99,W
0056E:  BRA    0572
00570:  BRA    057A
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
00572:  MOVFF  99,A5
00576:  MOVFF  98,A4
.................... 			} 
.................... 			ext1_state=0; 
0057A:  MOVLB  6
0057C:  BCF    xBC.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0057E:  BTFSC  xBC.4
00580:  BRA    0590
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
00582:  MOVLB  1
00584:  CLRF   xE5
00586:  CLRF   xE4
.................... 			ext1_count=1; 
00588:  MOVLB  8
0058A:  BSF    xD9.2
.................... 			ext1_state=1; 
0058C:  MOVLB  6
0058E:  BSF    xBC.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
00590:  MOVLB  6
00592:  BCF    xBC.3
00594:  MOVLB  8
00596:  BTFSS  xD9.3
00598:  BRA    05A0
0059A:  MOVLB  6
0059C:  BSF    xBC.3
0059E:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005A0:  BCF    xD9.5
005A2:  BTFSC  F81.2
005A4:  BSF    xD9.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005A6:  BTFSC  xD9.5
005A8:  BRA    062C
005AA:  MOVLB  6
005AC:  BTFSC  xBC.5
005AE:  BRA    05B4
005B0:  MOVLB  8
005B2:  BRA    062C
.................... 		current.pulse_count[2]++; 
005B4:  MOVLB  0
005B6:  INCF   xAC,F
005B8:  BTFSC  FD8.2
005BA:  INCF   xAD,F
.................... 		current.pulse_sum[2]++; 
005BC:  MOVLW  01
005BE:  ADDWF  xB6,F
005C0:  BTFSC  FD8.0
005C2:  INCF   xB7,F
005C4:  BTFSC  FD8.2
005C6:  INCF   xB8,F
005C8:  BTFSC  FD8.2
005CA:  INCF   xB9,F
.................... 		if ( 1 == ext2_state ) { 
005CC:  MOVLB  6
005CE:  BTFSS  xBC.6
005D0:  BRA    061A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
005D2:  MOVLB  8
005D4:  BCF    xD9.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005D6:  MOVFF  1E7,9B
005DA:  MOVFF  1E6,9A
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005DE:  MOVLB  0
005E0:  MOVF   x9B,W
005E2:  SUBWF  xA1,W
005E4:  BNC   05F6
005E6:  BNZ   05EE
005E8:  MOVF   xA0,W
005EA:  SUBWF  x9A,W
005EC:  BC    05F6
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005EE:  MOVFF  9B,A1
005F2:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005F6:  MOVF   xA7,W
005F8:  SUBWF  x9B,W
005FA:  BNC   0616
005FC:  BNZ   0604
005FE:  MOVF   x9A,W
00600:  SUBWF  xA6,W
00602:  BC    0616
00604:  INCFSZ x9A,W
00606:  BRA    060E
00608:  INCFSZ x9B,W
0060A:  BRA    060E
0060C:  BRA    0616
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0060E:  MOVFF  9B,A7
00612:  MOVFF  9A,A6
.................... 			} 
.................... 			ext2_state=0; 
00616:  MOVLB  6
00618:  BCF    xBC.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0061A:  BTFSC  xBC.6
0061C:  BRA    062C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0061E:  MOVLB  1
00620:  CLRF   xE7
00622:  CLRF   xE6
.................... 			ext2_count=1; 
00624:  MOVLB  8
00626:  BSF    xD9.4
.................... 			ext2_state=1; 
00628:  MOVLB  6
0062A:  BSF    xBC.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0062C:  MOVLB  6
0062E:  BCF    xBC.5
00630:  MOVLB  8
00632:  BTFSS  xD9.5
00634:  BRA    063C
00636:  MOVLB  6
00638:  BSF    xBC.5
0063A:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0063C:  MOVLB  7
0063E:  INCF   xC7,F
.................... 	if ( 10 == tick ) { 
00640:  MOVF   xC7,W
00642:  SUBLW  0A
00644:  BNZ   064E
.................... 		tick=0; 
00646:  CLRF   xC7
.................... 		timers.now_millisecond=1; 
00648:  MOVLB  1
0064A:  BSF    xF6.2
0064C:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0064E:  BCF    F9E.1
00650:  MOVLB  0
00652:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0066E:  BRA    0656
00670:  MOVFF  01,8D6
....................  
.................... 	if ( RS485_MODE_OFF != config.rs485_port_mode ) { 
00674:  MOVF   38,F
00676:  BZ    0698
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
00678:  MOVLB  2
0067A:  CLRF   xFB
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
0067C:  INCFSZ xFA,W
0067E:  BRA    0682
00680:  BRA    0696
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
00682:  MOVLW  FA
00684:  ADDWF  xFA,W
00686:  MOVWF  FE9
00688:  MOVLW  01
0068A:  MOVWF  FEA
0068C:  BTFSC  FD8.0
0068E:  INCF   FEA,F
00690:  MOVFF  8D6,FEF
.................... 			timers.rda2_buff_pos++; 
00694:  INCF   xFA,F
00696:  MOVLB  0
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00698:  BCF    FA4.5
0069A:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
006E8:  RCALL  069E
006EA:  MOVFF  01,8D6
....................  
.................... 	if ( current.bridged_uarts ) { 
006EE:  MOVLB  1
006F0:  BTFSS  xD8.0
006F2:  BRA    06FE
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,STREAM_RS485); 
006F4:  MOVLB  8
006F6:  MOVF   xD6,W
006F8:  MOVLB  0
006FA:  RCALL  06B4
.................... 		return; 
006FC:  BRA    0758
.................... 	} 
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006FE:  MOVLB  6
00700:  BTFSC  xBC.0
00702:  BRA    075A
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00704:  MOVF   xBD,F
00706:  BNZ   0718
.................... 			modbus_serial_crc.d = 0xFFFF; 
00708:  SETF   xBF
0070A:  SETF   xBE
.................... 			modbus_rx.address = c; 
0070C:  MOVFF  8D6,6C0
.................... 			modbus_serial_state++; 
00710:  INCF   xBD,F
.................... 			modbus_rx.len = 0; 
00712:  CLRF   xC1
.................... 			modbus_rx.error=0; 
00714:  CLRF   xC3
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00716:  BRA    0746
00718:  DECFSZ xBD,W
0071A:  BRA    0724
.................... 			modbus_rx.func = c; 
0071C:  MOVFF  8D6,6C2
.................... 			modbus_serial_state++; 
00720:  INCF   xBD,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00722:  BRA    0746
00724:  MOVF   xBD,W
00726:  SUBLW  02
00728:  BNZ   0746
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0072A:  INCFSZ xC1,W
0072C:  BRA    0732
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0072E:  MOVLW  FE
00730:  MOVWF  xC1
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
00732:  MOVLW  C4
00734:  ADDWF  xC1,W
00736:  MOVWF  FE9
00738:  MOVLW  06
0073A:  MOVWF  FEA
0073C:  BTFSC  FD8.0
0073E:  INCF   FEA,F
00740:  MOVFF  8D6,FEF
.................... 			modbus_rx.len++; 
00744:  INCF   xC1,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00746:  MOVFF  8D6,8D7
0074A:  MOVLB  0
0074C:  RCALL  06BC
.................... 		modbus_enable_timeout(TRUE); 
0074E:  MOVLW  01
00750:  MOVLB  8
00752:  MOVWF  xD7
00754:  MOVLB  0
00756:  RCALL  03CC
00758:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
....................  
0075A:  BCF    F9E.5
0075C:  MOVLB  0
0075E:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
007B4:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
007B6:  MOVLW  08
007B8:  MOVWF  F61
007BA:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
007BC:  MOVLW  00
007BE:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
007C0:  MOVLW  FF
007C2:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
007C4:  MOVLW  92
007C6:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
007C8:  MOVLW  80
007CA:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
007CC:  BCF    F96.0
007CE:  BCF    F96.1
007D0:  BCF    F96.2
007D2:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
007D4:  MOVLB  1
007D6:  CLRF   xF3
.................... 	timers.load_off_seconds=2; 
007D8:  CLRF   xF5
007DA:  MOVLW  02
007DC:  MOVWF  xF4
.................... 	timers.now_adc_sample=0; 
007DE:  BCF    xF6.0
.................... 	timers.now_adc_reset_count=0; 
007E0:  BCF    xF6.1
.................... 	timers.now_millisecond=0; 
007E2:  BCF    xF6.2
.................... 	timers.port_b=0b11111111; 
007E4:  SETF   xF7
.................... 	timers.port_c=0b11111111; 
007E6:  SETF   xF8
....................  
.................... 	timers.rda2_buff_pos=0; 
007E8:  MOVLB  2
007EA:  CLRF   xFA
.................... 	timers.rda2_buff_gap=255; 
007EC:  SETF   xFB
.................... 	timers.now_parse_rda2=0; 
007EE:  MOVLB  1
007F0:  BCF    xF9.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
007F2:  MOVLB  7
007F4:  CLRF   xD2
007F6:  MOVF   xD2,W
007F8:  SUBLW  02
007FA:  BNC   08A8
.................... 		current.pulse_period[i]=0; 
007FC:  CLRF   03
007FE:  MOVFF  7D2,02
00802:  BCF    FD8.0
00804:  RLCF   02,F
00806:  RLCF   03,F
00808:  MOVF   02,W
0080A:  ADDLW  96
0080C:  MOVWF  FE9
0080E:  MOVLW  00
00810:  ADDWFC 03,W
00812:  MOVWF  FEA
00814:  CLRF   FEC
00816:  MOVF   FED,F
00818:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
0081A:  CLRF   03
0081C:  MOVFF  7D2,02
00820:  BCF    FD8.0
00822:  RLCF   02,F
00824:  RLCF   03,F
00826:  MOVF   02,W
00828:  ADDLW  9C
0082A:  MOVWF  FE9
0082C:  MOVLW  00
0082E:  ADDWFC 03,W
00830:  MOVWF  FEA
00832:  SETF   FEC
00834:  MOVF   FED,F
00836:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00838:  CLRF   03
0083A:  MOVFF  7D2,02
0083E:  BCF    FD8.0
00840:  RLCF   02,F
00842:  RLCF   03,F
00844:  MOVF   02,W
00846:  ADDLW  A2
00848:  MOVWF  FE9
0084A:  MOVLW  00
0084C:  ADDWFC 03,W
0084E:  MOVWF  FEA
00850:  CLRF   FEC
00852:  MOVF   FED,F
00854:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00856:  CLRF   03
00858:  MOVFF  7D2,02
0085C:  BCF    FD8.0
0085E:  RLCF   02,F
00860:  RLCF   03,F
00862:  MOVF   02,W
00864:  ADDLW  A8
00866:  MOVWF  FE9
00868:  MOVLW  00
0086A:  ADDWFC 03,W
0086C:  MOVWF  FEA
0086E:  CLRF   FEC
00870:  MOVF   FED,F
00872:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00874:  CLRF   xF1
00876:  MOVFF  7D2,7F0
0087A:  CLRF   xF3
0087C:  MOVLW  04
0087E:  MOVWF  xF2
00880:  MOVLB  0
00882:  RCALL  0778
00884:  MOVF   01,W
00886:  ADDLW  AE
00888:  MOVWF  FE9
0088A:  MOVLW  00
0088C:  ADDWFC 02,W
0088E:  MOVWF  FEA
00890:  MOVF   FEE,F
00892:  MOVF   FEE,F
00894:  CLRF   FEC
00896:  MOVF   FED,F
00898:  CLRF   FEF
0089A:  MOVF   FED,F
0089C:  CLRF   FEF
0089E:  MOVF   FED,F
008A0:  CLRF   FEF
.................... 	} 
008A2:  MOVLB  7
008A4:  INCF   xD2,F
008A6:  BRA    07F6
....................  
.................... 	current.modbus_our_packets=0; 
008A8:  MOVLB  1
008AA:  CLRF   xCC
008AC:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
008AE:  CLRF   xCE
008B0:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
008B2:  CLRF   xD0
008B4:  CLRF   xCF
.................... 	current.sequence_number=0; 
008B6:  CLRF   xD2
008B8:  CLRF   xD1
.................... 	current.uptime_minutes=0; 
008BA:  CLRF   xD4
008BC:  CLRF   xD3
.................... 	current.interval_milliseconds=0; 
008BE:  CLRF   xD6
008C0:  CLRF   xD5
.................... 	current.adc_buffer_index=0; 
008C2:  CLRF   xCA
.................... 	current.factory_unlocked=0; 
008C4:  CLRF   xD7
.................... 	current.bridged_uarts=0; 
008C6:  BCF    xD8.0
.................... 	current.watchdog_seconds=0; 
008C8:  CLRF   xDA
008CA:  CLRF   xD9
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
008CC:  MOVLW  02
008CE:  MOVWF  FEA
008D0:  MOVLW  FC
008D2:  MOVWF  FE9
008D4:  CLRF   00
008D6:  MOVLW  03
008D8:  MOVWF  02
008DA:  MOVLW  C0
008DC:  MOVWF  01
008DE:  MOVLB  0
008E0:  RCALL  079A
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
008E2:  MOVFF  4B,1DD
008E6:  MOVFF  4A,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
008EA:  MOVFF  47,1DF
008EE:  MOVFF  46,1DE
.................... 	current.power_override_timeout=0; 
008F2:  MOVLB  1
008F4:  CLRF   xE1
008F6:  CLRF   xE0
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
008F8:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
008FA:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
008FC:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
008FE:  MOVLW  00
00900:  IORLW  05
00902:  MOVWF  FBA
00904:  MOVLW  4A
00906:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00908:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
0090A:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
0090C:  MOVLB  0
0090E:  GOTO   2532 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00DB0:  MOVLB  1
00DB2:  BCF    xF6.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00DB4:  BCF    FD8.0
00DB6:  MOVLB  7
00DB8:  RLCF   xCD,W
00DBA:  MOVWF  xD2
00DBC:  RLCF   xCE,W
00DBE:  MOVWF  xD3
00DC0:  MOVLW  00
00DC2:  MOVLB  1
00DC4:  BTFSS  xF8.5
00DC6:  MOVLW  01
00DC8:  MOVLB  7
00DCA:  IORWF  xD2,F
00DCC:  MOVFF  7D2,7CD
00DD0:  MOVF   xD3,W
00DD2:  IORLW  E0
00DD4:  MOVWF  xCE
.................... 	if ( b2_state==0xf000) { 
00DD6:  MOVF   xCD,F
00DD8:  BNZ   0DE0
00DDA:  MOVF   xCE,W
00DDC:  SUBLW  F0
00DDE:  BNZ   0DE0
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00DE0:  MOVLB  1
00DE2:  INCFSZ xE2,W
00DE4:  BRA    0DF2
00DE6:  INCFSZ xE3,W
00DE8:  BRA    0DF2
.................... 				current.pulse_period[0]=0; 
00DEA:  MOVLB  0
00DEC:  CLRF   x97
00DEE:  CLRF   x96
00DF0:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00DF2:  INCFSZ xE4,W
00DF4:  BRA    0E02
00DF6:  INCFSZ xE5,W
00DF8:  BRA    0E02
.................... 				current.pulse_period[1]=0; 
00DFA:  MOVLB  0
00DFC:  CLRF   x99
00DFE:  CLRF   x98
00E00:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00E02:  INCFSZ xE6,W
00E04:  BRA    0E12
00E06:  INCFSZ xE7,W
00E08:  BRA    0E12
.................... 				current.pulse_period[2]=0; 
00E0A:  MOVLB  0
00E0C:  CLRF   x9B
00E0E:  CLRF   x9A
00E10:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00E12:  MOVFF  F81,1F7
.................... 	timers.port_c=port_c; 
00E16:  MOVFF  F82,1F8
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00E1A:  BTFSS  xD8.0
00E1C:  BRA    0E22
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00E1E:  BSF    F89.3
.................... 	} else { 
00E20:  BRA    0E2E
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00E22:  MOVF   xF3,F
00E24:  BNZ   0E2A
.................... 			output_low(LED_GREEN); 
00E26:  BCF    F89.3
.................... 		} else { 
00E28:  BRA    0E2E
.................... 			output_high(LED_GREEN); 
00E2A:  BSF    F89.3
.................... 			timers.led_on_green--; 
00E2C:  DECF   xF3,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00E2E:  INCFSZ xD5,W
00E30:  BRA    0E38
00E32:  INCFSZ xD6,W
00E34:  BRA    0E38
00E36:  BRA    0E3E
.................... 		current.interval_milliseconds++; 
00E38:  INCF   xD5,F
00E3A:  BTFSC  FD8.2
00E3C:  INCF   xD6,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00E3E:  MOVLB  7
00E40:  INCF   xCB,F
00E42:  BTFSC  FD8.2
00E44:  INCF   xCC,F
.................... 	if ( 1000 == ticks ) { 
00E46:  MOVF   xCB,W
00E48:  SUBLW  E8
00E4A:  BNZ   0ED0
00E4C:  MOVF   xCC,W
00E4E:  SUBLW  03
00E50:  BNZ   0ED0
.................... 		ticks=0; 
00E52:  CLRF   xCC
00E54:  CLRF   xCB
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00E56:  MOVLB  1
00E58:  INCFSZ xD9,W
00E5A:  BRA    0E62
00E5C:  INCFSZ xDA,W
00E5E:  BRA    0E62
00E60:  BRA    0E68
.................... 			current.watchdog_seconds++; 
00E62:  INCF   xD9,F
00E64:  BTFSC  FD8.2
00E66:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00E68:  MOVF   3F,F
00E6A:  BNZ   0E70
00E6C:  MOVF   40,F
00E6E:  BZ    0E8E
00E70:  MOVF   40,W
00E72:  SUBWF  xDA,W
00E74:  BNC   0E8E
00E76:  BNZ   0E7E
00E78:  MOVF   xD9,W
00E7A:  SUBWF  3F,W
00E7C:  BC    0E8E
00E7E:  MOVF   xF4,F
00E80:  BNZ   0E8E
00E82:  MOVF   xF5,F
00E84:  BNZ   0E8E
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00E86:  MOVFF  42,1F5
00E8A:  MOVFF  41,1F4
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00E8E:  MOVF   xF4,F
00E90:  BNZ   0E9A
00E92:  MOVF   xF5,F
00E94:  BNZ   0E9A
.................... 			output_high(PI_POWER_EN); 
00E96:  BSF    F8B.0
.................... 		} else { 
00E98:  BRA    0EB0
.................... 			output_low(PI_POWER_EN); 
00E9A:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00E9C:  MOVF   xF4,W
00E9E:  BTFSC  FD8.2
00EA0:  DECF   xF5,F
00EA2:  DECF   xF4,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00EA4:  MOVF   xF4,F
00EA6:  BNZ   0EB0
00EA8:  MOVF   xF5,F
00EAA:  BNZ   0EB0
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00EAC:  CLRF   xDA
00EAE:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00EB0:  MOVLB  7
00EB2:  INCF   xC8,F
.................... 		if ( 60 == uptimeTicks ) { 
00EB4:  MOVF   xC8,W
00EB6:  SUBLW  3C
00EB8:  BNZ   0ED0
.................... 			uptimeTicks=0; 
00EBA:  CLRF   xC8
.................... 			if ( current.uptime_minutes < 65535 )  
00EBC:  MOVLB  1
00EBE:  INCFSZ xD3,W
00EC0:  BRA    0EC8
00EC2:  INCFSZ xD4,W
00EC4:  BRA    0EC8
00EC6:  BRA    0ECE
.................... 				current.uptime_minutes++; 
00EC8:  INCF   xD3,F
00ECA:  BTFSC  FD8.2
00ECC:  INCF   xD4,F
00ECE:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00ED0:  INCFSZ xCF,W
00ED2:  BRA    0EE6
00ED4:  INCFSZ xD0,W
00ED6:  BRA    0EE6
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00ED8:  CLRF   xEA
00EDA:  MOVLB  0
00EDC:  RCALL  0D28
00EDE:  MOVFF  02,7D0
00EE2:  MOVFF  01,7CF
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00EE6:  MOVLB  1
00EE8:  BTFSS  xF6.1
00EEA:  BRA    0EF4
.................... 		timers.now_adc_reset_count=0; 
00EEC:  BCF    xF6.1
.................... 		adcTicks=0; 
00EEE:  MOVLB  7
00EF0:  CLRF   xCA
00EF2:  CLRF   xC9
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00EF4:  MOVLB  7
00EF6:  INCF   xC9,F
00EF8:  BTFSC  FD8.2
00EFA:  INCF   xCA,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00EFC:  MOVF   3C,W
00EFE:  SUBWF  xC9,W
00F00:  BNZ   0F16
00F02:  MOVF   3D,W
00F04:  SUBWF  xCA,W
00F06:  BNZ   0F16
.................... 		adcTicks=0; 
00F08:  CLRF   xCA
00F0A:  CLRF   xC9
.................... 		timers.now_adc_sample=1; 
00F0C:  MOVLB  1
00F0E:  BSF    xF6.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00F10:  MOVLB  7
00F12:  SETF   xD0
00F14:  SETF   xCF
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
00F16:  MOVLB  2
00F18:  INCFSZ xFB,W
00F1A:  BRA    0F1E
00F1C:  BRA    0F20
.................... 		timers.rda2_buff_gap++; 
00F1E:  INCF   xFB,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
00F20:  MOVF   xFB,W
00F22:  SUBLW  09
00F24:  BC    0F30
00F26:  MOVF   xFA,F
00F28:  BZ    0F30
.................... 		timers.now_parse_rda2=1;	 
00F2A:  MOVLB  1
00F2C:  BSF    xF9.0
00F2E:  MOVLB  2
.................... 	} 
.................... } 
00F30:  MOVLB  0
00F32:  GOTO   259E (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
0241A:  MOVFF  2FA,8D2
.................... 	timers.rda2_buff_pos=255; /* stop getting more data for a second */ 
0241E:  MOVLB  2
02420:  SETF   xFA
.................... 	memcpy(buff,timers.rda2_buff,length); 
02422:  MOVLW  07
02424:  MOVWF  FEA
02426:  MOVLW  D2
02428:  MOVWF  FE9
0242A:  MOVLW  01
0242C:  MOVWF  FE2
0242E:  MOVLW  FA
02430:  MOVWF  FE1
02432:  MOVLB  8
02434:  MOVF   xD2,W
02436:  MOVWF  01
02438:  BZ    2442
0243A:  MOVFF  FE6,FEE
0243E:  DECFSZ 01,F
02440:  BRA    243A
.................... 	timers.rda2_buff_gap=0; 
02442:  MOVLB  2
02444:  CLRF   xFB
.................... 	timers.rda2_buff_pos=0; 
02446:  CLRF   xFA
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02448:  DECFSZ 38,W
0244A:  BRA    2482
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
0244C:  MOVLB  8
0244E:  CLRF   xD4
02450:  CLRF   xD3
02452:  MOVF   xD4,F
02454:  BNZ   247E
02456:  MOVF   xD2,W
02458:  SUBWF  xD3,W
0245A:  BC    247E
.................... 			fputc(buff[l],STREAM_PI); 
0245C:  MOVLW  D2
0245E:  ADDWF  xD3,W
02460:  MOVWF  FE9
02462:  MOVLW  07
02464:  ADDWFC xD4,W
02466:  MOVWF  FEA
02468:  MOVFF  FEF,8D5
0246C:  MOVF   xD5,W
0246E:  MOVLB  0
02470:  CALL   1022
.................... 		} 
02474:  MOVLB  8
02476:  INCF   xD3,F
02478:  BTFSC  FD8.2
0247A:  INCF   xD4,F
0247C:  BRA    2452
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
0247E:  BRA    248A
02480:  MOVLB  2
02482:  MOVF   38,W
02484:  SUBLW  02
02486:  BNZ   2488
02488:  MOVLB  8
.................... 		/* do something */ 
.................... 	} 
.................... } 
0248A:  MOVLB  0
0248C:  GOTO   25BC (RETURN)
....................  
....................  
.................... void main(void) { 
02490:  CLRF   FF8
02492:  BCF    FF1.2
02494:  BSF    F9F.1
02496:  BCF    F9F.5
02498:  BCF    FA5.5
0249A:  BSF    FD0.7
0249C:  BSF    07.7
0249E:  CLRF   FEA
024A0:  CLRF   FE9
024A2:  CLRF   35
024A4:  BCF    FB8.3
024A6:  MOVLW  0C
024A8:  MOVWF  FAF
024AA:  MOVLW  A6
024AC:  MOVWF  FAC
024AE:  MOVLW  90
024B0:  MOVWF  FAB
024B2:  BCF    F70.3
024B4:  MOVLW  4D
024B6:  MOVWF  F75
024B8:  MOVLW  A6
024BA:  MOVWF  F72
024BC:  MOVLW  90
024BE:  MOVWF  F71
024C0:  MOVLB  6
024C2:  BCF    xBC.0
024C4:  CLRF   xBD
024C6:  MOVLB  7
024C8:  CLRF   xC7
024CA:  MOVLB  6
024CC:  BCF    xBC.1
024CE:  BCF    xBC.2
024D0:  BCF    xBC.3
024D2:  BCF    xBC.4
024D4:  BCF    xBC.5
024D6:  BCF    xBC.6
024D8:  MOVLB  7
024DA:  CLRF   xC8
024DC:  CLRF   xCA
024DE:  CLRF   xC9
024E0:  CLRF   xCC
024E2:  CLRF   xCB
024E4:  CLRF   xCE
024E6:  CLRF   xCD
024E8:  MOVF   FC1,W
024EA:  ANDLW  F0
024EC:  MOVWF  FC1
024EE:  MOVLW  00
024F0:  MOVLB  F
024F2:  MOVWF  x38
024F4:  MOVWF  x3C
024F6:  MOVWF  x39
024F8:  MOVWF  x3A
024FA:  MOVWF  x3B
024FC:  MOVLB  1
024FE:  CLRF   x88
02500:  CLRF   F77
02502:  CLRF   F78
02504:  CLRF   F79
02506:  CLRF   2F
02508:  CLRF   30
0250A:  MOVLB  7
0250C:  CLRF   xC3
0250E:  CLRF   xC4
02510:  CLRF   xC5
02512:  CLRF   xC6
02514:  CLRF   xCF
02516:  CLRF   xD0
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02518:  MOVF   FD0,W
0251A:  ANDLW  0F
0251C:  BTFSS  FD0.4
0251E:  MOVLW  00
02520:  BSF    FD0.0
02522:  BSF    FD0.1
02524:  BSF    FD0.4
02526:  BSF    FD8.3
02528:  BSF    FD8.4
0252A:  MOVWF  xD1
....................  
.................... 	init(); 
0252C:  MOVLB  0
0252E:  GOTO   07B4
....................  
....................  
.................... #if 0 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
.................... 	output_high(RS485_NRE); 
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
....................  
.................... 	switch ( i ) { 
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02532:  GOTO   0B16
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02536:  MOVF   36,W
02538:  SUBLW  80
0253A:  BC    2540
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
0253C:  CALL   0A9E
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02540:  BSF    FAB.7
02542:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02544:  GOTO   0B74
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02548:  MOVLB  7
0254A:  CLRF   xD1
0254C:  MOVF   xD1,W
0254E:  SUBLW  1D
02550:  BNC   255E
.................... 		adc_update(); 
02552:  MOVLB  0
02554:  CALL   0C32
.................... 	} 
02558:  MOVLB  7
0255A:  INCF   xD1,F
0255C:  BRA    254C
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
0255E:  MOVFF  43,1DB
....................  
....................  
.................... #if 0 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
.................... 	output_low(RS485_DE); 
.................... 	output_low(RS485_NRE); 
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02562:  MOVLW  62
02564:  MOVWF  FF6
02566:  MOVLW  07
02568:  MOVWF  FF7
0256A:  MOVLW  07
0256C:  MOVWF  xD2
0256E:  MOVLB  0
02570:  GOTO   0CD8
02574:  MOVLW  6E
02576:  MOVWF  FF6
02578:  MOVLW  07
0257A:  MOVWF  FF7
0257C:  GOTO   0D04
02580:  MOVLW  0D
02582:  BTFSS  F9E.4
02584:  BRA    2582
02586:  MOVWF  FAD
02588:  MOVLW  0A
0258A:  BTFSS  F9E.4
0258C:  BRA    258A
0258E:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02590:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(STREAM_RS485) ) { 
.................... 				fputc(fgetc(STREAM_RS485),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
02592:  MOVLB  1
02594:  BTFSS  xF6.2
02596:  BRA    25A0
.................... 			periodic_millisecond(); 
02598:  MOVLB  0
0259A:  GOTO   0DB0
0259E:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
025A0:  BTFSS  xF6.0
025A2:  BRA    25AC
.................... 			timers.now_adc_sample=0; 
025A4:  BCF    xF6.0
.................... 			adc_update(); 
025A6:  MOVLB  0
025A8:  CALL   0C32
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
025AC:  MOVLB  0
025AE:  BRA    2128
.................... //		} 
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
025B0:  MOVLB  1
025B2:  BTFSS  xF9.0
025B4:  BRA    25BE
.................... 			timers.now_parse_rda2=0; 
025B6:  BCF    xF9.0
.................... 			rs485_to_host(); 
025B8:  MOVLB  0
025BA:  BRA    241A
025BC:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
025BE:  MOVLB  0
025C0:  BRA    2590
.................... } 
025C2:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
