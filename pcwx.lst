CCS PCH C Compiler, Version 4.135, 4375               02-Nov-15 06:23

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 9284 bytes (14%)
                         Largest free fragment is 56248
               RAM used: 712 (18%) at main() level
                         746 (19%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   21C6
*
00008:  GOTO   00CA
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03A4
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0658
0007C:  MOVFF  0E,00
00080:  MOVFF  0F,01
00084:  MOVFF  10,02
00088:  MOVFF  11,03
0008C:  MOVFF  0C,FE9
00090:  MOVFF  07,FEA
00094:  BSF    07.7
00096:  MOVFF  08,FE1
0009A:  MOVFF  09,FE2
0009E:  MOVFF  0A,FD9
000A2:  MOVFF  0B,FDA
000A6:  MOVFF  12,FF3
000AA:  MOVFF  13,FF4
000AE:  MOVFF  14,FFA
000B2:  MOVFF  15,FF5
000B6:  MOVFF  16,FF6
000BA:  MOVFF  17,FF7
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
000CA:  MOVWF  1A
000CC:  MOVFF  FD8,1B
000D0:  MOVFF  FE0,1C
000D4:  MOVLB  0
000D6:  MOVFF  FE9,22
000DA:  MOVFF  FEA,1D
000DE:  MOVFF  FE1,1E
000E2:  MOVFF  FE2,1F
000E6:  MOVFF  FD9,20
000EA:  MOVFF  FDA,21
000EE:  MOVFF  FF3,28
000F2:  MOVFF  FF4,29
000F6:  MOVFF  FFA,2A
000FA:  MOVFF  FF5,2B
000FE:  MOVFF  FF6,2C
00102:  MOVFF  FF7,2D
00106:  MOVFF  00,24
0010A:  MOVFF  01,25
0010E:  MOVFF  02,26
00112:  MOVFF  03,27
00116:  BTFSS  F9D.1
00118:  GOTO   0122
0011C:  BTFSC  F9E.1
0011E:  GOTO   03D6
00122:  MOVFF  24,00
00126:  MOVFF  25,01
0012A:  MOVFF  26,02
0012E:  MOVFF  27,03
00132:  MOVFF  22,FE9
00136:  MOVFF  1D,FEA
0013A:  BSF    1D.7
0013C:  MOVFF  1E,FE1
00140:  MOVFF  1F,FE2
00144:  MOVFF  20,FD9
00148:  MOVFF  21,FDA
0014C:  MOVFF  28,FF3
00150:  MOVFF  29,FF4
00154:  MOVFF  2A,FFA
00158:  MOVFF  2B,FF5
0015C:  MOVFF  2C,FF6
00160:  MOVFF  2D,FF7
00164:  MOVF   1A,W
00166:  MOVFF  1C,FE0
0016A:  MOVFF  1B,FD8
0016E:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=WEATHER_X_BAUD,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0060C:  BTFSS  F9E.5
0060E:  BRA    060C
00610:  MOVFF  FAB,35
00614:  MOVFF  FAE,01
00618:  BTFSS  35.1
0061A:  BRA    0620
0061C:  BCF    FAB.4
0061E:  BSF    FAB.4
00620:  RETURN 0
*
01082:  BTFSS  F9E.4
01084:  BRA    1082
01086:  MOVWF  FAD
01088:  GOTO   1094 (RETURN)
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=DEBUG, baud=9600,errors)	 
*
00622:  BTFSS  FA4.4
00624:  BRA    0622
00626:  MOVWF  F73
00628:  GOTO   066C (RETURN)
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
.................... 	int8 modbus_bridge; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
.................... } struct_time_keep; 
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00D3C:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00C9C:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00C9E:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00CA0:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00CA2:  MOVLB  2
00CA4:  MOVF   xCA,F
00CA6:  BNZ   0CAE
.................... 		c=0b00011; 
00CA8:  MOVLW  03
00CAA:  MOVWF  xCE
.................... 	else if ( 1 == ch )  
00CAC:  BRA    0CF8
00CAE:  DECFSZ xCA,W
00CB0:  BRA    0CB8
.................... 		c=0b10011; 
00CB2:  MOVLW  13
00CB4:  MOVWF  xCE
.................... 	else if ( 2 == ch )  
00CB6:  BRA    0CF8
00CB8:  MOVF   xCA,W
00CBA:  SUBLW  02
00CBC:  BNZ   0CC4
.................... 		c=0b01011; 
00CBE:  MOVLW  0B
00CC0:  MOVWF  xCE
.................... 	else if ( 3 == ch )  
00CC2:  BRA    0CF8
00CC4:  MOVF   xCA,W
00CC6:  SUBLW  03
00CC8:  BNZ   0CD0
.................... 		c=0b11011; 
00CCA:  MOVLW  1B
00CCC:  MOVWF  xCE
.................... 	else if ( 4 == ch ) 
00CCE:  BRA    0CF8
00CD0:  MOVF   xCA,W
00CD2:  SUBLW  04
00CD4:  BNZ   0CDC
.................... 		c=0b00111; 
00CD6:  MOVLW  07
00CD8:  MOVWF  xCE
.................... 	else if ( 5 == ch )  
00CDA:  BRA    0CF8
00CDC:  MOVF   xCA,W
00CDE:  SUBLW  05
00CE0:  BNZ   0CE8
.................... 		c=0b10111; 
00CE2:  MOVLW  17
00CE4:  MOVWF  xCE
.................... 	else if ( 6 == ch ) 
00CE6:  BRA    0CF8
00CE8:  MOVF   xCA,W
00CEA:  SUBLW  06
00CEC:  BNZ   0CF4
.................... 		c=0b01111; 
00CEE:  MOVLW  0F
00CF0:  MOVWF  xCE
.................... 	else 
00CF2:  BRA    0CF8
.................... 		c=0b11111; 
00CF4:  MOVLW  1F
00CF6:  MOVWF  xCE
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00CF8:  CLRF   xCD
00CFA:  MOVF   xCD,W
00CFC:  SUBLW  04
00CFE:  BNC   0D16
.................... 		output_low(MCP3208_CLK); 
00D00:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00D02:  BTFSC  xCE.0
00D04:  BRA    0D0A
00D06:  BCF    F8B.5
00D08:  BRA    0D0C
00D0A:  BSF    F8B.5
.................... 		c=c>>1; 
00D0C:  BCF    FD8.0
00D0E:  RRCF   xCE,F
.................... 		output_high(MCP3208_CLK); 
00D10:  BSF    F8B.3
.................... 	} 
00D12:  INCF   xCD,F
00D14:  BRA    0CFA
....................  
....................  
.................... 	value=0; 
00D16:  CLRF   xCC
00D18:  CLRF   xCB
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00D1A:  CLRF   xCD
00D1C:  MOVF   xCD,W
00D1E:  SUBLW  0D
00D20:  BNC   0D38
.................... 		output_low(MCP3208_CLK); 
00D22:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00D24:  BTFSC  F82.4
00D26:  BRA    0D2C
00D28:  BCF    FD8.0
00D2A:  BRA    0D2E
00D2C:  BSF    FD8.0
00D2E:  RLCF   xCB,F
00D30:  RLCF   xCC,F
.................... 		output_high(MCP3208_CLK); 
00D32:  BSF    F8B.3
.................... 	} 
00D34:  INCF   xCD,F
00D36:  BRA    0D1C
....................  
.................... 	bit_clear(value,13); 
00D38:  BCF    xCC.5
.................... 	bit_clear(value,12); 
00D3A:  BCF    xCC.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00D3E:  MOVFF  2CB,01
00D42:  MOVFF  2CC,02
.................... } 
00D46:  MOVLB  0
00D48:  GOTO   0DB8 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00DF2:  MOVLB  2
00DF4:  CLRF   xE2
00DF6:  MOVFF  2DB,2E1
00DFA:  CLRF   xE4
00DFC:  MOVLW  20
00DFE:  MOVWF  xE3
00E00:  MOVLB  0
00E02:  RCALL  081E
00E04:  MOVFF  02,03
00E08:  MOVF   01,W
00E0A:  ADDLW  82
00E0C:  MOVWF  01
00E0E:  MOVLW  00
00E10:  ADDWFC 03,F
00E12:  MOVFF  01,2DF
00E16:  MOVLB  2
00E18:  MOVFF  03,2E0
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00E1C:  CLRF   xDD
00E1E:  CLRF   xDC
.................... 	for( i = 0; i < 16 ; i++ ) { 
00E20:  CLRF   xDE
00E22:  MOVF   xDE,W
00E24:  SUBLW  0F
00E26:  BNC   0E4A
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00E28:  BCF    FD8.0
00E2A:  RLCF   xDE,W
00E2C:  CLRF   03
00E2E:  ADDWF  xDF,W
00E30:  MOVWF  FE9
00E32:  MOVF   xE0,W
00E34:  ADDWFC 03,W
00E36:  MOVWF  FEA
00E38:  MOVFF  FEC,03
00E3C:  MOVF   FED,F
00E3E:  MOVF   FEF,W
00E40:  ADDWF  xDC,F
00E42:  MOVF   03,W
00E44:  ADDWFC xDD,F
.................... 	} 
00E46:  INCF   xDE,F
00E48:  BRA    0E22
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00E4A:  MOVLW  08
00E4C:  ADDWF  xDC,W
00E4E:  MOVWF  xE1
00E50:  MOVLW  00
00E52:  ADDWFC xDD,W
00E54:  MOVWF  xE2
00E56:  RRCF   xE2,W
00E58:  MOVWF  03
00E5A:  RRCF   xE1,W
00E5C:  MOVWF  02
00E5E:  RRCF   03,F
00E60:  RRCF   02,F
00E62:  RRCF   03,F
00E64:  RRCF   02,F
00E66:  RRCF   03,F
00E68:  RRCF   02,F
00E6A:  MOVLW  0F
00E6C:  ANDWF  03,F
00E6E:  MOVFF  02,01
00E72:  MOVFF  03,02
.................... } 
00E76:  MOVLB  0
00E78:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00D4C:  MOVLB  1
00D4E:  INCF   x82,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00D50:  MOVF   x82,W
00D52:  SUBLW  0F
00D54:  BC    0D58
.................... 		current.adc_buffer_index=0; 
00D56:  CLRF   x82
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00D58:  MOVLB  2
00D5A:  CLRF   xC7
00D5C:  MOVF   xC7,W
00D5E:  SUBLW  07
00D60:  BNC   0DEE
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00D62:  CLRF   xE2
00D64:  MOVFF  2C7,2E1
00D68:  CLRF   xE4
00D6A:  MOVLW  20
00D6C:  MOVWF  xE3
00D6E:  MOVLB  0
00D70:  RCALL  081E
00D72:  MOVFF  02,03
00D76:  MOVF   01,W
00D78:  ADDLW  34
00D7A:  MOVLB  2
00D7C:  MOVWF  xC8
00D7E:  MOVLW  00
00D80:  ADDWFC 02,W
00D82:  MOVWF  xC9
00D84:  CLRF   03
00D86:  MOVLB  1
00D88:  MOVFF  182,02
00D8C:  BCF    FD8.0
00D8E:  RLCF   02,F
00D90:  RLCF   03,F
00D92:  MOVF   02,W
00D94:  MOVLB  2
00D96:  ADDWF  xC8,W
00D98:  MOVWF  01
00D9A:  MOVF   xC9,W
00D9C:  ADDWFC 03,F
00D9E:  MOVF   01,W
00DA0:  ADDLW  4E
00DA2:  MOVWF  01
00DA4:  MOVLW  00
00DA6:  ADDWFC 03,F
00DA8:  MOVFF  01,2C8
00DAC:  MOVFF  03,2C9
00DB0:  MOVFF  2C7,2CA
00DB4:  MOVLB  0
00DB6:  BRA    0C9C
00DB8:  MOVFF  2C9,FEA
00DBC:  MOVFF  2C8,FE9
00DC0:  MOVFF  02,FEC
00DC4:  MOVF   FED,F
00DC6:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00DCA:  CLRF   03
00DCC:  MOVLB  2
00DCE:  MOVFF  2C7,02
00DD2:  BCF    FD8.0
00DD4:  RLCF   02,F
00DD6:  RLCF   03,F
00DD8:  MOVF   02,W
00DDA:  ADDLW  72
00DDC:  MOVWF  FE9
00DDE:  MOVLW  00
00DE0:  ADDWFC 03,W
00DE2:  MOVWF  FEA
00DE4:  CLRF   FEC
00DE6:  MOVF   FED,F
00DE8:  CLRF   FEF
....................  
.................... 	} 
00DEA:  INCF   xC7,F
00DEC:  BRA    0D5C
.................... } 
00DEE:  MOVLB  0
00DF0:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00AE6:  MOVF   xE2,W
00AE8:  XORWF  xE3,W
00AEA:  MOVWF  01
*
00B38:  MOVF   xE2,W
00B3A:  XORWF  xE3,W
00B3C:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00A70:  MOVLB  2
00A72:  CLRF   xD0
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00A74:  MOVFF  2CF,03
00A78:  MOVF   xCE,W
00A7A:  BTFSC  FD8.2
00A7C:  DECF   xCF,F
00A7E:  DECF   xCE,F
00A80:  MOVWF  xD1
00A82:  MOVFF  03,2D2
00A86:  MOVF   xD1,F
00A88:  BNZ   0A8E
00A8A:  MOVF   xD2,F
00A8C:  BZ    0AF8
.................... 		*data = read_eeprom( address++ ); 
00A8E:  MOVFF  2CD,03
00A92:  MOVF   xCC,W
00A94:  MOVWF  FE9
00A96:  MOVFF  03,FEA
00A9A:  MOVF   xCB,W
00A9C:  MOVWF  03
00A9E:  MOVF   xCA,W
00AA0:  INCF   xCA,F
00AA2:  BTFSC  FD8.2
00AA4:  INCF   xCB,F
00AA6:  MOVWF  xD3
00AA8:  MOVFF  03,2D4
00AAC:  MOVFF  FF2,2D5
00AB0:  BCF    FF2.6
00AB2:  BCF    FF2.7
00AB4:  MOVFF  2D4,FAA
00AB8:  MOVFF  2D3,FA9
00ABC:  BCF    FA6.6
00ABE:  BCF    FA6.7
00AC0:  BSF    FA6.0
00AC2:  MOVF   FA8,W
00AC4:  BTFSC  xD5.6
00AC6:  BSF    FF2.6
00AC8:  BTFSC  xD5.7
00ACA:  BSF    FF2.7
00ACC:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00ACE:  MOVFF  2CD,03
00AD2:  MOVF   xCC,W
00AD4:  MOVWF  FE9
00AD6:  MOVFF  03,FEA
00ADA:  MOVFF  FEF,2D1
00ADE:  MOVFF  2D0,2E2
00AE2:  MOVFF  2D1,2E3
*
00AEC:  MOVFF  01,2D0
.................... 		data++; 
00AF0:  INCF   xCC,F
00AF2:  BTFSC  FD8.2
00AF4:  INCF   xCD,F
.................... 	} 
00AF6:  BRA    0A74
.................... 	return crc; 
00AF8:  MOVFF  2D0,01
.................... } 
00AFC:  MOVLB  0
00AFE:  GOTO   0C50 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00B02:  MOVLB  2
00B04:  CLRF   xE0
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B06:  MOVFF  2DF,03
00B0A:  MOVF   xDE,W
00B0C:  BTFSC  FD8.2
00B0E:  DECF   xDF,F
00B10:  DECF   xDE,F
00B12:  MOVWF  xE1
00B14:  MOVFF  03,2E2
00B18:  MOVF   xE1,F
00B1A:  BNZ   0B20
00B1C:  MOVF   xE2,F
00B1E:  BZ    0B9E
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00B20:  MOVFF  2DD,03
00B24:  MOVF   xDC,W
00B26:  MOVWF  FE9
00B28:  MOVFF  03,FEA
00B2C:  MOVFF  FEF,2E1
00B30:  MOVFF  2E0,2E2
00B34:  MOVFF  2E1,2E3
*
00B3E:  MOVFF  01,2E0
.................... 		write_eeprom( address++, *data++ ); 
00B42:  MOVF   xDB,W
00B44:  MOVWF  03
00B46:  MOVF   xDA,W
00B48:  INCF   xDA,F
00B4A:  BTFSC  FD8.2
00B4C:  INCF   xDB,F
00B4E:  MOVWF  xE1
00B50:  MOVFF  03,2E2
00B54:  MOVF   xDD,W
00B56:  MOVWF  03
00B58:  MOVF   xDC,W
00B5A:  INCF   xDC,F
00B5C:  BTFSC  FD8.2
00B5E:  INCF   xDD,F
00B60:  MOVWF  FE9
00B62:  MOVFF  03,FEA
00B66:  MOVFF  FEF,2E3
00B6A:  MOVFF  2E2,FAA
00B6E:  MOVFF  2E1,FA9
00B72:  MOVFF  2E3,FA8
00B76:  BCF    FA6.6
00B78:  BCF    FA6.7
00B7A:  BSF    FA6.2
00B7C:  MOVF   FF2,W
00B7E:  MOVWF  00
00B80:  BCF    FF2.6
00B82:  BCF    FF2.7
00B84:  MOVLB  F
00B86:  MOVLW  55
00B88:  MOVWF  FA7
00B8A:  MOVLW  AA
00B8C:  MOVWF  FA7
00B8E:  BSF    FA6.1
00B90:  BTFSC  FA6.1
00B92:  BRA    0B90
00B94:  BCF    FA6.2
00B96:  MOVF   00,W
00B98:  IORWF  FF2,F
.................... 	} 
00B9A:  MOVLB  2
00B9C:  BRA    0B06
....................  
.................... 	return crc; 
00B9E:  MOVFF  2E0,01
.................... } 
00BA2:  MOVLB  0
00BA4:  GOTO   0BC8 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00BA8:  MOVLB  2
00BAA:  CLRF   xD9
00BAC:  MOVLW  36
00BAE:  MOVWF  xD8
00BB0:  CLRF   xDB
00BB2:  MOVLW  02
00BB4:  MOVWF  xDA
00BB6:  MOVFF  2D9,2DD
00BBA:  MOVFF  2D8,2DC
00BBE:  CLRF   xDF
00BC0:  MOVLW  18
00BC2:  MOVWF  xDE
00BC4:  MOVLB  0
00BC6:  BRA    0B02
00BC8:  MOVFF  01,2D7
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00BCC:  CLRF   FAA
00BCE:  CLRF   FA9
00BD0:  MOVFF  2D7,FA8
00BD4:  BCF    FA6.6
00BD6:  BCF    FA6.7
00BD8:  BSF    FA6.2
00BDA:  MOVF   FF2,W
00BDC:  MOVWF  00
00BDE:  BCF    FF2.6
00BE0:  BCF    FF2.7
00BE2:  MOVLB  F
00BE4:  MOVLW  55
00BE6:  MOVWF  FA7
00BE8:  MOVLW  AA
00BEA:  MOVWF  FA7
00BEC:  BSF    FA6.1
00BEE:  BTFSC  FA6.1
00BF0:  BRA    0BEE
00BF2:  BCF    FA6.2
00BF4:  MOVF   00,W
00BF6:  IORWF  FF2,F
.................... } 
00BF8:  MOVLB  0
00BFA:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00BFC:  MOVLW  96
00BFE:  MOVLB  1
00C00:  MOVWF  xAB
....................  
.................... //	config.modbus_address=38; 
.................... 	config.modbus_address=128; /* use any address */ 
00C02:  MOVLW  80
00C04:  MOVWF  36
....................  
.................... 	config.serial_prefix='P'; 
00C06:  MOVLW  50
00C08:  MOVWF  39
.................... 	config.serial_number=9876; 
00C0A:  MOVLW  26
00C0C:  MOVWF  3B
00C0E:  MOVLW  94
00C10:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00C12:  CLRF   3D
00C14:  MOVLW  14
00C16:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00C18:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00C1A:  MOVLW  02
00C1C:  MOVWF  40
00C1E:  MOVLW  76
00C20:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00C22:  CLRF   42
00C24:  MOVLW  02
00C26:  MOVWF  41
.................... 	config.power_startup=0; 
00C28:  CLRF   43
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00C2A:  MOVLB  0
00C2C:  RCALL  0BA8
....................  
.................... } 
00C2E:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00C30:  MOVLB  2
00C32:  CLRF   xC9
00C34:  MOVLW  36
00C36:  MOVWF  xC8
00C38:  CLRF   xCB
00C3A:  MOVLW  02
00C3C:  MOVWF  xCA
00C3E:  MOVFF  2C9,2CD
00C42:  MOVFF  2C8,2CC
00C46:  CLRF   xCF
00C48:  MOVLW  18
00C4A:  MOVWF  xCE
00C4C:  MOVLB  0
00C4E:  BRA    0A70
00C50:  MOVFF  01,2C7
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00C54:  MOVFF  FF2,2C8
00C58:  BCF    FF2.6
00C5A:  BCF    FF2.7
00C5C:  CLRF   FAA
00C5E:  CLRF   FA9
00C60:  BCF    FA6.6
00C62:  BCF    FA6.7
00C64:  BSF    FA6.0
00C66:  MOVF   FA8,W
00C68:  MOVLB  2
00C6A:  BTFSC  xC8.6
00C6C:  BSF    FF2.6
00C6E:  BTFSC  xC8.7
00C70:  BSF    FF2.7
00C72:  SUBWF  xC7,W
00C74:  BZ    0C7C
.................... 		write_default_param_file(); 
00C76:  MOVLB  0
00C78:  RCALL  0BFC
00C7A:  MOVLB  2
.................... 	} 
.................... } 
00C7C:  MOVLB  0
00C7E:  GOTO   2374 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
010E6:  BTFSS  FAC.1
010E8:  BRA    10E6
.................... } 
010EA:  GOTO   1104 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(MODBUS_SERIAL) ) { 
*
00C82:  BTFSS  F9E.5
00C84:  BRA    0C8A
.................... 		fgetc(MODBUS_SERIAL); 
00C86:  RCALL  060C
.................... 	} 
00C88:  BRA    0C82
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00C8A:  BSF    F9D.5
.................... } 
00C8C:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00C8E:  RCALL  0C82
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00C90:  MOVLW  C6
00C92:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00C94:  MOVLW  C0
00C96:  IORWF  FF2,F
.................... } 
00C98:  GOTO   23B6 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
00390:  BCF    FF2.5
.................... 	if (enable) { 
00392:  MOVLB  2
00394:  MOVF   xE7,F
00396:  BZ    03A0
.................... 		set_timer0(0); 
00398:  CLRF   FD7
0039A:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
0039C:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
0039E:  BSF    FF2.5
.................... 	} 
.................... } 
003A0:  MOVLB  0
003A2:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003A4:  MOVLB  1
003A6:  MOVF   xB2,W
003A8:  SUBLW  02
003AA:  BNZ   03C0
003AC:  MOVF   xB3,F
003AE:  BNZ   03C0
003B0:  MOVF   xB4,F
003B2:  BNZ   03C0
003B4:  BTFSC  xB1.0
003B6:  BRA    03C0
....................    { 
....................       modbus_rx.len-=2; 
003B8:  MOVLW  02
003BA:  SUBWF  xB6,F
....................       modbus_serial_new=TRUE; 
003BC:  BSF    xB1.0
....................    } 
....................    else 
003BE:  BRA    03C2
....................       modbus_serial_new=FALSE; 
003C0:  BCF    xB1.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003C2:  SETF   xB4
003C4:  SETF   xB3
....................    modbus_serial_state=MODBUS_GETADDY; 
003C6:  CLRF   xB2
....................    modbus_enable_timeout(FALSE); 
003C8:  MOVLB  2
003CA:  CLRF   xE7
003CC:  MOVLB  0
003CE:  RCALL  0390
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003D0:  BCF    FF2.2
003D2:  GOTO   007C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
0062C:  MOVLB  1
0062E:  MOVF   xB4,W
00630:  MOVLB  2
00632:  XORWF  xE7,W
00634:  MOVWF  xE8
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00636:  CLRF   03
00638:  MOVF   xE8,W
0063A:  MOVLB  0
0063C:  RCALL  0170
0063E:  MOVWF  01
00640:  MOVLB  1
00642:  MOVF   xB3,W
00644:  XORWF  01,W
00646:  MOVWF  xB4
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00648:  CLRF   03
0064A:  MOVLB  2
0064C:  MOVF   xE8,W
0064E:  MOVLB  0
00650:  RCALL  0280
00652:  MOVFF  FE8,1B3
.................... } 
00656:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, MODBUS_SERIAL); 
*
0108C:  MOVLB  2
0108E:  MOVF   xD9,W
01090:  MOVLB  0
01092:  BRA    1082
01094:  CLRF   19
01096:  BTFSC  FF2.6
01098:  BSF    19.6
0109A:  BCF    FF2.6
0109C:  BTFSC  FF2.7
0109E:  BSF    19.7
010A0:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
010A2:  MOVFF  2D9,2E7
010A6:  CALL   062C
010AA:  BTFSC  19.6
010AC:  BSF    FF2.6
010AE:  BTFSC  19.7
010B0:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
010B2:  CLRWDT
010B4:  MOVLW  08
010B6:  MOVWF  00
010B8:  DECFSZ 00,F
010BA:  BRA    10B8
010BC:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
010BE:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
010C0:  MOVLB  1
010C2:  SETF   xB4
010C4:  SETF   xB3
....................    modbus_serial_new=FALSE; 
010C6:  BCF    xB1.0
....................  
....................    RCV_OFF(); 
010C8:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
010CA:  CLRWDT
010CC:  MOVLW  1E
010CE:  MOVWF  00
010D0:  DECFSZ 00,F
010D2:  BRA    10D0
010D4:  NOP   
....................  
....................    modbus_serial_putc(to); 
010D6:  MOVFF  2D7,2D9
010DA:  MOVLB  0
010DC:  RCALL  108C
....................    modbus_serial_putc(func); 
010DE:  MOVFF  2D8,2D9
010E2:  RCALL  108C
.................... } 
010E4:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
010EE:  MOVFF  1B4,2D8
....................    crc_low=modbus_serial_crc.b[0]; 
010F2:  MOVFF  1B3,2D7
....................  
....................    modbus_serial_putc(crc_high); 
010F6:  MOVFF  2D8,2D9
010FA:  RCALL  108C
....................    modbus_serial_putc(crc_low); 
010FC:  MOVFF  2D7,2D9
01100:  RCALL  108C
....................  
....................    WAIT_FOR_HW_BUFFER(); 
01102:  BRA    10E6
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
01104:  CLRWDT
01106:  MOVLW  1E
01108:  MOVWF  00
0110A:  DECFSZ 00,F
0110C:  BRA    110A
0110E:  NOP   
....................  
....................  
....................    RCV_ON(); 
01110:  RCALL  0C82
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
01112:  MOVLB  1
01114:  SETF   xB4
01116:  SETF   xB3
.................... } 
01118:  MOVLB  0
0111A:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00FDA:  MOVLB  1
00FDC:  BTFSC  xB1.0
00FDE:  BRA    0FE8
....................       return FALSE; 
00FE0:  MOVLW  00
00FE2:  MOVWF  01
00FE4:  BRA    0FFA
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00FE6:  BRA    0FF4
00FE8:  BTFSS  xB7.7
00FEA:  BRA    0FF4
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00FEC:  MOVFF  1B9,1B8
....................       modbus_rx.len = 1; 
00FF0:  MOVLW  01
00FF2:  MOVWF  xB6
....................    } 
....................    modbus_serial_new=FALSE; 
00FF4:  BCF    xB1.0
....................    return TRUE; 
00FF6:  MOVLW  01
00FF8:  MOVWF  01
.................... } 
00FFA:  MOVLB  0
00FFC:  GOTO   1F94 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01F00:  MOVFF  2CF,2D7
01F04:  MOVLW  06
01F06:  MOVLB  2
01F08:  MOVWF  xD8
01F0A:  MOVLB  0
01F0C:  CALL   10C0
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01F10:  MOVFF  2D1,2D4
01F14:  MOVFF  2D1,2D9
01F18:  CALL   108C
....................    modbus_serial_putc(make8(reg_address,0)); 
01F1C:  MOVFF  2D0,2D4
01F20:  MOVFF  2D0,2D9
01F24:  CALL   108C
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01F28:  MOVFF  2D3,2D4
01F2C:  MOVFF  2D3,2D9
01F30:  CALL   108C
....................    modbus_serial_putc(make8(reg_value,0)); 
01F34:  MOVFF  2D2,2D4
01F38:  MOVFF  2D2,2D9
01F3C:  CALL   108C
....................  
....................    modbus_serial_send_stop(); 
01F40:  CALL   10EE
.................... } 
01F44:  GOTO   20C0 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01F48:  MOVFF  2CD,2D7
01F4C:  MOVLW  10
01F4E:  MOVLB  2
01F50:  MOVWF  xD8
01F52:  MOVLB  0
01F54:  CALL   10C0
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01F58:  MOVFF  2CF,2D2
01F5C:  MOVFF  2CF,2D9
01F60:  CALL   108C
....................    modbus_serial_putc(make8(start_address,0)); 
01F64:  MOVFF  2CE,2D2
01F68:  MOVFF  2CE,2D9
01F6C:  CALL   108C
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01F70:  MOVFF  2D1,2D2
01F74:  MOVFF  2D1,2D9
01F78:  CALL   108C
....................    modbus_serial_putc(make8(quantity,0)); 
01F7C:  MOVFF  2D0,2D2
01F80:  MOVFF  2D0,2D9
01F84:  CALL   108C
....................  
....................    modbus_serial_send_stop(); 
01F88:  CALL   10EE
.................... } 
01F8C:  GOTO   2182 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0111C:  MOVLB  2
0111E:  MOVF   xCE,W
01120:  IORLW  80
01122:  MOVWF  xD1
01124:  MOVFF  2CF,2D2
01128:  MOVFF  2CD,2D7
0112C:  MOVWF  xD8
0112E:  MOVLB  0
01130:  RCALL  10C0
....................    modbus_serial_putc(error); 
01132:  MOVFF  2D0,2D9
01136:  RCALL  108C
....................    modbus_serial_send_stop(); 
01138:  RCALL  10EE
.................... } 
0113A:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1012 
....................  
.................... #define MIN_EE_REGISTER      2000 
.................... #define MAX_EE_REGISTER      MIN_EE_REGISTER + 512 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
01202:  MOVLB  1
01204:  CLRF   x84
01206:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
01208:  CLRF   x86
0120A:  CLRF   x85
.................... 	current.modbus_last_error=0; 
0120C:  CLRF   x88
0120E:  CLRF   x87
.................... } 
01210:  MOVLB  0
01212:  GOTO   1B38 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0119E:  BCF    FF2.6
011A0:  BCF    FF2.7
011A2:  BTFSC  FF2.7
011A4:  BRA    11A0
....................  
.................... 	current.pulse_count[0]=0; 
011A6:  CLRF   x61
011A8:  CLRF   x60
.................... 	current.pulse_count[1]=0; 
011AA:  CLRF   x63
011AC:  CLRF   x62
.................... 	current.pulse_count[2]=0; 
011AE:  CLRF   x65
011B0:  CLRF   x64
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
011B2:  SETF   55
011B4:  SETF   54
.................... 	current.pulse_min_period[1]=65535; 
011B6:  SETF   57
011B8:  SETF   56
.................... 	current.pulse_min_period[2]=65535; 
011BA:  SETF   59
011BC:  SETF   58
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
011BE:  CLRF   5B
011C0:  CLRF   5A
.................... 	current.pulse_max_period[1]=0; 
011C2:  CLRF   5D
011C4:  CLRF   5C
.................... 	current.pulse_max_period[2]=0; 
011C6:  CLRF   5F
011C8:  CLRF   5E
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
011CA:  MOVLB  1
011CC:  CLRF   x8E
011CE:  CLRF   x8D
....................  
.................... 	enable_interrupts(GLOBAL); 
011D0:  MOVLW  C0
011D2:  IORWF  FF2,F
.................... } 
011D4:  MOVLB  0
011D6:  GOTO   1AE8 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
011DA:  BCF    FF2.6
011DC:  BCF    FF2.7
011DE:  BTFSC  FF2.7
011E0:  BRA    11DC
.................... 	current.pulse_sum[0]=0; 
011E2:  CLRF   x69
011E4:  CLRF   x68
011E6:  CLRF   x67
011E8:  CLRF   x66
.................... 	current.pulse_sum[1]=0; 
011EA:  CLRF   x6D
011EC:  CLRF   x6C
011EE:  CLRF   x6B
011F0:  CLRF   x6A
.................... 	current.pulse_sum[2]=0; 
011F2:  CLRF   x71
011F4:  CLRF   x70
011F6:  CLRF   x6F
011F8:  CLRF   x6E
.................... 	enable_interrupts(GLOBAL); 
011FA:  MOVLW  C0
011FC:  IORWF  FF2,F
.................... } 
011FE:  GOTO   1AF8 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
0113C:  BCF    FF2.6
0113E:  BCF    FF2.7
01140:  BTFSC  FF2.7
01142:  BRA    113E
.................... 	l=current.pulse_sum[ch]; 
01144:  MOVLB  2
01146:  CLRF   xE2
01148:  MOVFF  2DB,2E1
0114C:  CLRF   xE4
0114E:  MOVLW  04
01150:  MOVWF  xE3
01152:  MOVLB  0
01154:  CALL   081E
01158:  MOVFF  02,03
0115C:  MOVF   01,W
0115E:  ADDLW  66
01160:  MOVWF  FE9
01162:  MOVLW  00
01164:  ADDWFC 02,W
01166:  MOVWF  FEA
01168:  MOVFF  FEF,00
0116C:  MOVFF  FEC,01
01170:  MOVFF  FEC,02
01174:  MOVFF  FEC,03
01178:  MOVFF  03,2DF
0117C:  MOVFF  02,2DE
01180:  MOVFF  01,2DD
01184:  MOVFF  00,2DC
.................... 	enable_interrupts(GLOBAL); 
01188:  MOVLW  C0
0118A:  IORWF  FF2,F
....................  
.................... 	return l; 
0118C:  MOVFF  2DC,00
01190:  MOVFF  2DD,01
01194:  MOVFF  2DE,02
01198:  MOVFF  2DF,03
.................... } 
0119C:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01216:  MOVLB  2
01218:  MOVF   xDA,W
0121A:  SUBLW  06
0121C:  BC    1272
0121E:  XORLW  FF
01220:  BNZ   1228
01222:  MOVF   xD9,W
01224:  SUBLW  CF
01226:  BC    1272
01228:  MOVF   xDA,W
0122A:  SUBLW  09
0122C:  BNC   1272
0122E:  BNZ   1236
01230:  MOVF   xD9,W
01232:  SUBLW  CF
01234:  BNC   1272
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01236:  MOVLW  D0
01238:  SUBWF  xD9,W
0123A:  MOVWF  xDB
0123C:  MOVLW  07
0123E:  SUBWFB xDA,W
01240:  MOVWF  xDC
01242:  MOVLW  02
01244:  ADDWF  xDC,F
01246:  MOVFF  FF2,2DD
0124A:  BCF    FF2.6
0124C:  BCF    FF2.7
0124E:  MOVFF  2DC,FAA
01252:  MOVFF  2DB,FA9
01256:  BCF    FA6.6
01258:  BCF    FA6.7
0125A:  BSF    FA6.0
0125C:  MOVF   FA8,W
0125E:  BTFSC  xDD.6
01260:  BSF    FF2.6
01262:  BTFSC  xDD.7
01264:  BSF    FF2.7
01266:  CLRF   03
01268:  MOVWF  01
0126A:  MOVF   03,W
0126C:  MOVWF  02
0126E:  GOTO   1C0A
.................... 	} 
....................  
.................... 	switch ( addr ) { 
01272:  MOVF   xD9,W
01274:  MOVWF  00
01276:  MOVF   xDA,W
01278:  MOVWF  03
0127A:  MOVF   03,W
0127C:  BNZ   1288
0127E:  MOVF   00,F
01280:  MOVLB  0
01282:  BTFSC  FD8.2
01284:  BRA    16A4
01286:  MOVLB  2
01288:  MOVF   03,W
0128A:  BNZ   1298
0128C:  MOVLW  01
0128E:  SUBWF  00,W
01290:  MOVLB  0
01292:  BTFSC  FD8.2
01294:  BRA    16B2
01296:  MOVLB  2
01298:  MOVF   03,W
0129A:  BNZ   12A8
0129C:  MOVLW  02
0129E:  SUBWF  00,W
012A0:  MOVLB  0
012A2:  BTFSC  FD8.2
012A4:  BRA    16C0
012A6:  MOVLB  2
012A8:  MOVF   03,W
012AA:  BNZ   12B8
012AC:  MOVLW  03
012AE:  SUBWF  00,W
012B0:  MOVLB  0
012B2:  BTFSC  FD8.2
012B4:  BRA    16CE
012B6:  MOVLB  2
012B8:  MOVF   03,W
012BA:  BNZ   12C8
012BC:  MOVLW  04
012BE:  SUBWF  00,W
012C0:  MOVLB  0
012C2:  BTFSC  FD8.2
012C4:  BRA    16DC
012C6:  MOVLB  2
012C8:  MOVF   03,W
012CA:  BNZ   12D8
012CC:  MOVLW  05
012CE:  SUBWF  00,W
012D0:  MOVLB  0
012D2:  BTFSC  FD8.2
012D4:  BRA    1702
012D6:  MOVLB  2
012D8:  MOVF   03,W
012DA:  BNZ   12E8
012DC:  MOVLW  06
012DE:  SUBWF  00,W
012E0:  MOVLB  0
012E2:  BTFSC  FD8.2
012E4:  BRA    1710
012E6:  MOVLB  2
012E8:  MOVF   03,W
012EA:  BNZ   12F8
012EC:  MOVLW  07
012EE:  SUBWF  00,W
012F0:  MOVLB  0
012F2:  BTFSC  FD8.2
012F4:  BRA    171E
012F6:  MOVLB  2
012F8:  MOVF   03,W
012FA:  BNZ   1308
012FC:  MOVLW  08
012FE:  SUBWF  00,W
01300:  MOVLB  0
01302:  BTFSC  FD8.2
01304:  BRA    172C
01306:  MOVLB  2
01308:  MOVF   03,W
0130A:  BNZ   1318
0130C:  MOVLW  09
0130E:  SUBWF  00,W
01310:  MOVLB  0
01312:  BTFSC  FD8.2
01314:  BRA    173A
01316:  MOVLB  2
01318:  MOVF   03,W
0131A:  BNZ   1328
0131C:  MOVLW  0A
0131E:  SUBWF  00,W
01320:  MOVLB  0
01322:  BTFSC  FD8.2
01324:  BRA    1748
01326:  MOVLB  2
01328:  MOVF   03,W
0132A:  BNZ   1338
0132C:  MOVLW  0B
0132E:  SUBWF  00,W
01330:  MOVLB  0
01332:  BTFSC  FD8.2
01334:  BRA    1770
01336:  MOVLB  2
01338:  MOVF   03,W
0133A:  BNZ   1348
0133C:  MOVLW  0C
0133E:  SUBWF  00,W
01340:  MOVLB  0
01342:  BTFSC  FD8.2
01344:  BRA    177E
01346:  MOVLB  2
01348:  MOVF   03,W
0134A:  BNZ   1358
0134C:  MOVLW  0D
0134E:  SUBWF  00,W
01350:  MOVLB  0
01352:  BTFSC  FD8.2
01354:  BRA    178C
01356:  MOVLB  2
01358:  MOVF   03,W
0135A:  BNZ   1368
0135C:  MOVLW  0E
0135E:  SUBWF  00,W
01360:  MOVLB  0
01362:  BTFSC  FD8.2
01364:  BRA    179A
01366:  MOVLB  2
01368:  MOVF   03,W
0136A:  BNZ   1378
0136C:  MOVLW  0F
0136E:  SUBWF  00,W
01370:  MOVLB  0
01372:  BTFSC  FD8.2
01374:  BRA    17A8
01376:  MOVLB  2
01378:  MOVF   03,W
0137A:  BNZ   1388
0137C:  MOVLW  10
0137E:  SUBWF  00,W
01380:  MOVLB  0
01382:  BTFSC  FD8.2
01384:  BRA    17B6
01386:  MOVLB  2
01388:  MOVF   03,W
0138A:  BNZ   1398
0138C:  MOVLW  11
0138E:  SUBWF  00,W
01390:  MOVLB  0
01392:  BTFSC  FD8.2
01394:  BRA    17DE
01396:  MOVLB  2
01398:  MOVF   03,W
0139A:  BNZ   13A8
0139C:  MOVLW  12
0139E:  SUBWF  00,W
013A0:  MOVLB  0
013A2:  BTFSC  FD8.2
013A4:  BRA    17EC
013A6:  MOVLB  2
013A8:  MOVF   03,W
013AA:  BNZ   13B8
013AC:  MOVLW  13
013AE:  SUBWF  00,W
013B0:  MOVLB  0
013B2:  BTFSC  FD8.2
013B4:  BRA    181A
013B6:  MOVLB  2
013B8:  MOVF   03,W
013BA:  BNZ   13C8
013BC:  MOVLW  14
013BE:  SUBWF  00,W
013C0:  MOVLB  0
013C2:  BTFSC  FD8.2
013C4:  BRA    1832
013C6:  MOVLB  2
013C8:  MOVF   03,W
013CA:  BNZ   13D8
013CC:  MOVLW  15
013CE:  SUBWF  00,W
013D0:  MOVLB  0
013D2:  BTFSC  FD8.2
013D4:  BRA    1840
013D6:  MOVLB  2
013D8:  MOVF   03,W
013DA:  BNZ   13E8
013DC:  MOVLW  16
013DE:  SUBWF  00,W
013E0:  MOVLB  0
013E2:  BTFSC  FD8.2
013E4:  BRA    186E
013E6:  MOVLB  2
013E8:  MOVF   03,W
013EA:  BNZ   13F8
013EC:  MOVLW  17
013EE:  SUBWF  00,W
013F0:  MOVLB  0
013F2:  BTFSC  FD8.2
013F4:  BRA    1888
013F6:  MOVLB  2
013F8:  MOVF   03,W
013FA:  BNZ   1408
013FC:  MOVLW  18
013FE:  SUBWF  00,W
01400:  MOVLB  0
01402:  BTFSC  FD8.2
01404:  BRA    1896
01406:  MOVLB  2
01408:  MOVF   03,W
0140A:  BNZ   1418
0140C:  MOVLW  19
0140E:  SUBWF  00,W
01410:  MOVLB  0
01412:  BTFSC  FD8.2
01414:  BRA    18C4
01416:  MOVLB  2
01418:  MOVF   03,W
0141A:  BNZ   1428
0141C:  MOVLW  1A
0141E:  SUBWF  00,W
01420:  MOVLB  0
01422:  BTFSC  FD8.2
01424:  BRA    18DE
01426:  MOVLB  2
01428:  MOVF   03,W
0142A:  BNZ   1438
0142C:  MOVLW  1B
0142E:  SUBWF  00,W
01430:  MOVLB  0
01432:  BTFSC  FD8.2
01434:  BRA    18EC
01436:  MOVLB  2
01438:  MOVF   03,W
0143A:  BNZ   1448
0143C:  MOVLW  1C
0143E:  SUBWF  00,W
01440:  MOVLB  0
01442:  BTFSC  FD8.2
01444:  BRA    191A
01446:  MOVLB  2
01448:  MOVF   03,W
0144A:  BNZ   1458
0144C:  MOVLW  1D
0144E:  SUBWF  00,W
01450:  MOVLB  0
01452:  BTFSC  FD8.2
01454:  BRA    1934
01456:  MOVLB  2
01458:  MOVF   03,W
0145A:  BNZ   1468
0145C:  MOVLW  1E
0145E:  SUBWF  00,W
01460:  MOVLB  0
01462:  BTFSC  FD8.2
01464:  BRA    1942
01466:  MOVLB  2
01468:  MOVF   03,W
0146A:  BNZ   1478
0146C:  MOVLW  1F
0146E:  SUBWF  00,W
01470:  MOVLB  0
01472:  BTFSC  FD8.2
01474:  BRA    1970
01476:  MOVLB  2
01478:  MOVF   03,W
0147A:  BNZ   1488
0147C:  MOVLW  20
0147E:  SUBWF  00,W
01480:  MOVLB  0
01482:  BTFSC  FD8.2
01484:  BRA    198A
01486:  MOVLB  2
01488:  MOVF   03,W
0148A:  BNZ   1498
0148C:  MOVLW  21
0148E:  SUBWF  00,W
01490:  MOVLB  0
01492:  BTFSC  FD8.2
01494:  BRA    1998
01496:  MOVLB  2
01498:  MOVF   03,W
0149A:  BNZ   14A8
0149C:  MOVLW  22
0149E:  SUBWF  00,W
014A0:  MOVLB  0
014A2:  BTFSC  FD8.2
014A4:  BRA    19C6
014A6:  MOVLB  2
014A8:  MOVF   03,W
014AA:  BNZ   14B8
014AC:  MOVLW  23
014AE:  SUBWF  00,W
014B0:  MOVLB  0
014B2:  BTFSC  FD8.2
014B4:  BRA    19E0
014B6:  MOVLB  2
014B8:  MOVF   03,W
014BA:  BNZ   14C8
014BC:  MOVLW  24
014BE:  SUBWF  00,W
014C0:  MOVLB  0
014C2:  BTFSC  FD8.2
014C4:  BRA    19EE
014C6:  MOVLB  2
014C8:  MOVF   03,W
014CA:  BNZ   14D8
014CC:  MOVLW  25
014CE:  SUBWF  00,W
014D0:  MOVLB  0
014D2:  BTFSC  FD8.2
014D4:  BRA    1A1C
014D6:  MOVLB  2
014D8:  MOVF   03,W
014DA:  BNZ   14E8
014DC:  MOVLW  26
014DE:  SUBWF  00,W
014E0:  MOVLB  0
014E2:  BTFSC  FD8.2
014E4:  BRA    1A36
014E6:  MOVLB  2
014E8:  MOVF   03,W
014EA:  BNZ   14F8
014EC:  MOVLW  27
014EE:  SUBWF  00,W
014F0:  MOVLB  0
014F2:  BTFSC  FD8.2
014F4:  BRA    1A44
014F6:  MOVLB  2
014F8:  MOVF   03,W
014FA:  BNZ   1508
014FC:  MOVLW  28
014FE:  SUBWF  00,W
01500:  MOVLB  0
01502:  BTFSC  FD8.2
01504:  BRA    1A72
01506:  MOVLB  2
01508:  MOVF   03,W
0150A:  BNZ   1518
0150C:  MOVLW  29
0150E:  SUBWF  00,W
01510:  MOVLB  0
01512:  BTFSC  FD8.2
01514:  BRA    1A8C
01516:  MOVLB  2
01518:  MOVF   03,W
0151A:  BNZ   1528
0151C:  MOVLW  2A
0151E:  SUBWF  00,W
01520:  MOVLB  0
01522:  BTFSC  FD8.2
01524:  BRA    1A9A
01526:  MOVLB  2
01528:  MOVF   03,W
0152A:  BNZ   1538
0152C:  MOVLW  2B
0152E:  SUBWF  00,W
01530:  MOVLB  0
01532:  BTFSC  FD8.2
01534:  BRA    1AB4
01536:  MOVLB  2
01538:  MOVF   03,W
0153A:  BNZ   1548
0153C:  MOVLW  2C
0153E:  SUBWF  00,W
01540:  MOVLB  0
01542:  BTFSC  FD8.2
01544:  BRA    1AC4
01546:  MOVLB  2
01548:  MOVF   03,W
0154A:  BNZ   1558
0154C:  MOVLW  2D
0154E:  SUBWF  00,W
01550:  MOVLB  0
01552:  BTFSC  FD8.2
01554:  BRA    1AD4
01556:  MOVLB  2
01558:  MOVF   03,W
0155A:  BNZ   1568
0155C:  MOVLW  2E
0155E:  SUBWF  00,W
01560:  MOVLB  0
01562:  BTFSC  FD8.2
01564:  BRA    1AE4
01566:  MOVLB  2
01568:  MOVF   03,W
0156A:  BNZ   1578
0156C:  MOVLW  2F
0156E:  SUBWF  00,W
01570:  MOVLB  0
01572:  BTFSC  FD8.2
01574:  BRA    1AF4
01576:  MOVLB  2
01578:  MOVF   03,W
0157A:  BNZ   1588
0157C:  MOVLW  30
0157E:  SUBWF  00,W
01580:  MOVLB  0
01582:  BTFSC  FD8.2
01584:  BRA    1B04
01586:  MOVLB  2
01588:  MOVF   03,W
0158A:  BNZ   1598
0158C:  MOVLW  31
0158E:  SUBWF  00,W
01590:  MOVLB  0
01592:  BTFSC  FD8.2
01594:  BRA    1B14
01596:  MOVLB  2
01598:  MOVF   03,W
0159A:  BNZ   15A8
0159C:  MOVLW  32
0159E:  SUBWF  00,W
015A0:  MOVLB  0
015A2:  BTFSC  FD8.2
015A4:  BRA    1B24
015A6:  MOVLB  2
015A8:  MOVF   03,W
015AA:  BNZ   15B8
015AC:  MOVLW  33
015AE:  SUBWF  00,W
015B0:  MOVLB  0
015B2:  BTFSC  FD8.2
015B4:  BRA    1B34
015B6:  MOVLB  2
015B8:  MOVLW  03
015BA:  SUBWF  03,W
015BC:  BNZ   15CA
015BE:  MOVLW  E8
015C0:  SUBWF  00,W
015C2:  MOVLB  0
015C4:  BTFSC  FD8.2
015C6:  BRA    1B44
015C8:  MOVLB  2
015CA:  MOVLW  03
015CC:  SUBWF  03,W
015CE:  BNZ   15DC
015D0:  MOVLW  E9
015D2:  SUBWF  00,W
015D4:  MOVLB  0
015D6:  BTFSC  FD8.2
015D8:  BRA    1B54
015DA:  MOVLB  2
015DC:  MOVLW  03
015DE:  SUBWF  03,W
015E0:  BNZ   15EE
015E2:  MOVLW  EA
015E4:  SUBWF  00,W
015E6:  MOVLB  0
015E8:  BTFSC  FD8.2
015EA:  BRA    1B62
015EC:  MOVLB  2
015EE:  MOVLW  03
015F0:  SUBWF  03,W
015F2:  BNZ   1600
015F4:  MOVLW  EB
015F6:  SUBWF  00,W
015F8:  MOVLB  0
015FA:  BTFSC  FD8.2
015FC:  BRA    1B70
015FE:  MOVLB  2
01600:  MOVLW  03
01602:  SUBWF  03,W
01604:  BNZ   1612
01606:  MOVLW  EC
01608:  SUBWF  00,W
0160A:  MOVLB  0
0160C:  BTFSC  FD8.2
0160E:  BRA    1B7E
01610:  MOVLB  2
01612:  MOVLW  03
01614:  SUBWF  03,W
01616:  BNZ   1624
01618:  MOVLW  ED
0161A:  SUBWF  00,W
0161C:  MOVLB  0
0161E:  BTFSC  FD8.2
01620:  BRA    1B8C
01622:  MOVLB  2
01624:  MOVLW  03
01626:  SUBWF  03,W
01628:  BNZ   1636
0162A:  MOVLW  EE
0162C:  SUBWF  00,W
0162E:  MOVLB  0
01630:  BTFSC  FD8.2
01632:  BRA    1B9A
01634:  MOVLB  2
01636:  MOVLW  03
01638:  SUBWF  03,W
0163A:  BNZ   1648
0163C:  MOVLW  EF
0163E:  SUBWF  00,W
01640:  MOVLB  0
01642:  BTFSC  FD8.2
01644:  BRA    1BAA
01646:  MOVLB  2
01648:  MOVLW  03
0164A:  SUBWF  03,W
0164C:  BNZ   165A
0164E:  MOVLW  F0
01650:  SUBWF  00,W
01652:  MOVLB  0
01654:  BTFSC  FD8.2
01656:  BRA    1BB8
01658:  MOVLB  2
0165A:  MOVLW  03
0165C:  SUBWF  03,W
0165E:  BNZ   166C
01660:  MOVLW  F1
01662:  SUBWF  00,W
01664:  MOVLB  0
01666:  BTFSC  FD8.2
01668:  BRA    1BC8
0166A:  MOVLB  2
0166C:  MOVLW  03
0166E:  SUBWF  03,W
01670:  BNZ   167E
01672:  MOVLW  F2
01674:  SUBWF  00,W
01676:  MOVLB  0
01678:  BTFSC  FD8.2
0167A:  BRA    1BD6
0167C:  MOVLB  2
0167E:  MOVLW  03
01680:  SUBWF  03,W
01682:  BNZ   1690
01684:  MOVLW  F3
01686:  SUBWF  00,W
01688:  MOVLB  0
0168A:  BTFSC  FD8.2
0168C:  BRA    1BE4
0168E:  MOVLB  2
01690:  MOVLW  03
01692:  SUBWF  03,W
01694:  BNZ   16A2
01696:  MOVLW  F4
01698:  SUBWF  00,W
0169A:  MOVLB  0
0169C:  BTFSC  FD8.2
0169E:  BRA    1BF4
016A0:  MOVLB  2
016A2:  BRA    1C02
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
016A4:  MOVFF  60,01
016A8:  MOVFF  61,02
016AC:  MOVLB  2
016AE:  BRA    1C0A
016B0:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
016B2:  MOVF   4E,W
016B4:  MOVWF  01
016B6:  MOVF   4F,W
016B8:  MOVWF  02
016BA:  MOVLB  2
016BC:  BRA    1C0A
016BE:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
016C0:  MOVF   54,W
016C2:  MOVWF  01
016C4:  MOVF   55,W
016C6:  MOVWF  02
016C8:  MOVLB  2
016CA:  BRA    1C0A
016CC:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
016CE:  MOVF   5A,W
016D0:  MOVWF  01
016D2:  MOVF   5B,W
016D4:  MOVWF  02
016D6:  MOVLB  2
016D8:  BRA    1C0A
016DA:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
016DC:  MOVLB  2
016DE:  CLRF   xDB
016E0:  MOVLB  0
016E2:  RCALL  113C
016E4:  MOVFF  03,2BB
016E8:  MOVFF  02,2BA
016EC:  MOVFF  01,2B9
016F0:  MOVFF  00,2B8
016F4:  MOVLB  2
016F6:  MOVF   xB8,W
016F8:  MOVWF  01
016FA:  MOVF   xB9,W
016FC:  MOVWF  02
016FE:  BRA    1C0A
01700:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01702:  MOVLB  2
01704:  MOVF   xBA,W
01706:  MOVWF  01
01708:  MOVF   xBB,W
0170A:  MOVWF  02
0170C:  BRA    1C0A
0170E:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01710:  MOVF   x62,W
01712:  MOVWF  01
01714:  MOVF   x63,W
01716:  MOVWF  02
01718:  MOVLB  2
0171A:  BRA    1C0A
0171C:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
0171E:  MOVF   50,W
01720:  MOVWF  01
01722:  MOVF   51,W
01724:  MOVWF  02
01726:  MOVLB  2
01728:  BRA    1C0A
0172A:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
0172C:  MOVF   56,W
0172E:  MOVWF  01
01730:  MOVF   57,W
01732:  MOVWF  02
01734:  MOVLB  2
01736:  BRA    1C0A
01738:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
0173A:  MOVF   5C,W
0173C:  MOVWF  01
0173E:  MOVF   5D,W
01740:  MOVWF  02
01742:  MOVLB  2
01744:  BRA    1C0A
01746:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01748:  MOVLW  01
0174A:  MOVLB  2
0174C:  MOVWF  xDB
0174E:  MOVLB  0
01750:  RCALL  113C
01752:  MOVFF  03,2BB
01756:  MOVFF  02,2BA
0175A:  MOVFF  01,2B9
0175E:  MOVFF  00,2B8
01762:  MOVLB  2
01764:  MOVF   xB8,W
01766:  MOVWF  01
01768:  MOVF   xB9,W
0176A:  MOVWF  02
0176C:  BRA    1C0A
0176E:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01770:  MOVLB  2
01772:  MOVF   xBA,W
01774:  MOVWF  01
01776:  MOVF   xBB,W
01778:  MOVWF  02
0177A:  BRA    1C0A
0177C:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
0177E:  MOVF   x64,W
01780:  MOVWF  01
01782:  MOVF   x65,W
01784:  MOVWF  02
01786:  MOVLB  2
01788:  BRA    1C0A
0178A:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
0178C:  MOVF   52,W
0178E:  MOVWF  01
01790:  MOVF   53,W
01792:  MOVWF  02
01794:  MOVLB  2
01796:  BRA    1C0A
01798:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
0179A:  MOVF   58,W
0179C:  MOVWF  01
0179E:  MOVF   59,W
017A0:  MOVWF  02
017A2:  MOVLB  2
017A4:  BRA    1C0A
017A6:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
017A8:  MOVF   5E,W
017AA:  MOVWF  01
017AC:  MOVF   5F,W
017AE:  MOVWF  02
017B0:  MOVLB  2
017B2:  BRA    1C0A
017B4:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
017B6:  MOVLW  02
017B8:  MOVLB  2
017BA:  MOVWF  xDB
017BC:  MOVLB  0
017BE:  RCALL  113C
017C0:  MOVFF  03,2BB
017C4:  MOVFF  02,2BA
017C8:  MOVFF  01,2B9
017CC:  MOVFF  00,2B8
017D0:  MOVLB  2
017D2:  MOVF   xB8,W
017D4:  MOVWF  01
017D6:  MOVF   xB9,W
017D8:  MOVWF  02
017DA:  BRA    1C0A
017DC:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
017DE:  MOVLB  2
017E0:  MOVF   xBA,W
017E2:  MOVWF  01
017E4:  MOVF   xBB,W
017E6:  MOVWF  02
017E8:  BRA    1C0A
017EA:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
017EC:  CLRF   03
017EE:  MOVLB  1
017F0:  MOVF   x82,W
017F2:  MOVWF  02
017F4:  BCF    FD8.0
017F6:  RLCF   02,F
017F8:  RLCF   03,F
017FA:  MOVF   02,W
017FC:  ADDLW  82
017FE:  MOVWF  FE9
01800:  MOVLW  00
01802:  ADDWFC 03,W
01804:  MOVWF  FEA
01806:  MOVFF  FEC,03
0180A:  MOVF   FED,F
0180C:  MOVF   FEF,W
0180E:  MOVWF  01
01810:  MOVF   03,W
01812:  MOVWF  02
01814:  MOVLB  2
01816:  BRA    1C0A
01818:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
0181A:  MOVLB  2
0181C:  CLRF   xDB
0181E:  MOVLB  0
01820:  CALL   0DF2
01824:  MOVF   01,W
01826:  MOVWF  01
01828:  MOVF   02,W
0182A:  MOVWF  02
0182C:  MOVLB  2
0182E:  BRA    1C0A
01830:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01832:  MOVF   x72,W
01834:  MOVWF  01
01836:  MOVF   x73,W
01838:  MOVWF  02
0183A:  MOVLB  2
0183C:  BRA    1C0A
0183E:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01840:  CLRF   03
01842:  MOVLB  1
01844:  MOVF   x82,W
01846:  MOVWF  02
01848:  BCF    FD8.0
0184A:  RLCF   02,F
0184C:  RLCF   03,F
0184E:  MOVF   02,W
01850:  ADDLW  A2
01852:  MOVWF  FE9
01854:  MOVLW  00
01856:  ADDWFC 03,W
01858:  MOVWF  FEA
0185A:  MOVFF  FEC,03
0185E:  MOVF   FED,F
01860:  MOVF   FEF,W
01862:  MOVWF  01
01864:  MOVF   03,W
01866:  MOVWF  02
01868:  MOVLB  2
0186A:  BRA    1C0A
0186C:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
0186E:  MOVLW  01
01870:  MOVLB  2
01872:  MOVWF  xDB
01874:  MOVLB  0
01876:  CALL   0DF2
0187A:  MOVF   01,W
0187C:  MOVWF  01
0187E:  MOVF   02,W
01880:  MOVWF  02
01882:  MOVLB  2
01884:  BRA    1C0A
01886:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01888:  MOVF   x74,W
0188A:  MOVWF  01
0188C:  MOVF   x75,W
0188E:  MOVWF  02
01890:  MOVLB  2
01892:  BRA    1C0A
01894:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01896:  CLRF   03
01898:  MOVLB  1
0189A:  MOVF   x82,W
0189C:  MOVWF  02
0189E:  BCF    FD8.0
018A0:  RLCF   02,F
018A2:  RLCF   03,F
018A4:  MOVF   02,W
018A6:  ADDLW  C2
018A8:  MOVWF  FE9
018AA:  MOVLW  00
018AC:  ADDWFC 03,W
018AE:  MOVWF  FEA
018B0:  MOVFF  FEC,03
018B4:  MOVF   FED,F
018B6:  MOVF   FEF,W
018B8:  MOVWF  01
018BA:  MOVF   03,W
018BC:  MOVWF  02
018BE:  MOVLB  2
018C0:  BRA    1C0A
018C2:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
018C4:  MOVLW  02
018C6:  MOVLB  2
018C8:  MOVWF  xDB
018CA:  MOVLB  0
018CC:  CALL   0DF2
018D0:  MOVF   01,W
018D2:  MOVWF  01
018D4:  MOVF   02,W
018D6:  MOVWF  02
018D8:  MOVLB  2
018DA:  BRA    1C0A
018DC:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
018DE:  MOVF   x76,W
018E0:  MOVWF  01
018E2:  MOVF   x77,W
018E4:  MOVWF  02
018E6:  MOVLB  2
018E8:  BRA    1C0A
018EA:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
018EC:  CLRF   03
018EE:  MOVLB  1
018F0:  MOVF   x82,W
018F2:  MOVWF  02
018F4:  BCF    FD8.0
018F6:  RLCF   02,F
018F8:  RLCF   03,F
018FA:  MOVF   02,W
018FC:  ADDLW  E2
018FE:  MOVWF  FE9
01900:  MOVLW  00
01902:  ADDWFC 03,W
01904:  MOVWF  FEA
01906:  MOVFF  FEC,03
0190A:  MOVF   FED,F
0190C:  MOVF   FEF,W
0190E:  MOVWF  01
01910:  MOVF   03,W
01912:  MOVWF  02
01914:  MOVLB  2
01916:  BRA    1C0A
01918:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
0191A:  MOVLW  03
0191C:  MOVLB  2
0191E:  MOVWF  xDB
01920:  MOVLB  0
01922:  CALL   0DF2
01926:  MOVF   01,W
01928:  MOVWF  01
0192A:  MOVF   02,W
0192C:  MOVWF  02
0192E:  MOVLB  2
01930:  BRA    1C0A
01932:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01934:  MOVF   x78,W
01936:  MOVWF  01
01938:  MOVF   x79,W
0193A:  MOVWF  02
0193C:  MOVLB  2
0193E:  BRA    1C0A
01940:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01942:  CLRF   03
01944:  MOVLB  1
01946:  MOVF   x82,W
01948:  MOVWF  02
0194A:  BCF    FD8.0
0194C:  RLCF   02,F
0194E:  RLCF   03,F
01950:  MOVF   02,W
01952:  ADDLW  02
01954:  MOVWF  FE9
01956:  MOVLW  01
01958:  ADDWFC 03,W
0195A:  MOVWF  FEA
0195C:  MOVFF  FEC,03
01960:  MOVF   FED,F
01962:  MOVF   FEF,W
01964:  MOVWF  01
01966:  MOVF   03,W
01968:  MOVWF  02
0196A:  MOVLB  2
0196C:  BRA    1C0A
0196E:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01970:  MOVLW  04
01972:  MOVLB  2
01974:  MOVWF  xDB
01976:  MOVLB  0
01978:  CALL   0DF2
0197C:  MOVF   01,W
0197E:  MOVWF  01
01980:  MOVF   02,W
01982:  MOVWF  02
01984:  MOVLB  2
01986:  BRA    1C0A
01988:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
0198A:  MOVF   x7A,W
0198C:  MOVWF  01
0198E:  MOVF   x7B,W
01990:  MOVWF  02
01992:  MOVLB  2
01994:  BRA    1C0A
01996:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01998:  CLRF   03
0199A:  MOVLB  1
0199C:  MOVF   x82,W
0199E:  MOVWF  02
019A0:  BCF    FD8.0
019A2:  RLCF   02,F
019A4:  RLCF   03,F
019A6:  MOVF   02,W
019A8:  ADDLW  22
019AA:  MOVWF  FE9
019AC:  MOVLW  01
019AE:  ADDWFC 03,W
019B0:  MOVWF  FEA
019B2:  MOVFF  FEC,03
019B6:  MOVF   FED,F
019B8:  MOVF   FEF,W
019BA:  MOVWF  01
019BC:  MOVF   03,W
019BE:  MOVWF  02
019C0:  MOVLB  2
019C2:  BRA    1C0A
019C4:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
019C6:  MOVLW  05
019C8:  MOVLB  2
019CA:  MOVWF  xDB
019CC:  MOVLB  0
019CE:  CALL   0DF2
019D2:  MOVF   01,W
019D4:  MOVWF  01
019D6:  MOVF   02,W
019D8:  MOVWF  02
019DA:  MOVLB  2
019DC:  BRA    1C0A
019DE:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
019E0:  MOVF   x7C,W
019E2:  MOVWF  01
019E4:  MOVF   x7D,W
019E6:  MOVWF  02
019E8:  MOVLB  2
019EA:  BRA    1C0A
019EC:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
019EE:  CLRF   03
019F0:  MOVLB  1
019F2:  MOVF   x82,W
019F4:  MOVWF  02
019F6:  BCF    FD8.0
019F8:  RLCF   02,F
019FA:  RLCF   03,F
019FC:  MOVF   02,W
019FE:  ADDLW  42
01A00:  MOVWF  FE9
01A02:  MOVLW  01
01A04:  ADDWFC 03,W
01A06:  MOVWF  FEA
01A08:  MOVFF  FEC,03
01A0C:  MOVF   FED,F
01A0E:  MOVF   FEF,W
01A10:  MOVWF  01
01A12:  MOVF   03,W
01A14:  MOVWF  02
01A16:  MOVLB  2
01A18:  BRA    1C0A
01A1A:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01A1C:  MOVLW  06
01A1E:  MOVLB  2
01A20:  MOVWF  xDB
01A22:  MOVLB  0
01A24:  CALL   0DF2
01A28:  MOVF   01,W
01A2A:  MOVWF  01
01A2C:  MOVF   02,W
01A2E:  MOVWF  02
01A30:  MOVLB  2
01A32:  BRA    1C0A
01A34:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01A36:  MOVF   x7E,W
01A38:  MOVWF  01
01A3A:  MOVF   x7F,W
01A3C:  MOVWF  02
01A3E:  MOVLB  2
01A40:  BRA    1C0A
01A42:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01A44:  CLRF   03
01A46:  MOVLB  1
01A48:  MOVF   x82,W
01A4A:  MOVWF  02
01A4C:  BCF    FD8.0
01A4E:  RLCF   02,F
01A50:  RLCF   03,F
01A52:  MOVF   02,W
01A54:  ADDLW  62
01A56:  MOVWF  FE9
01A58:  MOVLW  01
01A5A:  ADDWFC 03,W
01A5C:  MOVWF  FEA
01A5E:  MOVFF  FEC,03
01A62:  MOVF   FED,F
01A64:  MOVF   FEF,W
01A66:  MOVWF  01
01A68:  MOVF   03,W
01A6A:  MOVWF  02
01A6C:  MOVLB  2
01A6E:  BRA    1C0A
01A70:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01A72:  MOVLW  07
01A74:  MOVLB  2
01A76:  MOVWF  xDB
01A78:  MOVLB  0
01A7A:  CALL   0DF2
01A7E:  MOVF   01,W
01A80:  MOVWF  01
01A82:  MOVF   02,W
01A84:  MOVWF  02
01A86:  MOVLB  2
01A88:  BRA    1C0A
01A8A:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01A8C:  MOVF   x80,W
01A8E:  MOVWF  01
01A90:  MOVF   x81,W
01A92:  MOVWF  02
01A94:  MOVLB  2
01A96:  BRA    1C0A
01A98:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01A9A:  MOVLB  1
01A9C:  MOVF   x8A,W
01A9E:  MOVWF  03
01AA0:  MOVF   x89,W
01AA2:  INCF   x89,F
01AA4:  BTFSC  FD8.2
01AA6:  INCF   x8A,F
01AA8:  MOVWF  01
01AAA:  MOVF   03,W
01AAC:  MOVWF  02
01AAE:  MOVLB  2
01AB0:  BRA    1C0A
01AB2:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01AB4:  MOVLB  1
01AB6:  MOVF   x8D,W
01AB8:  MOVWF  01
01ABA:  MOVF   x8E,W
01ABC:  MOVWF  02
01ABE:  MOVLB  2
01AC0:  BRA    1C0A
01AC2:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01AC4:  MOVLB  1
01AC6:  MOVF   x8B,W
01AC8:  MOVWF  01
01ACA:  MOVF   x8C,W
01ACC:  MOVWF  02
01ACE:  MOVLB  2
01AD0:  BRA    1C0A
01AD2:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01AD4:  MOVLB  1
01AD6:  MOVF   x91,W
01AD8:  MOVWF  01
01ADA:  MOVF   x92,W
01ADC:  MOVWF  02
01ADE:  MOVLB  2
01AE0:  BRA    1C0A
01AE2:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01AE4:  GOTO   119E
01AE8:  MOVLW  00
01AEA:  MOVWF  01
01AEC:  MOVWF  02
01AEE:  MOVLB  2
01AF0:  BRA    1C0A
01AF2:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01AF4:  GOTO   11DA
01AF8:  MOVLW  00
01AFA:  MOVWF  01
01AFC:  MOVWF  02
01AFE:  MOVLB  2
01B00:  BRA    1C0A
01B02:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01B04:  MOVLB  1
01B06:  MOVF   x83,W
01B08:  MOVWF  01
01B0A:  MOVF   x84,W
01B0C:  MOVWF  02
01B0E:  MOVLB  2
01B10:  BRA    1C0A
01B12:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01B14:  MOVLB  1
01B16:  MOVF   x85,W
01B18:  MOVWF  01
01B1A:  MOVF   x86,W
01B1C:  MOVWF  02
01B1E:  MOVLB  2
01B20:  BRA    1C0A
01B22:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01B24:  MOVLB  1
01B26:  MOVF   x87,W
01B28:  MOVWF  01
01B2A:  MOVF   x88,W
01B2C:  MOVWF  02
01B2E:  MOVLB  2
01B30:  BRA    1C0A
01B32:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01B34:  GOTO   1202
01B38:  MOVLW  00
01B3A:  MOVWF  01
01B3C:  MOVWF  02
01B3E:  MOVLB  2
01B40:  BRA    1C0A
01B42:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01B44:  CLRF   03
01B46:  MOVF   39,W
01B48:  MOVWF  01
01B4A:  MOVF   03,W
01B4C:  MOVWF  02
01B4E:  MOVLB  2
01B50:  BRA    1C0A
01B52:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01B54:  MOVF   3A,W
01B56:  MOVWF  01
01B58:  MOVF   3B,W
01B5A:  MOVWF  02
01B5C:  MOVLB  2
01B5E:  BRA    1C0A
01B60:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01B62:  MOVLW  50
01B64:  MOVWF  01
01B66:  MOVLW  00
01B68:  MOVWF  02
01B6A:  MOVLB  2
01B6C:  BRA    1C0A
01B6E:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01B70:  MOVLW  57
01B72:  MOVWF  01
01B74:  MOVLW  00
01B76:  MOVWF  02
01B78:  MOVLB  2
01B7A:  BRA    1C0A
01B7C:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01B7E:  MOVLW  58
01B80:  MOVWF  01
01B82:  MOVLW  00
01B84:  MOVWF  02
01B86:  MOVLB  2
01B88:  BRA    1C0A
01B8A:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01B8C:  MOVLW  01
01B8E:  MOVWF  01
01B90:  MOVLW  00
01B92:  MOVWF  02
01B94:  MOVLB  2
01B96:  BRA    1C0A
01B98:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01B9A:  CLRF   03
01B9C:  MOVF   36,W
01B9E:  MOVWF  01
01BA0:  MOVF   03,W
01BA2:  MOVWF  02
01BA4:  MOVLB  2
01BA6:  BRA    1C0A
01BA8:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01BAA:  MOVF   3C,W
01BAC:  MOVWF  01
01BAE:  MOVF   3D,W
01BB0:  MOVWF  02
01BB2:  MOVLB  2
01BB4:  BRA    1C0A
01BB6:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01BB8:  CLRF   03
01BBA:  MOVF   3E,W
01BBC:  MOVWF  01
01BBE:  MOVF   03,W
01BC0:  MOVWF  02
01BC2:  MOVLB  2
01BC4:  BRA    1C0A
01BC6:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01BC8:  MOVF   3F,W
01BCA:  MOVWF  01
01BCC:  MOVF   40,W
01BCE:  MOVWF  02
01BD0:  MOVLB  2
01BD2:  BRA    1C0A
01BD4:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01BD6:  MOVF   41,W
01BD8:  MOVWF  01
01BDA:  MOVF   42,W
01BDC:  MOVWF  02
01BDE:  MOVLB  2
01BE0:  BRA    1C0A
01BE2:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01BE4:  CLRF   03
01BE6:  MOVF   43,W
01BE8:  MOVWF  01
01BEA:  MOVF   03,W
01BEC:  MOVWF  02
01BEE:  MOVLB  2
01BF0:  BRA    1C0A
01BF2:  MOVLB  0
.................... 		case 1012: return (int16) config.modbus_bridge; 
01BF4:  CLRF   03
01BF6:  MOVF   38,W
01BF8:  MOVWF  01
01BFA:  MOVF   03,W
01BFC:  MOVWF  02
01BFE:  MOVLB  2
01C00:  BRA    1C0A
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01C02:  MOVLW  FF
01C04:  MOVWF  01
01C06:  MOVWF  02
01C08:  BRA    1C0A
.................... 	} 
....................  
.................... } 
01C0A:  MOVLB  0
01C0C:  GOTO   1C5E (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01000:  MOVLB  2
01002:  MOVF   xCF,W
01004:  SUBLW  1F
01006:  BNZ   1020
01008:  MOVF   xD0,W
0100A:  SUBLW  4E
0100C:  BNZ   1020
0100E:  MOVF   xD1,W
01010:  SUBLW  20
01012:  BNZ   1020
01014:  MOVF   xD2,W
01016:  SUBLW  4E
01018:  BNZ   1020
.................... 		return 1; 
0101A:  MOVLW  01
0101C:  MOVWF  01
0101E:  BRA    107C
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
01020:  MOVF   xD0,W
01022:  SUBLW  02
01024:  BC    1044
01026:  XORLW  FF
01028:  BNZ   1030
0102A:  MOVF   xCF,W
0102C:  SUBLW  E7
0102E:  BC    1044
01030:  MOVF   xD2,W
01032:  SUBLW  03
01034:  BNC   1044
01036:  BNZ   103E
01038:  MOVF   xD1,W
0103A:  SUBLW  F5
0103C:  BNC   1044
.................... 		return 1; 
0103E:  MOVLW  01
01040:  MOVWF  01
01042:  BRA    107C
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
01044:  MOVF   xD0,W
01046:  SUBLW  06
01048:  BC    1068
0104A:  XORLW  FF
0104C:  BNZ   1054
0104E:  MOVF   xCF,W
01050:  SUBLW  CF
01052:  BC    1068
01054:  MOVF   xD2,W
01056:  SUBLW  09
01058:  BNC   1068
0105A:  BNZ   1062
0105C:  MOVF   xD1,W
0105E:  SUBLW  D1
01060:  BNC   1068
.................... 		return 1; 
01062:  MOVLW  01
01064:  MOVWF  01
01066:  BRA    107C
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01068:  MOVF   xD2,F
0106A:  BNZ   1078
0106C:  MOVF   xD1,W
0106E:  SUBLW  34
01070:  BNC   1078
.................... 		return 1; 
01072:  MOVLW  01
01074:  MOVWF  01
01076:  BRA    107C
....................  
.................... 	return 0; 
01078:  MOVLW  00
0107A:  MOVWF  01
.................... } 
0107C:  MOVLB  0
0107E:  GOTO   200C (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01C10:  MOVFF  2CE,2D7
01C14:  MOVFF  2CD,2D8
01C18:  CALL   10C0
.................... 	modbus_serial_putc(register_count*2); 
01C1C:  BCF    FD8.0
01C1E:  MOVLB  2
01C20:  RLCF   xD1,W
01C22:  MOVWF  xD7
01C24:  RLCF   xD2,W
01C26:  MOVWF  xD8
01C28:  MOVFF  2D7,2D9
01C2C:  MOVLB  0
01C2E:  CALL   108C
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01C32:  MOVLB  2
01C34:  CLRF   xD4
01C36:  CLRF   xD3
01C38:  MOVF   xD4,W
01C3A:  SUBWF  xD2,W
01C3C:  BNC   1C88
01C3E:  BNZ   1C46
01C40:  MOVF   xD1,W
01C42:  SUBWF  xD3,W
01C44:  BC    1C88
.................... 		l=map_modbus(start_address+i); 
01C46:  MOVF   xD3,W
01C48:  ADDWF  xCF,W
01C4A:  MOVWF  xD7
01C4C:  MOVF   xD4,W
01C4E:  ADDWFC xD0,W
01C50:  MOVWF  xD8
01C52:  MOVWF  xDA
01C54:  MOVFF  2D7,2D9
01C58:  MOVLB  0
01C5A:  GOTO   1216
01C5E:  MOVFF  02,2D6
01C62:  MOVFF  01,2D5
.................... 		modbus_serial_putc(make8(l,1)); 
01C66:  MOVFF  2D6,2D7
01C6A:  MOVFF  2D6,2D9
01C6E:  CALL   108C
....................   		modbus_serial_putc(make8(l,0)); 
01C72:  MOVFF  2D5,2D7
01C76:  MOVFF  2D5,2D9
01C7A:  CALL   108C
.................... 	} 
01C7E:  MOVLB  2
01C80:  INCF   xD3,F
01C82:  BTFSC  FD8.2
01C84:  INCF   xD4,F
01C86:  BRA    1C38
....................  
.................... 	modbus_serial_send_stop(); 
01C88:  MOVLB  0
01C8A:  CALL   10EE
.................... } 
01C8E:  GOTO   204E (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01C92:  MOVLB  2
01C94:  MOVF   xD4,W
01C96:  SUBLW  06
01C98:  BC    1D10
01C9A:  XORLW  FF
01C9C:  BNZ   1CA4
01C9E:  MOVF   xD3,W
01CA0:  SUBLW  CF
01CA2:  BC    1D10
01CA4:  MOVF   xD4,W
01CA6:  SUBLW  09
01CA8:  BNC   1D10
01CAA:  BNZ   1CB2
01CAC:  MOVF   xD3,W
01CAE:  SUBLW  CF
01CB0:  BNC   1D10
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01CB2:  MOVF   xD6,W
01CB4:  SUBLW  00
01CB6:  BC    1CC8
01CB8:  XORLW  FF
01CBA:  BNZ   1CC2
01CBC:  MOVF   xD5,W
01CBE:  SUBLW  00
01CC0:  BC    1CC8
01CC2:  MOVLW  03
01CC4:  MOVWF  01
01CC6:  BRA    1EFC
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01CC8:  MOVLW  D0
01CCA:  SUBWF  xD3,W
01CCC:  MOVWF  xD7
01CCE:  MOVLW  07
01CD0:  SUBWFB xD4,W
01CD2:  MOVWF  xD8
01CD4:  MOVLW  02
01CD6:  ADDWF  xD8,F
01CD8:  MOVFF  2D8,FAA
01CDC:  MOVFF  2D7,FA9
01CE0:  MOVFF  2D5,FA8
01CE4:  BCF    FA6.6
01CE6:  BCF    FA6.7
01CE8:  BSF    FA6.2
01CEA:  MOVF   FF2,W
01CEC:  MOVWF  00
01CEE:  BCF    FF2.6
01CF0:  BCF    FF2.7
01CF2:  MOVLB  F
01CF4:  MOVLW  55
01CF6:  MOVWF  FA7
01CF8:  MOVLW  AA
01CFA:  MOVWF  FA7
01CFC:  BSF    FA6.1
01CFE:  BTFSC  FA6.1
01D00:  BRA    1CFE
01D02:  BCF    FA6.2
01D04:  MOVF   00,W
01D06:  IORWF  FF2,F
.................... 		return 0; 
01D08:  MOVLW  00
01D0A:  MOVWF  01
01D0C:  MOVLB  2
01D0E:  BRA    1EFC
.................... 	} 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01D10:  MOVLB  1
01D12:  MOVF   x8F,F
01D14:  BZ    1D4C
.................... 		if ( 1000 == address ) { 
01D16:  MOVLB  2
01D18:  MOVF   xD3,W
01D1A:  SUBLW  E8
01D1C:  BNZ   1D30
01D1E:  MOVF   xD4,W
01D20:  SUBLW  03
01D22:  BNZ   1D30
.................... 			config.serial_prefix=value; 
01D24:  MOVFF  2D5,39
.................... 			return 0; 
01D28:  MOVLW  00
01D2A:  MOVWF  01
01D2C:  BRA    1EFC
.................... 		} else if ( 1001 == address ) { 
01D2E:  BRA    1D4A
01D30:  MOVF   xD3,W
01D32:  SUBLW  E9
01D34:  BNZ   1D4A
01D36:  MOVF   xD4,W
01D38:  SUBLW  03
01D3A:  BNZ   1D4A
.................... 			config.serial_number=value; 
01D3C:  MOVFF  2D6,3B
01D40:  MOVFF  2D5,3A
.................... 			return 0; 
01D44:  MOVLW  00
01D46:  MOVWF  01
01D48:  BRA    1EFC
01D4A:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01D4C:  MOVLB  2
01D4E:  MOVF   xD3,W
01D50:  MOVWF  00
01D52:  MOVF   xD4,W
01D54:  MOVWF  03
01D56:  MOVLW  03
01D58:  SUBWF  03,W
01D5A:  BNZ   1D66
01D5C:  MOVLW  EE
01D5E:  SUBWF  00,W
01D60:  MOVLB  0
01D62:  BZ    1E00
01D64:  MOVLB  2
01D66:  MOVLW  03
01D68:  SUBWF  03,W
01D6A:  BNZ   1D76
01D6C:  MOVLW  EF
01D6E:  SUBWF  00,W
01D70:  MOVLB  0
01D72:  BZ    1E18
01D74:  MOVLB  2
01D76:  MOVLW  03
01D78:  SUBWF  03,W
01D7A:  BNZ   1D86
01D7C:  MOVLW  F0
01D7E:  SUBWF  00,W
01D80:  MOVLB  0
01D82:  BZ    1E28
01D84:  MOVLB  2
01D86:  MOVLW  03
01D88:  SUBWF  03,W
01D8A:  BNZ   1D96
01D8C:  MOVLW  F1
01D8E:  SUBWF  00,W
01D90:  MOVLB  0
01D92:  BZ    1E40
01D94:  MOVLB  2
01D96:  MOVLW  03
01D98:  SUBWF  03,W
01D9A:  BNZ   1DA6
01D9C:  MOVLW  F2
01D9E:  SUBWF  00,W
01DA0:  MOVLB  0
01DA2:  BZ    1E4C
01DA4:  MOVLB  2
01DA6:  MOVLW  03
01DA8:  SUBWF  03,W
01DAA:  BNZ   1DB6
01DAC:  MOVLW  F3
01DAE:  SUBWF  00,W
01DB0:  MOVLB  0
01DB2:  BZ    1E66
01DB4:  MOVLB  2
01DB6:  MOVLW  03
01DB8:  SUBWF  03,W
01DBA:  BNZ   1DC8
01DBC:  MOVLW  F4
01DBE:  SUBWF  00,W
01DC0:  MOVLB  0
01DC2:  BTFSC  FD8.2
01DC4:  BRA    1E7E
01DC6:  MOVLB  2
01DC8:  MOVLW  07
01DCA:  SUBWF  03,W
01DCC:  BNZ   1DDA
01DCE:  MOVLW  CE
01DD0:  SUBWF  00,W
01DD2:  MOVLB  0
01DD4:  BTFSC  FD8.2
01DD6:  BRA    1E96
01DD8:  MOVLB  2
01DDA:  MOVLW  07
01DDC:  SUBWF  03,W
01DDE:  BNZ   1DEC
01DE0:  MOVLW  CF
01DE2:  SUBWF  00,W
01DE4:  MOVLB  0
01DE6:  BTFSC  FD8.2
01DE8:  BRA    1EB0
01DEA:  MOVLB  2
01DEC:  MOVLW  4E
01DEE:  SUBWF  03,W
01DF0:  BNZ   1DFE
01DF2:  MOVLW  1F
01DF4:  SUBWF  00,W
01DF6:  MOVLB  0
01DF8:  BTFSC  FD8.2
01DFA:  BRA    1ECA
01DFC:  MOVLB  2
01DFE:  BRA    1EF2
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01E00:  MOVLB  2
01E02:  MOVF   xD6,F
01E04:  BNZ   1E0C
01E06:  MOVF   xD5,W
01E08:  SUBLW  80
01E0A:  BC    1E12
01E0C:  MOVLW  03
01E0E:  MOVWF  01
01E10:  BRA    1EFC
.................... 			config.modbus_address=value; 
01E12:  MOVFF  2D5,36
.................... 			break; 
01E16:  BRA    1EF8
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01E18:  MOVLB  1
01E1A:  BSF    xAE.1
.................... 			config.adc_sample_ticks=value; 
01E1C:  MOVFF  2D6,3D
01E20:  MOVFF  2D5,3C
.................... 			break; 
01E24:  MOVLB  2
01E26:  BRA    1EF8
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01E28:  MOVLB  2
01E2A:  MOVF   xD6,F
01E2C:  BNZ   1E34
01E2E:  MOVF   xD5,W
01E30:  SUBLW  01
01E32:  BC    1E3A
01E34:  MOVLW  03
01E36:  MOVWF  01
01E38:  BRA    1EFC
.................... 			config.allow_bootload_request=value; 
01E3A:  MOVFF  2D5,3E
.................... 			break; 
01E3E:  BRA    1EF8
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01E40:  MOVFF  2D6,40
01E44:  MOVFF  2D5,3F
.................... 			break; 
01E48:  MOVLB  2
01E4A:  BRA    1EF8
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01E4C:  MOVLB  2
01E4E:  MOVF   xD5,F
01E50:  BNZ   1E5C
01E52:  MOVF   xD6,F
01E54:  BNZ   1E5C
01E56:  MOVLW  03
01E58:  MOVWF  01
01E5A:  BRA    1EFC
.................... 			config.pi_offtime_seconds=value; 
01E5C:  MOVFF  2D6,42
01E60:  MOVFF  2D5,41
.................... 			break; 
01E64:  BRA    1EF8
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01E66:  MOVLB  2
01E68:  MOVF   xD6,F
01E6A:  BNZ   1E72
01E6C:  MOVF   xD5,W
01E6E:  SUBLW  01
01E70:  BC    1E78
01E72:  MOVLW  03
01E74:  MOVWF  01
01E76:  BRA    1EFC
.................... 			config.power_startup=value; 
01E78:  MOVFF  2D5,43
.................... 			break; 
01E7C:  BRA    1EF8
....................  
.................... 		case 1012: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01E7E:  MOVLB  2
01E80:  MOVF   xD6,F
01E82:  BNZ   1E8A
01E84:  MOVF   xD5,W
01E86:  SUBLW  01
01E88:  BC    1E90
01E8A:  MOVLW  03
01E8C:  MOVWF  01
01E8E:  BRA    1EFC
.................... 			config.modbus_bridge=value; 
01E90:  MOVFF  2D5,38
.................... 			break; 
01E94:  BRA    1EF8
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01E96:  MOVLB  2
01E98:  DECFSZ xD5,W
01E9A:  BRA    1EA0
01E9C:  MOVF   xD6,F
01E9E:  BZ    1EA6
01EA0:  MOVLW  03
01EA2:  MOVWF  01
01EA4:  BRA    1EFC
.................... 			write_default_param_file(); 
01EA6:  MOVLB  0
01EA8:  CALL   0BFC
.................... 			break; 
01EAC:  MOVLB  2
01EAE:  BRA    1EF8
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01EB0:  MOVLB  2
01EB2:  DECFSZ xD5,W
01EB4:  BRA    1EBA
01EB6:  MOVF   xD6,F
01EB8:  BZ    1EC0
01EBA:  MOVLW  03
01EBC:  MOVWF  01
01EBE:  BRA    1EFC
.................... 			write_param_file(); 
01EC0:  MOVLB  0
01EC2:  CALL   0BA8
.................... 			break; 
01EC6:  MOVLB  2
01EC8:  BRA    1EF8
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01ECA:  MOVLB  2
01ECC:  MOVF   xD5,W
01ECE:  SUBLW  0A
01ED0:  BNZ   1ED8
01ED2:  MOVF   xD6,W
01ED4:  SUBLW  07
01ED6:  BZ    1EE4
.................... 				current.factory_unlocked=0; 
01ED8:  MOVLB  1
01EDA:  CLRF   x8F
.................... 				return ILLEGAL_DATA_VALUE; 
01EDC:  MOVLW  03
01EDE:  MOVWF  01
01EE0:  MOVLB  2
01EE2:  BRA    1EFC
.................... 			} 
.................... 			current.factory_unlocked=1; 
01EE4:  MOVLW  01
01EE6:  MOVLB  1
01EE8:  MOVWF  x8F
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01EEA:  MOVLW  C8
01EEC:  MOVWF  xAB
.................... 			break; 
01EEE:  MOVLB  2
01EF0:  BRA    1EF8
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01EF2:  MOVLW  02
01EF4:  MOVWF  01
01EF6:  BRA    1EFC
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01EF8:  MOVLW  00
01EFA:  MOVWF  01
.................... } 
01EFC:  MOVLB  0
01EFE:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
01F90:  GOTO   0FDA
01F94:  MOVF   01,F
01F96:  BTFSC  FD8.2
01F98:  BRA    21C0
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
01F9A:  MOVF   36,W
01F9C:  SUBLW  80
01F9E:  BZ    1FAC
01FA0:  MOVF   36,W
01FA2:  MOVLB  1
01FA4:  SUBWF  xB5,W
01FA6:  BTFSS  FD8.2
01FA8:  BRA    21AC
01FAA:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
01FAC:  MOVLB  1
01FAE:  INCFSZ x83,W
01FB0:  BRA    1FB8
01FB2:  INCFSZ x84,W
01FB4:  BRA    1FB8
01FB6:  BRA    1FBE
.................... 				current.modbus_our_packets++; 
01FB8:  INCF   x83,F
01FBA:  BTFSC  FD8.2
01FBC:  INCF   x84,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
01FBE:  MOVLW  14
01FC0:  MOVWF  xAB
....................  
.................... 			switch(modbus_rx.func) { 
01FC2:  MOVF   xB7,W
01FC4:  XORLW  03
01FC6:  MOVLB  0
01FC8:  BZ    1FDA
01FCA:  XORLW  07
01FCC:  BZ    1FDA
01FCE:  XORLW  02
01FD0:  BZ    2052
01FD2:  XORLW  16
01FD4:  BTFSC  FD8.2
01FD6:  BRA    20C4
01FD8:  BRA    2186
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01FDA:  MOVFF  1B9,2C8
01FDE:  MOVFF  1BA,2C7
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01FE2:  MOVFF  1BB,2CA
01FE6:  MOVFF  1BC,2C9
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
01FEA:  MOVLB  2
01FEC:  MOVF   xC9,W
01FEE:  ADDWF  xC7,W
01FF0:  MOVWF  xCD
01FF2:  MOVF   xCA,W
01FF4:  ADDWFC xC8,W
01FF6:  MOVWF  xCE
01FF8:  MOVFF  2C8,2D0
01FFC:  MOVFF  2C7,2CF
02000:  MOVWF  xD2
02002:  MOVFF  2CD,2D1
02006:  MOVLB  0
02008:  GOTO   1000
0200C:  MOVF   01,F
0200E:  BNZ   2034
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02010:  MOVFF  1B5,2CD
02014:  MOVLB  2
02016:  CLRF   xCF
02018:  MOVFF  1B7,2CE
0201C:  MOVLW  02
0201E:  MOVWF  xD0
02020:  MOVLB  0
02022:  CALL   111C
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02026:  MOVLB  1
02028:  CLRF   x88
0202A:  MOVLW  02
0202C:  MOVWF  x87
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0202E:  CLRF   xAB
.................... 					} else { 
02030:  BRA    2050
02032:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02034:  MOVFF  1B7,2CD
02038:  MOVFF  1B5,2CE
0203C:  MOVFF  2C8,2D0
02040:  MOVFF  2C7,2CF
02044:  MOVFF  2CA,2D2
02048:  MOVFF  2C9,2D1
0204C:  BRA    1C10
0204E:  MOVLB  1
.................... 					} 
.................... 					break; 
02050:  BRA    21A6
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02052:  MOVFF  1B9,2C8
02056:  MOVFF  1BA,2C7
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
0205A:  MOVFF  1BB,2CE
0205E:  MOVFF  1BC,2CD
02062:  MOVFF  2C8,2D4
02066:  MOVFF  2C7,2D3
0206A:  MOVFF  1BB,2D6
0206E:  MOVFF  1BC,2D5
02072:  RCALL  1C92
02074:  MOVFF  01,2CB
....................  
.................... 					if ( result ) { 
02078:  MOVLB  2
0207A:  MOVF   xCB,F
0207C:  BZ    20A0
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
0207E:  MOVFF  1B5,2CD
02082:  CLRF   xCF
02084:  MOVFF  1B7,2CE
02088:  MOVFF  2CB,2D0
0208C:  MOVLB  0
0208E:  CALL   111C
.................... 						current.modbus_last_error=result; 
02092:  MOVLB  1
02094:  CLRF   x88
02096:  MOVFF  2CB,187
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0209A:  CLRF   xAB
.................... 					}  else { 
0209C:  BRA    20C2
0209E:  MOVLB  2
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
020A0:  MOVFF  1BB,2CE
020A4:  MOVFF  1BC,2CD
020A8:  MOVFF  1B5,2CF
020AC:  MOVFF  2C8,2D1
020B0:  MOVFF  2C7,2D0
020B4:  MOVFF  1BB,2D3
020B8:  MOVFF  1BC,2D2
020BC:  MOVLB  0
020BE:  BRA    1F00
020C0:  MOVLB  1
.................... 					} 
.................... 					break; 
020C2:  BRA    21A6
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
020C4:  MOVFF  1B9,2C8
020C8:  MOVFF  1BA,2C7
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
020CC:  MOVFF  1BB,2CA
020D0:  MOVFF  1BC,2C9
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
020D4:  MOVLB  2
020D6:  CLRF   xCC
020D8:  MOVF   xCA,F
020DA:  BNZ   20E2
020DC:  MOVF   xC9,W
020DE:  SUBWF  xCC,W
020E0:  BC    2166
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
020E2:  MOVF   xCC,W
020E4:  ADDWF  xC7,W
020E6:  MOVWF  xCD
020E8:  MOVLW  00
020EA:  ADDWFC xC8,W
020EC:  MOVWF  xCE
020EE:  BCF    FD8.0
020F0:  RLCF   xCC,W
020F2:  ADDLW  05
020F4:  ADDLW  B9
020F6:  MOVWF  FE9
020F8:  MOVLW  01
020FA:  MOVWF  FEA
020FC:  BTFSC  FD8.0
020FE:  INCF   FEA,F
02100:  MOVFF  FEF,2CF
02104:  BCF    FD8.0
02106:  RLCF   xCC,W
02108:  ADDLW  06
0210A:  ADDLW  B9
0210C:  MOVWF  FE9
0210E:  MOVLW  01
02110:  MOVWF  FEA
02112:  BTFSC  FD8.0
02114:  INCF   FEA,F
02116:  MOVFF  FEF,2D0
0211A:  MOVFF  2CF,2D2
0211E:  MOVFF  2D0,2D1
02122:  MOVFF  2CE,2D4
02126:  MOVFF  2CD,2D3
0212A:  MOVFF  2CF,2D6
0212E:  MOVFF  2D0,2D5
02132:  MOVLB  0
02134:  RCALL  1C92
02136:  MOVFF  01,2CB
....................  
.................... 						if ( result ) { 
0213A:  MOVLB  2
0213C:  MOVF   xCB,F
0213E:  BZ    2162
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02140:  MOVFF  1B5,2CD
02144:  CLRF   xCF
02146:  MOVFF  1B7,2CE
0214A:  MOVFF  2CB,2D0
0214E:  MOVLB  0
02150:  CALL   111C
.................... 							current.modbus_last_error=result; 
02154:  MOVLB  1
02156:  CLRF   x88
02158:  MOVFF  2CB,187
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
0215C:  CLRF   xAB
.................... 			 
.................... 							break; 
0215E:  MOVLB  2
02160:  BRA    2166
.................... 						} 
.................... 					} 
02162:  INCF   xCC,F
02164:  BRA    20D8
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02166:  MOVF   xCB,F
02168:  BNZ   2182
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
0216A:  MOVFF  1B5,2CD
0216E:  MOVFF  2C8,2CF
02172:  MOVFF  2C7,2CE
02176:  MOVFF  2CA,2D1
0217A:  MOVFF  2C9,2D0
0217E:  MOVLB  0
02180:  BRA    1F48
.................... 					} 
....................  
.................... 					break;   
02182:  MOVLB  1
02184:  BRA    21A6
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02186:  MOVFF  1B5,2CD
0218A:  MOVLB  2
0218C:  CLRF   xCF
0218E:  MOVFF  1B7,2CE
02192:  MOVLW  01
02194:  MOVWF  xD0
02196:  MOVLB  0
02198:  CALL   111C
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
0219C:  MOVLB  1
0219E:  CLRF   x88
021A0:  MOVLW  01
021A2:  MOVWF  x87
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
021A4:  CLRF   xAB
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
021A6:  CLRF   x92
021A8:  CLRF   x91
....................  
.................... 		} else { 
021AA:  BRA    21C0
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
021AC:  INCFSZ x85,W
021AE:  BRA    21B6
021B0:  INCFSZ x86,W
021B2:  BRA    21B6
021B4:  BRA    21BC
.................... 				current.modbus_other_packets++; 
021B6:  INCF   x85,F
021B8:  BTFSC  FD8.2
021BA:  INCF   x86,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
021BC:  MOVLW  14
021BE:  MOVWF  xAB
021C0:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
021C2:  GOTO   2442 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003D6:  MOVLB  2
003D8:  BTFSS  xE9.0
003DA:  BRA    03F4
003DC:  MOVLB  1
003DE:  INCFSZ x9A,W
003E0:  BRA    03EC
003E2:  INCFSZ x9B,W
003E4:  BRA    03EC
003E6:  MOVLB  2
003E8:  BRA    03F4
003EA:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
003EC:  INCF   x9A,F
003EE:  BTFSC  FD8.2
003F0:  INCF   x9B,F
003F2:  MOVLB  2
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
003F4:  BTFSS  xE9.2
003F6:  BRA    0410
003F8:  MOVLB  1
003FA:  INCFSZ x9C,W
003FC:  BRA    0408
003FE:  INCFSZ x9D,W
00400:  BRA    0408
00402:  MOVLB  2
00404:  BRA    0410
00406:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00408:  INCF   x9C,F
0040A:  BTFSC  FD8.2
0040C:  INCF   x9D,F
0040E:  MOVLB  2
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
00410:  BTFSS  xE9.4
00412:  BRA    042C
00414:  MOVLB  1
00416:  INCFSZ x9E,W
00418:  BRA    0424
0041A:  INCFSZ x9F,W
0041C:  BRA    0424
0041E:  MOVLB  2
00420:  BRA    042C
00422:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00424:  INCF   x9E,F
00426:  BTFSC  FD8.2
00428:  INCF   x9F,F
0042A:  MOVLB  2
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
0042C:  BCF    xE9.1
0042E:  BTFSC  F81.0
00430:  BSF    xE9.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
00432:  BTFSC  xE9.1
00434:  BRA    04B4
00436:  MOVLB  1
00438:  BTFSC  xB1.1
0043A:  BRA    0440
0043C:  MOVLB  2
0043E:  BRA    04B4
.................... 		current.pulse_count[0]++; 
00440:  MOVLB  0
00442:  INCF   x60,F
00444:  BTFSC  FD8.2
00446:  INCF   x61,F
.................... 		current.pulse_sum[0]++; 
00448:  MOVLW  01
0044A:  ADDWF  x66,F
0044C:  BTFSC  FD8.0
0044E:  INCF   x67,F
00450:  BTFSC  FD8.2
00452:  INCF   x68,F
00454:  BTFSC  FD8.2
00456:  INCF   x69,F
.................... 		if ( 1 == ext0_state ) { 
00458:  MOVLB  1
0045A:  BTFSS  xB1.2
0045C:  BRA    04A4
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0045E:  MOVLB  2
00460:  BCF    xE9.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
00462:  MOVFF  19B,4F
00466:  MOVFF  19A,4E
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
0046A:  MOVF   4F,W
0046C:  SUBWF  55,W
0046E:  BNC   0480
00470:  BNZ   0478
00472:  MOVF   54,W
00474:  SUBWF  4E,W
00476:  BC    0480
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00478:  MOVFF  4F,55
0047C:  MOVFF  4E,54
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
00480:  MOVF   5B,W
00482:  SUBWF  4F,W
00484:  BNC   04A0
00486:  BNZ   048E
00488:  MOVF   4E,W
0048A:  SUBWF  5A,W
0048C:  BC    04A0
0048E:  INCFSZ 4E,W
00490:  BRA    0498
00492:  INCFSZ 4F,W
00494:  BRA    0498
00496:  BRA    04A0
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00498:  MOVFF  4F,5B
0049C:  MOVFF  4E,5A
.................... 			} 
.................... 			ext0_state=0; 
004A0:  MOVLB  1
004A2:  BCF    xB1.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004A4:  BTFSC  xB1.2
004A6:  BRA    04B4
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004A8:  CLRF   x9B
004AA:  CLRF   x9A
.................... 			ext0_count=1; 
004AC:  MOVLB  2
004AE:  BSF    xE9.0
.................... 			ext0_state=1; 
004B0:  MOVLB  1
004B2:  BSF    xB1.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004B4:  MOVLB  1
004B6:  BCF    xB1.1
004B8:  MOVLB  2
004BA:  BTFSS  xE9.1
004BC:  BRA    04C4
004BE:  MOVLB  1
004C0:  BSF    xB1.1
004C2:  MOVLB  2
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004C4:  BCF    xE9.3
004C6:  BTFSC  F81.1
004C8:  BSF    xE9.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004CA:  BTFSC  xE9.3
004CC:  BRA    054C
004CE:  MOVLB  1
004D0:  BTFSC  xB1.3
004D2:  BRA    04D8
004D4:  MOVLB  2
004D6:  BRA    054C
.................... 		current.pulse_count[1]++; 
004D8:  MOVLB  0
004DA:  INCF   x62,F
004DC:  BTFSC  FD8.2
004DE:  INCF   x63,F
.................... 		current.pulse_sum[1]++; 
004E0:  MOVLW  01
004E2:  ADDWF  x6A,F
004E4:  BTFSC  FD8.0
004E6:  INCF   x6B,F
004E8:  BTFSC  FD8.2
004EA:  INCF   x6C,F
004EC:  BTFSC  FD8.2
004EE:  INCF   x6D,F
.................... 		if ( 1 == ext1_state ) { 
004F0:  MOVLB  1
004F2:  BTFSS  xB1.4
004F4:  BRA    053C
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
004F6:  MOVLB  2
004F8:  BCF    xE9.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
004FA:  MOVFF  19D,51
004FE:  MOVFF  19C,50
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00502:  MOVF   51,W
00504:  SUBWF  57,W
00506:  BNC   0518
00508:  BNZ   0510
0050A:  MOVF   56,W
0050C:  SUBWF  50,W
0050E:  BC    0518
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00510:  MOVFF  51,57
00514:  MOVFF  50,56
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00518:  MOVF   5D,W
0051A:  SUBWF  51,W
0051C:  BNC   0538
0051E:  BNZ   0526
00520:  MOVF   50,W
00522:  SUBWF  5C,W
00524:  BC    0538
00526:  INCFSZ 50,W
00528:  BRA    0530
0052A:  INCFSZ 51,W
0052C:  BRA    0530
0052E:  BRA    0538
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
00530:  MOVFF  51,5D
00534:  MOVFF  50,5C
.................... 			} 
.................... 			ext1_state=0; 
00538:  MOVLB  1
0053A:  BCF    xB1.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0053C:  BTFSC  xB1.4
0053E:  BRA    054C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
00540:  CLRF   x9D
00542:  CLRF   x9C
.................... 			ext1_count=1; 
00544:  MOVLB  2
00546:  BSF    xE9.2
.................... 			ext1_state=1; 
00548:  MOVLB  1
0054A:  BSF    xB1.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
0054C:  MOVLB  1
0054E:  BCF    xB1.3
00550:  MOVLB  2
00552:  BTFSS  xE9.3
00554:  BRA    055C
00556:  MOVLB  1
00558:  BSF    xB1.3
0055A:  MOVLB  2
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0055C:  BCF    xE9.5
0055E:  BTFSC  F81.2
00560:  BSF    xE9.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00562:  BTFSC  xE9.5
00564:  BRA    05E4
00566:  MOVLB  1
00568:  BTFSC  xB1.5
0056A:  BRA    0570
0056C:  MOVLB  2
0056E:  BRA    05E4
.................... 		current.pulse_count[2]++; 
00570:  MOVLB  0
00572:  INCF   x64,F
00574:  BTFSC  FD8.2
00576:  INCF   x65,F
.................... 		current.pulse_sum[2]++; 
00578:  MOVLW  01
0057A:  ADDWF  x6E,F
0057C:  BTFSC  FD8.0
0057E:  INCF   x6F,F
00580:  BTFSC  FD8.2
00582:  INCF   x70,F
00584:  BTFSC  FD8.2
00586:  INCF   x71,F
.................... 		if ( 1 == ext2_state ) { 
00588:  MOVLB  1
0058A:  BTFSS  xB1.6
0058C:  BRA    05D4
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0058E:  MOVLB  2
00590:  BCF    xE9.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00592:  MOVFF  19F,53
00596:  MOVFF  19E,52
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0059A:  MOVF   53,W
0059C:  SUBWF  59,W
0059E:  BNC   05B0
005A0:  BNZ   05A8
005A2:  MOVF   58,W
005A4:  SUBWF  52,W
005A6:  BC    05B0
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005A8:  MOVFF  53,59
005AC:  MOVFF  52,58
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005B0:  MOVF   5F,W
005B2:  SUBWF  53,W
005B4:  BNC   05D0
005B6:  BNZ   05BE
005B8:  MOVF   52,W
005BA:  SUBWF  5E,W
005BC:  BC    05D0
005BE:  INCFSZ 52,W
005C0:  BRA    05C8
005C2:  INCFSZ 53,W
005C4:  BRA    05C8
005C6:  BRA    05D0
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005C8:  MOVFF  53,5F
005CC:  MOVFF  52,5E
.................... 			} 
.................... 			ext2_state=0; 
005D0:  MOVLB  1
005D2:  BCF    xB1.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005D4:  BTFSC  xB1.6
005D6:  BRA    05E4
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005D8:  CLRF   x9F
005DA:  CLRF   x9E
.................... 			ext2_count=1; 
005DC:  MOVLB  2
005DE:  BSF    xE9.4
.................... 			ext2_state=1; 
005E0:  MOVLB  1
005E2:  BSF    xB1.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
005E4:  MOVLB  1
005E6:  BCF    xB1.5
005E8:  MOVLB  2
005EA:  BTFSS  xE9.5
005EC:  BRA    05F4
005EE:  MOVLB  1
005F0:  BSF    xB1.5
005F2:  MOVLB  2
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
005F4:  INCF   xBC,F
.................... 	if ( 10 == tick ) { 
005F6:  MOVF   xBC,W
005F8:  SUBLW  0A
005FA:  BNZ   0604
.................... 		tick=0; 
005FC:  CLRF   xBC
.................... 		timers.now_millisecond=1; 
005FE:  MOVLB  1
00600:  BSF    xAE.2
00602:  MOVLB  2
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00604:  BCF    F9E.1
00606:  MOVLB  0
00608:  GOTO   0122
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(MODBUS_SERIAL); 
*
00658:  RCALL  060C
0065A:  MOVFF  01,2E6
....................  
.................... 	if ( current.bridged_uarts ) { 
0065E:  MOVLB  1
00660:  BTFSS  x90.0
00662:  BRA    0670
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,DEBUG); 
00664:  MOVLB  2
00666:  MOVF   xE6,W
00668:  MOVLB  0
0066A:  BRA    0622
.................... 		return; 
0066C:  BRA    06C8
0066E:  MOVLB  1
.................... 	}  
....................  
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
00670:  BTFSC  xB1.0
00672:  BRA    06CA
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00674:  MOVF   xB2,F
00676:  BNZ   0688
.................... 			modbus_serial_crc.d = 0xFFFF; 
00678:  SETF   xB4
0067A:  SETF   xB3
.................... 			modbus_rx.address = c; 
0067C:  MOVFF  2E6,1B5
.................... 			modbus_serial_state++; 
00680:  INCF   xB2,F
.................... 			modbus_rx.len = 0; 
00682:  CLRF   xB6
.................... 			modbus_rx.error=0; 
00684:  CLRF   xB8
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00686:  BRA    06B6
00688:  DECFSZ xB2,W
0068A:  BRA    0694
.................... 			modbus_rx.func = c; 
0068C:  MOVFF  2E6,1B7
.................... 			modbus_serial_state++; 
00690:  INCF   xB2,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00692:  BRA    06B6
00694:  MOVF   xB2,W
00696:  SUBLW  02
00698:  BNZ   06B6
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0069A:  INCFSZ xB6,W
0069C:  BRA    06A2
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0069E:  MOVLW  FE
006A0:  MOVWF  xB6
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
006A2:  MOVLW  B9
006A4:  ADDWF  xB6,W
006A6:  MOVWF  FE9
006A8:  MOVLW  01
006AA:  MOVWF  FEA
006AC:  BTFSC  FD8.0
006AE:  INCF   FEA,F
006B0:  MOVFF  2E6,FEF
.................... 			modbus_rx.len++; 
006B4:  INCF   xB6,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
006B6:  MOVFF  2E6,2E7
006BA:  MOVLB  0
006BC:  RCALL  062C
.................... 		modbus_enable_timeout(TRUE); 
006BE:  MOVLW  01
006C0:  MOVLB  2
006C2:  MOVWF  xE7
006C4:  MOVLB  0
006C6:  RCALL  0390
006C8:  MOVLB  1
.................... 	} 
.................... } 
....................  
....................  
....................  
006CA:  BCF    F9E.5
006CC:  MOVLB  0
006CE:  GOTO   007C
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00840:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00842:  MOVLW  08
00844:  MOVWF  F61
00846:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
00848:  MOVLW  00
0084A:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
0084C:  MOVLW  FF
0084E:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00850:  MOVLW  92
00852:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00854:  MOVLW  80
00856:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00858:  BCF    F96.0
0085A:  BCF    F96.1
0085C:  BCF    F96.2
0085E:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00860:  MOVLB  1
00862:  CLRF   xAB
.................... 	timers.load_off_seconds=2; 
00864:  CLRF   xAD
00866:  MOVLW  02
00868:  MOVWF  xAC
.................... 	timers.now_adc_sample=0; 
0086A:  BCF    xAE.0
.................... 	timers.now_adc_reset_count=0; 
0086C:  BCF    xAE.1
.................... 	timers.now_millisecond=0; 
0086E:  BCF    xAE.2
.................... 	timers.port_b=0b11111111; 
00870:  SETF   xAF
.................... 	timers.port_c=0b11111111; 
00872:  SETF   xB0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
00874:  MOVLB  2
00876:  CLRF   xC7
00878:  MOVF   xC7,W
0087A:  SUBLW  02
0087C:  BNC   092A
.................... 		current.pulse_period[i]=0; 
0087E:  CLRF   03
00880:  MOVFF  2C7,02
00884:  BCF    FD8.0
00886:  RLCF   02,F
00888:  RLCF   03,F
0088A:  MOVF   02,W
0088C:  ADDLW  4E
0088E:  MOVWF  FE9
00890:  MOVLW  00
00892:  ADDWFC 03,W
00894:  MOVWF  FEA
00896:  CLRF   FEC
00898:  MOVF   FED,F
0089A:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
0089C:  CLRF   03
0089E:  MOVFF  2C7,02
008A2:  BCF    FD8.0
008A4:  RLCF   02,F
008A6:  RLCF   03,F
008A8:  MOVF   02,W
008AA:  ADDLW  54
008AC:  MOVWF  FE9
008AE:  MOVLW  00
008B0:  ADDWFC 03,W
008B2:  MOVWF  FEA
008B4:  SETF   FEC
008B6:  MOVF   FED,F
008B8:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
008BA:  CLRF   03
008BC:  MOVFF  2C7,02
008C0:  BCF    FD8.0
008C2:  RLCF   02,F
008C4:  RLCF   03,F
008C6:  MOVF   02,W
008C8:  ADDLW  5A
008CA:  MOVWF  FE9
008CC:  MOVLW  00
008CE:  ADDWFC 03,W
008D0:  MOVWF  FEA
008D2:  CLRF   FEC
008D4:  MOVF   FED,F
008D6:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
008D8:  CLRF   03
008DA:  MOVFF  2C7,02
008DE:  BCF    FD8.0
008E0:  RLCF   02,F
008E2:  RLCF   03,F
008E4:  MOVF   02,W
008E6:  ADDLW  60
008E8:  MOVWF  FE9
008EA:  MOVLW  00
008EC:  ADDWFC 03,W
008EE:  MOVWF  FEA
008F0:  CLRF   FEC
008F2:  MOVF   FED,F
008F4:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
008F6:  CLRF   xE2
008F8:  MOVFF  2C7,2E1
008FC:  CLRF   xE4
008FE:  MOVLW  04
00900:  MOVWF  xE3
00902:  MOVLB  0
00904:  RCALL  081E
00906:  MOVF   01,W
00908:  ADDLW  66
0090A:  MOVWF  FE9
0090C:  MOVLW  00
0090E:  ADDWFC 02,W
00910:  MOVWF  FEA
00912:  MOVF   FEE,F
00914:  MOVF   FEE,F
00916:  CLRF   FEC
00918:  MOVF   FED,F
0091A:  CLRF   FEF
0091C:  MOVF   FED,F
0091E:  CLRF   FEF
00920:  MOVF   FED,F
00922:  CLRF   FEF
.................... 	} 
00924:  MOVLB  2
00926:  INCF   xC7,F
00928:  BRA    0878
....................  
.................... 	current.modbus_our_packets=0; 
0092A:  MOVLB  1
0092C:  CLRF   x84
0092E:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
00930:  CLRF   x86
00932:  CLRF   x85
.................... 	current.modbus_last_error=0; 
00934:  CLRF   x88
00936:  CLRF   x87
.................... 	current.sequence_number=0; 
00938:  CLRF   x8A
0093A:  CLRF   x89
.................... 	current.uptime_minutes=0; 
0093C:  CLRF   x8C
0093E:  CLRF   x8B
.................... 	current.interval_milliseconds=0; 
00940:  CLRF   x8E
00942:  CLRF   x8D
.................... 	current.adc_buffer_index=0; 
00944:  CLRF   x82
.................... 	current.factory_unlocked=0; 
00946:  CLRF   x8F
.................... 	current.bridged_uarts=0; 
00948:  BCF    x90.0
.................... 	current.watchdog_seconds=0; 
0094A:  CLRF   x92
0094C:  CLRF   x91
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
0094E:  MOVFF  4B,195
00952:  MOVFF  4A,194
.................... 	current.power_off_delay=config.power_off_below_delay; 
00956:  MOVFF  47,197
0095A:  MOVFF  46,196
.................... 	current.power_override_timeout=0; 
0095E:  CLRF   x99
00960:  CLRF   x98
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
00962:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
00964:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
00966:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00968:  MOVLW  00
0096A:  IORLW  05
0096C:  MOVWF  FBA
0096E:  MOVLW  4A
00970:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00972:  BSF    F9D.1
.................... //	enable_interrupts(INT_RDA2); /* debug cable */ 
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00974:  MOVLB  0
00976:  GOTO   2266 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00E7A:  MOVLB  1
00E7C:  BCF    xAE.2
....................  
.................... //	fputc('.',DEBUG); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(DEBUG,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00E7E:  BCF    FD8.0
00E80:  MOVLB  2
00E82:  RLCF   xC2,W
00E84:  MOVWF  xC7
00E86:  RLCF   xC3,W
00E88:  MOVWF  xC8
00E8A:  MOVLW  00
00E8C:  MOVLB  1
00E8E:  BTFSS  xB0.5
00E90:  MOVLW  01
00E92:  MOVLB  2
00E94:  IORWF  xC7,F
00E96:  MOVFF  2C7,2C2
00E9A:  MOVF   xC8,W
00E9C:  IORLW  E0
00E9E:  MOVWF  xC3
.................... 	if ( b2_state==0xf000) { 
00EA0:  MOVF   xC2,F
00EA2:  BNZ   0EAA
00EA4:  MOVF   xC3,W
00EA6:  SUBLW  F0
00EA8:  BNZ   0EAA
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00EAA:  MOVLB  1
00EAC:  INCFSZ x9A,W
00EAE:  BRA    0EB8
00EB0:  INCFSZ x9B,W
00EB2:  BRA    0EB8
.................... 				current.pulse_period[0]=0; 
00EB4:  CLRF   4F
00EB6:  CLRF   4E
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00EB8:  INCFSZ x9C,W
00EBA:  BRA    0EC4
00EBC:  INCFSZ x9D,W
00EBE:  BRA    0EC4
.................... 				current.pulse_period[1]=0; 
00EC0:  CLRF   51
00EC2:  CLRF   50
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00EC4:  INCFSZ x9E,W
00EC6:  BRA    0ED0
00EC8:  INCFSZ x9F,W
00ECA:  BRA    0ED0
.................... 				current.pulse_period[2]=0; 
00ECC:  CLRF   53
00ECE:  CLRF   52
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00ED0:  MOVFF  F81,1AF
.................... 	timers.port_c=port_c; 
00ED4:  MOVFF  F82,1B0
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00ED8:  BTFSS  x90.0
00EDA:  BRA    0EE0
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00EDC:  BSF    F89.3
.................... 	} else { 
00EDE:  BRA    0EEC
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00EE0:  MOVF   xAB,F
00EE2:  BNZ   0EE8
.................... 			output_low(LED_GREEN); 
00EE4:  BCF    F89.3
.................... 		} else { 
00EE6:  BRA    0EEC
.................... 			output_high(LED_GREEN); 
00EE8:  BSF    F89.3
.................... 			timers.led_on_green--; 
00EEA:  DECF   xAB,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00EEC:  INCFSZ x8D,W
00EEE:  BRA    0EF6
00EF0:  INCFSZ x8E,W
00EF2:  BRA    0EF6
00EF4:  BRA    0EFC
.................... 		current.interval_milliseconds++; 
00EF6:  INCF   x8D,F
00EF8:  BTFSC  FD8.2
00EFA:  INCF   x8E,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00EFC:  MOVLB  2
00EFE:  INCF   xC0,F
00F00:  BTFSC  FD8.2
00F02:  INCF   xC1,F
.................... 	if ( 1000 == ticks ) { 
00F04:  MOVF   xC0,W
00F06:  SUBLW  E8
00F08:  BNZ   0F8E
00F0A:  MOVF   xC1,W
00F0C:  SUBLW  03
00F0E:  BNZ   0F8E
.................... 		ticks=0; 
00F10:  CLRF   xC1
00F12:  CLRF   xC0
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00F14:  MOVLB  1
00F16:  INCFSZ x91,W
00F18:  BRA    0F20
00F1A:  INCFSZ x92,W
00F1C:  BRA    0F20
00F1E:  BRA    0F26
.................... 			current.watchdog_seconds++; 
00F20:  INCF   x91,F
00F22:  BTFSC  FD8.2
00F24:  INCF   x92,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00F26:  MOVF   3F,F
00F28:  BNZ   0F2E
00F2A:  MOVF   40,F
00F2C:  BZ    0F4C
00F2E:  MOVF   40,W
00F30:  SUBWF  x92,W
00F32:  BNC   0F4C
00F34:  BNZ   0F3C
00F36:  MOVF   x91,W
00F38:  SUBWF  3F,W
00F3A:  BC    0F4C
00F3C:  MOVF   xAC,F
00F3E:  BNZ   0F4C
00F40:  MOVF   xAD,F
00F42:  BNZ   0F4C
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00F44:  MOVFF  42,1AD
00F48:  MOVFF  41,1AC
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00F4C:  MOVF   xAC,F
00F4E:  BNZ   0F58
00F50:  MOVF   xAD,F
00F52:  BNZ   0F58
.................... 			output_high(PI_POWER_EN); 
00F54:  BSF    F8B.0
.................... 		} else { 
00F56:  BRA    0F6E
.................... 			output_low(PI_POWER_EN); 
00F58:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00F5A:  MOVF   xAC,W
00F5C:  BTFSC  FD8.2
00F5E:  DECF   xAD,F
00F60:  DECF   xAC,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00F62:  MOVF   xAC,F
00F64:  BNZ   0F6E
00F66:  MOVF   xAD,F
00F68:  BNZ   0F6E
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00F6A:  CLRF   x92
00F6C:  CLRF   x91
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00F6E:  MOVLB  2
00F70:  INCF   xBD,F
.................... 		if ( 60 == uptimeTicks ) { 
00F72:  MOVF   xBD,W
00F74:  SUBLW  3C
00F76:  BNZ   0F8E
.................... 			uptimeTicks=0; 
00F78:  CLRF   xBD
.................... 			if ( current.uptime_minutes < 65535 )  
00F7A:  MOVLB  1
00F7C:  INCFSZ x8B,W
00F7E:  BRA    0F86
00F80:  INCFSZ x8C,W
00F82:  BRA    0F86
00F84:  BRA    0F8C
.................... 				current.uptime_minutes++; 
00F86:  INCF   x8B,F
00F88:  BTFSC  FD8.2
00F8A:  INCF   x8C,F
00F8C:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00F8E:  INCFSZ xC4,W
00F90:  BRA    0FA4
00F92:  INCFSZ xC5,W
00F94:  BRA    0FA4
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00F96:  CLRF   xDB
00F98:  MOVLB  0
00F9A:  RCALL  0DF2
00F9C:  MOVFF  02,2C5
00FA0:  MOVFF  01,2C4
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00FA4:  MOVLB  1
00FA6:  BTFSS  xAE.1
00FA8:  BRA    0FB2
.................... 		timers.now_adc_reset_count=0; 
00FAA:  BCF    xAE.1
.................... 		adcTicks=0; 
00FAC:  MOVLB  2
00FAE:  CLRF   xBF
00FB0:  CLRF   xBE
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00FB2:  MOVLB  2
00FB4:  INCF   xBE,F
00FB6:  BTFSC  FD8.2
00FB8:  INCF   xBF,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00FBA:  MOVF   3C,W
00FBC:  SUBWF  xBE,W
00FBE:  BNZ   0FD4
00FC0:  MOVF   3D,W
00FC2:  SUBWF  xBF,W
00FC4:  BNZ   0FD4
.................... 		adcTicks=0; 
00FC6:  CLRF   xBF
00FC8:  CLRF   xBE
.................... 		timers.now_adc_sample=1; 
00FCA:  MOVLB  1
00FCC:  BSF    xAE.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00FCE:  MOVLB  2
00FD0:  SETF   xC5
00FD2:  SETF   xC4
.................... 	} 
....................  
....................  
....................  
.................... } 
00FD4:  MOVLB  0
00FD6:  GOTO   2430 (RETURN)
....................  
....................  
.................... void main(void) { 
*
021C6:  CLRF   FF8
021C8:  BCF    FF1.2
021CA:  BSF    F9F.1
021CC:  BCF    F9F.5
021CE:  BSF    FD0.7
021D0:  BSF    07.7
021D2:  CLRF   FEA
021D4:  CLRF   FE9
021D6:  CLRF   35
021D8:  BCF    FB8.3
021DA:  MOVLW  0C
021DC:  MOVWF  FAF
021DE:  MOVLW  A6
021E0:  MOVWF  FAC
021E2:  MOVLW  90
021E4:  MOVWF  FAB
021E6:  BCF    F70.3
021E8:  MOVLW  4D
021EA:  MOVWF  F75
021EC:  MOVLW  A6
021EE:  MOVWF  F72
021F0:  MOVLW  90
021F2:  MOVWF  F71
021F4:  MOVLB  1
021F6:  BCF    xB1.0
021F8:  CLRF   xB2
021FA:  MOVLB  2
021FC:  CLRF   xBC
021FE:  MOVLB  1
02200:  BCF    xB1.1
02202:  BCF    xB1.2
02204:  BCF    xB1.3
02206:  BCF    xB1.4
02208:  BCF    xB1.5
0220A:  BCF    xB1.6
0220C:  MOVLB  2
0220E:  CLRF   xBD
02210:  CLRF   xBF
02212:  CLRF   xBE
02214:  CLRF   xC1
02216:  CLRF   xC0
02218:  CLRF   xC3
0221A:  CLRF   xC2
0221C:  MOVF   FC1,W
0221E:  ANDLW  F0
02220:  MOVWF  FC1
02222:  MOVLW  00
02224:  MOVLB  F
02226:  MOVWF  x38
02228:  MOVWF  x3C
0222A:  MOVWF  x39
0222C:  MOVWF  x3A
0222E:  MOVWF  x3B
02230:  MOVLB  1
02232:  CLRF   x88
02234:  CLRF   F77
02236:  CLRF   F78
02238:  CLRF   F79
0223A:  CLRF   2F
0223C:  CLRF   30
0223E:  MOVLB  2
02240:  CLRF   xB8
02242:  CLRF   xB9
02244:  CLRF   xBA
02246:  CLRF   xBB
02248:  CLRF   xC4
0224A:  CLRF   xC5
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
0224C:  MOVF   FD0,W
0224E:  ANDLW  0F
02250:  BTFSS  FD0.4
02252:  MOVLW  00
02254:  BSF    FD0.0
02256:  BSF    FD0.1
02258:  BSF    FD0.4
0225A:  BSF    FD8.3
0225C:  BSF    FD8.4
0225E:  MOVWF  xC6
....................  
.................... 	init(); 
02260:  MOVLB  0
02262:  GOTO   0840
....................  
....................  
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
02266:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
02268:  BSF    F8C.0
....................  
.................... 	fprintf(DEBUG,"# pcwx %s\r\n",__DATE__); 
0226A:  MOVLW  D2
0226C:  MOVWF  FF6
0226E:  MOVLW  06
02270:  MOVWF  FF7
02272:  MOVLW  07
02274:  MOVLB  2
02276:  MOVWF  xC8
02278:  MOVLB  0
0227A:  CALL   097A
0227E:  MOVLW  DE
02280:  MOVWF  FF6
02282:  MOVLW  06
02284:  MOVWF  FF7
02286:  CALL   09A4
0228A:  MOVLW  0D
0228C:  BTFSS  FA4.4
0228E:  BRA    228C
02290:  MOVWF  F73
02292:  MOVLW  0A
02294:  BTFSS  FA4.4
02296:  BRA    2294
02298:  MOVWF  F73
.................... 	fprintf(DEBUG,"# restart_cause()=%u ",i); 
0229A:  MOVLW  E8
0229C:  MOVWF  FF6
0229E:  MOVLW  06
022A0:  MOVWF  FF7
022A2:  MOVLW  12
022A4:  MOVLB  2
022A6:  MOVWF  xC8
022A8:  MOVLB  0
022AA:  CALL   097A
022AE:  MOVFF  2C6,2C8
022B2:  MOVLW  1B
022B4:  MOVLB  2
022B6:  MOVWF  xC9
022B8:  MOVLB  0
022BA:  CALL   09F2
022BE:  MOVLW  20
022C0:  BTFSS  FA4.4
022C2:  BRA    22C0
022C4:  MOVWF  F73
.................... 	switch ( i ) { 
022C6:  MOVLB  2
022C8:  MOVF   xC6,W
022CA:  XORLW  07
022CC:  MOVLB  0
022CE:  BZ    22EA
022D0:  XORLW  0C
022D2:  BZ    22F8
022D4:  XORLW  04
022D6:  BZ    2306
022D8:  XORLW  03
022DA:  BZ    2314
022DC:  XORLW  02
022DE:  BZ    2322
022E0:  XORLW  0D
022E2:  BZ    2330
022E4:  XORLW  03
022E6:  BZ    233E
022E8:  BRA    234C
.................... 		case WDT_TIMEOUT: fprintf(DEBUG,"WDT_TIMEOUT"); break; 
022EA:  MOVLW  FE
022EC:  MOVWF  FF6
022EE:  MOVLW  06
022F0:  MOVWF  FF7
022F2:  CALL   09A4
022F6:  BRA    2358
.................... 		case MCLR_FROM_SLEEP: fprintf(DEBUG,"MCLR_FROM_SLEEP"); break; 
022F8:  MOVLW  0A
022FA:  MOVWF  FF6
022FC:  MOVLW  07
022FE:  MOVWF  FF7
02300:  CALL   09A4
02304:  BRA    2358
.................... 		case MCLR_FROM_RUN: fprintf(DEBUG,"MCLR_FROM_RUN"); break; 
02306:  MOVLW  1A
02308:  MOVWF  FF6
0230A:  MOVLW  07
0230C:  MOVWF  FF7
0230E:  CALL   09A4
02312:  BRA    2358
.................... 		case NORMAL_POWER_UP: fprintf(DEBUG,"NORMAL_POWER_UP"); break; 
02314:  MOVLW  28
02316:  MOVWF  FF6
02318:  MOVLW  07
0231A:  MOVWF  FF7
0231C:  CALL   09A4
02320:  BRA    2358
.................... 		case BROWNOUT_RESTART: fprintf(DEBUG,"BROWNOUT_RESTART"); break; 
02322:  MOVLW  38
02324:  MOVWF  FF6
02326:  MOVLW  07
02328:  MOVWF  FF7
0232A:  CALL   09A4
0232E:  BRA    2358
.................... 		case WDT_FROM_SLEEP: fprintf(DEBUG,"WDT_FROM_SLEEP"); break; 
02330:  MOVLW  4A
02332:  MOVWF  FF6
02334:  MOVLW  07
02336:  MOVWF  FF7
02338:  CALL   09A4
0233C:  BRA    2358
.................... 		case RESET_INSTRUCTION: fprintf(DEBUG,"RESET_INSTRUCTION"); break; 
0233E:  MOVLW  5A
02340:  MOVWF  FF6
02342:  MOVLW  07
02344:  MOVWF  FF7
02346:  CALL   09A4
0234A:  BRA    2358
.................... 		default: fprintf(DEBUG,"unknown!"); 
0234C:  MOVLW  6C
0234E:  MOVWF  FF6
02350:  MOVLW  07
02352:  MOVWF  FF7
02354:  CALL   09A4
.................... 	} 
.................... 	fprintf(DEBUG,"\r\n"); 
02358:  MOVLW  76
0235A:  MOVWF  FF6
0235C:  MOVLW  07
0235E:  MOVWF  FF7
02360:  CALL   09A4
....................  
.................... 	fprintf(DEBUG,"# read_param_file() starting ..."); 
02364:  MOVLW  7A
02366:  MOVWF  FF6
02368:  MOVLW  07
0236A:  MOVWF  FF7
0236C:  CALL   09A4
.................... 	read_param_file(); 
02370:  GOTO   0C30
.................... 	fprintf(DEBUG," complete\r\n"); 
02374:  MOVLW  9C
02376:  MOVWF  FF6
02378:  MOVLW  07
0237A:  MOVWF  FF7
0237C:  CALL   09A4
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02380:  MOVF   36,W
02382:  SUBLW  80
02384:  BC    23A2
.................... 		fprintf(DEBUG,"# write_default_param_file() starting ..."); 
02386:  MOVLW  A8
02388:  MOVWF  FF6
0238A:  MOVLW  07
0238C:  MOVWF  FF7
0238E:  CALL   09A4
.................... 		write_default_param_file(); 
02392:  CALL   0BFC
.................... 		fprintf(DEBUG," complete\r\n"); 
02396:  MOVLW  D2
02398:  MOVWF  FF6
0239A:  MOVLW  07
0239C:  MOVWF  FF7
0239E:  CALL   09A4
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
023A2:  BSF    FAB.7
023A4:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	fprintf(DEBUG,"# modbus_init() starting ..."); 
023A6:  MOVLW  DE
023A8:  MOVWF  FF6
023AA:  MOVLW  07
023AC:  MOVWF  FF7
023AE:  CALL   09A4
.................... 	modbus_init(); 
023B2:  GOTO   0C8E
.................... 	fprintf(DEBUG," complete\r\n"); 
023B6:  MOVLW  FC
023B8:  MOVWF  FF6
023BA:  MOVLW  07
023BC:  MOVWF  FF7
023BE:  CALL   09A4
....................  
.................... 	fprintf(DEBUG,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
023C2:  MOVLW  00
023C4:  MOVLB  1
023C6:  BTFSC  x90.0
023C8:  MOVLW  01
023CA:  MOVLB  2
023CC:  MOVWF  xC7
023CE:  MOVLW  08
023D0:  MOVWF  FF6
023D2:  MOVLW  08
023D4:  MOVWF  FF7
023D6:  MOVLW  10
023D8:  MOVWF  xC8
023DA:  MOVLB  0
023DC:  CALL   097A
023E0:  MOVFF  2C7,2C8
023E4:  MOVLW  1B
023E6:  MOVLB  2
023E8:  MOVWF  xC9
023EA:  MOVLB  0
023EC:  CALL   09F2
023F0:  MOVLW  0D
023F2:  BTFSS  FA4.4
023F4:  BRA    23F2
023F6:  MOVWF  F73
023F8:  MOVLW  0A
023FA:  BTFSS  FA4.4
023FC:  BRA    23FA
023FE:  MOVWF  F73
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02400:  MOVLB  2
02402:  CLRF   xC6
02404:  MOVF   xC6,W
02406:  SUBLW  1D
02408:  BNC   2416
.................... 		adc_update(); 
0240A:  MOVLB  0
0240C:  CALL   0D4C
.................... 	} 
02410:  MOVLB  2
02412:  INCF   xC6,F
02414:  BRA    2404
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02416:  MOVFF  43,193
....................  
....................  
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
0241A:  BTFSS  F72.1
0241C:  BRA    241A
.................... 	output_low(RS485_DE); 
0241E:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02420:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
....................  
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02422:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(DEBUG) ) { 
.................... 				fputc(fgetc(DEBUG),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
02424:  MOVLB  1
02426:  BTFSS  xAE.2
02428:  BRA    2432
.................... 			periodic_millisecond(); 
0242A:  MOVLB  0
0242C:  GOTO   0E7A
02430:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02432:  BTFSS  xAE.0
02434:  BRA    243E
.................... 			timers.now_adc_sample=0; 
02436:  BCF    xAE.0
.................... 			adc_update(); 
02438:  MOVLB  0
0243A:  CALL   0D4C
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
0243E:  MOVLB  0
02440:  BRA    1F90
.................... //		} 
....................  
.................... 	} 
02442:  MOVLB  2
02444:  BRA    2422
.................... } 
02446:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
