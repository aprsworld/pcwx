CCS PCH C Compiler, Version 4.135, 4375               20-Mar-16 09:50

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 13106 bytes (20%)
                         Largest free fragment is 52426
               RAM used: 2302 (59%) at main() level
                         2580 (66%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   30CA
*
00008:  GOTO   00E2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03BC
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0748
0007C:  BTFSS  F9D.4
0007E:  GOTO   0088
00082:  BTFSC  F9E.4
00084:  GOTO   06D2
00088:  BTFSS  FA3.5
0008A:  GOTO   0094
0008E:  BTFSC  FA4.5
00090:  GOTO   064A
00094:  MOVFF  0E,00
00098:  MOVFF  0F,01
0009C:  MOVFF  10,02
000A0:  MOVFF  11,03
000A4:  MOVFF  0C,FE9
000A8:  MOVFF  07,FEA
000AC:  BSF    07.7
000AE:  MOVFF  08,FE1
000B2:  MOVFF  09,FE2
000B6:  MOVFF  0A,FD9
000BA:  MOVFF  0B,FDA
000BE:  MOVFF  12,FF3
000C2:  MOVFF  13,FF4
000C6:  MOVFF  14,FFA
000CA:  MOVFF  15,FF5
000CE:  MOVFF  16,FF6
000D2:  MOVFF  17,FF7
000D6:  MOVF   04,W
000D8:  MOVFF  06,FE0
000DC:  MOVFF  05,FD8
000E0:  RETFIE 0
000E2:  MOVWF  1A
000E4:  MOVFF  FD8,1B
000E8:  MOVFF  FE0,1C
000EC:  MOVLB  0
000EE:  MOVFF  FE9,22
000F2:  MOVFF  FEA,1D
000F6:  MOVFF  FE1,1E
000FA:  MOVFF  FE2,1F
000FE:  MOVFF  FD9,20
00102:  MOVFF  FDA,21
00106:  MOVFF  FF3,28
0010A:  MOVFF  FF4,29
0010E:  MOVFF  FFA,2A
00112:  MOVFF  FF5,2B
00116:  MOVFF  FF6,2C
0011A:  MOVFF  FF7,2D
0011E:  MOVFF  00,24
00122:  MOVFF  01,25
00126:  MOVFF  02,26
0012A:  MOVFF  03,27
0012E:  BTFSS  F9D.1
00130:  GOTO   013A
00134:  BTFSC  F9E.1
00136:  GOTO   03EE
0013A:  MOVFF  24,00
0013E:  MOVFF  25,01
00142:  MOVFF  26,02
00146:  MOVFF  27,03
0014A:  MOVFF  22,FE9
0014E:  MOVFF  1D,FEA
00152:  BSF    1D.7
00154:  MOVFF  1E,FE1
00158:  MOVFF  1F,FE2
0015C:  MOVFF  20,FD9
00160:  MOVFF  21,FDA
00164:  MOVFF  28,FF3
00168:  MOVFF  29,FF4
0016C:  MOVFF  2A,FFA
00170:  MOVFF  2B,FF5
00174:  MOVFF  2C,FF6
00178:  MOVFF  2D,FF7
0017C:  MOVF   1A,W
0017E:  MOVFF  1C,FE0
00182:  MOVFF  1B,FD8
00186:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02E08:  MOVLB  A
02E0A:  MOVF   x08,F
02E0C:  BNZ   2E12
02E0E:  MOVF   x09,F
02E10:  BZ    2E96
....................       if (*s1 != *s2) 
02E12:  MOVFF  A04,FE9
02E16:  MOVFF  A05,FEA
02E1A:  MOVFF  FEF,A0A
02E1E:  MOVFF  A07,03
02E22:  MOVFF  A06,FE9
02E26:  MOVFF  A07,FEA
02E2A:  MOVF   FEF,W
02E2C:  SUBWF  x0A,W
02E2E:  BZ    2E5E
....................          return((*s1 <*s2) ? -1: 1); 
02E30:  MOVFF  A05,03
02E34:  MOVFF  A04,FE9
02E38:  MOVFF  A05,FEA
02E3C:  MOVFF  FEF,A0A
02E40:  MOVFF  A07,03
02E44:  MOVFF  A06,FE9
02E48:  MOVFF  A07,FEA
02E4C:  MOVF   FEF,W
02E4E:  SUBWF  x0A,W
02E50:  BC    2E56
02E52:  MOVLW  FF
02E54:  BRA    2E58
02E56:  MOVLW  01
02E58:  MOVWF  01
02E5A:  BRA    2E9A
....................       else if (*s1 == '\0') 
02E5C:  BRA    2E74
02E5E:  MOVFF  A05,03
02E62:  MOVFF  A04,FE9
02E66:  MOVFF  A05,FEA
02E6A:  MOVF   FEF,F
02E6C:  BNZ   2E74
....................          return(0); 
02E6E:  MOVLW  00
02E70:  MOVWF  01
02E72:  BRA    2E9A
02E74:  MOVFF  A05,03
02E78:  MOVF   x04,W
02E7A:  INCF   x04,F
02E7C:  BTFSC  FD8.2
02E7E:  INCF   x05,F
02E80:  MOVFF  A07,03
02E84:  MOVF   x06,W
02E86:  INCF   x06,F
02E88:  BTFSC  FD8.2
02E8A:  INCF   x07,F
02E8C:  MOVF   x08,W
02E8E:  BTFSC  FD8.2
02E90:  DECF   x09,F
02E92:  DECF   x08,F
02E94:  BRA    2E0A
....................    return(0); 
02E96:  MOVLW  00
02E98:  MOVWF  01
.................... } 
02E9A:  MOVLB  0
02E9C:  GOTO   301A (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
011DC:  MOVLW  05
011DE:  MOVLB  9
011E0:  SUBWF  x07,F
011E2:  BNC   11F8
011E4:  MOVLW  09
011E6:  MOVWF  FEA
011E8:  MOVLW  07
011EA:  MOVWF  FE9
011EC:  MOVF   FEF,W
011EE:  BZ    11F8
011F0:  BRA    11F4
011F2:  CLRWDT
011F4:  DECFSZ FEF,F
011F6:  BRA    11F2
011F8:  MOVLB  0
011FA:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
006CA:  BTFSS  F9E.4
006CC:  BRA    06CA
006CE:  MOVWF  FAD
006D0:  RETURN 0
*
00706:  BTFSS  F9E.5
00708:  BRA    0706
0070A:  MOVFF  FAB,35
0070E:  MOVFF  FAE,01
00712:  BTFSS  35.1
00714:  BRA    071A
00716:  BCF    FAB.4
00718:  BSF    FAB.4
0071A:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00632:  BTFSS  FA4.5
00634:  BRA    0632
00636:  MOVFF  F71,35
0063A:  MOVFF  F74,01
0063E:  BTFSS  35.1
00640:  BRA    0646
00642:  BCF    F71.4
00644:  BSF    F71.4
00646:  GOTO   064C (RETURN)
*
011FC:  BTFSS  FA4.4
011FE:  BRA    11FC
01200:  MOVWF  F73
01202:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... 	int8 pic_to_pi_latch_mask; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
....................  
.................... 	/* push button / magnetic switch on board */ 
.................... 	int8 button_state; 
....................  
.................... 	/* push button / magnetic switch on board */ 
.................... 	int8 latch_sw_magnet; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
....................  
.................... 	/* transmit buffer for PIC to PI */ 
.................... 	int8 rda_tx_buff[256]; 
.................... 	int8 rda_tx_length; 
.................... 	int8 rda_tx_pos; 
.................... 	int1 now_rda_tx_ready; 
.................... 	int1 now_rda_tx_done; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][NMEA_SENTENCE_LENGTH]; 
.................... 	int16 sentence_age[N_NMEA0183_SENTENCES]; 
.................... 	int8 sentence_length[N_NMEA0183_SENTENCES]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00EC8:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00E28:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00E2A:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00E2C:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00E2E:  MOVLB  9
00E30:  MOVF   x01,F
00E32:  BNZ   0E3A
.................... 		c=0b00011; 
00E34:  MOVLW  03
00E36:  MOVWF  x05
.................... 	else if ( 1 == ch )  
00E38:  BRA    0E84
00E3A:  DECFSZ x01,W
00E3C:  BRA    0E44
.................... 		c=0b10011; 
00E3E:  MOVLW  13
00E40:  MOVWF  x05
.................... 	else if ( 2 == ch )  
00E42:  BRA    0E84
00E44:  MOVF   x01,W
00E46:  SUBLW  02
00E48:  BNZ   0E50
.................... 		c=0b01011; 
00E4A:  MOVLW  0B
00E4C:  MOVWF  x05
.................... 	else if ( 3 == ch )  
00E4E:  BRA    0E84
00E50:  MOVF   x01,W
00E52:  SUBLW  03
00E54:  BNZ   0E5C
.................... 		c=0b11011; 
00E56:  MOVLW  1B
00E58:  MOVWF  x05
.................... 	else if ( 4 == ch ) 
00E5A:  BRA    0E84
00E5C:  MOVF   x01,W
00E5E:  SUBLW  04
00E60:  BNZ   0E68
.................... 		c=0b00111; 
00E62:  MOVLW  07
00E64:  MOVWF  x05
.................... 	else if ( 5 == ch )  
00E66:  BRA    0E84
00E68:  MOVF   x01,W
00E6A:  SUBLW  05
00E6C:  BNZ   0E74
.................... 		c=0b10111; 
00E6E:  MOVLW  17
00E70:  MOVWF  x05
.................... 	else if ( 6 == ch ) 
00E72:  BRA    0E84
00E74:  MOVF   x01,W
00E76:  SUBLW  06
00E78:  BNZ   0E80
.................... 		c=0b01111; 
00E7A:  MOVLW  0F
00E7C:  MOVWF  x05
.................... 	else 
00E7E:  BRA    0E84
.................... 		c=0b11111; 
00E80:  MOVLW  1F
00E82:  MOVWF  x05
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00E84:  CLRF   x04
00E86:  MOVF   x04,W
00E88:  SUBLW  04
00E8A:  BNC   0EA2
.................... 		output_low(MCP3208_CLK); 
00E8C:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00E8E:  BTFSC  x05.0
00E90:  BRA    0E96
00E92:  BCF    F8B.5
00E94:  BRA    0E98
00E96:  BSF    F8B.5
.................... 		c=c>>1; 
00E98:  BCF    FD8.0
00E9A:  RRCF   x05,F
.................... 		output_high(MCP3208_CLK); 
00E9C:  BSF    F8B.3
.................... 	} 
00E9E:  INCF   x04,F
00EA0:  BRA    0E86
....................  
....................  
.................... 	value=0; 
00EA2:  CLRF   x03
00EA4:  CLRF   x02
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00EA6:  CLRF   x04
00EA8:  MOVF   x04,W
00EAA:  SUBLW  0D
00EAC:  BNC   0EC4
.................... 		output_low(MCP3208_CLK); 
00EAE:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00EB0:  BTFSC  F82.4
00EB2:  BRA    0EB8
00EB4:  BCF    FD8.0
00EB6:  BRA    0EBA
00EB8:  BSF    FD8.0
00EBA:  RLCF   x02,F
00EBC:  RLCF   x03,F
.................... 		output_high(MCP3208_CLK); 
00EBE:  BSF    F8B.3
.................... 	} 
00EC0:  INCF   x04,F
00EC2:  BRA    0EA8
....................  
.................... 	bit_clear(value,13); 
00EC4:  BCF    x03.5
.................... 	bit_clear(value,12); 
00EC6:  BCF    x03.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00ECA:  MOVFF  902,01
00ECE:  MOVFF  903,02
.................... } 
00ED2:  MOVLB  0
00ED4:  GOTO   0F4A (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
01410:  MOVLB  A
01412:  CLRF   x03
01414:  MOVFF  918,A02
01418:  CLRF   x05
0141A:  MOVLW  20
0141C:  MOVWF  x04
0141E:  MOVLB  0
01420:  CALL   0878
01424:  MOVFF  02,03
01428:  MOVF   01,W
0142A:  ADDLW  CC
0142C:  MOVWF  01
0142E:  MOVLW  00
01430:  ADDWFC 03,F
01432:  MOVFF  01,91C
01436:  MOVLB  9
01438:  MOVFF  03,91D
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
0143C:  CLRF   x1A
0143E:  CLRF   x19
.................... 	for( i = 0; i < 16 ; i++ ) { 
01440:  CLRF   x1B
01442:  MOVF   x1B,W
01444:  SUBLW  0F
01446:  BNC   146A
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
01448:  BCF    FD8.0
0144A:  RLCF   x1B,W
0144C:  CLRF   03
0144E:  ADDWF  x1C,W
01450:  MOVWF  FE9
01452:  MOVF   x1D,W
01454:  ADDWFC 03,W
01456:  MOVWF  FEA
01458:  MOVFF  FEC,03
0145C:  MOVF   FED,F
0145E:  MOVF   FEF,W
01460:  ADDWF  x19,F
01462:  MOVF   03,W
01464:  ADDWFC x1A,F
.................... 	} 
01466:  INCF   x1B,F
01468:  BRA    1442
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
0146A:  MOVLW  08
0146C:  ADDWF  x19,W
0146E:  MOVWF  x1E
01470:  MOVLW  00
01472:  ADDWFC x1A,W
01474:  MOVWF  x1F
01476:  RRCF   x1F,W
01478:  MOVWF  03
0147A:  RRCF   x1E,W
0147C:  MOVWF  02
0147E:  RRCF   03,F
01480:  RRCF   02,F
01482:  RRCF   03,F
01484:  RRCF   02,F
01486:  RRCF   03,F
01488:  RRCF   02,F
0148A:  MOVLW  0F
0148C:  ANDWF  03,F
0148E:  MOVFF  02,01
01492:  MOVFF  03,02
.................... } 
01496:  MOVLB  0
01498:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00ED8:  MOVLB  1
00EDA:  INCF   xCC,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00EDC:  MOVF   xCC,W
00EDE:  SUBLW  0F
00EE0:  BC    0EE4
.................... 		current.adc_buffer_index=0; 
00EE2:  CLRF   xCC
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00EE4:  MOVLB  8
00EE6:  CLRF   xFE
00EE8:  MOVF   xFE,W
00EEA:  SUBLW  07
00EEC:  BNC   0F80
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00EEE:  MOVLB  A
00EF0:  CLRF   x03
00EF2:  MOVFF  8FE,A02
00EF6:  CLRF   x05
00EF8:  MOVLW  20
00EFA:  MOVWF  x04
00EFC:  MOVLB  0
00EFE:  RCALL  0878
00F00:  MOVFF  02,03
00F04:  MOVF   01,W
00F06:  ADDLW  34
00F08:  MOVLB  8
00F0A:  MOVWF  xFF
00F0C:  MOVLW  00
00F0E:  ADDWFC 02,W
00F10:  MOVLB  9
00F12:  MOVWF  x00
00F14:  CLRF   03
00F16:  MOVLB  1
00F18:  MOVFF  1CC,02
00F1C:  BCF    FD8.0
00F1E:  RLCF   02,F
00F20:  RLCF   03,F
00F22:  MOVF   02,W
00F24:  MOVLB  8
00F26:  ADDWF  xFF,W
00F28:  MOVWF  01
00F2A:  MOVLB  9
00F2C:  MOVF   x00,W
00F2E:  ADDWFC 03,F
00F30:  MOVF   01,W
00F32:  ADDLW  98
00F34:  MOVWF  01
00F36:  MOVLW  00
00F38:  ADDWFC 03,F
00F3A:  MOVFF  01,8FF
00F3E:  MOVFF  03,900
00F42:  MOVFF  8FE,901
00F46:  MOVLB  0
00F48:  BRA    0E28
00F4A:  MOVFF  900,FEA
00F4E:  MOVFF  8FF,FE9
00F52:  MOVFF  02,FEC
00F56:  MOVF   FED,F
00F58:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00F5C:  CLRF   03
00F5E:  MOVLB  8
00F60:  MOVFF  8FE,02
00F64:  BCF    FD8.0
00F66:  RLCF   02,F
00F68:  RLCF   03,F
00F6A:  MOVF   02,W
00F6C:  ADDLW  BC
00F6E:  MOVWF  FE9
00F70:  MOVLW  00
00F72:  ADDWFC 03,W
00F74:  MOVWF  FEA
00F76:  CLRF   FEC
00F78:  MOVF   FED,F
00F7A:  CLRF   FEF
....................  
.................... 	} 
00F7C:  INCF   xFE,F
00F7E:  BRA    0EE8
.................... } 
00F80:  MOVLB  0
00F82:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00BCE:  MOVF   x1D,W
00BD0:  XORWF  x1E,W
00BD2:  MOVWF  01
*
00C20:  MOVF   x1D,W
00C22:  XORWF  x1E,W
00C24:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00B58:  MOVLB  9
00B5A:  CLRF   x07
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B5C:  MOVFF  906,03
00B60:  MOVF   x05,W
00B62:  BTFSC  FD8.2
00B64:  DECF   x06,F
00B66:  DECF   x05,F
00B68:  MOVWF  x08
00B6A:  MOVFF  03,909
00B6E:  MOVF   x08,F
00B70:  BNZ   0B76
00B72:  MOVF   x09,F
00B74:  BZ    0BE0
.................... 		*data = read_eeprom( address++ ); 
00B76:  MOVFF  904,03
00B7A:  MOVF   x03,W
00B7C:  MOVWF  FE9
00B7E:  MOVFF  03,FEA
00B82:  MOVF   x02,W
00B84:  MOVWF  03
00B86:  MOVF   x01,W
00B88:  INCF   x01,F
00B8A:  BTFSC  FD8.2
00B8C:  INCF   x02,F
00B8E:  MOVWF  x0A
00B90:  MOVFF  03,90B
00B94:  MOVFF  FF2,90C
00B98:  BCF    FF2.6
00B9A:  BCF    FF2.7
00B9C:  MOVFF  90B,FAA
00BA0:  MOVFF  90A,FA9
00BA4:  BCF    FA6.6
00BA6:  BCF    FA6.7
00BA8:  BSF    FA6.0
00BAA:  MOVF   FA8,W
00BAC:  BTFSC  x0C.6
00BAE:  BSF    FF2.6
00BB0:  BTFSC  x0C.7
00BB2:  BSF    FF2.7
00BB4:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00BB6:  MOVFF  904,03
00BBA:  MOVF   x03,W
00BBC:  MOVWF  FE9
00BBE:  MOVFF  03,FEA
00BC2:  MOVFF  FEF,908
00BC6:  MOVFF  907,91D
00BCA:  MOVFF  908,91E
*
00BD4:  MOVFF  01,907
.................... 		data++; 
00BD8:  INCF   x03,F
00BDA:  BTFSC  FD8.2
00BDC:  INCF   x04,F
.................... 	} 
00BDE:  BRA    0B5C
.................... 	return crc; 
00BE0:  MOVFF  907,01
.................... } 
00BE4:  MOVLB  0
00BE6:  GOTO   0D5A (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00BEA:  MOVLB  9
00BEC:  CLRF   x1B
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BEE:  MOVFF  91A,03
00BF2:  MOVF   x19,W
00BF4:  BTFSC  FD8.2
00BF6:  DECF   x1A,F
00BF8:  DECF   x19,F
00BFA:  MOVWF  x1C
00BFC:  MOVFF  03,91D
00C00:  MOVF   x1C,F
00C02:  BNZ   0C08
00C04:  MOVF   x1D,F
00C06:  BZ    0C86
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00C08:  MOVFF  918,03
00C0C:  MOVF   x17,W
00C0E:  MOVWF  FE9
00C10:  MOVFF  03,FEA
00C14:  MOVFF  FEF,91C
00C18:  MOVFF  91B,91D
00C1C:  MOVFF  91C,91E
*
00C26:  MOVFF  01,91B
.................... 		write_eeprom( address++, *data++ ); 
00C2A:  MOVF   x16,W
00C2C:  MOVWF  03
00C2E:  MOVF   x15,W
00C30:  INCF   x15,F
00C32:  BTFSC  FD8.2
00C34:  INCF   x16,F
00C36:  MOVWF  x1C
00C38:  MOVFF  03,91D
00C3C:  MOVF   x18,W
00C3E:  MOVWF  03
00C40:  MOVF   x17,W
00C42:  INCF   x17,F
00C44:  BTFSC  FD8.2
00C46:  INCF   x18,F
00C48:  MOVWF  FE9
00C4A:  MOVFF  03,FEA
00C4E:  MOVFF  FEF,91E
00C52:  MOVFF  91D,FAA
00C56:  MOVFF  91C,FA9
00C5A:  MOVFF  91E,FA8
00C5E:  BCF    FA6.6
00C60:  BCF    FA6.7
00C62:  BSF    FA6.2
00C64:  MOVF   FF2,W
00C66:  MOVWF  00
00C68:  BCF    FF2.6
00C6A:  BCF    FF2.7
00C6C:  MOVLB  F
00C6E:  MOVLW  55
00C70:  MOVWF  FA7
00C72:  MOVLW  AA
00C74:  MOVWF  FA7
00C76:  BSF    FA6.1
00C78:  BTFSC  FA6.1
00C7A:  BRA    0C78
00C7C:  BCF    FA6.2
00C7E:  MOVF   00,W
00C80:  IORWF  FF2,F
.................... 	} 
00C82:  MOVLB  9
00C84:  BRA    0BEE
....................  
.................... 	return crc; 
00C86:  MOVFF  91B,01
.................... } 
00C8A:  MOVLB  0
00C8C:  GOTO   0CB0 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00C90:  MOVLB  9
00C92:  CLRF   x14
00C94:  MOVLW  36
00C96:  MOVWF  x13
00C98:  CLRF   x16
00C9A:  MOVLW  02
00C9C:  MOVWF  x15
00C9E:  MOVFF  914,918
00CA2:  MOVFF  913,917
00CA6:  CLRF   x1A
00CA8:  MOVLW  62
00CAA:  MOVWF  x19
00CAC:  MOVLB  0
00CAE:  BRA    0BEA
00CB0:  MOVFF  01,912
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00CB4:  CLRF   FAA
00CB6:  CLRF   FA9
00CB8:  MOVFF  912,FA8
00CBC:  BCF    FA6.6
00CBE:  BCF    FA6.7
00CC0:  BSF    FA6.2
00CC2:  MOVF   FF2,W
00CC4:  MOVWF  00
00CC6:  BCF    FF2.6
00CC8:  BCF    FF2.7
00CCA:  MOVLB  F
00CCC:  MOVLW  55
00CCE:  MOVWF  FA7
00CD0:  MOVLW  AA
00CD2:  MOVWF  FA7
00CD4:  BSF    FA6.1
00CD6:  BTFSC  FA6.1
00CD8:  BRA    0CD6
00CDA:  BCF    FA6.2
00CDC:  MOVF   00,W
00CDE:  IORWF  FF2,F
.................... } 
00CE0:  MOVLB  0
00CE2:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00CE4:  MOVLW  96
00CE6:  MOVLB  1
00CE8:  MOVWF  xFA
....................  
.................... 	config.modbus_address=38; 
00CEA:  MOVLW  26
00CEC:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00CEE:  MOVLW  03
00CF0:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00CF2:  MOVLW  02
00CF4:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00CF6:  MOVLW  50
00CF8:  MOVWF  3A
.................... 	config.serial_number=9876; 
00CFA:  MOVLW  26
00CFC:  MOVWF  3C
00CFE:  MOVLW  94
00D00:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00D02:  CLRF   3E
00D04:  MOVLW  14
00D06:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00D08:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00D0A:  MOVLW  02
00D0C:  MOVWF  41
00D0E:  MOVLW  76
00D10:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00D12:  CLRF   43
00D14:  MOVLW  02
00D16:  MOVWF  42
.................... 	config.power_startup=0; 
00D18:  CLRF   44
.................... 	config.pic_to_pi_latch_mask=1;  
00D1A:  MOVLW  01
00D1C:  MOVWF  4F
....................  
.................... 	/* set NMEA0183 sentence character array to all '*' */ 
.................... 	memset(config.nmea0183_sentence,'*',sizeof(config.nmea0183_sentence)); 
00D1E:  CLRF   FEA
00D20:  MOVLW  50
00D22:  MOVWF  FE9
00D24:  MOVLW  2A
00D26:  MOVWF  00
00D28:  CLRF   02
00D2A:  MOVLW  48
00D2C:  MOVWF  01
00D2E:  MOVLB  0
00D30:  RCALL  089A
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00D32:  RCALL  0C90
....................  
.................... } 
00D34:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00D36:  MOVLB  9
00D38:  CLRF   x00
00D3A:  MOVLW  36
00D3C:  MOVLB  8
00D3E:  MOVWF  xFF
00D40:  MOVLB  9
00D42:  CLRF   x02
00D44:  MOVLW  02
00D46:  MOVWF  x01
00D48:  MOVFF  900,904
00D4C:  MOVFF  8FF,903
00D50:  CLRF   x06
00D52:  MOVLW  62
00D54:  MOVWF  x05
00D56:  MOVLB  0
00D58:  BRA    0B58
00D5A:  MOVFF  01,8FE
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00D5E:  MOVFF  FF2,8FF
00D62:  BCF    FF2.6
00D64:  BCF    FF2.7
00D66:  CLRF   FAA
00D68:  CLRF   FA9
00D6A:  BCF    FA6.6
00D6C:  BCF    FA6.7
00D6E:  BSF    FA6.0
00D70:  MOVF   FA8,W
00D72:  MOVLB  8
00D74:  BTFSC  xFF.6
00D76:  BSF    FF2.6
00D78:  BTFSC  xFF.7
00D7A:  BSF    FF2.7
00D7C:  SUBWF  xFE,W
00D7E:  BZ    0D86
.................... 		write_default_param_file(); 
00D80:  MOVLB  0
00D82:  RCALL  0CE4
00D84:  MOVLB  8
.................... 	} 
.................... } 
00D86:  MOVLB  0
00D88:  GOTO   326C (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
.................... } 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00E0E:  BTFSS  F9E.5
00E10:  BRA    0E16
.................... 		fgetc(STREAM_PI); 
00E12:  RCALL  0706
.................... 	} 
00E14:  BRA    0E0E
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00E16:  BSF    F9D.5
.................... } 
00E18:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00E1A:  RCALL  0E0E
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_8 | T0_8_BIT); /* 0.683 ms @ 12 MHz. Use fosc/4 not fosc */ 
00E1C:  MOVLW  C2
00E1E:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00E20:  MOVLW  C0
00E22:  IORWF  FF2,F
.................... } 
00E24:  GOTO   3282 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003A8:  BCF    FF2.5
.................... 	if (enable) { 
003AA:  MOVLB  A
003AC:  MOVF   x11,F
003AE:  BZ    03B8
.................... 		set_timer0(0); 
003B0:  CLRF   FD7
003B2:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003B4:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003B6:  BSF    FF2.5
.................... 	} 
.................... } 
003B8:  MOVLB  0
003BA:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003BC:  MOVLB  7
003BE:  MOVF   xEB,W
003C0:  SUBLW  02
003C2:  BNZ   03D8
003C4:  MOVF   xEC,F
003C6:  BNZ   03D8
003C8:  MOVF   xED,F
003CA:  BNZ   03D8
003CC:  BTFSC  xEA.0
003CE:  BRA    03D8
....................    { 
....................       modbus_rx.len-=2; 
003D0:  MOVLW  02
003D2:  SUBWF  xEF,F
....................       modbus_serial_new=TRUE; 
003D4:  BSF    xEA.0
....................    } 
....................    else 
003D6:  BRA    03DA
....................       modbus_serial_new=FALSE; 
003D8:  BCF    xEA.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003DA:  SETF   xED
003DC:  SETF   xEC
....................    modbus_serial_state=MODBUS_GETADDY; 
003DE:  CLRF   xEB
....................    modbus_enable_timeout(FALSE); 
003E0:  MOVLB  A
003E2:  CLRF   x11
003E4:  MOVLB  0
003E6:  RCALL  03A8
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003E8:  BCF    FF2.2
003EA:  GOTO   0094
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
0071C:  MOVLB  7
0071E:  MOVF   xED,W
00720:  MOVLB  A
00722:  XORWF  x11,W
00724:  MOVWF  x12
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00726:  CLRF   03
00728:  MOVF   x12,W
0072A:  MOVLB  0
0072C:  RCALL  0188
0072E:  MOVWF  01
00730:  MOVLB  7
00732:  MOVF   xEC,W
00734:  XORWF  01,W
00736:  MOVWF  xED
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00738:  CLRF   03
0073A:  MOVLB  A
0073C:  MOVF   x12,W
0073E:  MOVLB  0
00740:  RCALL  0298
00742:  MOVFF  FE8,7EC
.................... } 
00746:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	timers.rda_tx_buff[timers.rda_tx_length]=c; 
*
01316:  MOVLW  03
01318:  MOVLB  4
0131A:  ADDWF  x03,W
0131C:  MOVWF  FE9
0131E:  MOVLW  03
01320:  MOVWF  FEA
01322:  BTFSC  FD8.0
01324:  INCF   FEA,F
01326:  MOVFF  912,FEF
.................... 	timers.rda_tx_length++; 
0132A:  INCF   x03,F
0132C:  CLRF   19
0132E:  BTFSC  FF2.6
01330:  BSF    19.6
01332:  BCF    FF2.6
01334:  BTFSC  FF2.7
01336:  BSF    19.7
01338:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
0133A:  MOVFF  912,A11
0133E:  MOVLB  0
01340:  CALL   071C
01344:  BTFSC  19.6
01346:  BSF    FF2.6
01348:  BTFSC  19.7
0134A:  BSF    FF2.7
.................... } 
0134C:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) { 
.................... 	/* reset out transmit buffer */ 
.................... 	timers.rda_tx_length=0; 
0134E:  MOVLB  4
01350:  CLRF   x03
.................... 	timers.rda_tx_pos=0; 
01352:  CLRF   x04
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01354:  MOVLB  7
01356:  SETF   xED
01358:  SETF   xEC
.................... 	modbus_serial_new=FALSE; 
0135A:  BCF    xEA.0
....................  
.................... 	modbus_serial_putc(to); 
0135C:  MOVFF  910,912
01360:  MOVLB  0
01362:  RCALL  1316
.................... 	modbus_serial_putc(func); 
01364:  MOVFF  911,912
01368:  RCALL  1316
.................... } 
0136A:  RETURN 0
....................  
.................... void modbus_serial_send_stop() { 
.................... 	int8 crc_low, crc_high; 
....................  
.................... 	crc_high=modbus_serial_crc.b[1]; 
0136C:  MOVFF  7ED,911
.................... 	crc_low=modbus_serial_crc.b[0]; 
01370:  MOVFF  7EC,910
....................  
.................... 	modbus_serial_putc(crc_high); 
01374:  MOVFF  911,912
01378:  RCALL  1316
.................... 	modbus_serial_putc(crc_low); 
0137A:  MOVFF  910,912
0137E:  RCALL  1316
....................  
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01380:  MOVLB  7
01382:  SETF   xED
01384:  SETF   xEC
....................  
.................... 	/* ready to transmit from buffer flag set. Elsewhere we start sending */ 
.................... 	timers.now_rda_tx_ready=1; 
01386:  MOVLB  4
01388:  BSF    x05.0
.................... } 
0138A:  MOVLB  0
0138C:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
011B6:  MOVLB  7
011B8:  BTFSC  xEA.0
011BA:  BRA    11C4
....................       return FALSE; 
011BC:  MOVLW  00
011BE:  MOVWF  01
011C0:  BRA    11D6
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
011C2:  BRA    11D0
011C4:  BTFSS  xF0.7
011C6:  BRA    11D0
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
011C8:  MOVFF  7F2,7F1
....................       modbus_rx.len = 1; 
011CC:  MOVLW  01
011CE:  MOVWF  xEF
....................    } 
....................    modbus_serial_new=FALSE; 
011D0:  BCF    xEA.0
....................    return TRUE; 
011D2:  MOVLW  01
011D4:  MOVWF  01
.................... } 
011D6:  MOVLB  0
011D8:  GOTO   2B0A (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02A76:  MOVFF  908,910
02A7A:  MOVLW  06
02A7C:  MOVLB  9
02A7E:  MOVWF  x11
02A80:  MOVLB  0
02A82:  CALL   134E
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02A86:  MOVFF  90A,90D
02A8A:  MOVFF  90A,912
02A8E:  CALL   1316
....................    modbus_serial_putc(make8(reg_address,0)); 
02A92:  MOVFF  909,90D
02A96:  MOVFF  909,912
02A9A:  CALL   1316
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02A9E:  MOVFF  90C,90D
02AA2:  MOVFF  90C,912
02AA6:  CALL   1316
....................    modbus_serial_putc(make8(reg_value,0)); 
02AAA:  MOVFF  90B,90D
02AAE:  MOVFF  90B,912
02AB2:  CALL   1316
....................  
....................    modbus_serial_send_stop(); 
02AB6:  CALL   136C
.................... } 
02ABA:  GOTO   2CF6 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02ABE:  MOVFF  906,910
02AC2:  MOVLW  10
02AC4:  MOVLB  9
02AC6:  MOVWF  x11
02AC8:  MOVLB  0
02ACA:  CALL   134E
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02ACE:  MOVFF  908,90B
02AD2:  MOVFF  908,912
02AD6:  CALL   1316
....................    modbus_serial_putc(make8(start_address,0)); 
02ADA:  MOVFF  907,90B
02ADE:  MOVFF  907,912
02AE2:  CALL   1316
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02AE6:  MOVFF  90A,90B
02AEA:  MOVFF  90A,912
02AEE:  CALL   1316
....................    modbus_serial_putc(make8(quantity,0)); 
02AF2:  MOVFF  909,90B
02AF6:  MOVFF  909,912
02AFA:  CALL   1316
....................  
....................    modbus_serial_send_stop(); 
02AFE:  CALL   136C
.................... } 
02B02:  GOTO   2DC0 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0138E:  MOVLB  9
01390:  MOVF   x07,W
01392:  IORLW  80
01394:  MOVWF  x0A
01396:  MOVFF  908,90B
0139A:  MOVFF  906,910
0139E:  MOVWF  x11
013A0:  MOVLB  0
013A2:  RCALL  134E
....................    modbus_serial_putc(error); 
013A4:  MOVFF  909,912
013A8:  RCALL  1316
....................    modbus_serial_send_stop(); 
013AA:  RCALL  136C
.................... } 
013AC:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          55 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1014 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
.................... #define MIN_NMEA0183_META_REGISTER   6500 
.................... #define MAX_NMEA0183_META_REGISTER   MIN_NMEA0183_META_REGISTER + N_NMEA0183_SENTENCES*2 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
014FE:  MOVLB  1
01500:  CLRF   xCE
01502:  CLRF   xCD
.................... 	current.modbus_other_packets=0; 
01504:  CLRF   xD0
01506:  CLRF   xCF
.................... 	current.modbus_last_error=0; 
01508:  CLRF   xD2
0150A:  CLRF   xD1
.................... } 
0150C:  MOVLB  0
0150E:  GOTO   226A (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0149A:  BCF    FF2.6
0149C:  BCF    FF2.7
0149E:  BTFSC  FF2.7
014A0:  BRA    149C
....................  
.................... 	current.pulse_count[0]=0; 
014A2:  CLRF   xAB
014A4:  CLRF   xAA
.................... 	current.pulse_count[1]=0; 
014A6:  CLRF   xAD
014A8:  CLRF   xAC
.................... 	current.pulse_count[2]=0; 
014AA:  CLRF   xAF
014AC:  CLRF   xAE
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
014AE:  SETF   x9F
014B0:  SETF   x9E
.................... 	current.pulse_min_period[1]=65535; 
014B2:  SETF   xA1
014B4:  SETF   xA0
.................... 	current.pulse_min_period[2]=65535; 
014B6:  SETF   xA3
014B8:  SETF   xA2
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
014BA:  CLRF   xA5
014BC:  CLRF   xA4
.................... 	current.pulse_max_period[1]=0; 
014BE:  CLRF   xA7
014C0:  CLRF   xA6
.................... 	current.pulse_max_period[2]=0; 
014C2:  CLRF   xA9
014C4:  CLRF   xA8
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
014C6:  MOVLB  1
014C8:  CLRF   xD8
014CA:  CLRF   xD7
....................  
.................... 	enable_interrupts(GLOBAL); 
014CC:  MOVLW  C0
014CE:  IORWF  FF2,F
.................... } 
014D0:  MOVLB  0
014D2:  GOTO   221A (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
014D6:  BCF    FF2.6
014D8:  BCF    FF2.7
014DA:  BTFSC  FF2.7
014DC:  BRA    14D8
.................... 	current.pulse_sum[0]=0; 
014DE:  CLRF   xB3
014E0:  CLRF   xB2
014E2:  CLRF   xB1
014E4:  CLRF   xB0
.................... 	current.pulse_sum[1]=0; 
014E6:  CLRF   xB7
014E8:  CLRF   xB6
014EA:  CLRF   xB5
014EC:  CLRF   xB4
.................... 	current.pulse_sum[2]=0; 
014EE:  CLRF   xBB
014F0:  CLRF   xBA
014F2:  CLRF   xB9
014F4:  CLRF   xB8
.................... 	enable_interrupts(GLOBAL); 
014F6:  MOVLW  C0
014F8:  IORWF  FF2,F
.................... } 
014FA:  GOTO   222A (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
013AE:  BCF    FF2.6
013B0:  BCF    FF2.7
013B2:  BTFSC  FF2.7
013B4:  BRA    13B0
.................... 	l=current.pulse_sum[ch]; 
013B6:  MOVLB  A
013B8:  CLRF   x03
013BA:  MOVFF  918,A02
013BE:  CLRF   x05
013C0:  MOVLW  04
013C2:  MOVWF  x04
013C4:  MOVLB  0
013C6:  CALL   0878
013CA:  MOVFF  02,03
013CE:  MOVF   01,W
013D0:  ADDLW  B0
013D2:  MOVWF  FE9
013D4:  MOVLW  00
013D6:  ADDWFC 02,W
013D8:  MOVWF  FEA
013DA:  MOVFF  FEF,00
013DE:  MOVFF  FEC,01
013E2:  MOVFF  FEC,02
013E6:  MOVFF  FEC,03
013EA:  MOVFF  03,91C
013EE:  MOVFF  02,91B
013F2:  MOVFF  01,91A
013F6:  MOVFF  00,919
.................... 	enable_interrupts(GLOBAL); 
013FA:  MOVLW  C0
013FC:  IORWF  FF2,F
....................  
.................... 	return l; 
013FE:  MOVFF  919,00
01402:  MOVFF  91A,01
01406:  MOVFF  91B,02
0140A:  MOVFF  91C,03
.................... } 
0140E:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01512:  MOVLB  9
01514:  MOVF   x13,W
01516:  SUBLW  06
01518:  BC    156E
0151A:  XORLW  FF
0151C:  BNZ   1524
0151E:  MOVF   x12,W
01520:  SUBLW  CF
01522:  BC    156E
01524:  MOVF   x13,W
01526:  SUBLW  09
01528:  BNC   156E
0152A:  BNZ   1532
0152C:  MOVF   x12,W
0152E:  SUBLW  CF
01530:  BNC   156E
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01532:  MOVLW  D0
01534:  SUBWF  x12,W
01536:  MOVWF  x18
01538:  MOVLW  07
0153A:  SUBWFB x13,W
0153C:  MOVWF  x19
0153E:  MOVLW  02
01540:  ADDWF  x19,F
01542:  MOVFF  FF2,91A
01546:  BCF    FF2.6
01548:  BCF    FF2.7
0154A:  MOVFF  919,FAA
0154E:  MOVFF  918,FA9
01552:  BCF    FA6.6
01554:  BCF    FA6.7
01556:  BSF    FA6.0
01558:  MOVF   FA8,W
0155A:  BTFSC  x1A.6
0155C:  BSF    FF2.6
0155E:  BTFSC  x1A.7
01560:  BSF    FF2.7
01562:  CLRF   03
01564:  MOVWF  01
01566:  MOVF   03,W
01568:  MOVWF  02
0156A:  GOTO   25AA
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
0156E:  MOVF   x13,W
01570:  SUBLW  03
01572:  BC    15F2
01574:  XORLW  FF
01576:  BNZ   157E
01578:  MOVF   x12,W
0157A:  SUBLW  4B
0157C:  BC    15F2
0157E:  MOVF   x13,W
01580:  SUBLW  04
01582:  BNC   15F2
01584:  BNZ   158C
01586:  MOVF   x12,W
01588:  SUBLW  93
0158A:  BNC   15F2
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0158C:  MOVLW  4C
0158E:  SUBWF  x12,W
01590:  MOVWF  x14
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01592:  MOVFF  914,918
01596:  MOVLW  06
01598:  MOVWF  x19
0159A:  MOVLB  0
0159C:  CALL   0AAA
015A0:  MOVFF  00,915
.................... 		n = n / 6; /* number of sentence */ 
015A4:  MOVFF  914,918
015A8:  MOVLW  06
015AA:  MOVLB  9
015AC:  MOVWF  x19
015AE:  MOVLB  0
015B0:  CALL   0AAA
015B4:  MOVFF  01,914
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
015B8:  MOVLB  9
015BA:  MOVF   x14,W
015BC:  MULLW  06
015BE:  MOVF   FF3,W
015C0:  CLRF   03
015C2:  ADDLW  1A
015C4:  MOVWF  x18
015C6:  MOVLW  00
015C8:  ADDWFC 03,W
015CA:  MOVWF  x19
015CC:  CLRF   03
015CE:  MOVF   x15,W
015D0:  ADDWF  x18,W
015D2:  MOVWF  01
015D4:  MOVF   x19,W
015D6:  ADDWFC 03,F
015D8:  MOVF   01,W
015DA:  ADDLW  36
015DC:  MOVWF  FE9
015DE:  MOVLW  00
015E0:  ADDWFC 03,W
015E2:  MOVWF  FEA
015E4:  MOVF   FEF,W
015E6:  CLRF   03
015E8:  MOVWF  01
015EA:  MOVFF  03,02
015EE:  GOTO   25AA
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
015F2:  MOVF   x13,W
015F4:  SUBLW  12
015F6:  BC    163A
015F8:  XORLW  FF
015FA:  BNZ   1602
015FC:  MOVF   x12,W
015FE:  SUBLW  87
01600:  BC    163A
01602:  MOVF   x13,W
01604:  SUBLW  17
01606:  BNC   163A
01608:  BNZ   1610
0160A:  MOVF   x12,W
0160C:  SUBLW  47
0160E:  BNC   163A
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
01610:  MOVLW  88
01612:  SUBWF  x12,F
01614:  MOVLW  13
01616:  SUBWFB x13,F
....................  
....................  		p  = nmea.sentence[0]; 
01618:  MOVLW  04
0161A:  MOVWF  x17
0161C:  MOVLW  06
0161E:  MOVWF  x16
.................... 		return (int16) p[addr]; 
01620:  MOVF   x16,W
01622:  ADDWF  x12,W
01624:  MOVWF  FE9
01626:  MOVF   x17,W
01628:  ADDWFC x13,W
0162A:  MOVWF  FEA
0162C:  MOVF   FEF,W
0162E:  CLRF   03
01630:  MOVWF  01
01632:  MOVFF  03,02
01636:  GOTO   25AA
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
0163A:  MOVF   x13,W
0163C:  SUBLW  16
0163E:  BC    16AA
01640:  XORLW  FF
01642:  BNZ   164A
01644:  MOVF   x12,W
01646:  SUBLW  6F
01648:  BC    16AA
0164A:  MOVF   x13,W
0164C:  SUBLW  19
0164E:  BNC   16AA
01650:  BNZ   1658
01652:  MOVF   x12,W
01654:  SUBLW  4F
01656:  BNC   16AA
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01658:  MOVLW  70
0165A:  SUBWF  x12,F
0165C:  MOVLW  17
0165E:  SUBWFB x13,F
.................... 		addr = addr * 2; 
01660:  BCF    FD8.0
01662:  RLCF   x12,F
01664:  RLCF   x13,F
....................  
....................  		p  = nmea.sentence[0]; 
01666:  MOVLW  04
01668:  MOVWF  x17
0166A:  MOVLW  06
0166C:  MOVWF  x16
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0166E:  MOVF   x16,W
01670:  ADDWF  x12,W
01672:  MOVWF  FE9
01674:  MOVF   x17,W
01676:  ADDWFC x13,W
01678:  MOVWF  FEA
0167A:  MOVFF  FEF,918
0167E:  MOVLW  01
01680:  ADDWF  x12,W
01682:  MOVWF  x19
01684:  MOVLW  00
01686:  ADDWFC x13,W
01688:  MOVWF  x1A
0168A:  MOVF   x16,W
0168C:  ADDWF  x19,W
0168E:  MOVWF  FE9
01690:  MOVF   x17,W
01692:  ADDWFC x1A,W
01694:  MOVWF  FEA
01696:  MOVFF  FEF,91B
0169A:  MOVFF  918,03
0169E:  MOVFF  91B,01
016A2:  MOVFF  918,02
016A6:  GOTO   25AA
.................... 	} 
....................  
....................  
.................... 	switch ( addr ) { 
016AA:  MOVF   x12,W
016AC:  MOVWF  00
016AE:  MOVF   x13,W
016B0:  MOVWF  03
016B2:  MOVF   03,W
016B4:  BNZ   16C2
016B6:  MOVF   00,F
016B8:  MOVLB  0
016BA:  BTFSC  FD8.2
016BC:  GOTO   1DB0
016C0:  MOVLB  9
016C2:  MOVF   03,W
016C4:  BNZ   16D4
016C6:  MOVLW  01
016C8:  SUBWF  00,W
016CA:  MOVLB  0
016CC:  BTFSC  FD8.2
016CE:  GOTO   1DC0
016D2:  MOVLB  9
016D4:  MOVF   03,W
016D6:  BNZ   16E6
016D8:  MOVLW  02
016DA:  SUBWF  00,W
016DC:  MOVLB  0
016DE:  BTFSC  FD8.2
016E0:  GOTO   1DD0
016E4:  MOVLB  9
016E6:  MOVF   03,W
016E8:  BNZ   16F8
016EA:  MOVLW  03
016EC:  SUBWF  00,W
016EE:  MOVLB  0
016F0:  BTFSC  FD8.2
016F2:  GOTO   1DE0
016F6:  MOVLB  9
016F8:  MOVF   03,W
016FA:  BNZ   170A
016FC:  MOVLW  04
016FE:  SUBWF  00,W
01700:  MOVLB  0
01702:  BTFSC  FD8.2
01704:  GOTO   1DF0
01708:  MOVLB  9
0170A:  MOVF   03,W
0170C:  BNZ   171C
0170E:  MOVLW  05
01710:  SUBWF  00,W
01712:  MOVLB  0
01714:  BTFSC  FD8.2
01716:  GOTO   1E1C
0171A:  MOVLB  9
0171C:  MOVF   03,W
0171E:  BNZ   172E
01720:  MOVLW  06
01722:  SUBWF  00,W
01724:  MOVLB  0
01726:  BTFSC  FD8.2
01728:  GOTO   1E2E
0172C:  MOVLB  9
0172E:  MOVF   03,W
01730:  BNZ   1740
01732:  MOVLW  07
01734:  SUBWF  00,W
01736:  MOVLB  0
01738:  BTFSC  FD8.2
0173A:  GOTO   1E3E
0173E:  MOVLB  9
01740:  MOVF   03,W
01742:  BNZ   1752
01744:  MOVLW  08
01746:  SUBWF  00,W
01748:  MOVLB  0
0174A:  BTFSC  FD8.2
0174C:  GOTO   1E4E
01750:  MOVLB  9
01752:  MOVF   03,W
01754:  BNZ   1764
01756:  MOVLW  09
01758:  SUBWF  00,W
0175A:  MOVLB  0
0175C:  BTFSC  FD8.2
0175E:  GOTO   1E5E
01762:  MOVLB  9
01764:  MOVF   03,W
01766:  BNZ   1776
01768:  MOVLW  0A
0176A:  SUBWF  00,W
0176C:  MOVLB  0
0176E:  BTFSC  FD8.2
01770:  GOTO   1E6E
01774:  MOVLB  9
01776:  MOVF   03,W
01778:  BNZ   1788
0177A:  MOVLW  0B
0177C:  SUBWF  00,W
0177E:  MOVLB  0
01780:  BTFSC  FD8.2
01782:  GOTO   1E9A
01786:  MOVLB  9
01788:  MOVF   03,W
0178A:  BNZ   179A
0178C:  MOVLW  0C
0178E:  SUBWF  00,W
01790:  MOVLB  0
01792:  BTFSC  FD8.2
01794:  GOTO   1EAA
01798:  MOVLB  9
0179A:  MOVF   03,W
0179C:  BNZ   17AC
0179E:  MOVLW  0D
017A0:  SUBWF  00,W
017A2:  MOVLB  0
017A4:  BTFSC  FD8.2
017A6:  GOTO   1EB8
017AA:  MOVLB  9
017AC:  MOVF   03,W
017AE:  BNZ   17BE
017B0:  MOVLW  0E
017B2:  SUBWF  00,W
017B4:  MOVLB  0
017B6:  BTFSC  FD8.2
017B8:  GOTO   1EC6
017BC:  MOVLB  9
017BE:  MOVF   03,W
017C0:  BNZ   17D0
017C2:  MOVLW  0F
017C4:  SUBWF  00,W
017C6:  MOVLB  0
017C8:  BTFSC  FD8.2
017CA:  GOTO   1ED4
017CE:  MOVLB  9
017D0:  MOVF   03,W
017D2:  BNZ   17E2
017D4:  MOVLW  10
017D6:  SUBWF  00,W
017D8:  MOVLB  0
017DA:  BTFSC  FD8.2
017DC:  GOTO   1EE2
017E0:  MOVLB  9
017E2:  MOVF   03,W
017E4:  BNZ   17F4
017E6:  MOVLW  11
017E8:  SUBWF  00,W
017EA:  MOVLB  0
017EC:  BTFSC  FD8.2
017EE:  GOTO   1F0E
017F2:  MOVLB  9
017F4:  MOVF   03,W
017F6:  BNZ   1806
017F8:  MOVLW  12
017FA:  SUBWF  00,W
017FC:  MOVLB  0
017FE:  BTFSC  FD8.2
01800:  GOTO   1F1E
01804:  MOVLB  9
01806:  MOVF   03,W
01808:  BNZ   1818
0180A:  MOVLW  13
0180C:  SUBWF  00,W
0180E:  MOVLB  0
01810:  BTFSC  FD8.2
01812:  GOTO   1F4C
01816:  MOVLB  9
01818:  MOVF   03,W
0181A:  BNZ   182A
0181C:  MOVLW  14
0181E:  SUBWF  00,W
01820:  MOVLB  0
01822:  BTFSC  FD8.2
01824:  GOTO   1F64
01828:  MOVLB  9
0182A:  MOVF   03,W
0182C:  BNZ   183C
0182E:  MOVLW  15
01830:  SUBWF  00,W
01832:  MOVLB  0
01834:  BTFSC  FD8.2
01836:  GOTO   1F72
0183A:  MOVLB  9
0183C:  MOVF   03,W
0183E:  BNZ   184E
01840:  MOVLW  16
01842:  SUBWF  00,W
01844:  MOVLB  0
01846:  BTFSC  FD8.2
01848:  GOTO   1FA0
0184C:  MOVLB  9
0184E:  MOVF   03,W
01850:  BNZ   1860
01852:  MOVLW  17
01854:  SUBWF  00,W
01856:  MOVLB  0
01858:  BTFSC  FD8.2
0185A:  GOTO   1FBA
0185E:  MOVLB  9
01860:  MOVF   03,W
01862:  BNZ   1872
01864:  MOVLW  18
01866:  SUBWF  00,W
01868:  MOVLB  0
0186A:  BTFSC  FD8.2
0186C:  GOTO   1FC8
01870:  MOVLB  9
01872:  MOVF   03,W
01874:  BNZ   1884
01876:  MOVLW  19
01878:  SUBWF  00,W
0187A:  MOVLB  0
0187C:  BTFSC  FD8.2
0187E:  GOTO   1FF6
01882:  MOVLB  9
01884:  MOVF   03,W
01886:  BNZ   1896
01888:  MOVLW  1A
0188A:  SUBWF  00,W
0188C:  MOVLB  0
0188E:  BTFSC  FD8.2
01890:  GOTO   2010
01894:  MOVLB  9
01896:  MOVF   03,W
01898:  BNZ   18A8
0189A:  MOVLW  1B
0189C:  SUBWF  00,W
0189E:  MOVLB  0
018A0:  BTFSC  FD8.2
018A2:  GOTO   201E
018A6:  MOVLB  9
018A8:  MOVF   03,W
018AA:  BNZ   18BA
018AC:  MOVLW  1C
018AE:  SUBWF  00,W
018B0:  MOVLB  0
018B2:  BTFSC  FD8.2
018B4:  GOTO   204C
018B8:  MOVLB  9
018BA:  MOVF   03,W
018BC:  BNZ   18CC
018BE:  MOVLW  1D
018C0:  SUBWF  00,W
018C2:  MOVLB  0
018C4:  BTFSC  FD8.2
018C6:  GOTO   2066
018CA:  MOVLB  9
018CC:  MOVF   03,W
018CE:  BNZ   18DE
018D0:  MOVLW  1E
018D2:  SUBWF  00,W
018D4:  MOVLB  0
018D6:  BTFSC  FD8.2
018D8:  GOTO   2074
018DC:  MOVLB  9
018DE:  MOVF   03,W
018E0:  BNZ   18F0
018E2:  MOVLW  1F
018E4:  SUBWF  00,W
018E6:  MOVLB  0
018E8:  BTFSC  FD8.2
018EA:  GOTO   20A2
018EE:  MOVLB  9
018F0:  MOVF   03,W
018F2:  BNZ   1902
018F4:  MOVLW  20
018F6:  SUBWF  00,W
018F8:  MOVLB  0
018FA:  BTFSC  FD8.2
018FC:  GOTO   20BC
01900:  MOVLB  9
01902:  MOVF   03,W
01904:  BNZ   1914
01906:  MOVLW  21
01908:  SUBWF  00,W
0190A:  MOVLB  0
0190C:  BTFSC  FD8.2
0190E:  GOTO   20CA
01912:  MOVLB  9
01914:  MOVF   03,W
01916:  BNZ   1926
01918:  MOVLW  22
0191A:  SUBWF  00,W
0191C:  MOVLB  0
0191E:  BTFSC  FD8.2
01920:  GOTO   20F8
01924:  MOVLB  9
01926:  MOVF   03,W
01928:  BNZ   1938
0192A:  MOVLW  23
0192C:  SUBWF  00,W
0192E:  MOVLB  0
01930:  BTFSC  FD8.2
01932:  GOTO   2112
01936:  MOVLB  9
01938:  MOVF   03,W
0193A:  BNZ   194A
0193C:  MOVLW  24
0193E:  SUBWF  00,W
01940:  MOVLB  0
01942:  BTFSC  FD8.2
01944:  GOTO   2120
01948:  MOVLB  9
0194A:  MOVF   03,W
0194C:  BNZ   195C
0194E:  MOVLW  25
01950:  SUBWF  00,W
01952:  MOVLB  0
01954:  BTFSC  FD8.2
01956:  GOTO   214E
0195A:  MOVLB  9
0195C:  MOVF   03,W
0195E:  BNZ   196E
01960:  MOVLW  26
01962:  SUBWF  00,W
01964:  MOVLB  0
01966:  BTFSC  FD8.2
01968:  GOTO   2168
0196C:  MOVLB  9
0196E:  MOVF   03,W
01970:  BNZ   1980
01972:  MOVLW  27
01974:  SUBWF  00,W
01976:  MOVLB  0
01978:  BTFSC  FD8.2
0197A:  GOTO   2176
0197E:  MOVLB  9
01980:  MOVF   03,W
01982:  BNZ   1992
01984:  MOVLW  28
01986:  SUBWF  00,W
01988:  MOVLB  0
0198A:  BTFSC  FD8.2
0198C:  GOTO   21A4
01990:  MOVLB  9
01992:  MOVF   03,W
01994:  BNZ   19A4
01996:  MOVLW  29
01998:  SUBWF  00,W
0199A:  MOVLB  0
0199C:  BTFSC  FD8.2
0199E:  GOTO   21BE
019A2:  MOVLB  9
019A4:  MOVF   03,W
019A6:  BNZ   19B6
019A8:  MOVLW  2A
019AA:  SUBWF  00,W
019AC:  MOVLB  0
019AE:  BTFSC  FD8.2
019B0:  GOTO   21CC
019B4:  MOVLB  9
019B6:  MOVF   03,W
019B8:  BNZ   19C8
019BA:  MOVLW  2B
019BC:  SUBWF  00,W
019BE:  MOVLB  0
019C0:  BTFSC  FD8.2
019C2:  GOTO   21E6
019C6:  MOVLB  9
019C8:  MOVF   03,W
019CA:  BNZ   19DA
019CC:  MOVLW  2C
019CE:  SUBWF  00,W
019D0:  MOVLB  0
019D2:  BTFSC  FD8.2
019D4:  GOTO   21F6
019D8:  MOVLB  9
019DA:  MOVF   03,W
019DC:  BNZ   19EC
019DE:  MOVLW  2D
019E0:  SUBWF  00,W
019E2:  MOVLB  0
019E4:  BTFSC  FD8.2
019E6:  GOTO   2206
019EA:  MOVLB  9
019EC:  MOVF   03,W
019EE:  BNZ   19FE
019F0:  MOVLW  2E
019F2:  SUBWF  00,W
019F4:  MOVLB  0
019F6:  BTFSC  FD8.2
019F8:  GOTO   2216
019FC:  MOVLB  9
019FE:  MOVF   03,W
01A00:  BNZ   1A10
01A02:  MOVLW  2F
01A04:  SUBWF  00,W
01A06:  MOVLB  0
01A08:  BTFSC  FD8.2
01A0A:  GOTO   2226
01A0E:  MOVLB  9
01A10:  MOVF   03,W
01A12:  BNZ   1A22
01A14:  MOVLW  30
01A16:  SUBWF  00,W
01A18:  MOVLB  0
01A1A:  BTFSC  FD8.2
01A1C:  GOTO   2236
01A20:  MOVLB  9
01A22:  MOVF   03,W
01A24:  BNZ   1A34
01A26:  MOVLW  31
01A28:  SUBWF  00,W
01A2A:  MOVLB  0
01A2C:  BTFSC  FD8.2
01A2E:  GOTO   2246
01A32:  MOVLB  9
01A34:  MOVF   03,W
01A36:  BNZ   1A46
01A38:  MOVLW  32
01A3A:  SUBWF  00,W
01A3C:  MOVLB  0
01A3E:  BTFSC  FD8.2
01A40:  GOTO   2256
01A44:  MOVLB  9
01A46:  MOVF   03,W
01A48:  BNZ   1A58
01A4A:  MOVLW  33
01A4C:  SUBWF  00,W
01A4E:  MOVLB  0
01A50:  BTFSC  FD8.2
01A52:  GOTO   2266
01A56:  MOVLB  9
01A58:  MOVF   03,W
01A5A:  BNZ   1A6A
01A5C:  MOVLW  34
01A5E:  SUBWF  00,W
01A60:  MOVLB  0
01A62:  BTFSC  FD8.2
01A64:  GOTO   2276
01A68:  MOVLB  9
01A6A:  MOVF   03,W
01A6C:  BNZ   1A7C
01A6E:  MOVLW  35
01A70:  SUBWF  00,W
01A72:  MOVLB  0
01A74:  BTFSC  FD8.2
01A76:  GOTO   2286
01A7A:  MOVLB  9
01A7C:  MOVF   03,W
01A7E:  BNZ   1A8E
01A80:  MOVLW  36
01A82:  SUBWF  00,W
01A84:  MOVLB  0
01A86:  BTFSC  FD8.2
01A88:  GOTO   2296
01A8C:  MOVLB  9
01A8E:  MOVF   03,W
01A90:  BNZ   1AA0
01A92:  MOVLW  37
01A94:  SUBWF  00,W
01A96:  MOVLB  0
01A98:  BTFSC  FD8.2
01A9A:  GOTO   22A8
01A9E:  MOVLB  9
01AA0:  MOVLW  03
01AA2:  SUBWF  03,W
01AA4:  BNZ   1AB4
01AA6:  MOVLW  E8
01AA8:  SUBWF  00,W
01AAA:  MOVLB  0
01AAC:  BTFSC  FD8.2
01AAE:  GOTO   22BA
01AB2:  MOVLB  9
01AB4:  MOVLW  03
01AB6:  SUBWF  03,W
01AB8:  BNZ   1AC8
01ABA:  MOVLW  E9
01ABC:  SUBWF  00,W
01ABE:  MOVLB  0
01AC0:  BTFSC  FD8.2
01AC2:  GOTO   22CA
01AC6:  MOVLB  9
01AC8:  MOVLW  03
01ACA:  SUBWF  03,W
01ACC:  BNZ   1ADC
01ACE:  MOVLW  EA
01AD0:  SUBWF  00,W
01AD2:  MOVLB  0
01AD4:  BTFSC  FD8.2
01AD6:  GOTO   22D8
01ADA:  MOVLB  9
01ADC:  MOVLW  03
01ADE:  SUBWF  03,W
01AE0:  BNZ   1AF0
01AE2:  MOVLW  EB
01AE4:  SUBWF  00,W
01AE6:  MOVLB  0
01AE8:  BTFSC  FD8.2
01AEA:  GOTO   22E6
01AEE:  MOVLB  9
01AF0:  MOVLW  03
01AF2:  SUBWF  03,W
01AF4:  BNZ   1B04
01AF6:  MOVLW  EC
01AF8:  SUBWF  00,W
01AFA:  MOVLB  0
01AFC:  BTFSC  FD8.2
01AFE:  GOTO   22F4
01B02:  MOVLB  9
01B04:  MOVLW  03
01B06:  SUBWF  03,W
01B08:  BNZ   1B18
01B0A:  MOVLW  ED
01B0C:  SUBWF  00,W
01B0E:  MOVLB  0
01B10:  BTFSC  FD8.2
01B12:  GOTO   2302
01B16:  MOVLB  9
01B18:  MOVLW  03
01B1A:  SUBWF  03,W
01B1C:  BNZ   1B2C
01B1E:  MOVLW  EE
01B20:  SUBWF  00,W
01B22:  MOVLB  0
01B24:  BTFSC  FD8.2
01B26:  GOTO   2310
01B2A:  MOVLB  9
01B2C:  MOVLW  03
01B2E:  SUBWF  03,W
01B30:  BNZ   1B40
01B32:  MOVLW  EF
01B34:  SUBWF  00,W
01B36:  MOVLB  0
01B38:  BTFSC  FD8.2
01B3A:  GOTO   2320
01B3E:  MOVLB  9
01B40:  MOVLW  03
01B42:  SUBWF  03,W
01B44:  BNZ   1B54
01B46:  MOVLW  F0
01B48:  SUBWF  00,W
01B4A:  MOVLB  0
01B4C:  BTFSC  FD8.2
01B4E:  GOTO   232E
01B52:  MOVLB  9
01B54:  MOVLW  03
01B56:  SUBWF  03,W
01B58:  BNZ   1B68
01B5A:  MOVLW  F1
01B5C:  SUBWF  00,W
01B5E:  MOVLB  0
01B60:  BTFSC  FD8.2
01B62:  GOTO   233E
01B66:  MOVLB  9
01B68:  MOVLW  03
01B6A:  SUBWF  03,W
01B6C:  BNZ   1B7C
01B6E:  MOVLW  F2
01B70:  SUBWF  00,W
01B72:  MOVLB  0
01B74:  BTFSC  FD8.2
01B76:  GOTO   234C
01B7A:  MOVLB  9
01B7C:  MOVLW  03
01B7E:  SUBWF  03,W
01B80:  BNZ   1B90
01B82:  MOVLW  F3
01B84:  SUBWF  00,W
01B86:  MOVLB  0
01B88:  BTFSC  FD8.2
01B8A:  GOTO   235A
01B8E:  MOVLB  9
01B90:  MOVLW  03
01B92:  SUBWF  03,W
01B94:  BNZ   1BA4
01B96:  MOVLW  F4
01B98:  SUBWF  00,W
01B9A:  MOVLB  0
01B9C:  BTFSC  FD8.2
01B9E:  GOTO   236A
01BA2:  MOVLB  9
01BA4:  MOVLW  03
01BA6:  SUBWF  03,W
01BA8:  BNZ   1BB8
01BAA:  MOVLW  F5
01BAC:  SUBWF  00,W
01BAE:  MOVLB  0
01BB0:  BTFSC  FD8.2
01BB2:  GOTO   237A
01BB6:  MOVLB  9
01BB8:  MOVLW  03
01BBA:  SUBWF  03,W
01BBC:  BNZ   1BCC
01BBE:  MOVLW  F6
01BC0:  SUBWF  00,W
01BC2:  MOVLB  0
01BC4:  BTFSC  FD8.2
01BC6:  GOTO   23FC
01BCA:  MOVLB  9
01BCC:  MOVLW  19
01BCE:  SUBWF  03,W
01BD0:  BNZ   1BE0
01BD2:  MOVLW  64
01BD4:  SUBWF  00,W
01BD6:  MOVLB  0
01BD8:  BTFSC  FD8.2
01BDA:  GOTO   240C
01BDE:  MOVLB  9
01BE0:  MOVLW  19
01BE2:  SUBWF  03,W
01BE4:  BNZ   1BF4
01BE6:  MOVLW  65
01BE8:  SUBWF  00,W
01BEA:  MOVLB  0
01BEC:  BTFSC  FD8.2
01BEE:  GOTO   241C
01BF2:  MOVLB  9
01BF4:  MOVLW  19
01BF6:  SUBWF  03,W
01BF8:  BNZ   1C08
01BFA:  MOVLW  66
01BFC:  SUBWF  00,W
01BFE:  MOVLB  0
01C00:  BTFSC  FD8.2
01C02:  GOTO   242E
01C06:  MOVLB  9
01C08:  MOVLW  19
01C0A:  SUBWF  03,W
01C0C:  BNZ   1C1C
01C0E:  MOVLW  67
01C10:  SUBWF  00,W
01C12:  MOVLB  0
01C14:  BTFSC  FD8.2
01C16:  GOTO   243E
01C1A:  MOVLB  9
01C1C:  MOVLW  19
01C1E:  SUBWF  03,W
01C20:  BNZ   1C30
01C22:  MOVLW  68
01C24:  SUBWF  00,W
01C26:  MOVLB  0
01C28:  BTFSC  FD8.2
01C2A:  GOTO   2450
01C2E:  MOVLB  9
01C30:  MOVLW  19
01C32:  SUBWF  03,W
01C34:  BNZ   1C44
01C36:  MOVLW  69
01C38:  SUBWF  00,W
01C3A:  MOVLB  0
01C3C:  BTFSC  FD8.2
01C3E:  GOTO   2460
01C42:  MOVLB  9
01C44:  MOVLW  19
01C46:  SUBWF  03,W
01C48:  BNZ   1C58
01C4A:  MOVLW  6A
01C4C:  SUBWF  00,W
01C4E:  MOVLB  0
01C50:  BTFSC  FD8.2
01C52:  GOTO   2472
01C56:  MOVLB  9
01C58:  MOVLW  19
01C5A:  SUBWF  03,W
01C5C:  BNZ   1C6C
01C5E:  MOVLW  6B
01C60:  SUBWF  00,W
01C62:  MOVLB  0
01C64:  BTFSC  FD8.2
01C66:  GOTO   2482
01C6A:  MOVLB  9
01C6C:  MOVLW  19
01C6E:  SUBWF  03,W
01C70:  BNZ   1C80
01C72:  MOVLW  6C
01C74:  SUBWF  00,W
01C76:  MOVLB  0
01C78:  BTFSC  FD8.2
01C7A:  GOTO   2494
01C7E:  MOVLB  9
01C80:  MOVLW  19
01C82:  SUBWF  03,W
01C84:  BNZ   1C94
01C86:  MOVLW  6D
01C88:  SUBWF  00,W
01C8A:  MOVLB  0
01C8C:  BTFSC  FD8.2
01C8E:  GOTO   24A4
01C92:  MOVLB  9
01C94:  MOVLW  19
01C96:  SUBWF  03,W
01C98:  BNZ   1CA8
01C9A:  MOVLW  6E
01C9C:  SUBWF  00,W
01C9E:  MOVLB  0
01CA0:  BTFSC  FD8.2
01CA2:  GOTO   24B6
01CA6:  MOVLB  9
01CA8:  MOVLW  19
01CAA:  SUBWF  03,W
01CAC:  BNZ   1CBC
01CAE:  MOVLW  6F
01CB0:  SUBWF  00,W
01CB2:  MOVLB  0
01CB4:  BTFSC  FD8.2
01CB6:  GOTO   24C6
01CBA:  MOVLB  9
01CBC:  MOVLW  19
01CBE:  SUBWF  03,W
01CC0:  BNZ   1CD0
01CC2:  MOVLW  70
01CC4:  SUBWF  00,W
01CC6:  MOVLB  0
01CC8:  BTFSC  FD8.2
01CCA:  GOTO   24D8
01CCE:  MOVLB  9
01CD0:  MOVLW  19
01CD2:  SUBWF  03,W
01CD4:  BNZ   1CE4
01CD6:  MOVLW  71
01CD8:  SUBWF  00,W
01CDA:  MOVLB  0
01CDC:  BTFSC  FD8.2
01CDE:  GOTO   24E8
01CE2:  MOVLB  9
01CE4:  MOVLW  19
01CE6:  SUBWF  03,W
01CE8:  BNZ   1CF8
01CEA:  MOVLW  72
01CEC:  SUBWF  00,W
01CEE:  MOVLB  0
01CF0:  BTFSC  FD8.2
01CF2:  GOTO   24FA
01CF6:  MOVLB  9
01CF8:  MOVLW  19
01CFA:  SUBWF  03,W
01CFC:  BNZ   1D0C
01CFE:  MOVLW  73
01D00:  SUBWF  00,W
01D02:  MOVLB  0
01D04:  BTFSC  FD8.2
01D06:  GOTO   250A
01D0A:  MOVLB  9
01D0C:  MOVLW  19
01D0E:  SUBWF  03,W
01D10:  BNZ   1D20
01D12:  MOVLW  74
01D14:  SUBWF  00,W
01D16:  MOVLB  0
01D18:  BTFSC  FD8.2
01D1A:  GOTO   251C
01D1E:  MOVLB  9
01D20:  MOVLW  19
01D22:  SUBWF  03,W
01D24:  BNZ   1D34
01D26:  MOVLW  75
01D28:  SUBWF  00,W
01D2A:  MOVLB  0
01D2C:  BTFSC  FD8.2
01D2E:  GOTO   252C
01D32:  MOVLB  9
01D34:  MOVLW  19
01D36:  SUBWF  03,W
01D38:  BNZ   1D48
01D3A:  MOVLW  76
01D3C:  SUBWF  00,W
01D3E:  MOVLB  0
01D40:  BTFSC  FD8.2
01D42:  GOTO   253E
01D46:  MOVLB  9
01D48:  MOVLW  19
01D4A:  SUBWF  03,W
01D4C:  BNZ   1D5C
01D4E:  MOVLW  77
01D50:  SUBWF  00,W
01D52:  MOVLB  0
01D54:  BTFSC  FD8.2
01D56:  GOTO   254E
01D5A:  MOVLB  9
01D5C:  MOVLW  19
01D5E:  SUBWF  03,W
01D60:  BNZ   1D70
01D62:  MOVLW  78
01D64:  SUBWF  00,W
01D66:  MOVLB  0
01D68:  BTFSC  FD8.2
01D6A:  GOTO   2560
01D6E:  MOVLB  9
01D70:  MOVLW  19
01D72:  SUBWF  03,W
01D74:  BNZ   1D84
01D76:  MOVLW  79
01D78:  SUBWF  00,W
01D7A:  MOVLB  0
01D7C:  BTFSC  FD8.2
01D7E:  GOTO   2570
01D82:  MOVLB  9
01D84:  MOVLW  19
01D86:  SUBWF  03,W
01D88:  BNZ   1D98
01D8A:  MOVLW  7A
01D8C:  SUBWF  00,W
01D8E:  MOVLB  0
01D90:  BTFSC  FD8.2
01D92:  GOTO   2582
01D96:  MOVLB  9
01D98:  MOVLW  19
01D9A:  SUBWF  03,W
01D9C:  BNZ   1DAC
01D9E:  MOVLW  7B
01DA0:  SUBWF  00,W
01DA2:  MOVLB  0
01DA4:  BTFSC  FD8.2
01DA6:  GOTO   2592
01DAA:  MOVLB  9
01DAC:  GOTO   25A2
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01DB0:  MOVFF  AA,01
01DB4:  MOVFF  AB,02
01DB8:  MOVLB  9
01DBA:  GOTO   25AA
01DBE:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01DC0:  MOVF   x98,W
01DC2:  MOVWF  01
01DC4:  MOVF   x99,W
01DC6:  MOVWF  02
01DC8:  MOVLB  9
01DCA:  GOTO   25AA
01DCE:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01DD0:  MOVF   x9E,W
01DD2:  MOVWF  01
01DD4:  MOVF   x9F,W
01DD6:  MOVWF  02
01DD8:  MOVLB  9
01DDA:  GOTO   25AA
01DDE:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01DE0:  MOVF   xA4,W
01DE2:  MOVWF  01
01DE4:  MOVF   xA5,W
01DE6:  MOVWF  02
01DE8:  MOVLB  9
01DEA:  GOTO   25AA
01DEE:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01DF0:  MOVLB  9
01DF2:  CLRF   x18
01DF4:  MOVLB  0
01DF6:  CALL   13AE
01DFA:  MOVFF  03,8F4
01DFE:  MOVFF  02,8F3
01E02:  MOVFF  01,8F2
01E06:  MOVFF  00,8F1
01E0A:  MOVLB  8
01E0C:  MOVF   xF1,W
01E0E:  MOVWF  01
01E10:  MOVF   xF2,W
01E12:  MOVWF  02
01E14:  MOVLB  9
01E16:  GOTO   25AA
01E1A:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01E1C:  MOVLB  8
01E1E:  MOVF   xF3,W
01E20:  MOVWF  01
01E22:  MOVF   xF4,W
01E24:  MOVWF  02
01E26:  MOVLB  9
01E28:  GOTO   25AA
01E2C:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01E2E:  MOVF   xAC,W
01E30:  MOVWF  01
01E32:  MOVF   xAD,W
01E34:  MOVWF  02
01E36:  MOVLB  9
01E38:  GOTO   25AA
01E3C:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01E3E:  MOVF   x9A,W
01E40:  MOVWF  01
01E42:  MOVF   x9B,W
01E44:  MOVWF  02
01E46:  MOVLB  9
01E48:  GOTO   25AA
01E4C:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01E4E:  MOVF   xA0,W
01E50:  MOVWF  01
01E52:  MOVF   xA1,W
01E54:  MOVWF  02
01E56:  MOVLB  9
01E58:  GOTO   25AA
01E5C:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01E5E:  MOVF   xA6,W
01E60:  MOVWF  01
01E62:  MOVF   xA7,W
01E64:  MOVWF  02
01E66:  MOVLB  9
01E68:  GOTO   25AA
01E6C:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01E6E:  MOVLW  01
01E70:  MOVLB  9
01E72:  MOVWF  x18
01E74:  MOVLB  0
01E76:  CALL   13AE
01E7A:  MOVFF  03,8F4
01E7E:  MOVFF  02,8F3
01E82:  MOVFF  01,8F2
01E86:  MOVFF  00,8F1
01E8A:  MOVLB  8
01E8C:  MOVF   xF1,W
01E8E:  MOVWF  01
01E90:  MOVF   xF2,W
01E92:  MOVWF  02
01E94:  MOVLB  9
01E96:  BRA    25AA
01E98:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01E9A:  MOVLB  8
01E9C:  MOVF   xF3,W
01E9E:  MOVWF  01
01EA0:  MOVF   xF4,W
01EA2:  MOVWF  02
01EA4:  MOVLB  9
01EA6:  BRA    25AA
01EA8:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01EAA:  MOVF   xAE,W
01EAC:  MOVWF  01
01EAE:  MOVF   xAF,W
01EB0:  MOVWF  02
01EB2:  MOVLB  9
01EB4:  BRA    25AA
01EB6:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01EB8:  MOVF   x9C,W
01EBA:  MOVWF  01
01EBC:  MOVF   x9D,W
01EBE:  MOVWF  02
01EC0:  MOVLB  9
01EC2:  BRA    25AA
01EC4:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01EC6:  MOVF   xA2,W
01EC8:  MOVWF  01
01ECA:  MOVF   xA3,W
01ECC:  MOVWF  02
01ECE:  MOVLB  9
01ED0:  BRA    25AA
01ED2:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01ED4:  MOVF   xA8,W
01ED6:  MOVWF  01
01ED8:  MOVF   xA9,W
01EDA:  MOVWF  02
01EDC:  MOVLB  9
01EDE:  BRA    25AA
01EE0:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01EE2:  MOVLW  02
01EE4:  MOVLB  9
01EE6:  MOVWF  x18
01EE8:  MOVLB  0
01EEA:  CALL   13AE
01EEE:  MOVFF  03,8F4
01EF2:  MOVFF  02,8F3
01EF6:  MOVFF  01,8F2
01EFA:  MOVFF  00,8F1
01EFE:  MOVLB  8
01F00:  MOVF   xF1,W
01F02:  MOVWF  01
01F04:  MOVF   xF2,W
01F06:  MOVWF  02
01F08:  MOVLB  9
01F0A:  BRA    25AA
01F0C:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01F0E:  MOVLB  8
01F10:  MOVF   xF3,W
01F12:  MOVWF  01
01F14:  MOVF   xF4,W
01F16:  MOVWF  02
01F18:  MOVLB  9
01F1A:  BRA    25AA
01F1C:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01F1E:  CLRF   03
01F20:  MOVLB  1
01F22:  MOVF   xCC,W
01F24:  MOVWF  02
01F26:  BCF    FD8.0
01F28:  RLCF   02,F
01F2A:  RLCF   03,F
01F2C:  MOVF   02,W
01F2E:  ADDLW  CC
01F30:  MOVWF  FE9
01F32:  MOVLW  00
01F34:  ADDWFC 03,W
01F36:  MOVWF  FEA
01F38:  MOVFF  FEC,03
01F3C:  MOVF   FED,F
01F3E:  MOVF   FEF,W
01F40:  MOVWF  01
01F42:  MOVF   03,W
01F44:  MOVWF  02
01F46:  MOVLB  9
01F48:  BRA    25AA
01F4A:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01F4C:  MOVLB  9
01F4E:  CLRF   x18
01F50:  MOVLB  0
01F52:  CALL   1410
01F56:  MOVF   01,W
01F58:  MOVWF  01
01F5A:  MOVF   02,W
01F5C:  MOVWF  02
01F5E:  MOVLB  9
01F60:  BRA    25AA
01F62:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01F64:  MOVF   xBC,W
01F66:  MOVWF  01
01F68:  MOVF   xBD,W
01F6A:  MOVWF  02
01F6C:  MOVLB  9
01F6E:  BRA    25AA
01F70:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01F72:  CLRF   03
01F74:  MOVLB  1
01F76:  MOVF   xCC,W
01F78:  MOVWF  02
01F7A:  BCF    FD8.0
01F7C:  RLCF   02,F
01F7E:  RLCF   03,F
01F80:  MOVF   02,W
01F82:  ADDLW  EC
01F84:  MOVWF  FE9
01F86:  MOVLW  00
01F88:  ADDWFC 03,W
01F8A:  MOVWF  FEA
01F8C:  MOVFF  FEC,03
01F90:  MOVF   FED,F
01F92:  MOVF   FEF,W
01F94:  MOVWF  01
01F96:  MOVF   03,W
01F98:  MOVWF  02
01F9A:  MOVLB  9
01F9C:  BRA    25AA
01F9E:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01FA0:  MOVLW  01
01FA2:  MOVLB  9
01FA4:  MOVWF  x18
01FA6:  MOVLB  0
01FA8:  CALL   1410
01FAC:  MOVF   01,W
01FAE:  MOVWF  01
01FB0:  MOVF   02,W
01FB2:  MOVWF  02
01FB4:  MOVLB  9
01FB6:  BRA    25AA
01FB8:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01FBA:  MOVF   xBE,W
01FBC:  MOVWF  01
01FBE:  MOVF   xBF,W
01FC0:  MOVWF  02
01FC2:  MOVLB  9
01FC4:  BRA    25AA
01FC6:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01FC8:  CLRF   03
01FCA:  MOVLB  1
01FCC:  MOVF   xCC,W
01FCE:  MOVWF  02
01FD0:  BCF    FD8.0
01FD2:  RLCF   02,F
01FD4:  RLCF   03,F
01FD6:  MOVF   02,W
01FD8:  ADDLW  0C
01FDA:  MOVWF  FE9
01FDC:  MOVLW  01
01FDE:  ADDWFC 03,W
01FE0:  MOVWF  FEA
01FE2:  MOVFF  FEC,03
01FE6:  MOVF   FED,F
01FE8:  MOVF   FEF,W
01FEA:  MOVWF  01
01FEC:  MOVF   03,W
01FEE:  MOVWF  02
01FF0:  MOVLB  9
01FF2:  BRA    25AA
01FF4:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01FF6:  MOVLW  02
01FF8:  MOVLB  9
01FFA:  MOVWF  x18
01FFC:  MOVLB  0
01FFE:  CALL   1410
02002:  MOVF   01,W
02004:  MOVWF  01
02006:  MOVF   02,W
02008:  MOVWF  02
0200A:  MOVLB  9
0200C:  BRA    25AA
0200E:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
02010:  MOVF   xC0,W
02012:  MOVWF  01
02014:  MOVF   xC1,W
02016:  MOVWF  02
02018:  MOVLB  9
0201A:  BRA    25AA
0201C:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
0201E:  CLRF   03
02020:  MOVLB  1
02022:  MOVF   xCC,W
02024:  MOVWF  02
02026:  BCF    FD8.0
02028:  RLCF   02,F
0202A:  RLCF   03,F
0202C:  MOVF   02,W
0202E:  ADDLW  2C
02030:  MOVWF  FE9
02032:  MOVLW  01
02034:  ADDWFC 03,W
02036:  MOVWF  FEA
02038:  MOVFF  FEC,03
0203C:  MOVF   FED,F
0203E:  MOVF   FEF,W
02040:  MOVWF  01
02042:  MOVF   03,W
02044:  MOVWF  02
02046:  MOVLB  9
02048:  BRA    25AA
0204A:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
0204C:  MOVLW  03
0204E:  MOVLB  9
02050:  MOVWF  x18
02052:  MOVLB  0
02054:  CALL   1410
02058:  MOVF   01,W
0205A:  MOVWF  01
0205C:  MOVF   02,W
0205E:  MOVWF  02
02060:  MOVLB  9
02062:  BRA    25AA
02064:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
02066:  MOVF   xC2,W
02068:  MOVWF  01
0206A:  MOVF   xC3,W
0206C:  MOVWF  02
0206E:  MOVLB  9
02070:  BRA    25AA
02072:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
02074:  CLRF   03
02076:  MOVLB  1
02078:  MOVF   xCC,W
0207A:  MOVWF  02
0207C:  BCF    FD8.0
0207E:  RLCF   02,F
02080:  RLCF   03,F
02082:  MOVF   02,W
02084:  ADDLW  4C
02086:  MOVWF  FE9
02088:  MOVLW  01
0208A:  ADDWFC 03,W
0208C:  MOVWF  FEA
0208E:  MOVFF  FEC,03
02092:  MOVF   FED,F
02094:  MOVF   FEF,W
02096:  MOVWF  01
02098:  MOVF   03,W
0209A:  MOVWF  02
0209C:  MOVLB  9
0209E:  BRA    25AA
020A0:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
020A2:  MOVLW  04
020A4:  MOVLB  9
020A6:  MOVWF  x18
020A8:  MOVLB  0
020AA:  CALL   1410
020AE:  MOVF   01,W
020B0:  MOVWF  01
020B2:  MOVF   02,W
020B4:  MOVWF  02
020B6:  MOVLB  9
020B8:  BRA    25AA
020BA:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
020BC:  MOVF   xC4,W
020BE:  MOVWF  01
020C0:  MOVF   xC5,W
020C2:  MOVWF  02
020C4:  MOVLB  9
020C6:  BRA    25AA
020C8:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
020CA:  CLRF   03
020CC:  MOVLB  1
020CE:  MOVF   xCC,W
020D0:  MOVWF  02
020D2:  BCF    FD8.0
020D4:  RLCF   02,F
020D6:  RLCF   03,F
020D8:  MOVF   02,W
020DA:  ADDLW  6C
020DC:  MOVWF  FE9
020DE:  MOVLW  01
020E0:  ADDWFC 03,W
020E2:  MOVWF  FEA
020E4:  MOVFF  FEC,03
020E8:  MOVF   FED,F
020EA:  MOVF   FEF,W
020EC:  MOVWF  01
020EE:  MOVF   03,W
020F0:  MOVWF  02
020F2:  MOVLB  9
020F4:  BRA    25AA
020F6:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
020F8:  MOVLW  05
020FA:  MOVLB  9
020FC:  MOVWF  x18
020FE:  MOVLB  0
02100:  CALL   1410
02104:  MOVF   01,W
02106:  MOVWF  01
02108:  MOVF   02,W
0210A:  MOVWF  02
0210C:  MOVLB  9
0210E:  BRA    25AA
02110:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
02112:  MOVF   xC6,W
02114:  MOVWF  01
02116:  MOVF   xC7,W
02118:  MOVWF  02
0211A:  MOVLB  9
0211C:  BRA    25AA
0211E:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
02120:  CLRF   03
02122:  MOVLB  1
02124:  MOVF   xCC,W
02126:  MOVWF  02
02128:  BCF    FD8.0
0212A:  RLCF   02,F
0212C:  RLCF   03,F
0212E:  MOVF   02,W
02130:  ADDLW  8C
02132:  MOVWF  FE9
02134:  MOVLW  01
02136:  ADDWFC 03,W
02138:  MOVWF  FEA
0213A:  MOVFF  FEC,03
0213E:  MOVF   FED,F
02140:  MOVF   FEF,W
02142:  MOVWF  01
02144:  MOVF   03,W
02146:  MOVWF  02
02148:  MOVLB  9
0214A:  BRA    25AA
0214C:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
0214E:  MOVLW  06
02150:  MOVLB  9
02152:  MOVWF  x18
02154:  MOVLB  0
02156:  CALL   1410
0215A:  MOVF   01,W
0215C:  MOVWF  01
0215E:  MOVF   02,W
02160:  MOVWF  02
02162:  MOVLB  9
02164:  BRA    25AA
02166:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
02168:  MOVF   xC8,W
0216A:  MOVWF  01
0216C:  MOVF   xC9,W
0216E:  MOVWF  02
02170:  MOVLB  9
02172:  BRA    25AA
02174:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
02176:  CLRF   03
02178:  MOVLB  1
0217A:  MOVF   xCC,W
0217C:  MOVWF  02
0217E:  BCF    FD8.0
02180:  RLCF   02,F
02182:  RLCF   03,F
02184:  MOVF   02,W
02186:  ADDLW  AC
02188:  MOVWF  FE9
0218A:  MOVLW  01
0218C:  ADDWFC 03,W
0218E:  MOVWF  FEA
02190:  MOVFF  FEC,03
02194:  MOVF   FED,F
02196:  MOVF   FEF,W
02198:  MOVWF  01
0219A:  MOVF   03,W
0219C:  MOVWF  02
0219E:  MOVLB  9
021A0:  BRA    25AA
021A2:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
021A4:  MOVLW  07
021A6:  MOVLB  9
021A8:  MOVWF  x18
021AA:  MOVLB  0
021AC:  CALL   1410
021B0:  MOVF   01,W
021B2:  MOVWF  01
021B4:  MOVF   02,W
021B6:  MOVWF  02
021B8:  MOVLB  9
021BA:  BRA    25AA
021BC:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
021BE:  MOVF   xCA,W
021C0:  MOVWF  01
021C2:  MOVF   xCB,W
021C4:  MOVWF  02
021C6:  MOVLB  9
021C8:  BRA    25AA
021CA:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
021CC:  MOVLB  1
021CE:  MOVF   xD4,W
021D0:  MOVWF  03
021D2:  MOVF   xD3,W
021D4:  INCF   xD3,F
021D6:  BTFSC  FD8.2
021D8:  INCF   xD4,F
021DA:  MOVWF  01
021DC:  MOVF   03,W
021DE:  MOVWF  02
021E0:  MOVLB  9
021E2:  BRA    25AA
021E4:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
021E6:  MOVLB  1
021E8:  MOVF   xD7,W
021EA:  MOVWF  01
021EC:  MOVF   xD8,W
021EE:  MOVWF  02
021F0:  MOVLB  9
021F2:  BRA    25AA
021F4:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
021F6:  MOVLB  1
021F8:  MOVF   xD5,W
021FA:  MOVWF  01
021FC:  MOVF   xD6,W
021FE:  MOVWF  02
02200:  MOVLB  9
02202:  BRA    25AA
02204:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
02206:  MOVLB  1
02208:  MOVF   xDA,W
0220A:  MOVWF  01
0220C:  MOVF   xDB,W
0220E:  MOVWF  02
02210:  MOVLB  9
02212:  BRA    25AA
02214:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
02216:  GOTO   149A
0221A:  MOVLW  00
0221C:  MOVWF  01
0221E:  MOVWF  02
02220:  MOVLB  9
02222:  BRA    25AA
02224:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
02226:  GOTO   14D6
0222A:  MOVLW  00
0222C:  MOVWF  01
0222E:  MOVWF  02
02230:  MOVLB  9
02232:  BRA    25AA
02234:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
02236:  MOVLB  1
02238:  MOVF   xCD,W
0223A:  MOVWF  01
0223C:  MOVF   xCE,W
0223E:  MOVWF  02
02240:  MOVLB  9
02242:  BRA    25AA
02244:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
02246:  MOVLB  1
02248:  MOVF   xCF,W
0224A:  MOVWF  01
0224C:  MOVF   xD0,W
0224E:  MOVWF  02
02250:  MOVLB  9
02252:  BRA    25AA
02254:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
02256:  MOVLB  1
02258:  MOVF   xD1,W
0225A:  MOVWF  01
0225C:  MOVF   xD2,W
0225E:  MOVWF  02
02260:  MOVLB  9
02262:  BRA    25AA
02264:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
02266:  GOTO   14FE
0226A:  MOVLW  00
0226C:  MOVWF  01
0226E:  MOVWF  02
02270:  MOVLB  9
02272:  BRA    25AA
02274:  MOVLB  0
.................... 		 
.................... 		/* meta */ 
.................... 		case 52: return (int16) current.rda_bytes_received; 
02276:  MOVLB  1
02278:  MOVF   xE3,W
0227A:  MOVWF  01
0227C:  MOVF   xE4,W
0227E:  MOVWF  02
02280:  MOVLB  9
02282:  BRA    25AA
02284:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
02286:  MOVLB  1
02288:  MOVF   xE5,W
0228A:  MOVWF  01
0228C:  MOVF   xE6,W
0228E:  MOVWF  02
02290:  MOVLB  9
02292:  BRA    25AA
02294:  MOVLB  0
.................... 		case 54: return (int16) current.button_state; 
02296:  CLRF   03
02298:  MOVLB  1
0229A:  MOVF   xE7,W
0229C:  MOVWF  01
0229E:  MOVF   03,W
022A0:  MOVWF  02
022A2:  MOVLB  9
022A4:  BRA    25AA
022A6:  MOVLB  0
.................... 		case 55: return (int16) current.latch_sw_magnet; 
022A8:  CLRF   03
022AA:  MOVLB  1
022AC:  MOVF   xE8,W
022AE:  MOVWF  01
022B0:  MOVF   03,W
022B2:  MOVWF  02
022B4:  MOVLB  9
022B6:  BRA    25AA
022B8:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
022BA:  CLRF   03
022BC:  MOVF   3A,W
022BE:  MOVWF  01
022C0:  MOVF   03,W
022C2:  MOVWF  02
022C4:  MOVLB  9
022C6:  BRA    25AA
022C8:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
022CA:  MOVF   3B,W
022CC:  MOVWF  01
022CE:  MOVF   3C,W
022D0:  MOVWF  02
022D2:  MOVLB  9
022D4:  BRA    25AA
022D6:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
022D8:  MOVLW  50
022DA:  MOVWF  01
022DC:  MOVLW  00
022DE:  MOVWF  02
022E0:  MOVLB  9
022E2:  BRA    25AA
022E4:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
022E6:  MOVLW  57
022E8:  MOVWF  01
022EA:  MOVLW  00
022EC:  MOVWF  02
022EE:  MOVLB  9
022F0:  BRA    25AA
022F2:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
022F4:  MOVLW  58
022F6:  MOVWF  01
022F8:  MOVLW  00
022FA:  MOVWF  02
022FC:  MOVLB  9
022FE:  BRA    25AA
02300:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
02302:  MOVLW  01
02304:  MOVWF  01
02306:  MOVLW  00
02308:  MOVWF  02
0230A:  MOVLB  9
0230C:  BRA    25AA
0230E:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
02310:  CLRF   03
02312:  MOVF   36,W
02314:  MOVWF  01
02316:  MOVF   03,W
02318:  MOVWF  02
0231A:  MOVLB  9
0231C:  BRA    25AA
0231E:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
02320:  MOVF   3D,W
02322:  MOVWF  01
02324:  MOVF   3E,W
02326:  MOVWF  02
02328:  MOVLB  9
0232A:  BRA    25AA
0232C:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
0232E:  CLRF   03
02330:  MOVF   3F,W
02332:  MOVWF  01
02334:  MOVF   03,W
02336:  MOVWF  02
02338:  MOVLB  9
0233A:  BRA    25AA
0233C:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
0233E:  MOVF   40,W
02340:  MOVWF  01
02342:  MOVF   41,W
02344:  MOVWF  02
02346:  MOVLB  9
02348:  BRA    25AA
0234A:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
0234C:  MOVF   42,W
0234E:  MOVWF  01
02350:  MOVF   43,W
02352:  MOVWF  02
02354:  MOVLB  9
02356:  BRA    25AA
02358:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
0235A:  CLRF   03
0235C:  MOVF   44,W
0235E:  MOVWF  01
02360:  MOVF   03,W
02362:  MOVWF  02
02364:  MOVLB  9
02366:  BRA    25AA
02368:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
0236A:  CLRF   03
0236C:  MOVF   38,W
0236E:  MOVWF  01
02370:  MOVF   03,W
02372:  MOVWF  02
02374:  MOVLB  9
02376:  BRA    25AA
02378:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
0237A:  MOVF   39,F
0237C:  BNZ   238C
0237E:  MOVLW  B0
02380:  MOVWF  01
02382:  MOVLW  04
02384:  MOVWF  02
02386:  MOVLB  9
02388:  BRA    25AA
0238A:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
0238C:  DECFSZ 39,W
0238E:  BRA    239E
02390:  MOVLW  60
02392:  MOVWF  01
02394:  MOVLW  09
02396:  MOVWF  02
02398:  MOVLB  9
0239A:  BRA    25AA
0239C:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
0239E:  MOVF   39,W
023A0:  SUBLW  02
023A2:  BNZ   23B2
023A4:  MOVLW  C0
023A6:  MOVWF  01
023A8:  MOVLW  12
023AA:  MOVWF  02
023AC:  MOVLB  9
023AE:  BRA    25AA
023B0:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
023B2:  MOVF   39,W
023B4:  SUBLW  04
023B6:  BNZ   23C6
023B8:  MOVLW  00
023BA:  MOVWF  01
023BC:  MOVLW  4B
023BE:  MOVWF  02
023C0:  MOVLB  9
023C2:  BRA    25AA
023C4:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
023C6:  MOVF   39,W
023C8:  SUBLW  05
023CA:  BNZ   23DA
023CC:  MOVLW  00
023CE:  MOVWF  01
023D0:  MOVLW  96
023D2:  MOVWF  02
023D4:  MOVLB  9
023D6:  BRA    25AA
023D8:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
023DA:  MOVF   39,W
023DC:  SUBLW  06
023DE:  BNZ   23EE
023E0:  MOVLW  00
023E2:  MOVWF  01
023E4:  MOVLW  E1
023E6:  MOVWF  02
023E8:  MOVLB  9
023EA:  BRA    25AA
023EC:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
023EE:  MOVLW  80
023F0:  MOVWF  01
023F2:  MOVLW  25
023F4:  MOVWF  02
023F6:  MOVLB  9
023F8:  BRA    25AA
023FA:  MOVLB  0
.................... 		case 1014: return (int16) config.pic_to_pi_latch_mask; 
023FC:  CLRF   03
023FE:  MOVF   4F,W
02400:  MOVWF  01
02402:  MOVF   03,W
02404:  MOVWF  02
02406:  MOVLB  9
02408:  BRA    25AA
0240A:  MOVLB  0
....................  
.................... 		/* NMEA sentence age and length */ 
.................... 		case 6500: return (int16) nmea.sentence_age[0]; 
0240C:  MOVLB  7
0240E:  MOVF   xC6,W
02410:  MOVWF  01
02412:  MOVF   xC7,W
02414:  MOVWF  02
02416:  MOVLB  9
02418:  BRA    25AA
0241A:  MOVLB  0
.................... 		case 6501: return (int16) nmea.sentence_length[0]; 
0241C:  CLRF   03
0241E:  MOVLB  7
02420:  MOVF   xDE,W
02422:  MOVWF  01
02424:  MOVF   03,W
02426:  MOVWF  02
02428:  MOVLB  9
0242A:  BRA    25AA
0242C:  MOVLB  0
.................... 		case 6502: return (int16) nmea.sentence_age[1]; 
0242E:  MOVLB  7
02430:  MOVF   xC8,W
02432:  MOVWF  01
02434:  MOVF   xC9,W
02436:  MOVWF  02
02438:  MOVLB  9
0243A:  BRA    25AA
0243C:  MOVLB  0
.................... 		case 6503: return (int16) nmea.sentence_length[1]; 
0243E:  CLRF   03
02440:  MOVLB  7
02442:  MOVF   xDF,W
02444:  MOVWF  01
02446:  MOVF   03,W
02448:  MOVWF  02
0244A:  MOVLB  9
0244C:  BRA    25AA
0244E:  MOVLB  0
.................... 		case 6504: return (int16) nmea.sentence_age[2]; 
02450:  MOVLB  7
02452:  MOVF   xCA,W
02454:  MOVWF  01
02456:  MOVF   xCB,W
02458:  MOVWF  02
0245A:  MOVLB  9
0245C:  BRA    25AA
0245E:  MOVLB  0
.................... 		case 6505: return (int16) nmea.sentence_length[2]; 
02460:  CLRF   03
02462:  MOVLB  7
02464:  MOVF   xE0,W
02466:  MOVWF  01
02468:  MOVF   03,W
0246A:  MOVWF  02
0246C:  MOVLB  9
0246E:  BRA    25AA
02470:  MOVLB  0
.................... 		case 6506: return (int16) nmea.sentence_age[3]; 
02472:  MOVLB  7
02474:  MOVF   xCC,W
02476:  MOVWF  01
02478:  MOVF   xCD,W
0247A:  MOVWF  02
0247C:  MOVLB  9
0247E:  BRA    25AA
02480:  MOVLB  0
.................... 		case 6507: return (int16) nmea.sentence_length[3]; 
02482:  CLRF   03
02484:  MOVLB  7
02486:  MOVF   xE1,W
02488:  MOVWF  01
0248A:  MOVF   03,W
0248C:  MOVWF  02
0248E:  MOVLB  9
02490:  BRA    25AA
02492:  MOVLB  0
.................... 		case 6508: return (int16) nmea.sentence_age[4]; 
02494:  MOVLB  7
02496:  MOVF   xCE,W
02498:  MOVWF  01
0249A:  MOVF   xCF,W
0249C:  MOVWF  02
0249E:  MOVLB  9
024A0:  BRA    25AA
024A2:  MOVLB  0
.................... 		case 6509: return (int16) nmea.sentence_length[4]; 
024A4:  CLRF   03
024A6:  MOVLB  7
024A8:  MOVF   xE2,W
024AA:  MOVWF  01
024AC:  MOVF   03,W
024AE:  MOVWF  02
024B0:  MOVLB  9
024B2:  BRA    25AA
024B4:  MOVLB  0
.................... 		case 6510: return (int16) nmea.sentence_age[5]; 
024B6:  MOVLB  7
024B8:  MOVF   xD0,W
024BA:  MOVWF  01
024BC:  MOVF   xD1,W
024BE:  MOVWF  02
024C0:  MOVLB  9
024C2:  BRA    25AA
024C4:  MOVLB  0
.................... 		case 6511: return (int16) nmea.sentence_length[5]; 
024C6:  CLRF   03
024C8:  MOVLB  7
024CA:  MOVF   xE3,W
024CC:  MOVWF  01
024CE:  MOVF   03,W
024D0:  MOVWF  02
024D2:  MOVLB  9
024D4:  BRA    25AA
024D6:  MOVLB  0
.................... 		case 6512: return (int16) nmea.sentence_age[6]; 
024D8:  MOVLB  7
024DA:  MOVF   xD2,W
024DC:  MOVWF  01
024DE:  MOVF   xD3,W
024E0:  MOVWF  02
024E2:  MOVLB  9
024E4:  BRA    25AA
024E6:  MOVLB  0
.................... 		case 6513: return (int16) nmea.sentence_length[6]; 
024E8:  CLRF   03
024EA:  MOVLB  7
024EC:  MOVF   xE4,W
024EE:  MOVWF  01
024F0:  MOVF   03,W
024F2:  MOVWF  02
024F4:  MOVLB  9
024F6:  BRA    25AA
024F8:  MOVLB  0
.................... 		case 6514: return (int16) nmea.sentence_age[7]; 
024FA:  MOVLB  7
024FC:  MOVF   xD4,W
024FE:  MOVWF  01
02500:  MOVF   xD5,W
02502:  MOVWF  02
02504:  MOVLB  9
02506:  BRA    25AA
02508:  MOVLB  0
.................... 		case 6515: return (int16) nmea.sentence_length[7]; 
0250A:  CLRF   03
0250C:  MOVLB  7
0250E:  MOVF   xE5,W
02510:  MOVWF  01
02512:  MOVF   03,W
02514:  MOVWF  02
02516:  MOVLB  9
02518:  BRA    25AA
0251A:  MOVLB  0
.................... 		case 6516: return (int16) nmea.sentence_age[8]; 
0251C:  MOVLB  7
0251E:  MOVF   xD6,W
02520:  MOVWF  01
02522:  MOVF   xD7,W
02524:  MOVWF  02
02526:  MOVLB  9
02528:  BRA    25AA
0252A:  MOVLB  0
.................... 		case 6517: return (int16) nmea.sentence_length[8]; 
0252C:  CLRF   03
0252E:  MOVLB  7
02530:  MOVF   xE6,W
02532:  MOVWF  01
02534:  MOVF   03,W
02536:  MOVWF  02
02538:  MOVLB  9
0253A:  BRA    25AA
0253C:  MOVLB  0
.................... 		case 6518: return (int16) nmea.sentence_age[9]; 
0253E:  MOVLB  7
02540:  MOVF   xD8,W
02542:  MOVWF  01
02544:  MOVF   xD9,W
02546:  MOVWF  02
02548:  MOVLB  9
0254A:  BRA    25AA
0254C:  MOVLB  0
.................... 		case 6519: return (int16) nmea.sentence_length[9]; 
0254E:  CLRF   03
02550:  MOVLB  7
02552:  MOVF   xE7,W
02554:  MOVWF  01
02556:  MOVF   03,W
02558:  MOVWF  02
0255A:  MOVLB  9
0255C:  BRA    25AA
0255E:  MOVLB  0
.................... 		case 6520: return (int16) nmea.sentence_age[10]; 
02560:  MOVLB  7
02562:  MOVF   xDA,W
02564:  MOVWF  01
02566:  MOVF   xDB,W
02568:  MOVWF  02
0256A:  MOVLB  9
0256C:  BRA    25AA
0256E:  MOVLB  0
.................... 		case 6521: return (int16) nmea.sentence_length[10]; 
02570:  CLRF   03
02572:  MOVLB  7
02574:  MOVF   xE8,W
02576:  MOVWF  01
02578:  MOVF   03,W
0257A:  MOVWF  02
0257C:  MOVLB  9
0257E:  BRA    25AA
02580:  MOVLB  0
.................... 		case 6522: return (int16) nmea.sentence_age[11]; 
02582:  MOVLB  7
02584:  MOVF   xDC,W
02586:  MOVWF  01
02588:  MOVF   xDD,W
0258A:  MOVWF  02
0258C:  MOVLB  9
0258E:  BRA    25AA
02590:  MOVLB  0
.................... 		case 6523: return (int16) nmea.sentence_length[11]; 
02592:  CLRF   03
02594:  MOVLB  7
02596:  MOVF   xE9,W
02598:  MOVWF  01
0259A:  MOVF   03,W
0259C:  MOVWF  02
0259E:  MOVLB  9
025A0:  BRA    25AA
....................  
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
025A2:  MOVLW  FF
025A4:  MOVWF  01
025A6:  MOVWF  02
025A8:  BRA    25AA
.................... 	} 
....................  
.................... } 
025AA:  MOVLB  0
025AC:  GOTO   25FE (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01204:  MOVLB  9
01206:  MOVF   x08,W
01208:  SUBLW  1F
0120A:  BNZ   1224
0120C:  MOVF   x09,W
0120E:  SUBLW  4E
01210:  BNZ   1224
01212:  MOVF   x0A,W
01214:  SUBLW  20
01216:  BNZ   1224
01218:  MOVF   x0B,W
0121A:  SUBLW  4E
0121C:  BNZ   1224
.................... 		return 1; 
0121E:  MOVLW  01
01220:  MOVWF  01
01222:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_META_REGISTER && end <= MAX_NMEA0183_META_REGISTER )  
01224:  MOVF   x09,W
01226:  SUBLW  18
01228:  BC    1248
0122A:  XORLW  FF
0122C:  BNZ   1234
0122E:  MOVF   x08,W
01230:  SUBLW  63
01232:  BC    1248
01234:  MOVF   x0B,W
01236:  SUBLW  19
01238:  BNC   1248
0123A:  BNZ   1242
0123C:  MOVF   x0A,W
0123E:  SUBLW  7C
01240:  BNC   1248
.................... 		return 1; 
01242:  MOVLW  01
01244:  MOVWF  01
01246:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
01248:  MOVF   x09,W
0124A:  SUBLW  16
0124C:  BC    126C
0124E:  XORLW  FF
01250:  BNZ   1258
01252:  MOVF   x08,W
01254:  SUBLW  6F
01256:  BC    126C
01258:  MOVF   x0B,W
0125A:  SUBLW  19
0125C:  BNC   126C
0125E:  BNZ   1266
01260:  MOVF   x0A,W
01262:  SUBLW  50
01264:  BNC   126C
.................... 		return 1; 
01266:  MOVLW  01
01268:  MOVWF  01
0126A:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
0126C:  MOVF   x09,W
0126E:  SUBLW  12
01270:  BC    1290
01272:  XORLW  FF
01274:  BNZ   127C
01276:  MOVF   x08,W
01278:  SUBLW  87
0127A:  BC    1290
0127C:  MOVF   x0B,W
0127E:  SUBLW  17
01280:  BNC   1290
01282:  BNZ   128A
01284:  MOVF   x0A,W
01286:  SUBLW  48
01288:  BNC   1290
.................... 		return 1; 
0128A:  MOVLW  01
0128C:  MOVWF  01
0128E:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01290:  MOVF   x09,W
01292:  SUBLW  03
01294:  BC    12B4
01296:  XORLW  FF
01298:  BNZ   12A0
0129A:  MOVF   x08,W
0129C:  SUBLW  4B
0129E:  BC    12B4
012A0:  MOVF   x0B,W
012A2:  SUBLW  04
012A4:  BNC   12B4
012A6:  BNZ   12AE
012A8:  MOVF   x0A,W
012AA:  SUBLW  94
012AC:  BNC   12B4
.................... 		return 1; 
012AE:  MOVLW  01
012B0:  MOVWF  01
012B2:  BRA    1310
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
012B4:  MOVF   x09,W
012B6:  SUBLW  02
012B8:  BC    12D8
012BA:  XORLW  FF
012BC:  BNZ   12C4
012BE:  MOVF   x08,W
012C0:  SUBLW  E7
012C2:  BC    12D8
012C4:  MOVF   x0B,W
012C6:  SUBLW  03
012C8:  BNC   12D8
012CA:  BNZ   12D2
012CC:  MOVF   x0A,W
012CE:  SUBLW  F7
012D0:  BNC   12D8
.................... 		return 1; 
012D2:  MOVLW  01
012D4:  MOVWF  01
012D6:  BRA    1310
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
012D8:  MOVF   x09,W
012DA:  SUBLW  06
012DC:  BC    12FC
012DE:  XORLW  FF
012E0:  BNZ   12E8
012E2:  MOVF   x08,W
012E4:  SUBLW  CF
012E6:  BC    12FC
012E8:  MOVF   x0B,W
012EA:  SUBLW  09
012EC:  BNC   12FC
012EE:  BNZ   12F6
012F0:  MOVF   x0A,W
012F2:  SUBLW  D1
012F4:  BNC   12FC
.................... 		return 1; 
012F6:  MOVLW  01
012F8:  MOVWF  01
012FA:  BRA    1310
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
012FC:  MOVF   x0B,F
012FE:  BNZ   130C
01300:  MOVF   x0A,W
01302:  SUBLW  38
01304:  BNC   130C
.................... 		return 1; 
01306:  MOVLW  01
01308:  MOVWF  01
0130A:  BRA    1310
....................  
.................... 	return 0; 
0130C:  MOVLW  00
0130E:  MOVWF  01
.................... } 
01310:  MOVLB  0
01312:  GOTO   2C42 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
025B0:  MOVFF  907,910
025B4:  MOVFF  906,911
025B8:  CALL   134E
.................... 	modbus_serial_putc(register_count*2); 
025BC:  BCF    FD8.0
025BE:  MOVLB  9
025C0:  RLCF   x0A,W
025C2:  MOVWF  x10
025C4:  RLCF   x0B,W
025C6:  MOVWF  x11
025C8:  MOVFF  910,912
025CC:  MOVLB  0
025CE:  CALL   1316
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
025D2:  MOVLB  9
025D4:  CLRF   x0D
025D6:  CLRF   x0C
025D8:  MOVF   x0D,W
025DA:  SUBWF  x0B,W
025DC:  BNC   2628
025DE:  BNZ   25E6
025E0:  MOVF   x0A,W
025E2:  SUBWF  x0C,W
025E4:  BC    2628
.................... 		l=map_modbus(start_address+i); 
025E6:  MOVF   x0C,W
025E8:  ADDWF  x08,W
025EA:  MOVWF  x10
025EC:  MOVF   x0D,W
025EE:  ADDWFC x09,W
025F0:  MOVWF  x11
025F2:  MOVWF  x13
025F4:  MOVFF  910,912
025F8:  MOVLB  0
025FA:  GOTO   1512
025FE:  MOVFF  02,90F
02602:  MOVFF  01,90E
.................... 		modbus_serial_putc(make8(l,1)); 
02606:  MOVFF  90F,910
0260A:  MOVFF  90F,912
0260E:  CALL   1316
....................   		modbus_serial_putc(make8(l,0)); 
02612:  MOVFF  90E,910
02616:  MOVFF  90E,912
0261A:  CALL   1316
.................... 	} 
0261E:  MOVLB  9
02620:  INCF   x0C,F
02622:  BTFSC  FD8.2
02624:  INCF   x0D,F
02626:  BRA    25D8
....................  
.................... 	modbus_serial_send_stop(); 
02628:  MOVLB  0
0262A:  CALL   136C
.................... } 
0262E:  GOTO   2C84 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
02632:  MOVLB  9
02634:  MOVF   x0D,W
02636:  SUBLW  06
02638:  BC    26B0
0263A:  XORLW  FF
0263C:  BNZ   2644
0263E:  MOVF   x0C,W
02640:  SUBLW  CF
02642:  BC    26B0
02644:  MOVF   x0D,W
02646:  SUBLW  09
02648:  BNC   26B0
0264A:  BNZ   2652
0264C:  MOVF   x0C,W
0264E:  SUBLW  CF
02650:  BNC   26B0
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02652:  MOVF   x0F,W
02654:  SUBLW  00
02656:  BC    2668
02658:  XORLW  FF
0265A:  BNZ   2662
0265C:  MOVF   x0E,W
0265E:  SUBLW  00
02660:  BC    2668
02662:  MOVLW  03
02664:  MOVWF  01
02666:  BRA    2A72
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
02668:  MOVLW  D0
0266A:  SUBWF  x0C,W
0266C:  MOVWF  x12
0266E:  MOVLW  07
02670:  SUBWFB x0D,W
02672:  MOVWF  x13
02674:  MOVLW  02
02676:  ADDWF  x13,F
02678:  MOVFF  913,FAA
0267C:  MOVFF  912,FA9
02680:  MOVFF  90E,FA8
02684:  BCF    FA6.6
02686:  BCF    FA6.7
02688:  BSF    FA6.2
0268A:  MOVF   FF2,W
0268C:  MOVWF  00
0268E:  BCF    FF2.6
02690:  BCF    FF2.7
02692:  MOVLB  F
02694:  MOVLW  55
02696:  MOVWF  FA7
02698:  MOVLW  AA
0269A:  MOVWF  FA7
0269C:  BSF    FA6.1
0269E:  BTFSC  FA6.1
026A0:  BRA    269E
026A2:  BCF    FA6.2
026A4:  MOVF   00,W
026A6:  IORWF  FF2,F
.................... 		return 0; 
026A8:  MOVLW  00
026AA:  MOVWF  01
026AC:  MOVLB  9
026AE:  BRA    2A72
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
026B0:  MOVF   x0D,W
026B2:  SUBLW  03
026B4:  BC    2746
026B6:  XORLW  FF
026B8:  BNZ   26C0
026BA:  MOVF   x0C,W
026BC:  SUBLW  4B
026BE:  BC    2746
026C0:  MOVF   x0D,W
026C2:  SUBLW  04
026C4:  BNC   2746
026C6:  BNZ   26CE
026C8:  MOVF   x0C,W
026CA:  SUBLW  93
026CC:  BNC   2746
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
026CE:  MOVF   x0F,W
026D0:  SUBLW  00
026D2:  BC    26E4
026D4:  XORLW  FF
026D6:  BNZ   26DE
026D8:  MOVF   x0E,W
026DA:  SUBLW  00
026DC:  BC    26E4
026DE:  MOVLW  03
026E0:  MOVWF  01
026E2:  BRA    2A72
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
026E4:  MOVLW  4C
026E6:  SUBWF  x0C,W
026E8:  MOVWF  x10
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
026EA:  MOVFF  910,918
026EE:  MOVLW  06
026F0:  MOVWF  x19
026F2:  MOVLB  0
026F4:  CALL   0AAA
026F8:  MOVFF  00,911
.................... 		n = n / 6; /* number of sentence */ 
026FC:  MOVFF  910,918
02700:  MOVLW  06
02702:  MOVLB  9
02704:  MOVWF  x19
02706:  MOVLB  0
02708:  CALL   0AAA
0270C:  MOVFF  01,910
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
02710:  MOVLB  9
02712:  MOVF   x10,W
02714:  MULLW  06
02716:  MOVF   FF3,W
02718:  CLRF   03
0271A:  ADDLW  1A
0271C:  MOVWF  x12
0271E:  MOVLW  00
02720:  ADDWFC 03,W
02722:  MOVWF  x13
02724:  CLRF   03
02726:  MOVF   x11,W
02728:  ADDWF  x12,W
0272A:  MOVWF  01
0272C:  MOVF   x13,W
0272E:  ADDWFC 03,F
02730:  MOVF   01,W
02732:  ADDLW  36
02734:  MOVWF  FE9
02736:  MOVLW  00
02738:  ADDWFC 03,W
0273A:  MOVWF  FEA
0273C:  MOVFF  90E,FEF
.................... 		 
.................... 		return 0; 
02740:  MOVLW  00
02742:  MOVWF  01
02744:  BRA    2A72
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
02746:  MOVLB  1
02748:  MOVF   xD9,F
0274A:  BZ    2782
.................... 		if ( 1000 == address ) { 
0274C:  MOVLB  9
0274E:  MOVF   x0C,W
02750:  SUBLW  E8
02752:  BNZ   2766
02754:  MOVF   x0D,W
02756:  SUBLW  03
02758:  BNZ   2766
.................... 			config.serial_prefix=value; 
0275A:  MOVFF  90E,3A
.................... 			return 0; 
0275E:  MOVLW  00
02760:  MOVWF  01
02762:  BRA    2A72
.................... 		} else if ( 1001 == address ) { 
02764:  BRA    2780
02766:  MOVF   x0C,W
02768:  SUBLW  E9
0276A:  BNZ   2780
0276C:  MOVF   x0D,W
0276E:  SUBLW  03
02770:  BNZ   2780
.................... 			config.serial_number=value; 
02772:  MOVFF  90F,3C
02776:  MOVFF  90E,3B
.................... 			return 0; 
0277A:  MOVLW  00
0277C:  MOVWF  01
0277E:  BRA    2A72
02780:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
02782:  MOVLB  9
02784:  MOVF   x0C,W
02786:  MOVWF  00
02788:  MOVF   x0D,W
0278A:  MOVWF  03
0278C:  MOVF   03,W
0278E:  BNZ   279C
02790:  MOVLW  37
02792:  SUBWF  00,W
02794:  MOVLB  0
02796:  BTFSC  FD8.2
02798:  BRA    2888
0279A:  MOVLB  9
0279C:  MOVLW  03
0279E:  SUBWF  03,W
027A0:  BNZ   27AE
027A2:  MOVLW  EE
027A4:  SUBWF  00,W
027A6:  MOVLB  0
027A8:  BTFSC  FD8.2
027AA:  BRA    289E
027AC:  MOVLB  9
027AE:  MOVLW  03
027B0:  SUBWF  03,W
027B2:  BNZ   27C0
027B4:  MOVLW  EF
027B6:  SUBWF  00,W
027B8:  MOVLB  0
027BA:  BTFSC  FD8.2
027BC:  BRA    28B8
027BE:  MOVLB  9
027C0:  MOVLW  03
027C2:  SUBWF  03,W
027C4:  BNZ   27D2
027C6:  MOVLW  F0
027C8:  SUBWF  00,W
027CA:  MOVLB  0
027CC:  BTFSC  FD8.2
027CE:  BRA    28C6
027D0:  MOVLB  9
027D2:  MOVLW  03
027D4:  SUBWF  03,W
027D6:  BNZ   27E4
027D8:  MOVLW  F1
027DA:  SUBWF  00,W
027DC:  MOVLB  0
027DE:  BTFSC  FD8.2
027E0:  BRA    28E0
027E2:  MOVLB  9
027E4:  MOVLW  03
027E6:  SUBWF  03,W
027E8:  BNZ   27F6
027EA:  MOVLW  F2
027EC:  SUBWF  00,W
027EE:  MOVLB  0
027F0:  BTFSC  FD8.2
027F2:  BRA    28EC
027F4:  MOVLB  9
027F6:  MOVLW  03
027F8:  SUBWF  03,W
027FA:  BNZ   2808
027FC:  MOVLW  F3
027FE:  SUBWF  00,W
02800:  MOVLB  0
02802:  BTFSC  FD8.2
02804:  BRA    2908
02806:  MOVLB  9
02808:  MOVLW  03
0280A:  SUBWF  03,W
0280C:  BNZ   281A
0280E:  MOVLW  F4
02810:  SUBWF  00,W
02812:  MOVLB  0
02814:  BTFSC  FD8.2
02816:  BRA    2922
02818:  MOVLB  9
0281A:  MOVLW  03
0281C:  SUBWF  03,W
0281E:  BNZ   282C
02820:  MOVLW  F5
02822:  SUBWF  00,W
02824:  MOVLB  0
02826:  BTFSC  FD8.2
02828:  BRA    293C
0282A:  MOVLB  9
0282C:  MOVLW  03
0282E:  SUBWF  03,W
02830:  BNZ   283E
02832:  MOVLW  F6
02834:  SUBWF  00,W
02836:  MOVLB  0
02838:  BTFSC  FD8.2
0283A:  BRA    29DA
0283C:  MOVLB  9
0283E:  MOVLW  07
02840:  SUBWF  03,W
02842:  BNZ   2850
02844:  MOVLW  CD
02846:  SUBWF  00,W
02848:  MOVLB  0
0284A:  BTFSC  FD8.2
0284C:  BRA    29F4
0284E:  MOVLB  9
02850:  MOVLW  07
02852:  SUBWF  03,W
02854:  BNZ   2862
02856:  MOVLW  CE
02858:  SUBWF  00,W
0285A:  MOVLB  0
0285C:  BTFSC  FD8.2
0285E:  BRA    2A08
02860:  MOVLB  9
02862:  MOVLW  07
02864:  SUBWF  03,W
02866:  BNZ   2874
02868:  MOVLW  CF
0286A:  SUBWF  00,W
0286C:  MOVLB  0
0286E:  BTFSC  FD8.2
02870:  BRA    2A22
02872:  MOVLB  9
02874:  MOVLW  4E
02876:  SUBWF  03,W
02878:  BNZ   2886
0287A:  MOVLW  1F
0287C:  SUBWF  00,W
0287E:  MOVLB  0
02880:  BTFSC  FD8.2
02882:  BRA    2A3C
02884:  MOVLB  9
02886:  BRA    2A64
.................... 		case 55: 
.................... 			if ( 0 != value ) return ILLEGAL_DATA_VALUE; 
02888:  MOVLB  9
0288A:  MOVF   x0E,F
0288C:  BNZ   2892
0288E:  MOVF   x0F,F
02890:  BZ    2898
02892:  MOVLW  03
02894:  MOVWF  01
02896:  BRA    2A72
.................... 			current.latch_sw_magnet=0; 
02898:  MOVLB  1
0289A:  CLRF   xE8
.................... 			break;			 
0289C:  BRA    2A6C
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
0289E:  MOVLB  9
028A0:  MOVF   x0F,F
028A2:  BNZ   28AA
028A4:  MOVF   x0E,W
028A6:  SUBLW  80
028A8:  BC    28B0
028AA:  MOVLW  03
028AC:  MOVWF  01
028AE:  BRA    2A72
.................... 			config.modbus_address=value; 
028B0:  MOVFF  90E,36
.................... 			break; 
028B4:  MOVLB  1
028B6:  BRA    2A6C
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
028B8:  MOVLB  1
028BA:  BSF    xFD.1
.................... 			config.adc_sample_ticks=value; 
028BC:  MOVFF  90F,3E
028C0:  MOVFF  90E,3D
.................... 			break; 
028C4:  BRA    2A6C
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
028C6:  MOVLB  9
028C8:  MOVF   x0F,F
028CA:  BNZ   28D2
028CC:  MOVF   x0E,W
028CE:  SUBLW  01
028D0:  BC    28D8
028D2:  MOVLW  03
028D4:  MOVWF  01
028D6:  BRA    2A72
.................... 			config.allow_bootload_request=value; 
028D8:  MOVFF  90E,3F
.................... 			break; 
028DC:  MOVLB  1
028DE:  BRA    2A6C
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
028E0:  MOVFF  90F,41
028E4:  MOVFF  90E,40
.................... 			break; 
028E8:  MOVLB  1
028EA:  BRA    2A6C
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
028EC:  MOVLB  9
028EE:  MOVF   x0E,F
028F0:  BNZ   28FC
028F2:  MOVF   x0F,F
028F4:  BNZ   28FC
028F6:  MOVLW  03
028F8:  MOVWF  01
028FA:  BRA    2A72
.................... 			config.pi_offtime_seconds=value; 
028FC:  MOVFF  90F,43
02900:  MOVFF  90E,42
.................... 			break; 
02904:  MOVLB  1
02906:  BRA    2A6C
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02908:  MOVLB  9
0290A:  MOVF   x0F,F
0290C:  BNZ   2914
0290E:  MOVF   x0E,W
02910:  SUBLW  01
02912:  BC    291A
02914:  MOVLW  03
02916:  MOVWF  01
02918:  BRA    2A72
.................... 			config.power_startup=value; 
0291A:  MOVFF  90E,44
.................... 			break; 
0291E:  MOVLB  1
02920:  BRA    2A6C
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
02922:  MOVLB  9
02924:  MOVF   x0F,F
02926:  BNZ   292E
02928:  MOVF   x0E,W
0292A:  SUBLW  02
0292C:  BC    2934
0292E:  MOVLW  03
02930:  MOVWF  01
02932:  BRA    2A72
.................... 			config.rs485_port_mode=value; 
02934:  MOVFF  90E,38
.................... 			break; 
02938:  MOVLB  1
0293A:  BRA    2A6C
.................... 		 
.................... 		case 1013: 
....................  
.................... 			n=0; 
0293C:  MOVLB  9
0293E:  CLRF   x10
.................... 			if ( 1200 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_1200; } 
02940:  MOVF   x0E,W
02942:  SUBLW  B0
02944:  BNZ   2952
02946:  MOVF   x0F,W
02948:  SUBLW  04
0294A:  BNZ   2952
0294C:  MOVLW  01
0294E:  MOVWF  x10
02950:  CLRF   39
.................... 			if ( 2400 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_2400; } 
02952:  MOVF   x0E,W
02954:  SUBLW  60
02956:  BNZ   2964
02958:  MOVF   x0F,W
0295A:  SUBLW  09
0295C:  BNZ   2964
0295E:  MOVLW  01
02960:  MOVWF  x10
02962:  MOVWF  39
.................... 			if ( 4800 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_4800; } 
02964:  MOVF   x0E,W
02966:  SUBLW  C0
02968:  BNZ   2978
0296A:  MOVF   x0F,W
0296C:  SUBLW  12
0296E:  BNZ   2978
02970:  MOVLW  01
02972:  MOVWF  x10
02974:  MOVLW  02
02976:  MOVWF  39
.................... 			if ( 9600 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_9600; } 
02978:  MOVF   x0E,W
0297A:  SUBLW  80
0297C:  BNZ   298C
0297E:  MOVF   x0F,W
02980:  SUBLW  25
02982:  BNZ   298C
02984:  MOVLW  01
02986:  MOVWF  x10
02988:  MOVLW  03
0298A:  MOVWF  39
.................... 			if ( 19200 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_19200; } 
0298C:  MOVF   x0E,F
0298E:  BNZ   299E
02990:  MOVF   x0F,W
02992:  SUBLW  4B
02994:  BNZ   299E
02996:  MOVLW  01
02998:  MOVWF  x10
0299A:  MOVLW  04
0299C:  MOVWF  39
.................... 			if ( 38400 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_38400; } 
0299E:  MOVF   x0E,F
029A0:  BNZ   29B0
029A2:  MOVF   x0F,W
029A4:  SUBLW  96
029A6:  BNZ   29B0
029A8:  MOVLW  01
029AA:  MOVWF  x10
029AC:  MOVLW  05
029AE:  MOVWF  39
.................... 			if ( 57600 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_57600; } 
029B0:  MOVF   x0E,F
029B2:  BNZ   29C2
029B4:  MOVF   x0F,W
029B6:  SUBLW  E1
029B8:  BNZ   29C2
029BA:  MOVLW  01
029BC:  MOVWF  x10
029BE:  MOVLW  06
029C0:  MOVWF  39
....................  
.................... 			if (  1==n ) { 
029C2:  DECFSZ x10,W
029C4:  BRA    29D0
.................... 				set_rs485_speed(); 
029C6:  MOVLB  0
029C8:  CALL   0D8C
.................... 			}  else { 
029CC:  BRA    29D6
029CE:  MOVLB  9
.................... 				return ILLEGAL_DATA_VALUE; 
029D0:  MOVLW  03
029D2:  MOVWF  01
029D4:  BRA    2A72
.................... 			} 
.................... 			break; 
029D6:  MOVLB  1
029D8:  BRA    2A6C
....................  
....................  
.................... 		case 1014: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
029DA:  MOVLB  9
029DC:  MOVF   x0F,F
029DE:  BNZ   29E6
029E0:  MOVF   x0E,W
029E2:  SUBLW  01
029E4:  BC    29EC
029E6:  MOVLW  03
029E8:  MOVWF  01
029EA:  BRA    2A72
.................... 			config.pic_to_pi_latch_mask=value; 
029EC:  MOVFF  90E,4F
.................... 			break; 
029F0:  MOVLB  1
029F2:  BRA    2A6C
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
029F4:  MOVLB  9
029F6:  DECFSZ x0E,W
029F8:  BRA    29FE
029FA:  MOVF   x0F,F
029FC:  BZ    2A04
029FE:  MOVLW  03
02A00:  MOVWF  01
02A02:  BRA    2A72
.................... 			reset_cpu(); 
02A04:  RESET
02A06:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A08:  MOVLB  9
02A0A:  DECFSZ x0E,W
02A0C:  BRA    2A12
02A0E:  MOVF   x0F,F
02A10:  BZ    2A18
02A12:  MOVLW  03
02A14:  MOVWF  01
02A16:  BRA    2A72
.................... 			write_default_param_file(); 
02A18:  MOVLB  0
02A1A:  CALL   0CE4
.................... 			break; 
02A1E:  MOVLB  1
02A20:  BRA    2A6C
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A22:  MOVLB  9
02A24:  DECFSZ x0E,W
02A26:  BRA    2A2C
02A28:  MOVF   x0F,F
02A2A:  BZ    2A32
02A2C:  MOVLW  03
02A2E:  MOVWF  01
02A30:  BRA    2A72
.................... 			write_param_file(); 
02A32:  MOVLB  0
02A34:  CALL   0C90
.................... 			break; 
02A38:  MOVLB  1
02A3A:  BRA    2A6C
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
02A3C:  MOVLB  9
02A3E:  MOVF   x0E,W
02A40:  SUBLW  0A
02A42:  BNZ   2A4A
02A44:  MOVF   x0F,W
02A46:  SUBLW  07
02A48:  BZ    2A56
.................... 				current.factory_unlocked=0; 
02A4A:  MOVLB  1
02A4C:  CLRF   xD9
.................... 				return ILLEGAL_DATA_VALUE; 
02A4E:  MOVLW  03
02A50:  MOVWF  01
02A52:  MOVLB  9
02A54:  BRA    2A72
.................... 			} 
.................... 			current.factory_unlocked=1; 
02A56:  MOVLW  01
02A58:  MOVLB  1
02A5A:  MOVWF  xD9
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02A5C:  MOVLW  C8
02A5E:  MOVWF  xFA
.................... 			break; 
02A60:  BRA    2A6C
02A62:  MOVLB  9
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02A64:  MOVLW  02
02A66:  MOVWF  01
02A68:  BRA    2A72
02A6A:  MOVLB  1
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02A6C:  MOVLW  00
02A6E:  MOVWF  01
02A70:  MOVLB  9
.................... } 
02A72:  MOVLB  0
02A74:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02B06:  GOTO   11B6
02B0A:  MOVF   01,F
02B0C:  BTFSC  FD8.2
02B0E:  BRA    2E02
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02B10:  DECFSZ 38,W
02B12:  BRA    2BC6
02B14:  MOVF   36,W
02B16:  MOVLB  7
02B18:  SUBWF  xEE,W
02B1A:  BTFSS  FD8.2
02B1C:  BRA    2B22
02B1E:  MOVLB  0
02B20:  BRA    2BC6
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02B22:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02B24:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02B26:  CLRWDT
02B28:  MOVLW  02
02B2A:  MOVLB  9
02B2C:  MOVWF  x04
02B2E:  MOVLW  B5
02B30:  MOVWF  x07
02B32:  MOVLB  0
02B34:  CALL   11DC
02B38:  MOVLB  9
02B3A:  DECFSZ x04,F
02B3C:  BRA    2B2E
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02B3E:  MOVLB  7
02B40:  MOVF   xEE,W
02B42:  MOVLB  0
02B44:  CALL   11FC
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02B48:  CLRWDT
02B4A:  MOVLW  67
02B4C:  MOVWF  00
02B4E:  DECFSZ 00,F
02B50:  BRA    2B4E
02B52:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02B54:  MOVLB  7
02B56:  MOVF   xF0,W
02B58:  MOVLB  0
02B5A:  CALL   11FC
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02B5E:  CLRWDT
02B60:  MOVLW  67
02B62:  MOVWF  00
02B64:  DECFSZ 00,F
02B66:  BRA    2B64
02B68:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02B6A:  MOVLB  9
02B6C:  CLRF   x03
02B6E:  MOVLW  02
02B70:  MOVLB  7
02B72:  ADDWF  xEF,W
02B74:  MOVLB  9
02B76:  SUBWF  x03,W
02B78:  BC    2BA6
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02B7A:  MOVLW  F2
02B7C:  ADDWF  x03,W
02B7E:  MOVWF  FE9
02B80:  MOVLW  07
02B82:  MOVWF  FEA
02B84:  BTFSC  FD8.0
02B86:  INCF   FEA,F
02B88:  MOVFF  FEF,904
02B8C:  MOVF   x04,W
02B8E:  MOVLB  0
02B90:  CALL   11FC
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02B94:  CLRWDT
02B96:  MOVLW  67
02B98:  MOVWF  00
02B9A:  DECFSZ 00,F
02B9C:  BRA    2B9A
02B9E:  NOP   
.................... 			} 
02BA0:  MOVLB  9
02BA2:  INCF   x03,F
02BA4:  BRA    2B6E
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02BA6:  BTFSS  F72.1
02BA8:  BRA    2BA6
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02BAA:  CLRWDT
02BAC:  MOVLW  02
02BAE:  MOVWF  x04
02BB0:  MOVLW  B5
02BB2:  MOVWF  x07
02BB4:  MOVLB  0
02BB6:  CALL   11DC
02BBA:  MOVLB  9
02BBC:  DECFSZ x04,F
02BBE:  BRA    2BB0
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02BC0:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02BC2:  BCF    F8C.0
02BC4:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02BC6:  MOVF   36,W
02BC8:  SUBLW  80
02BCA:  BZ    2BD8
02BCC:  MOVF   36,W
02BCE:  MOVLB  7
02BD0:  SUBWF  xEE,W
02BD2:  BTFSS  FD8.2
02BD4:  BRA    2DEC
02BD6:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02BD8:  MOVLB  1
02BDA:  INCFSZ xCD,W
02BDC:  BRA    2BE4
02BDE:  INCFSZ xCE,W
02BE0:  BRA    2BE4
02BE2:  BRA    2BEA
.................... 				current.modbus_our_packets++; 
02BE4:  INCF   xCD,F
02BE6:  BTFSC  FD8.2
02BE8:  INCF   xCE,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02BEA:  MOVLW  14
02BEC:  MOVWF  xFA
....................  
.................... 			switch(modbus_rx.func) { 
02BEE:  MOVLB  7
02BF0:  MOVF   xF0,W
02BF2:  XORLW  03
02BF4:  MOVLB  0
02BF6:  BZ    2C08
02BF8:  XORLW  07
02BFA:  BZ    2C08
02BFC:  XORLW  02
02BFE:  BZ    2C88
02C00:  XORLW  16
02C02:  BTFSC  FD8.2
02C04:  BRA    2CFA
02C06:  BRA    2DC4
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02C08:  MOVFF  7F2,8FF
02C0C:  MOVFF  7F3,8FE
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02C10:  MOVFF  7F4,901
02C14:  MOVFF  7F5,900
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02C18:  MOVLB  9
02C1A:  MOVF   x00,W
02C1C:  MOVLB  8
02C1E:  ADDWF  xFE,W
02C20:  MOVLB  9
02C22:  MOVWF  x04
02C24:  MOVF   x01,W
02C26:  MOVLB  8
02C28:  ADDWFC xFF,W
02C2A:  MOVLB  9
02C2C:  MOVWF  x05
02C2E:  MOVFF  8FF,909
02C32:  MOVFF  8FE,908
02C36:  MOVWF  x0B
02C38:  MOVFF  904,90A
02C3C:  MOVLB  0
02C3E:  GOTO   1204
02C42:  MOVF   01,F
02C44:  BNZ   2C6A
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02C46:  MOVFF  7EE,906
02C4A:  MOVLB  9
02C4C:  CLRF   x08
02C4E:  MOVFF  7F0,907
02C52:  MOVLW  02
02C54:  MOVWF  x09
02C56:  MOVLB  0
02C58:  CALL   138E
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02C5C:  MOVLB  1
02C5E:  CLRF   xD2
02C60:  MOVLW  02
02C62:  MOVWF  xD1
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02C64:  CLRF   xFA
.................... 					} else { 
02C66:  BRA    2C86
02C68:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02C6A:  MOVFF  7F0,906
02C6E:  MOVFF  7EE,907
02C72:  MOVFF  8FF,909
02C76:  MOVFF  8FE,908
02C7A:  MOVFF  901,90B
02C7E:  MOVFF  900,90A
02C82:  BRA    25B0
02C84:  MOVLB  1
.................... 					} 
.................... 					break; 
02C86:  BRA    2DE4
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02C88:  MOVFF  7F2,8FF
02C8C:  MOVFF  7F3,8FE
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02C90:  MOVFF  7F4,905
02C94:  MOVFF  7F5,904
02C98:  MOVFF  8FF,90D
02C9C:  MOVFF  8FE,90C
02CA0:  MOVFF  7F4,90F
02CA4:  MOVFF  7F5,90E
02CA8:  RCALL  2632
02CAA:  MOVFF  01,902
....................  
.................... 					if ( result ) { 
02CAE:  MOVLB  9
02CB0:  MOVF   x02,F
02CB2:  BZ    2CD6
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02CB4:  MOVFF  7EE,906
02CB8:  CLRF   x08
02CBA:  MOVFF  7F0,907
02CBE:  MOVFF  902,909
02CC2:  MOVLB  0
02CC4:  CALL   138E
.................... 						current.modbus_last_error=result; 
02CC8:  MOVLB  1
02CCA:  CLRF   xD2
02CCC:  MOVFF  902,1D1
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02CD0:  CLRF   xFA
.................... 					}  else { 
02CD2:  BRA    2CF8
02CD4:  MOVLB  9
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02CD6:  MOVFF  7F4,905
02CDA:  MOVFF  7F5,904
02CDE:  MOVFF  7EE,908
02CE2:  MOVFF  8FF,90A
02CE6:  MOVFF  8FE,909
02CEA:  MOVFF  7F4,90C
02CEE:  MOVFF  7F5,90B
02CF2:  MOVLB  0
02CF4:  BRA    2A76
02CF6:  MOVLB  1
.................... 					} 
.................... 					break; 
02CF8:  BRA    2DE4
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02CFA:  MOVFF  7F2,8FF
02CFE:  MOVFF  7F3,8FE
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02D02:  MOVFF  7F4,901
02D06:  MOVFF  7F5,900
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02D0A:  MOVLB  9
02D0C:  CLRF   x03
02D0E:  MOVF   x01,F
02D10:  BNZ   2D18
02D12:  MOVF   x00,W
02D14:  SUBWF  x03,W
02D16:  BC    2DA4
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02D18:  MOVF   x03,W
02D1A:  MOVLB  8
02D1C:  ADDWF  xFE,W
02D1E:  MOVLB  9
02D20:  MOVWF  x04
02D22:  MOVLW  00
02D24:  MOVLB  8
02D26:  ADDWFC xFF,W
02D28:  MOVLB  9
02D2A:  MOVWF  x05
02D2C:  BCF    FD8.0
02D2E:  RLCF   x03,W
02D30:  ADDLW  05
02D32:  ADDLW  F2
02D34:  MOVWF  FE9
02D36:  MOVLW  07
02D38:  MOVWF  FEA
02D3A:  BTFSC  FD8.0
02D3C:  INCF   FEA,F
02D3E:  MOVFF  FEF,906
02D42:  BCF    FD8.0
02D44:  RLCF   x03,W
02D46:  ADDLW  06
02D48:  ADDLW  F2
02D4A:  MOVWF  FE9
02D4C:  MOVLW  07
02D4E:  MOVWF  FEA
02D50:  BTFSC  FD8.0
02D52:  INCF   FEA,F
02D54:  MOVFF  FEF,907
02D58:  MOVFF  906,909
02D5C:  MOVFF  907,908
02D60:  MOVFF  905,90D
02D64:  MOVFF  904,90C
02D68:  MOVFF  906,90F
02D6C:  MOVFF  907,90E
02D70:  MOVLB  0
02D72:  RCALL  2632
02D74:  MOVFF  01,902
....................  
.................... 						if ( result ) { 
02D78:  MOVLB  9
02D7A:  MOVF   x02,F
02D7C:  BZ    2DA0
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02D7E:  MOVFF  7EE,906
02D82:  CLRF   x08
02D84:  MOVFF  7F0,907
02D88:  MOVFF  902,909
02D8C:  MOVLB  0
02D8E:  CALL   138E
.................... 							current.modbus_last_error=result; 
02D92:  MOVLB  1
02D94:  CLRF   xD2
02D96:  MOVFF  902,1D1
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02D9A:  CLRF   xFA
.................... 			 
.................... 							break; 
02D9C:  MOVLB  9
02D9E:  BRA    2DA4
.................... 						} 
.................... 					} 
02DA0:  INCF   x03,F
02DA2:  BRA    2D0E
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02DA4:  MOVF   x02,F
02DA6:  BNZ   2DC0
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02DA8:  MOVFF  7EE,906
02DAC:  MOVFF  8FF,908
02DB0:  MOVFF  8FE,907
02DB4:  MOVFF  901,90A
02DB8:  MOVFF  900,909
02DBC:  MOVLB  0
02DBE:  BRA    2ABE
.................... 					} 
....................  
.................... 					break;   
02DC0:  MOVLB  1
02DC2:  BRA    2DE4
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02DC4:  MOVFF  7EE,906
02DC8:  MOVLB  9
02DCA:  CLRF   x08
02DCC:  MOVFF  7F0,907
02DD0:  MOVLW  01
02DD2:  MOVWF  x09
02DD4:  MOVLB  0
02DD6:  CALL   138E
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02DDA:  MOVLB  1
02DDC:  CLRF   xD2
02DDE:  MOVLW  01
02DE0:  MOVWF  xD1
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02DE2:  CLRF   xFA
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02DE4:  CLRF   xDB
02DE6:  CLRF   xDA
....................  
.................... 		} else { 
02DE8:  BRA    2E02
02DEA:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02DEC:  MOVLB  1
02DEE:  INCFSZ xCF,W
02DF0:  BRA    2DF8
02DF2:  INCFSZ xD0,W
02DF4:  BRA    2DF8
02DF6:  BRA    2DFE
.................... 				current.modbus_other_packets++; 
02DF8:  INCF   xCF,F
02DFA:  BTFSC  FD8.2
02DFC:  INCF   xD0,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02DFE:  MOVLW  0A
02E00:  MOVWF  xFA
02E02:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02E04:  GOTO   32F2 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003EE:  MOVLB  A
003F0:  BTFSS  x13.0
003F2:  BRA    040C
003F4:  MOVLB  1
003F6:  INCFSZ xE9,W
003F8:  BRA    0404
003FA:  INCFSZ xEA,W
003FC:  BRA    0404
003FE:  MOVLB  A
00400:  BRA    040C
00402:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00404:  INCF   xE9,F
00406:  BTFSC  FD8.2
00408:  INCF   xEA,F
0040A:  MOVLB  A
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0040C:  BTFSS  x13.2
0040E:  BRA    0428
00410:  MOVLB  1
00412:  INCFSZ xEB,W
00414:  BRA    0420
00416:  INCFSZ xEC,W
00418:  BRA    0420
0041A:  MOVLB  A
0041C:  BRA    0428
0041E:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00420:  INCF   xEB,F
00422:  BTFSC  FD8.2
00424:  INCF   xEC,F
00426:  MOVLB  A
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
00428:  BTFSS  x13.4
0042A:  BRA    0444
0042C:  MOVLB  1
0042E:  INCFSZ xED,W
00430:  BRA    043C
00432:  INCFSZ xEE,W
00434:  BRA    043C
00436:  MOVLB  A
00438:  BRA    0444
0043A:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
0043C:  INCF   xED,F
0043E:  BTFSC  FD8.2
00440:  INCF   xEE,F
00442:  MOVLB  A
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00444:  BCF    x13.1
00446:  BTFSC  F81.0
00448:  BSF    x13.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0044A:  BTFSC  x13.1
0044C:  BRA    04D0
0044E:  MOVLB  7
00450:  BTFSC  xEA.1
00452:  BRA    0458
00454:  MOVLB  A
00456:  BRA    04D0
.................... 		current.pulse_count[0]++; 
00458:  MOVLB  0
0045A:  INCF   xAA,F
0045C:  BTFSC  FD8.2
0045E:  INCF   xAB,F
.................... 		current.pulse_sum[0]++; 
00460:  MOVLW  01
00462:  ADDWF  xB0,F
00464:  BTFSC  FD8.0
00466:  INCF   xB1,F
00468:  BTFSC  FD8.2
0046A:  INCF   xB2,F
0046C:  BTFSC  FD8.2
0046E:  INCF   xB3,F
.................... 		if ( 1 == ext0_state ) { 
00470:  MOVLB  7
00472:  BTFSS  xEA.2
00474:  BRA    04BE
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
00476:  MOVLB  A
00478:  BCF    x13.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0047A:  MOVFF  1EA,99
0047E:  MOVFF  1E9,98
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
00482:  MOVLB  0
00484:  MOVF   x99,W
00486:  SUBWF  x9F,W
00488:  BNC   049A
0048A:  BNZ   0492
0048C:  MOVF   x9E,W
0048E:  SUBWF  x98,W
00490:  BC    049A
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00492:  MOVFF  99,9F
00496:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0049A:  MOVF   xA5,W
0049C:  SUBWF  x99,W
0049E:  BNC   04BA
004A0:  BNZ   04A8
004A2:  MOVF   x98,W
004A4:  SUBWF  xA4,W
004A6:  BC    04BA
004A8:  INCFSZ x98,W
004AA:  BRA    04B2
004AC:  INCFSZ x99,W
004AE:  BRA    04B2
004B0:  BRA    04BA
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004B2:  MOVFF  99,A5
004B6:  MOVFF  98,A4
.................... 			} 
.................... 			ext0_state=0; 
004BA:  MOVLB  7
004BC:  BCF    xEA.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004BE:  BTFSC  xEA.2
004C0:  BRA    04D0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004C2:  MOVLB  1
004C4:  CLRF   xEA
004C6:  CLRF   xE9
.................... 			ext0_count=1; 
004C8:  MOVLB  A
004CA:  BSF    x13.0
.................... 			ext0_state=1; 
004CC:  MOVLB  7
004CE:  BSF    xEA.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004D0:  MOVLB  7
004D2:  BCF    xEA.1
004D4:  MOVLB  A
004D6:  BTFSS  x13.1
004D8:  BRA    04E0
004DA:  MOVLB  7
004DC:  BSF    xEA.1
004DE:  MOVLB  A
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004E0:  BCF    x13.3
004E2:  BTFSC  F81.1
004E4:  BSF    x13.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004E6:  BTFSC  x13.3
004E8:  BRA    056C
004EA:  MOVLB  7
004EC:  BTFSC  xEA.3
004EE:  BRA    04F4
004F0:  MOVLB  A
004F2:  BRA    056C
.................... 		current.pulse_count[1]++; 
004F4:  MOVLB  0
004F6:  INCF   xAC,F
004F8:  BTFSC  FD8.2
004FA:  INCF   xAD,F
.................... 		current.pulse_sum[1]++; 
004FC:  MOVLW  01
004FE:  ADDWF  xB4,F
00500:  BTFSC  FD8.0
00502:  INCF   xB5,F
00504:  BTFSC  FD8.2
00506:  INCF   xB6,F
00508:  BTFSC  FD8.2
0050A:  INCF   xB7,F
.................... 		if ( 1 == ext1_state ) { 
0050C:  MOVLB  7
0050E:  BTFSS  xEA.4
00510:  BRA    055A
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00512:  MOVLB  A
00514:  BCF    x13.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00516:  MOVFF  1EC,9B
0051A:  MOVFF  1EB,9A
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
0051E:  MOVLB  0
00520:  MOVF   x9B,W
00522:  SUBWF  xA1,W
00524:  BNC   0536
00526:  BNZ   052E
00528:  MOVF   xA0,W
0052A:  SUBWF  x9A,W
0052C:  BC    0536
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0052E:  MOVFF  9B,A1
00532:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00536:  MOVF   xA7,W
00538:  SUBWF  x9B,W
0053A:  BNC   0556
0053C:  BNZ   0544
0053E:  MOVF   x9A,W
00540:  SUBWF  xA6,W
00542:  BC    0556
00544:  INCFSZ x9A,W
00546:  BRA    054E
00548:  INCFSZ x9B,W
0054A:  BRA    054E
0054C:  BRA    0556
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
0054E:  MOVFF  9B,A7
00552:  MOVFF  9A,A6
.................... 			} 
.................... 			ext1_state=0; 
00556:  MOVLB  7
00558:  BCF    xEA.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0055A:  BTFSC  xEA.4
0055C:  BRA    056C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
0055E:  MOVLB  1
00560:  CLRF   xEC
00562:  CLRF   xEB
.................... 			ext1_count=1; 
00564:  MOVLB  A
00566:  BSF    x13.2
.................... 			ext1_state=1; 
00568:  MOVLB  7
0056A:  BSF    xEA.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
0056C:  MOVLB  7
0056E:  BCF    xEA.3
00570:  MOVLB  A
00572:  BTFSS  x13.3
00574:  BRA    057C
00576:  MOVLB  7
00578:  BSF    xEA.3
0057A:  MOVLB  A
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0057C:  BCF    x13.5
0057E:  BTFSC  F81.2
00580:  BSF    x13.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00582:  BTFSC  x13.5
00584:  BRA    0608
00586:  MOVLB  7
00588:  BTFSC  xEA.5
0058A:  BRA    0590
0058C:  MOVLB  A
0058E:  BRA    0608
.................... 		current.pulse_count[2]++; 
00590:  MOVLB  0
00592:  INCF   xAE,F
00594:  BTFSC  FD8.2
00596:  INCF   xAF,F
.................... 		current.pulse_sum[2]++; 
00598:  MOVLW  01
0059A:  ADDWF  xB8,F
0059C:  BTFSC  FD8.0
0059E:  INCF   xB9,F
005A0:  BTFSC  FD8.2
005A2:  INCF   xBA,F
005A4:  BTFSC  FD8.2
005A6:  INCF   xBB,F
.................... 		if ( 1 == ext2_state ) { 
005A8:  MOVLB  7
005AA:  BTFSS  xEA.6
005AC:  BRA    05F6
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
005AE:  MOVLB  A
005B0:  BCF    x13.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005B2:  MOVFF  1EE,9D
005B6:  MOVFF  1ED,9C
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005BA:  MOVLB  0
005BC:  MOVF   x9D,W
005BE:  SUBWF  xA3,W
005C0:  BNC   05D2
005C2:  BNZ   05CA
005C4:  MOVF   xA2,W
005C6:  SUBWF  x9C,W
005C8:  BC    05D2
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005CA:  MOVFF  9D,A3
005CE:  MOVFF  9C,A2
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005D2:  MOVF   xA9,W
005D4:  SUBWF  x9D,W
005D6:  BNC   05F2
005D8:  BNZ   05E0
005DA:  MOVF   x9C,W
005DC:  SUBWF  xA8,W
005DE:  BC    05F2
005E0:  INCFSZ x9C,W
005E2:  BRA    05EA
005E4:  INCFSZ x9D,W
005E6:  BRA    05EA
005E8:  BRA    05F2
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005EA:  MOVFF  9D,A9
005EE:  MOVFF  9C,A8
.................... 			} 
.................... 			ext2_state=0; 
005F2:  MOVLB  7
005F4:  BCF    xEA.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005F6:  BTFSC  xEA.6
005F8:  BRA    0608
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005FA:  MOVLB  1
005FC:  CLRF   xEE
005FE:  CLRF   xED
.................... 			ext2_count=1; 
00600:  MOVLB  A
00602:  BSF    x13.4
.................... 			ext2_state=1; 
00604:  MOVLB  7
00606:  BSF    xEA.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
00608:  MOVLB  7
0060A:  BCF    xEA.5
0060C:  MOVLB  A
0060E:  BTFSS  x13.5
00610:  BRA    0618
00612:  MOVLB  7
00614:  BSF    xEA.5
00616:  MOVLB  A
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00618:  MOVLB  8
0061A:  INCF   xF5,F
.................... 	if ( 10 == tick ) { 
0061C:  MOVF   xF5,W
0061E:  SUBLW  0A
00620:  BNZ   062A
.................... 		tick=0; 
00622:  CLRF   xF5
.................... 		timers.now_millisecond=1; 
00624:  MOVLB  1
00626:  BSF    xFD.2
00628:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0062A:  BCF    F9E.1
0062C:  MOVLB  0
0062E:  GOTO   013A
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0064A:  BRA    0632
0064C:  MOVFF  01,A10
.................... 	current.rda2_bytes_received++; 
00650:  MOVLB  1
00652:  INCF   xE5,F
00654:  BTFSC  FD8.2
00656:  INCF   xE6,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
00658:  DECFSZ 38,W
0065A:  BRA    067E
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
0065C:  MOVLB  3
0065E:  CLRF   x02
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
00660:  INCFSZ x01,W
00662:  BRA    0666
00664:  BRA    067A
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
00666:  MOVLW  01
00668:  ADDWF  x01,W
0066A:  MOVWF  FE9
0066C:  MOVLW  02
0066E:  MOVWF  FEA
00670:  BTFSC  FD8.0
00672:  INCF   FEA,F
00674:  MOVFF  A10,FEF
.................... 			timers.rda2_buff_pos++; 
00678:  INCF   x01,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
0067A:  BRA    06C0
0067C:  MOVLB  1
0067E:  MOVF   38,W
00680:  SUBLW  02
00682:  BNZ   06C2
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
00684:  MOVLB  A
00686:  MOVF   x10,W
00688:  SUBLW  0A
0068A:  BZ    0692
0068C:  MOVF   x10,W
0068E:  SUBLW  0D
00690:  BNZ   06A2
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
00692:  MOVLB  3
00694:  MOVF   x01,F
00696:  BZ    069E
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
00698:  MOVLW  14
0069A:  MOVWF  x02
.................... 			}  else { 
0069C:  BRA    069E
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
0069E:  BRA    06C0
006A0:  MOVLB  A
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
006A2:  MOVLB  3
006A4:  CLRF   x02
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006A6:  INCFSZ x01,W
006A8:  BRA    06AC
006AA:  BRA    06C0
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
006AC:  MOVLW  01
006AE:  ADDWF  x01,W
006B0:  MOVWF  FE9
006B2:  MOVLW  02
006B4:  MOVWF  FEA
006B6:  BTFSC  FD8.0
006B8:  INCF   FEA,F
006BA:  MOVFF  A10,FEF
.................... 				timers.rda2_buff_pos++; 
006BE:  INCF   x01,F
006C0:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /* transmit buffer empty for Modbus to raspberry pi buffer */ 
006C2:  BCF    FA4.5
006C4:  MOVLB  0
006C6:  GOTO   0094
.................... #int_tbe 
.................... void isr_uart1_tbe() { 
.................... 	if ( timers.rda_tx_pos >= timers.rda_tx_length ) { 
*
006D2:  MOVLB  4
006D4:  MOVF   x03,W
006D6:  SUBWF  x04,W
006D8:  BNC   06E0
.................... 		/* done transmitting */ 
.................... 		timers.now_rda_tx_done=1; 
006DA:  BSF    x05.1
.................... 		disable_interrupts(INT_TBE); 
006DC:  BCF    F9D.4
.................... 	} else { 
006DE:  BRA    06FE
.................... 		/* put another character into TX buffer */ 
.................... 		fputc(timers.rda_tx_buff[timers.rda_tx_pos], STREAM_PI); 
006E0:  MOVLW  03
006E2:  ADDWF  x04,W
006E4:  MOVWF  FE9
006E6:  MOVLW  03
006E8:  MOVWF  FEA
006EA:  BTFSC  FD8.0
006EC:  INCF   FEA,F
006EE:  MOVFF  FEF,A10
006F2:  MOVLB  A
006F4:  MOVF   x10,W
006F6:  MOVLB  0
006F8:  RCALL  06CA
.................... 		timers.rda_tx_pos++; 
006FA:  MOVLB  4
006FC:  INCF   x04,F
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
006FE:  BCF    F9E.4
00700:  MOVLB  0
00702:  GOTO   0094
.................... #int_rda 
.................... void isr_uart1_rx() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
00748:  RCALL  0706
0074A:  MOVFF  01,A10
....................  
.................... 	current.rda_bytes_received++; 
0074E:  MOVLB  1
00750:  INCF   xE3,F
00752:  BTFSC  FD8.2
00754:  INCF   xE4,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
00756:  MOVLB  7
00758:  BTFSC  xEA.0
0075A:  BRA    07B2
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
0075C:  MOVF   xEB,F
0075E:  BNZ   0770
.................... 			modbus_serial_crc.d = 0xFFFF; 
00760:  SETF   xED
00762:  SETF   xEC
.................... 			modbus_rx.address = c; 
00764:  MOVFF  A10,7EE
.................... 			modbus_serial_state++; 
00768:  INCF   xEB,F
.................... 			modbus_rx.len = 0; 
0076A:  CLRF   xEF
.................... 			modbus_rx.error=0; 
0076C:  CLRF   xF1
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
0076E:  BRA    079E
00770:  DECFSZ xEB,W
00772:  BRA    077C
.................... 			modbus_rx.func = c; 
00774:  MOVFF  A10,7F0
.................... 			modbus_serial_state++; 
00778:  INCF   xEB,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
0077A:  BRA    079E
0077C:  MOVF   xEB,W
0077E:  SUBLW  02
00780:  BNZ   079E
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
00782:  INCFSZ xEF,W
00784:  BRA    078A
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00786:  MOVLW  FE
00788:  MOVWF  xEF
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
0078A:  MOVLW  F2
0078C:  ADDWF  xEF,W
0078E:  MOVWF  FE9
00790:  MOVLW  07
00792:  MOVWF  FEA
00794:  BTFSC  FD8.0
00796:  INCF   FEA,F
00798:  MOVFF  A10,FEF
.................... 			modbus_rx.len++; 
0079C:  INCF   xEF,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
0079E:  MOVFF  A10,A11
007A2:  MOVLB  0
007A4:  RCALL  071C
.................... 		modbus_enable_timeout(TRUE); 
007A6:  MOVLW  01
007A8:  MOVLB  A
007AA:  MOVWF  x11
007AC:  MOVLB  0
007AE:  RCALL  03A8
007B0:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
007B2:  BCF    F9E.5
007B4:  MOVLB  0
007B6:  GOTO   0094
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
00D8C:  MOVF   39,W
00D8E:  XORLW  00
00D90:  BZ    0DA8
00D92:  XORLW  01
00D94:  BZ    0DB8
00D96:  XORLW  03
00D98:  BZ    0DC8
00D9A:  XORLW  06
00D9C:  BZ    0DD8
00D9E:  XORLW  01
00DA0:  BZ    0DE4
00DA2:  XORLW  03
00DA4:  BZ    0DF4
00DA6:  BRA    0E00
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
00DA8:  BSF    F70.3
00DAA:  MOVLW  C3
00DAC:  MOVWF  F75
00DAE:  MOVLW  09
00DB0:  MOVWF  F76
00DB2:  MOVLW  A6
00DB4:  MOVWF  F72
00DB6:  BRA    0E0C
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
00DB8:  BSF    F70.3
00DBA:  MOVLW  E1
00DBC:  MOVWF  F75
00DBE:  MOVLW  04
00DC0:  MOVWF  F76
00DC2:  MOVLW  A6
00DC4:  MOVWF  F72
00DC6:  BRA    0E0C
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
00DC8:  BSF    F70.3
00DCA:  MOVLW  70
00DCC:  MOVWF  F75
00DCE:  MOVLW  02
00DD0:  MOVWF  F76
00DD2:  MOVLW  A6
00DD4:  MOVWF  F72
00DD6:  BRA    0E0C
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
00DD8:  BCF    F70.3
00DDA:  MOVLW  26
00DDC:  MOVWF  F75
00DDE:  MOVLW  A6
00DE0:  MOVWF  F72
00DE2:  BRA    0E0C
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
00DE4:  BSF    F70.3
00DE6:  MOVLW  4D
00DE8:  MOVWF  F75
00DEA:  MOVLW  00
00DEC:  MOVWF  F76
00DEE:  MOVLW  A6
00DF0:  MOVWF  F72
00DF2:  BRA    0E0C
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
00DF4:  BCF    F70.3
00DF6:  MOVLW  0C
00DF8:  MOVWF  F75
00DFA:  MOVLW  A6
00DFC:  MOVWF  F72
00DFE:  BRA    0E0C
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
00E00:  BCF    F70.3
00E02:  MOVLW  4D
00E04:  MOVWF  F75
00E06:  MOVLW  A6
00E08:  MOVWF  F72
00E0A:  BRA    0E0C
.................... 	} 
.................... } 
00E0C:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... 	setup_adc(ADC_OFF); 
*
008B4:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
008B6:  MOVLW  08
008B8:  MOVWF  F61
008BA:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
008BC:  MOVLW  00
008BE:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
008C0:  MOVLW  FF
008C2:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
008C4:  MOVLW  92
008C6:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
008C8:  MOVLW  80
008CA:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
008CC:  BCF    F96.0
008CE:  BCF    F96.1
008D0:  BCF    F96.2
008D2:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
008D4:  MOVLB  1
008D6:  CLRF   xFA
.................... 	timers.load_off_seconds=2; 
008D8:  CLRF   xFC
008DA:  MOVLW  02
008DC:  MOVWF  xFB
.................... 	timers.now_adc_sample=0; 
008DE:  BCF    xFD.0
.................... 	timers.now_adc_reset_count=0; 
008E0:  BCF    xFD.1
.................... 	timers.now_millisecond=0; 
008E2:  BCF    xFD.2
.................... 	timers.port_b=0b11111111; 
008E4:  SETF   xFE
.................... 	timers.port_c=0b11111111; 
008E6:  SETF   xFF
....................  
.................... 	timers.rda2_buff_pos=0; 
008E8:  MOVLB  3
008EA:  CLRF   x01
.................... 	timers.rda2_buff_gap=255; 
008EC:  SETF   x02
.................... 	timers.now_parse_rda2=0; 
008EE:  MOVLB  2
008F0:  BCF    x00.0
....................  
.................... 	timers.rda_tx_length=0; 
008F2:  MOVLB  4
008F4:  CLRF   x03
.................... 	timers.rda_tx_pos=0; 
008F6:  CLRF   x04
.................... 	timers.now_rda_tx_ready=0; 
008F8:  BCF    x05.0
.................... 	timers.now_rda_tx_done=0; 
008FA:  BCF    x05.1
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
008FC:  MOVLB  8
008FE:  CLRF   xFE
00900:  MOVF   xFE,W
00902:  SUBLW  02
00904:  BNC   09B4
.................... 		current.pulse_period[i]=0; 
00906:  CLRF   03
00908:  MOVFF  8FE,02
0090C:  BCF    FD8.0
0090E:  RLCF   02,F
00910:  RLCF   03,F
00912:  MOVF   02,W
00914:  ADDLW  98
00916:  MOVWF  FE9
00918:  MOVLW  00
0091A:  ADDWFC 03,W
0091C:  MOVWF  FEA
0091E:  CLRF   FEC
00920:  MOVF   FED,F
00922:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
00924:  CLRF   03
00926:  MOVFF  8FE,02
0092A:  BCF    FD8.0
0092C:  RLCF   02,F
0092E:  RLCF   03,F
00930:  MOVF   02,W
00932:  ADDLW  9E
00934:  MOVWF  FE9
00936:  MOVLW  00
00938:  ADDWFC 03,W
0093A:  MOVWF  FEA
0093C:  SETF   FEC
0093E:  MOVF   FED,F
00940:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00942:  CLRF   03
00944:  MOVFF  8FE,02
00948:  BCF    FD8.0
0094A:  RLCF   02,F
0094C:  RLCF   03,F
0094E:  MOVF   02,W
00950:  ADDLW  A4
00952:  MOVWF  FE9
00954:  MOVLW  00
00956:  ADDWFC 03,W
00958:  MOVWF  FEA
0095A:  CLRF   FEC
0095C:  MOVF   FED,F
0095E:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00960:  CLRF   03
00962:  MOVFF  8FE,02
00966:  BCF    FD8.0
00968:  RLCF   02,F
0096A:  RLCF   03,F
0096C:  MOVF   02,W
0096E:  ADDLW  AA
00970:  MOVWF  FE9
00972:  MOVLW  00
00974:  ADDWFC 03,W
00976:  MOVWF  FEA
00978:  CLRF   FEC
0097A:  MOVF   FED,F
0097C:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
0097E:  MOVLB  A
00980:  CLRF   x03
00982:  MOVFF  8FE,A02
00986:  CLRF   x05
00988:  MOVLW  04
0098A:  MOVWF  x04
0098C:  MOVLB  0
0098E:  RCALL  0878
00990:  MOVF   01,W
00992:  ADDLW  B0
00994:  MOVWF  FE9
00996:  MOVLW  00
00998:  ADDWFC 02,W
0099A:  MOVWF  FEA
0099C:  MOVF   FEE,F
0099E:  MOVF   FEE,F
009A0:  CLRF   FEC
009A2:  MOVF   FED,F
009A4:  CLRF   FEF
009A6:  MOVF   FED,F
009A8:  CLRF   FEF
009AA:  MOVF   FED,F
009AC:  CLRF   FEF
.................... 	} 
009AE:  MOVLB  8
009B0:  INCF   xFE,F
009B2:  BRA    0900
....................  
.................... 	current.modbus_our_packets=0; 
009B4:  MOVLB  1
009B6:  CLRF   xCE
009B8:  CLRF   xCD
.................... 	current.modbus_other_packets=0; 
009BA:  CLRF   xD0
009BC:  CLRF   xCF
.................... 	current.modbus_last_error=0; 
009BE:  CLRF   xD2
009C0:  CLRF   xD1
.................... 	current.sequence_number=0; 
009C2:  CLRF   xD4
009C4:  CLRF   xD3
.................... 	current.uptime_minutes=0; 
009C6:  CLRF   xD6
009C8:  CLRF   xD5
.................... 	current.interval_milliseconds=0; 
009CA:  CLRF   xD8
009CC:  CLRF   xD7
.................... 	current.adc_buffer_index=0; 
009CE:  CLRF   xCC
.................... 	current.factory_unlocked=0; 
009D0:  CLRF   xD9
.................... 	current.watchdog_seconds=0; 
009D2:  CLRF   xDB
009D4:  CLRF   xDA
.................... 	current.rda_bytes_received=0; 
009D6:  CLRF   xE4
009D8:  CLRF   xE3
.................... 	current.rda2_bytes_received=0; 
009DA:  CLRF   xE6
009DC:  CLRF   xE5
.................... 	current.button_state=0; 
009DE:  CLRF   xE7
.................... 	current.latch_sw_magnet=0; 
009E0:  CLRF   xE8
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
009E2:  MOVLW  04
009E4:  MOVWF  FEA
009E6:  MOVLW  06
009E8:  MOVWF  FE9
009EA:  CLRF   00
009EC:  MOVLW  03
009EE:  MOVWF  02
009F0:  MOVLW  E4
009F2:  MOVWF  01
009F4:  MOVLB  0
009F6:  RCALL  089A
.................... 	for ( i=0 ; i < N_NMEA0183_SENTENCES ; i++ ) { 
009F8:  MOVLB  8
009FA:  CLRF   xFE
009FC:  MOVF   xFE,W
009FE:  SUBLW  0B
00A00:  BNC   0A34
.................... 		nmea.sentence_age[i]=0xffff; 
00A02:  CLRF   03
00A04:  MOVFF  8FE,02
00A08:  BCF    FD8.0
00A0A:  RLCF   02,F
00A0C:  RLCF   03,F
00A0E:  MOVF   02,W
00A10:  ADDLW  C6
00A12:  MOVWF  FE9
00A14:  MOVLW  07
00A16:  ADDWFC 03,W
00A18:  MOVWF  FEA
00A1A:  SETF   FEC
00A1C:  MOVF   FED,F
00A1E:  SETF   FEF
.................... 		nmea.sentence_length[i]=0; 
00A20:  MOVLW  DE
00A22:  ADDWF  xFE,W
00A24:  MOVWF  FE9
00A26:  MOVLW  07
00A28:  MOVWF  FEA
00A2A:  BTFSC  FD8.0
00A2C:  INCF   FEA,F
00A2E:  CLRF   FEF
.................... 	} 
00A30:  INCF   xFE,F
00A32:  BRA    09FC
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00A34:  MOVFF  4C,1DE
00A38:  MOVFF  4B,1DD
.................... 	current.power_off_delay=config.power_off_below_delay; 
00A3C:  MOVFF  48,1E0
00A40:  MOVFF  47,1DF
.................... 	current.power_override_timeout=0; 
00A44:  MOVLB  1
00A46:  CLRF   xE2
00A48:  CLRF   xE1
....................  
.................... 	/* UART2 - RS-485 port speed will be set after parameters are read */ 
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00A4A:  MOVLW  00
00A4C:  IORLW  05
00A4E:  MOVWF  FBA
00A50:  MOVLW  4A
00A52:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00A54:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00A56:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00A58:  MOVLB  0
00A5A:  GOTO   316A (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... 	static int16 b0_state=0; /* push button */ 
.................... 	/* power control */ 
.................... 	int8 i; 
....................  
....................  
.................... 	timers.now_millisecond=0; 
*
00FD4:  MOVLB  1
00FD6:  BCF    xFD.2
....................  
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
00FD8:  BCF    FD8.0
00FDA:  MOVLB  8
00FDC:  RLCF   xFB,W
00FDE:  MOVWF  xFF
00FE0:  RLCF   xFC,W
00FE2:  MOVLB  9
00FE4:  MOVWF  x00
00FE6:  MOVLW  00
00FE8:  MOVLB  1
00FEA:  BTFSS  xFE.3
00FEC:  MOVLW  01
00FEE:  MOVLB  8
00FF0:  IORWF  xFF,F
00FF2:  MOVFF  8FF,8FB
00FF6:  MOVLB  9
00FF8:  MOVF   x00,W
00FFA:  IORLW  E0
00FFC:  MOVLB  8
00FFE:  MOVWF  xFC
.................... 	if ( b0_state==0xf000) { 
01000:  MOVF   xFB,F
01002:  BNZ   1016
01004:  MOVF   xFC,W
01006:  SUBLW  F0
01008:  BNZ   1016
.................... 		/* button pressed */ 
.................... 		current.button_state=1; 
0100A:  MOVLW  01
0100C:  MOVLB  1
0100E:  MOVWF  xE7
.................... 		current.latch_sw_magnet=1; 
01010:  MOVWF  xE8
.................... 	} else { 
01012:  BRA    101A
01014:  MOVLB  8
.................... 		current.button_State=0; 
01016:  MOVLB  1
01018:  CLRF   xE7
.................... 	} 
....................  
.................... 	/* set PIC to PI line based on latch state(s) */ 
.................... 	if ( bit_test(config.pic_to_pi_latch_mask,0) && current.latch_sw_magnet ) { 
0101A:  BTFSS  4F.0
0101C:  BRA    1026
0101E:  MOVF   xE8,F
01020:  BZ    1026
.................... 		output_high(PIC_TO_PI); 
01022:  BSF    F8C.3
.................... 	} else { 
01024:  BRA    1028
.................... 		output_low(PIC_TO_PI); 
01026:  BCF    F8C.3
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
01028:  INCFSZ xE9,W
0102A:  BRA    1038
0102C:  INCFSZ xEA,W
0102E:  BRA    1038
.................... 				current.pulse_period[0]=0; 
01030:  MOVLB  0
01032:  CLRF   x99
01034:  CLRF   x98
01036:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
01038:  INCFSZ xEB,W
0103A:  BRA    1048
0103C:  INCFSZ xEC,W
0103E:  BRA    1048
.................... 				current.pulse_period[1]=0; 
01040:  MOVLB  0
01042:  CLRF   x9B
01044:  CLRF   x9A
01046:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
01048:  INCFSZ xED,W
0104A:  BRA    1058
0104C:  INCFSZ xEE,W
0104E:  BRA    1058
.................... 				current.pulse_period[2]=0; 
01050:  MOVLB  0
01052:  CLRF   x9D
01054:  CLRF   x9C
01056:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
01058:  MOVFF  F81,1FE
.................... 	timers.port_c=port_c; 
0105C:  MOVFF  F82,1FF
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
01060:  MOVF   xFA,F
01062:  BNZ   1068
.................... 		output_low(LED_GREEN); 
01064:  BCF    F89.3
.................... 	} else { 
01066:  BRA    106C
.................... 		output_high(LED_GREEN); 
01068:  BSF    F89.3
.................... 		timers.led_on_green--; 
0106A:  DECF   xFA,F
.................... 	} 
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
0106C:  INCFSZ xD7,W
0106E:  BRA    1076
01070:  INCFSZ xD8,W
01072:  BRA    1076
01074:  BRA    107C
.................... 		current.interval_milliseconds++; 
01076:  INCF   xD7,F
01078:  BTFSC  FD8.2
0107A:  INCF   xD8,F
.................... 	} 
....................  
.................... 	if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
0107C:  MOVF   38,W
0107E:  SUBLW  02
01080:  BNZ   10DA
.................... 		/* NMEA sentence age */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
01082:  MOVLB  8
01084:  CLRF   xFE
01086:  MOVF   xFE,W
01088:  SUBLW  0B
0108A:  BNC   10DA
.................... 			if ( 0xffff != nmea.sentence_age[i] ) 
0108C:  CLRF   03
0108E:  MOVFF  8FE,02
01092:  BCF    FD8.0
01094:  RLCF   02,F
01096:  RLCF   03,F
01098:  MOVF   02,W
0109A:  ADDLW  C6
0109C:  MOVWF  FE9
0109E:  MOVLW  07
010A0:  ADDWFC 03,W
010A2:  MOVWF  FEA
010A4:  MOVFF  FEC,03
010A8:  MOVF   FED,F
010AA:  MOVF   FEF,W
010AC:  SUBLW  FF
010AE:  BNZ   10B6
010B0:  INCFSZ 03,W
010B2:  BRA    10B6
010B4:  BRA    10D6
.................... 				nmea.sentence_age[i]++; 
010B6:  CLRF   03
010B8:  MOVFF  8FE,02
010BC:  BCF    FD8.0
010BE:  RLCF   02,F
010C0:  RLCF   03,F
010C2:  MOVF   02,W
010C4:  ADDLW  C6
010C6:  MOVWF  FE9
010C8:  MOVLW  07
010CA:  ADDWFC 03,W
010CC:  MOVWF  FEA
010CE:  MOVLW  01
010D0:  ADDWF  FEE,F
010D2:  BNC   10D6
010D4:  INCF   FEF,F
.................... 		} 
010D6:  INCF   xFE,F
010D8:  BRA    1086
.................... 	} 
....................  
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
010DA:  MOVLB  8
010DC:  INCF   xF9,F
010DE:  BTFSC  FD8.2
010E0:  INCF   xFA,F
.................... 	if ( 1000 == ticks ) { 
010E2:  MOVF   xF9,W
010E4:  SUBLW  E8
010E6:  BNZ   116C
010E8:  MOVF   xFA,W
010EA:  SUBLW  03
010EC:  BNZ   116C
.................... 		ticks=0; 
010EE:  CLRF   xFA
010F0:  CLRF   xF9
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
010F2:  MOVLB  1
010F4:  INCFSZ xDA,W
010F6:  BRA    10FE
010F8:  INCFSZ xDB,W
010FA:  BRA    10FE
010FC:  BRA    1104
.................... 			current.watchdog_seconds++; 
010FE:  INCF   xDA,F
01100:  BTFSC  FD8.2
01102:  INCF   xDB,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
01104:  MOVF   40,F
01106:  BNZ   110C
01108:  MOVF   41,F
0110A:  BZ    112A
0110C:  MOVF   41,W
0110E:  SUBWF  xDB,W
01110:  BNC   112A
01112:  BNZ   111A
01114:  MOVF   xDA,W
01116:  SUBWF  40,W
01118:  BC    112A
0111A:  MOVF   xFB,F
0111C:  BNZ   112A
0111E:  MOVF   xFC,F
01120:  BNZ   112A
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
01122:  MOVFF  43,1FC
01126:  MOVFF  42,1FB
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
0112A:  MOVF   xFB,F
0112C:  BNZ   1136
0112E:  MOVF   xFC,F
01130:  BNZ   1136
.................... 			output_high(PI_POWER_EN); 
01132:  BSF    F8B.0
.................... 		} else { 
01134:  BRA    114C
.................... 			output_low(PI_POWER_EN); 
01136:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01138:  MOVF   xFB,W
0113A:  BTFSC  FD8.2
0113C:  DECF   xFC,F
0113E:  DECF   xFB,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
01140:  MOVF   xFB,F
01142:  BNZ   114C
01144:  MOVF   xFC,F
01146:  BNZ   114C
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01148:  CLRF   xDB
0114A:  CLRF   xDA
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
0114C:  MOVLB  8
0114E:  INCF   xF6,F
.................... 		if ( 60 == uptimeTicks ) { 
01150:  MOVF   xF6,W
01152:  SUBLW  3C
01154:  BNZ   116C
.................... 			uptimeTicks=0; 
01156:  CLRF   xF6
.................... 			if ( current.uptime_minutes < 65535 )  
01158:  MOVLB  1
0115A:  INCFSZ xD5,W
0115C:  BRA    1164
0115E:  INCFSZ xD6,W
01160:  BRA    1164
01162:  BRA    116A
.................... 				current.uptime_minutes++; 
01164:  INCF   xD5,F
01166:  BTFSC  FD8.2
01168:  INCF   xD6,F
0116A:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
0116C:  MOVLB  1
0116E:  BTFSS  xFD.1
01170:  BRA    117A
.................... 		timers.now_adc_reset_count=0; 
01172:  BCF    xFD.1
.................... 		adcTicks=0; 
01174:  MOVLB  8
01176:  CLRF   xF8
01178:  CLRF   xF7
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
0117A:  MOVLB  8
0117C:  INCF   xF7,F
0117E:  BTFSC  FD8.2
01180:  INCF   xF8,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
01182:  MOVF   3D,W
01184:  SUBWF  xF7,W
01186:  BNZ   1196
01188:  MOVF   3E,W
0118A:  SUBWF  xF8,W
0118C:  BNZ   1196
.................... 		adcTicks=0; 
0118E:  CLRF   xF8
01190:  CLRF   xF7
.................... 		timers.now_adc_sample=1; 
01192:  MOVLB  1
01194:  BSF    xFD.0
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01196:  MOVLB  3
01198:  INCFSZ x02,W
0119A:  BRA    119E
0119C:  BRA    11A0
.................... 		timers.rda2_buff_gap++; 
0119E:  INCF   x02,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
011A0:  MOVF   x02,W
011A2:  SUBLW  09
011A4:  BC    11B0
011A6:  MOVF   x01,F
011A8:  BZ    11B0
.................... 		timers.now_parse_rda2=1;	 
011AA:  MOVLB  2
011AC:  BSF    x00.0
011AE:  MOVLB  3
.................... 	} 
.................... } 
011B0:  MOVLB  0
011B2:  GOTO   32E0 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && i < maxLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
02EA0:  MOVLB  A
02EA2:  CLRF   x0A
02EA4:  MOVF   x08,W
02EA6:  SUBWF  x0A,W
02EA8:  BC    2F1C
02EAA:  MOVF   x09,W
02EAC:  SUBWF  x0A,W
02EAE:  BC    2F1C
02EB0:  CLRF   03
02EB2:  MOVF   x0A,W
02EB4:  ADDWF  x06,W
02EB6:  MOVWF  FE9
02EB8:  MOVF   x07,W
02EBA:  ADDWFC 03,W
02EBC:  MOVWF  FEA
02EBE:  MOVF   FEF,F
02EC0:  BZ    2F1C
02EC2:  CLRF   03
02EC4:  MOVF   x0A,W
02EC6:  ADDWF  x06,W
02EC8:  MOVWF  FE9
02ECA:  MOVF   x07,W
02ECC:  ADDWFC 03,W
02ECE:  MOVWF  FEA
02ED0:  MOVF   FEF,W
02ED2:  SUBLW  0A
02ED4:  BZ    2F1C
02ED6:  CLRF   03
02ED8:  MOVF   x0A,W
02EDA:  ADDWF  x06,W
02EDC:  MOVWF  FE9
02EDE:  MOVF   x07,W
02EE0:  ADDWFC 03,W
02EE2:  MOVWF  FEA
02EE4:  MOVF   FEF,W
02EE6:  SUBLW  0D
02EE8:  BZ    2F1C
.................... 		dest[i] = src[i]; 
02EEA:  CLRF   03
02EEC:  MOVF   x0A,W
02EEE:  ADDWF  x04,W
02EF0:  MOVWF  01
02EF2:  MOVF   x05,W
02EF4:  ADDWFC 03,F
02EF6:  MOVFF  03,A0C
02EFA:  CLRF   03
02EFC:  MOVF   x0A,W
02EFE:  ADDWF  x06,W
02F00:  MOVWF  FE9
02F02:  MOVF   x07,W
02F04:  ADDWFC 03,W
02F06:  MOVWF  FEA
02F08:  MOVFF  FEF,A0D
02F0C:  MOVFF  A0C,FEA
02F10:  MOVFF  01,FE9
02F14:  MOVFF  A0D,FEF
.................... 	} 
02F18:  INCF   x0A,F
02F1A:  BRA    2EA4
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
02F1C:  MOVF   x09,W
02F1E:  SUBWF  x0A,W
02F20:  BC    2F36
.................... 		dest[i] = '\0'; 
02F22:  CLRF   03
02F24:  MOVF   x0A,W
02F26:  ADDWF  x04,W
02F28:  MOVWF  FE9
02F2A:  MOVF   x05,W
02F2C:  ADDWFC 03,W
02F2E:  MOVWF  FEA
02F30:  CLRF   FEF
.................... 	} 
02F32:  INCF   x0A,F
02F34:  BRA    2F1C
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
02F36:  MOVLW  01
02F38:  SUBWF  x09,W
02F3A:  CLRF   03
02F3C:  ADDWF  x04,W
02F3E:  MOVWF  FE9
02F40:  MOVF   x05,W
02F42:  ADDWFC 03,W
02F44:  MOVWF  FEA
02F46:  CLRF   FEF
.................... } 
02F48:  MOVLB  0
02F4A:  GOTO   3088 (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
02F4E:  MOVFF  301,9FE
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02F52:  MOVLB  3
02F54:  SETF   x01
.................... 	memcpy(buff,timers.rda2_buff,length); 
02F56:  MOVLW  08
02F58:  MOVWF  FEA
02F5A:  MOVLW  FE
02F5C:  MOVWF  FE9
02F5E:  MOVLW  02
02F60:  MOVWF  FE2
02F62:  MOVLW  01
02F64:  MOVWF  FE1
02F66:  MOVLB  9
02F68:  MOVF   xFE,W
02F6A:  MOVWF  01
02F6C:  BZ    2F76
02F6E:  MOVFF  FE6,FEE
02F72:  DECFSZ 01,F
02F74:  BRA    2F6E
.................... 	timers.rda2_buff_gap=0; 
02F76:  MOVLB  3
02F78:  CLRF   x02
.................... 	timers.rda2_buff_pos=0; 
02F7A:  CLRF   x01
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02F7C:  DECFSZ 38,W
02F7E:  BRA    2FCC
.................... 		/* transmit MODBUS received data back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02F80:  MOVLB  A
02F82:  CLRF   x00
02F84:  MOVLB  9
02F86:  CLRF   xFF
02F88:  MOVLB  A
02F8A:  MOVF   x00,F
02F8C:  BNZ   2FC8
02F8E:  MOVLB  9
02F90:  MOVF   xFE,W
02F92:  SUBWF  xFF,W
02F94:  BTFSS  FD8.0
02F96:  BRA    2F9C
02F98:  MOVLB  A
02F9A:  BRA    2FC8
.................... 			fputc(buff[l],STREAM_PI); 
02F9C:  MOVLW  FE
02F9E:  ADDWF  xFF,W
02FA0:  MOVWF  FE9
02FA2:  MOVLW  08
02FA4:  MOVLB  A
02FA6:  ADDWFC x00,W
02FA8:  MOVWF  FEA
02FAA:  MOVFF  FEF,A02
02FAE:  MOVF   x02,W
02FB0:  MOVLB  0
02FB2:  CALL   06CA
.................... 		} 
02FB6:  MOVLB  9
02FB8:  INCF   xFF,F
02FBA:  BTFSS  FD8.2
02FBC:  BRA    2FC4
02FBE:  MOVLB  A
02FC0:  INCF   x00,F
02FC2:  MOVLB  9
02FC4:  BRA    2F88
02FC6:  MOVLB  A
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
02FC8:  BRA    30C0
02FCA:  MOVLB  3
02FCC:  MOVF   38,W
02FCE:  SUBLW  02
02FD0:  BTFSS  FD8.2
02FD2:  BRA    30C2
.................... 		/* process NMEA0183 sentence */ 
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
02FD4:  MOVLB  9
02FD6:  MOVF   xFE,W
02FD8:  SUBLW  05
02FDA:  BNC   2FDE
.................... 			return; 
02FDC:  BRA    30C4
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
02FDE:  MOVLB  A
02FE0:  CLRF   x01
02FE2:  MOVF   x01,W
02FE4:  SUBLW  0B
02FE6:  BNC   30C0
.................... 			/* compare first six characters or look for wild card */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) && '*' != config.nmea0183_sentence[i][0] ) { 
02FE8:  MOVF   x01,W
02FEA:  MULLW  06
02FEC:  MOVF   FF3,W
02FEE:  CLRF   03
02FF0:  ADDLW  50
02FF2:  MOVWF  01
02FF4:  MOVLW  00
02FF6:  ADDWFC 03,F
02FF8:  MOVFF  01,A02
02FFC:  MOVFF  03,A03
03000:  MOVLW  08
03002:  MOVWF  x05
03004:  MOVLW  FE
03006:  MOVWF  x04
03008:  MOVFF  03,A07
0300C:  MOVFF  01,A06
03010:  CLRF   x09
03012:  MOVLW  06
03014:  MOVWF  x08
03016:  MOVLB  0
03018:  BRA    2E08
0301A:  MOVF   01,F
0301C:  BZ    3040
0301E:  MOVLB  A
03020:  MOVF   x01,W
03022:  MULLW  06
03024:  MOVF   FF3,W
03026:  CLRF   03
03028:  ADDLW  50
0302A:  MOVWF  FE9
0302C:  MOVLW  00
0302E:  ADDWFC 03,W
03030:  MOVWF  FEA
03032:  MOVF   FEF,W
03034:  SUBLW  2A
03036:  BTFSS  FD8.2
03038:  BRA    303E
0303A:  MOVLB  0
0303C:  BRA    3040
.................... 				/* no match */ 
.................... 				continue; 
0303E:  BRA    30BC
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
03040:  MOVLB  A
03042:  CLRF   x03
03044:  MOVFF  A01,A02
03048:  CLRF   x05
0304A:  MOVLW  50
0304C:  MOVWF  x04
0304E:  MOVLB  0
03050:  CALL   0878
03054:  MOVFF  02,03
03058:  MOVF   01,W
0305A:  ADDLW  06
0305C:  MOVWF  01
0305E:  MOVLW  04
03060:  ADDWFC 03,F
03062:  MOVFF  01,A02
03066:  MOVLB  A
03068:  MOVFF  03,A03
0306C:  MOVFF  03,A05
03070:  MOVFF  01,A04
03074:  MOVLW  08
03076:  MOVWF  x07
03078:  MOVLW  FE
0307A:  MOVWF  x06
0307C:  MOVFF  9FE,A08
03080:  MOVLW  50
03082:  MOVWF  x09
03084:  MOVLB  0
03086:  BRA    2EA0
.................... 			nmea.sentence_age[i]=0; 
03088:  CLRF   03
0308A:  MOVLB  A
0308C:  MOVFF  A01,02
03090:  BCF    FD8.0
03092:  RLCF   02,F
03094:  RLCF   03,F
03096:  MOVF   02,W
03098:  ADDLW  C6
0309A:  MOVWF  FE9
0309C:  MOVLW  07
0309E:  ADDWFC 03,W
030A0:  MOVWF  FEA
030A2:  CLRF   FEC
030A4:  MOVF   FED,F
030A6:  CLRF   FEF
.................... 			nmea.sentence_length[i]=length; 
030A8:  MOVLW  DE
030AA:  ADDWF  x01,W
030AC:  MOVWF  FE9
030AE:  MOVLW  07
030B0:  MOVWF  FEA
030B2:  BTFSC  FD8.0
030B4:  INCF   FEA,F
030B6:  MOVFF  9FE,FEF
....................  
.................... 			/* only fill in our first match */ 
.................... 			break; 
030BA:  BRA    30C0
.................... 		} 
030BC:  INCF   x01,F
030BE:  BRA    2FE2
030C0:  MOVLB  3
030C2:  MOVLB  9
.................... 	} 
.................... } 
030C4:  MOVLB  0
030C6:  GOTO   332E (RETURN)
....................  
....................  
.................... void main(void) { 
030CA:  CLRF   FF8
030CC:  BCF    FF1.2
030CE:  BSF    F9F.1
030D0:  BCF    F9F.5
030D2:  BCF    F9F.4
030D4:  BCF    FA5.5
030D6:  BSF    FD0.7
030D8:  BSF    07.7
030DA:  CLRF   FEA
030DC:  CLRF   FE9
030DE:  CLRF   35
030E0:  BCF    FB8.3
030E2:  MOVLW  0C
030E4:  MOVWF  FAF
030E6:  MOVLW  A6
030E8:  MOVWF  FAC
030EA:  MOVLW  90
030EC:  MOVWF  FAB
030EE:  BCF    F70.3
030F0:  MOVLW  4D
030F2:  MOVWF  F75
030F4:  MOVLW  A6
030F6:  MOVWF  F72
030F8:  MOVLW  90
030FA:  MOVWF  F71
030FC:  MOVLB  7
030FE:  BCF    xEA.0
03100:  CLRF   xEB
03102:  MOVLB  8
03104:  CLRF   xF5
03106:  MOVLB  7
03108:  BCF    xEA.1
0310A:  BCF    xEA.2
0310C:  BCF    xEA.3
0310E:  BCF    xEA.4
03110:  BCF    xEA.5
03112:  BCF    xEA.6
03114:  MOVLB  8
03116:  CLRF   xF6
03118:  CLRF   xF8
0311A:  CLRF   xF7
0311C:  CLRF   xFA
0311E:  CLRF   xF9
03120:  CLRF   xFC
03122:  CLRF   xFB
03124:  MOVF   FC1,W
03126:  ANDLW  F0
03128:  MOVWF  FC1
0312A:  MOVLW  00
0312C:  MOVLB  F
0312E:  MOVWF  x38
03130:  MOVWF  x3C
03132:  MOVWF  x39
03134:  MOVWF  x3A
03136:  MOVWF  x3B
03138:  MOVLB  1
0313A:  CLRF   x88
0313C:  CLRF   F77
0313E:  CLRF   F78
03140:  CLRF   F79
03142:  CLRF   2F
03144:  CLRF   30
03146:  MOVLB  8
03148:  CLRF   xF1
0314A:  CLRF   xF2
0314C:  CLRF   xF3
0314E:  CLRF   xF4
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
03150:  MOVF   FD0,W
03152:  ANDLW  0F
03154:  BTFSS  FD0.4
03156:  MOVLW  00
03158:  BSF    FD0.0
0315A:  BSF    FD0.1
0315C:  BSF    FD0.4
0315E:  BSF    FD8.3
03160:  BSF    FD8.4
03162:  MOVWF  xFD
....................  
.................... 	init(); 
03164:  MOVLB  0
03166:  GOTO   08B4
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
0316A:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
0316C:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
0316E:  MOVLW  BA
03170:  MOVWF  FF6
03172:  MOVLW  07
03174:  MOVWF  FF7
03176:  MOVLW  07
03178:  MOVLB  8
0317A:  MOVWF  xFE
0317C:  MOVLB  0
0317E:  CALL   0A5E
03182:  MOVLW  C6
03184:  MOVWF  FF6
03186:  MOVLW  07
03188:  MOVWF  FF7
0318A:  CALL   0A88
0318E:  MOVLW  0D
03190:  BTFSS  FA4.4
03192:  BRA    3190
03194:  MOVWF  F73
03196:  MOVLW  0A
03198:  BTFSS  FA4.4
0319A:  BRA    3198
0319C:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
0319E:  MOVLW  D0
031A0:  MOVWF  FF6
031A2:  MOVLW  07
031A4:  MOVWF  FF7
031A6:  MOVLW  12
031A8:  MOVLB  8
031AA:  MOVWF  xFE
031AC:  MOVLB  0
031AE:  CALL   0A5E
031B2:  MOVFF  8FD,8FE
031B6:  MOVLW  1B
031B8:  MOVLB  8
031BA:  MOVWF  xFF
031BC:  MOVLB  0
031BE:  GOTO   0AD6
031C2:  MOVLW  20
031C4:  BTFSS  FA4.4
031C6:  BRA    31C4
031C8:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
031CA:  MOVLB  8
031CC:  MOVF   xFD,W
031CE:  XORLW  07
031D0:  MOVLB  0
031D2:  BZ    31EE
031D4:  XORLW  0C
031D6:  BZ    31FC
031D8:  XORLW  04
031DA:  BZ    320A
031DC:  XORLW  03
031DE:  BZ    3218
031E0:  XORLW  02
031E2:  BZ    3226
031E4:  XORLW  0D
031E6:  BZ    3234
031E8:  XORLW  03
031EA:  BZ    3242
031EC:  BRA    3250
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
031EE:  MOVLW  E6
031F0:  MOVWF  FF6
031F2:  MOVLW  07
031F4:  MOVWF  FF7
031F6:  CALL   0A88
031FA:  BRA    325C
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
031FC:  MOVLW  F2
031FE:  MOVWF  FF6
03200:  MOVLW  07
03202:  MOVWF  FF7
03204:  CALL   0A88
03208:  BRA    325C
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
0320A:  MOVLW  02
0320C:  MOVWF  FF6
0320E:  MOVLW  08
03210:  MOVWF  FF7
03212:  CALL   0A88
03216:  BRA    325C
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
03218:  MOVLW  10
0321A:  MOVWF  FF6
0321C:  MOVLW  08
0321E:  MOVWF  FF7
03220:  CALL   0A88
03224:  BRA    325C
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
03226:  MOVLW  20
03228:  MOVWF  FF6
0322A:  MOVLW  08
0322C:  MOVWF  FF7
0322E:  CALL   0A88
03232:  BRA    325C
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
03234:  MOVLW  32
03236:  MOVWF  FF6
03238:  MOVLW  08
0323A:  MOVWF  FF7
0323C:  CALL   0A88
03240:  BRA    325C
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
03242:  MOVLW  42
03244:  MOVWF  FF6
03246:  MOVLW  08
03248:  MOVWF  FF7
0324A:  CALL   0A88
0324E:  BRA    325C
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
03250:  MOVLW  54
03252:  MOVWF  FF6
03254:  MOVLW  08
03256:  MOVWF  FF7
03258:  CALL   0A88
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
0325C:  MOVLW  5E
0325E:  MOVWF  FF6
03260:  MOVLW  08
03262:  MOVWF  FF7
03264:  CALL   0A88
.................... #endif 
....................  
....................  
.................... 	read_param_file(); 
03268:  GOTO   0D36
.................... 	set_rs485_speed(); 
0326C:  CALL   0D8C
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
03270:  MOVF   36,W
03272:  SUBLW  80
03274:  BC    327A
.................... 		write_default_param_file(); 
03276:  CALL   0CE4
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
0327A:  BSF    FAB.7
0327C:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	modbus_init(); 
0327E:  GOTO   0E1A
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
03282:  MOVLB  8
03284:  CLRF   xFD
03286:  MOVF   xFD,W
03288:  SUBLW  1D
0328A:  BNC   3298
.................... 		adc_update(); 
0328C:  MOVLB  0
0328E:  CALL   0ED8
.................... 	} 
03292:  MOVLB  8
03294:  INCF   xFD,F
03296:  BRA    3286
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
03298:  MOVFF  44,1DC
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
0329C:  BTFSS  F72.1
0329E:  BRA    329C
.................... 	output_low(RS485_DE); 
032A0:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
032A2:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
032A4:  MOVLW  62
032A6:  MOVWF  FF6
032A8:  MOVLW  08
032AA:  MOVWF  FF7
032AC:  MOVLW  07
032AE:  MOVWF  xFE
032B0:  MOVLB  0
032B2:  GOTO   0F84
032B6:  MOVLW  6E
032B8:  MOVWF  FF6
032BA:  MOVLW  08
032BC:  MOVWF  FF7
032BE:  GOTO   0FB0
032C2:  MOVLW  0D
032C4:  BTFSS  F9E.4
032C6:  BRA    32C4
032C8:  MOVWF  FAD
032CA:  MOVLW  0A
032CC:  BTFSS  F9E.4
032CE:  BRA    32CC
032D0:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
032D2:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
032D4:  MOVLB  1
032D6:  BTFSS  xFD.2
032D8:  BRA    32E2
.................... 			periodic_millisecond(); 
032DA:  MOVLB  0
032DC:  GOTO   0FD4
032E0:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
032E2:  BTFSS  xFD.0
032E4:  BRA    32EE
.................... 			timers.now_adc_sample=0; 
032E6:  BCF    xFD.0
.................... 			adc_update(); 
032E8:  MOVLB  0
032EA:  CALL   0ED8
.................... 		} 
....................  
.................... 		modbus_process(); 
032EE:  MOVLB  0
032F0:  BRA    2B06
....................  
....................  
.................... 		/* buffered modbus transmit */ 
....................  
.................... 		/* start transmitting */ 
.................... 		if ( timers.now_rda_tx_ready ) { 
032F2:  MOVLB  4
032F4:  BTFSS  x05.0
032F6:  BRA    330A
.................... 			timers.now_rda_tx_ready=0; 
032F8:  BCF    x05.0
....................  
.................... //			output_high(_PIC_TO_PI); 
....................  
.................... 			RCV_OFF(); 
032FA:  BCF    F9D.5
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
032FC:  CLRWDT
032FE:  MOVLW  3C
03300:  MOVWF  00
03302:  DECFSZ 00,F
03304:  BRA    3302
03306:  NOP   
....................  
.................... 			/* enable transmit buffer empty interrupt. It will feed itself */ 
.................... 			enable_interrupts(INT_TBE); 
03308:  BSF    F9D.4
.................... 		} 
....................  
.................... 		/* done transmitting */ 
.................... 		if ( timers.now_rda_tx_done ) { 
0330A:  BTFSS  x05.1
0330C:  BRA    3322
.................... 			timers.now_rda_tx_done=0; 
0330E:  BCF    x05.1
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
03310:  CLRWDT
03312:  MOVLW  3C
03314:  MOVWF  00
03316:  DECFSZ 00,F
03318:  BRA    3316
0331A:  NOP   
....................    			RCV_ON(); 
0331C:  MOVLB  0
0331E:  CALL   0E0E
....................  
.................... //			output_low(_PIC_TO_PI); 
.................... 		} 
....................  
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
03322:  MOVLB  2
03324:  BTFSS  x00.0
03326:  BRA    3330
.................... 			timers.now_parse_rda2=0; 
03328:  BCF    x00.0
.................... 			rs485_to_host(); 
0332A:  MOVLB  0
0332C:  BRA    2F4E
0332E:  MOVLB  2
.................... 		} 
....................  
.................... 	} 
03330:  MOVLB  0
03332:  BRA    32D2
.................... } 
03334:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
