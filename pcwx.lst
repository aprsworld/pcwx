CCS PCH C Compiler, Version 4.135, 4375               20-Nov-15 16:16

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 9480 bytes (14%)
                         Largest free fragment is 56052
               RAM used: 2002 (51%) at main() level
                         2266 (58%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   23D8
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03E0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   06E8
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   066E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0412
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
00F5C:  MOVLW  05
00F5E:  MOVLB  7
00F60:  SUBWF  xD9,F
00F62:  BNC   0F78
00F64:  MOVLW  07
00F66:  MOVWF  FEA
00F68:  MOVLW  D9
00F6A:  MOVWF  FE9
00F6C:  MOVF   FEF,W
00F6E:  BZ    0F78
00F70:  BRA    0F74
00F72:  CLRWDT
00F74:  DECFSZ FEF,F
00F76:  BRA    0F72
00F78:  MOVLB  0
00F7A:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0069E:  BTFSS  F9E.5
006A0:  BRA    069E
006A2:  MOVFF  FAB,35
006A6:  MOVFF  FAE,01
006AA:  BTFSS  35.1
006AC:  BRA    06B2
006AE:  BCF    FAB.4
006B0:  BSF    FAB.4
006B2:  RETURN 0
*
01022:  BTFSS  F9E.4
01024:  BRA    1022
01026:  MOVWF  FAD
01028:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00656:  BTFSS  FA4.5
00658:  BRA    0656
0065A:  MOVFF  F71,35
0065E:  MOVFF  F74,01
00662:  BTFSS  35.1
00664:  BRA    066A
00666:  BCF    F71.4
00668:  BSF    F71.4
0066A:  GOTO   0670 (RETURN)
*
006B4:  BTFSS  FA4.4
006B6:  BRA    06B4
006B8:  MOVWF  F73
006BA:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00C22:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00B82:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00B84:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00B86:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00B88:  MOVLB  7
00B8A:  MOVF   xD5,F
00B8C:  BNZ   0B94
.................... 		c=0b00011; 
00B8E:  MOVLW  03
00B90:  MOVWF  xD9
.................... 	else if ( 1 == ch )  
00B92:  BRA    0BDE
00B94:  DECFSZ xD5,W
00B96:  BRA    0B9E
.................... 		c=0b10011; 
00B98:  MOVLW  13
00B9A:  MOVWF  xD9
.................... 	else if ( 2 == ch )  
00B9C:  BRA    0BDE
00B9E:  MOVF   xD5,W
00BA0:  SUBLW  02
00BA2:  BNZ   0BAA
.................... 		c=0b01011; 
00BA4:  MOVLW  0B
00BA6:  MOVWF  xD9
.................... 	else if ( 3 == ch )  
00BA8:  BRA    0BDE
00BAA:  MOVF   xD5,W
00BAC:  SUBLW  03
00BAE:  BNZ   0BB6
.................... 		c=0b11011; 
00BB0:  MOVLW  1B
00BB2:  MOVWF  xD9
.................... 	else if ( 4 == ch ) 
00BB4:  BRA    0BDE
00BB6:  MOVF   xD5,W
00BB8:  SUBLW  04
00BBA:  BNZ   0BC2
.................... 		c=0b00111; 
00BBC:  MOVLW  07
00BBE:  MOVWF  xD9
.................... 	else if ( 5 == ch )  
00BC0:  BRA    0BDE
00BC2:  MOVF   xD5,W
00BC4:  SUBLW  05
00BC6:  BNZ   0BCE
.................... 		c=0b10111; 
00BC8:  MOVLW  17
00BCA:  MOVWF  xD9
.................... 	else if ( 6 == ch ) 
00BCC:  BRA    0BDE
00BCE:  MOVF   xD5,W
00BD0:  SUBLW  06
00BD2:  BNZ   0BDA
.................... 		c=0b01111; 
00BD4:  MOVLW  0F
00BD6:  MOVWF  xD9
.................... 	else 
00BD8:  BRA    0BDE
.................... 		c=0b11111; 
00BDA:  MOVLW  1F
00BDC:  MOVWF  xD9
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00BDE:  CLRF   xD8
00BE0:  MOVF   xD8,W
00BE2:  SUBLW  04
00BE4:  BNC   0BFC
.................... 		output_low(MCP3208_CLK); 
00BE6:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00BE8:  BTFSC  xD9.0
00BEA:  BRA    0BF0
00BEC:  BCF    F8B.5
00BEE:  BRA    0BF2
00BF0:  BSF    F8B.5
.................... 		c=c>>1; 
00BF2:  BCF    FD8.0
00BF4:  RRCF   xD9,F
.................... 		output_high(MCP3208_CLK); 
00BF6:  BSF    F8B.3
.................... 	} 
00BF8:  INCF   xD8,F
00BFA:  BRA    0BE0
....................  
....................  
.................... 	value=0; 
00BFC:  CLRF   xD7
00BFE:  CLRF   xD6
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00C00:  CLRF   xD8
00C02:  MOVF   xD8,W
00C04:  SUBLW  0D
00C06:  BNC   0C1E
.................... 		output_low(MCP3208_CLK); 
00C08:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00C0A:  BTFSC  F82.4
00C0C:  BRA    0C12
00C0E:  BCF    FD8.0
00C10:  BRA    0C14
00C12:  BSF    FD8.0
00C14:  RLCF   xD6,F
00C16:  RLCF   xD7,F
.................... 		output_high(MCP3208_CLK); 
00C18:  BSF    F8B.3
.................... 	} 
00C1A:  INCF   xD8,F
00C1C:  BRA    0C02
....................  
.................... 	bit_clear(value,13); 
00C1E:  BCF    xD7.5
.................... 	bit_clear(value,12); 
00C20:  BCF    xD7.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00C24:  MOVFF  7D6,01
00C28:  MOVFF  7D7,02
.................... } 
00C2C:  MOVLB  0
00C2E:  GOTO   0C9E (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00D28:  MOVLB  7
00D2A:  CLRF   xEF
00D2C:  MOVFF  7E8,7EE
00D30:  CLRF   xF1
00D32:  MOVLW  20
00D34:  MOVWF  xF0
00D36:  MOVLB  0
00D38:  RCALL  0778
00D3A:  MOVFF  02,03
00D3E:  MOVF   01,W
00D40:  ADDLW  CA
00D42:  MOVWF  01
00D44:  MOVLW  00
00D46:  ADDWFC 03,F
00D48:  MOVFF  01,7EC
00D4C:  MOVLB  7
00D4E:  MOVFF  03,7ED
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00D52:  CLRF   xEA
00D54:  CLRF   xE9
.................... 	for( i = 0; i < 16 ; i++ ) { 
00D56:  CLRF   xEB
00D58:  MOVF   xEB,W
00D5A:  SUBLW  0F
00D5C:  BNC   0D80
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00D5E:  BCF    FD8.0
00D60:  RLCF   xEB,W
00D62:  CLRF   03
00D64:  ADDWF  xEC,W
00D66:  MOVWF  FE9
00D68:  MOVF   xED,W
00D6A:  ADDWFC 03,W
00D6C:  MOVWF  FEA
00D6E:  MOVFF  FEC,03
00D72:  MOVF   FED,F
00D74:  MOVF   FEF,W
00D76:  ADDWF  xE9,F
00D78:  MOVF   03,W
00D7A:  ADDWFC xEA,F
.................... 	} 
00D7C:  INCF   xEB,F
00D7E:  BRA    0D58
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00D80:  MOVLW  08
00D82:  ADDWF  xE9,W
00D84:  MOVWF  xEE
00D86:  MOVLW  00
00D88:  ADDWFC xEA,W
00D8A:  MOVWF  xEF
00D8C:  RRCF   xEF,W
00D8E:  MOVWF  03
00D90:  RRCF   xEE,W
00D92:  MOVWF  02
00D94:  RRCF   03,F
00D96:  RRCF   02,F
00D98:  RRCF   03,F
00D9A:  RRCF   02,F
00D9C:  RRCF   03,F
00D9E:  RRCF   02,F
00DA0:  MOVLW  0F
00DA2:  ANDWF  03,F
00DA4:  MOVFF  02,01
00DA8:  MOVFF  03,02
.................... } 
00DAC:  MOVLB  0
00DAE:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00C32:  MOVLB  1
00C34:  INCF   xCA,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00C36:  MOVF   xCA,W
00C38:  SUBLW  0F
00C3A:  BC    0C3E
.................... 		current.adc_buffer_index=0; 
00C3C:  CLRF   xCA
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00C3E:  MOVLB  7
00C40:  CLRF   xD2
00C42:  MOVF   xD2,W
00C44:  SUBLW  07
00C46:  BNC   0CD4
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00C48:  CLRF   xEF
00C4A:  MOVFF  7D2,7EE
00C4E:  CLRF   xF1
00C50:  MOVLW  20
00C52:  MOVWF  xF0
00C54:  MOVLB  0
00C56:  RCALL  0778
00C58:  MOVFF  02,03
00C5C:  MOVF   01,W
00C5E:  ADDLW  34
00C60:  MOVLB  7
00C62:  MOVWF  xD3
00C64:  MOVLW  00
00C66:  ADDWFC 02,W
00C68:  MOVWF  xD4
00C6A:  CLRF   03
00C6C:  MOVLB  1
00C6E:  MOVFF  1CA,02
00C72:  BCF    FD8.0
00C74:  RLCF   02,F
00C76:  RLCF   03,F
00C78:  MOVF   02,W
00C7A:  MOVLB  7
00C7C:  ADDWF  xD3,W
00C7E:  MOVWF  01
00C80:  MOVF   xD4,W
00C82:  ADDWFC 03,F
00C84:  MOVF   01,W
00C86:  ADDLW  96
00C88:  MOVWF  01
00C8A:  MOVLW  00
00C8C:  ADDWFC 03,F
00C8E:  MOVFF  01,7D3
00C92:  MOVFF  03,7D4
00C96:  MOVFF  7D2,7D5
00C9A:  MOVLB  0
00C9C:  BRA    0B82
00C9E:  MOVFF  7D4,FEA
00CA2:  MOVFF  7D3,FE9
00CA6:  MOVFF  02,FEC
00CAA:  MOVF   FED,F
00CAC:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00CB0:  CLRF   03
00CB2:  MOVLB  7
00CB4:  MOVFF  7D2,02
00CB8:  BCF    FD8.0
00CBA:  RLCF   02,F
00CBC:  RLCF   03,F
00CBE:  MOVF   02,W
00CC0:  ADDLW  BA
00CC2:  MOVWF  FE9
00CC4:  MOVLW  00
00CC6:  ADDWFC 03,W
00CC8:  MOVWF  FEA
00CCA:  CLRF   FEC
00CCC:  MOVF   FED,F
00CCE:  CLRF   FEF
....................  
.................... 	} 
00CD0:  INCF   xD2,F
00CD2:  BRA    0C42
.................... } 
00CD4:  MOVLB  0
00CD6:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00988:  MOVF   xEF,W
0098A:  XORWF  xF0,W
0098C:  MOVWF  01
*
009DA:  MOVF   xEF,W
009DC:  XORWF  xF0,W
009DE:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00912:  MOVLB  7
00914:  CLRF   xDB
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00916:  MOVFF  7DA,03
0091A:  MOVF   xD9,W
0091C:  BTFSC  FD8.2
0091E:  DECF   xDA,F
00920:  DECF   xD9,F
00922:  MOVWF  xDC
00924:  MOVFF  03,7DD
00928:  MOVF   xDC,F
0092A:  BNZ   0930
0092C:  MOVF   xDD,F
0092E:  BZ    099A
.................... 		*data = read_eeprom( address++ ); 
00930:  MOVFF  7D8,03
00934:  MOVF   xD7,W
00936:  MOVWF  FE9
00938:  MOVFF  03,FEA
0093C:  MOVF   xD6,W
0093E:  MOVWF  03
00940:  MOVF   xD5,W
00942:  INCF   xD5,F
00944:  BTFSC  FD8.2
00946:  INCF   xD6,F
00948:  MOVWF  xDE
0094A:  MOVFF  03,7DF
0094E:  MOVFF  FF2,7E0
00952:  BCF    FF2.6
00954:  BCF    FF2.7
00956:  MOVFF  7DF,FAA
0095A:  MOVFF  7DE,FA9
0095E:  BCF    FA6.6
00960:  BCF    FA6.7
00962:  BSF    FA6.0
00964:  MOVF   FA8,W
00966:  BTFSC  xE0.6
00968:  BSF    FF2.6
0096A:  BTFSC  xE0.7
0096C:  BSF    FF2.7
0096E:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00970:  MOVFF  7D8,03
00974:  MOVF   xD7,W
00976:  MOVWF  FE9
00978:  MOVFF  03,FEA
0097C:  MOVFF  FEF,7DC
00980:  MOVFF  7DB,7EF
00984:  MOVFF  7DC,7F0
*
0098E:  MOVFF  01,7DB
.................... 		data++; 
00992:  INCF   xD7,F
00994:  BTFSC  FD8.2
00996:  INCF   xD8,F
.................... 	} 
00998:  BRA    0916
.................... 	return crc; 
0099A:  MOVFF  7DB,01
.................... } 
0099E:  MOVLB  0
009A0:  GOTO   0B36 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
009A4:  MOVLB  7
009A6:  CLRF   xED
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
009A8:  MOVFF  7EC,03
009AC:  MOVF   xEB,W
009AE:  BTFSC  FD8.2
009B0:  DECF   xEC,F
009B2:  DECF   xEB,F
009B4:  MOVWF  xEE
009B6:  MOVFF  03,7EF
009BA:  MOVF   xEE,F
009BC:  BNZ   09C2
009BE:  MOVF   xEF,F
009C0:  BZ    0A40
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
009C2:  MOVFF  7EA,03
009C6:  MOVF   xE9,W
009C8:  MOVWF  FE9
009CA:  MOVFF  03,FEA
009CE:  MOVFF  FEF,7EE
009D2:  MOVFF  7ED,7EF
009D6:  MOVFF  7EE,7F0
*
009E0:  MOVFF  01,7ED
.................... 		write_eeprom( address++, *data++ ); 
009E4:  MOVF   xE8,W
009E6:  MOVWF  03
009E8:  MOVF   xE7,W
009EA:  INCF   xE7,F
009EC:  BTFSC  FD8.2
009EE:  INCF   xE8,F
009F0:  MOVWF  xEE
009F2:  MOVFF  03,7EF
009F6:  MOVF   xEA,W
009F8:  MOVWF  03
009FA:  MOVF   xE9,W
009FC:  INCF   xE9,F
009FE:  BTFSC  FD8.2
00A00:  INCF   xEA,F
00A02:  MOVWF  FE9
00A04:  MOVFF  03,FEA
00A08:  MOVFF  FEF,7F0
00A0C:  MOVFF  7EF,FAA
00A10:  MOVFF  7EE,FA9
00A14:  MOVFF  7F0,FA8
00A18:  BCF    FA6.6
00A1A:  BCF    FA6.7
00A1C:  BSF    FA6.2
00A1E:  MOVF   FF2,W
00A20:  MOVWF  00
00A22:  BCF    FF2.6
00A24:  BCF    FF2.7
00A26:  MOVLB  F
00A28:  MOVLW  55
00A2A:  MOVWF  FA7
00A2C:  MOVLW  AA
00A2E:  MOVWF  FA7
00A30:  BSF    FA6.1
00A32:  BTFSC  FA6.1
00A34:  BRA    0A32
00A36:  BCF    FA6.2
00A38:  MOVF   00,W
00A3A:  IORWF  FF2,F
.................... 	} 
00A3C:  MOVLB  7
00A3E:  BRA    09A8
....................  
.................... 	return crc; 
00A40:  MOVFF  7ED,01
.................... } 
00A44:  MOVLB  0
00A46:  GOTO   0A6A (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00A4A:  MOVLB  7
00A4C:  CLRF   xE6
00A4E:  MOVLW  36
00A50:  MOVWF  xE5
00A52:  CLRF   xE8
00A54:  MOVLW  02
00A56:  MOVWF  xE7
00A58:  MOVFF  7E6,7EA
00A5C:  MOVFF  7E5,7E9
00A60:  CLRF   xEC
00A62:  MOVLW  60
00A64:  MOVWF  xEB
00A66:  MOVLB  0
00A68:  BRA    09A4
00A6A:  MOVFF  01,7E4
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00A6E:  CLRF   FAA
00A70:  CLRF   FA9
00A72:  MOVFF  7E4,FA8
00A76:  BCF    FA6.6
00A78:  BCF    FA6.7
00A7A:  BSF    FA6.2
00A7C:  MOVF   FF2,W
00A7E:  MOVWF  00
00A80:  BCF    FF2.6
00A82:  BCF    FF2.7
00A84:  MOVLB  F
00A86:  MOVLW  55
00A88:  MOVWF  FA7
00A8A:  MOVLW  AA
00A8C:  MOVWF  FA7
00A8E:  BSF    FA6.1
00A90:  BTFSC  FA6.1
00A92:  BRA    0A90
00A94:  BCF    FA6.2
00A96:  MOVF   00,W
00A98:  IORWF  FF2,F
.................... } 
00A9A:  MOVLB  0
00A9C:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00A9E:  MOVLW  96
00AA0:  MOVLB  1
00AA2:  MOVWF  xF3
....................  
.................... 	config.modbus_address=38; 
00AA4:  MOVLW  26
00AA6:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_MODBUS_BRIDGE; 
00AA8:  MOVLW  01
00AAA:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00AAC:  MOVLW  50
00AAE:  MOVWF  39
.................... 	config.serial_number=9876; 
00AB0:  MOVLW  26
00AB2:  MOVWF  3B
00AB4:  MOVLW  94
00AB6:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00AB8:  CLRF   3D
00ABA:  MOVLW  14
00ABC:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00ABE:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00AC0:  MOVLW  02
00AC2:  MOVWF  40
00AC4:  MOVLW  76
00AC6:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00AC8:  CLRF   42
00ACA:  MOVLW  02
00ACC:  MOVWF  41
.................... 	config.power_startup=0; 
00ACE:  CLRF   43
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00AD0:  CLRF   FEA
00AD2:  MOVLW  4E
00AD4:  MOVWF  FE9
00AD6:  CLRF   00
00AD8:  CLRF   02
00ADA:  MOVLW  48
00ADC:  MOVWF  01
00ADE:  MOVLB  0
00AE0:  RCALL  079A
.................... 	/* set defaults. Can set the first 11 this way. Have to do them in order. 
.................... 	 12th would overrun end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00AE2:  CLRF   FEA
00AE4:  MOVLW  4E
00AE6:  MOVWF  FE9
00AE8:  MOVLW  00
00AEA:  CALL   017C
00AEE:  TBLRD*-
00AF0:  TBLRD*+
00AF2:  MOVF   FF5,W
00AF4:  MOVWF  FEE
00AF6:  IORLW  00
00AF8:  BNZ   0AF0
.................... 	strcpy(config.nmea0183_sentence[1],"$WIMDA"); 
00AFA:  CLRF   FEA
00AFC:  MOVLW  54
00AFE:  MOVWF  FE9
00B00:  MOVLW  00
00B02:  CALL   0194
00B06:  TBLRD*-
00B08:  TBLRD*+
00B0A:  MOVF   FF5,W
00B0C:  MOVWF  FEE
00B0E:  IORLW  00
00B10:  BNZ   0B08
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00B12:  RCALL  0A4A
....................  
.................... } 
00B14:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00B16:  MOVLB  7
00B18:  CLRF   xD4
00B1A:  MOVLW  36
00B1C:  MOVWF  xD3
00B1E:  CLRF   xD6
00B20:  MOVLW  02
00B22:  MOVWF  xD5
00B24:  MOVFF  7D4,7D8
00B28:  MOVFF  7D3,7D7
00B2C:  CLRF   xDA
00B2E:  MOVLW  60
00B30:  MOVWF  xD9
00B32:  MOVLB  0
00B34:  BRA    0912
00B36:  MOVFF  01,7D2
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00B3A:  MOVFF  FF2,7D3
00B3E:  BCF    FF2.6
00B40:  BCF    FF2.7
00B42:  CLRF   FAA
00B44:  CLRF   FA9
00B46:  BCF    FA6.6
00B48:  BCF    FA6.7
00B4A:  BSF    FA6.0
00B4C:  MOVF   FA8,W
00B4E:  MOVLB  7
00B50:  BTFSC  xD3.6
00B52:  BSF    FF2.6
00B54:  BTFSC  xD3.7
00B56:  BSF    FF2.7
00B58:  SUBWF  xD2,W
00B5A:  BZ    0B62
.................... 		write_default_param_file(); 
00B5C:  MOVLB  0
00B5E:  RCALL  0A9E
00B60:  MOVLB  7
.................... 	} 
.................... } 
00B62:  MOVLB  0
00B64:  GOTO   247E (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
01084:  BTFSS  FAC.1
01086:  BRA    1084
.................... } 
01088:  GOTO   10A2 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00B68:  BTFSS  F9E.5
00B6A:  BRA    0B70
.................... 		fgetc(STREAM_PI); 
00B6C:  RCALL  069E
.................... 	} 
00B6E:  BRA    0B68
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00B70:  BSF    F9D.5
.................... } 
00B72:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00B74:  RCALL  0B68
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00B76:  MOVLW  C6
00B78:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00B7A:  MOVLW  C0
00B7C:  IORWF  FF2,F
.................... } 
00B7E:  GOTO   2490 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003CC:  BCF    FF2.5
.................... 	if (enable) { 
003CE:  MOVLB  8
003D0:  MOVF   xD7,F
003D2:  BZ    03DC
.................... 		set_timer0(0); 
003D4:  CLRF   FD7
003D6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003D8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003DA:  BSF    FF2.5
.................... 	} 
.................... } 
003DC:  MOVLB  0
003DE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003E0:  MOVLB  6
003E2:  MOVF   xBD,W
003E4:  SUBLW  02
003E6:  BNZ   03FC
003E8:  MOVF   xBE,F
003EA:  BNZ   03FC
003EC:  MOVF   xBF,F
003EE:  BNZ   03FC
003F0:  BTFSC  xBC.0
003F2:  BRA    03FC
....................    { 
....................       modbus_rx.len-=2; 
003F4:  MOVLW  02
003F6:  SUBWF  xC1,F
....................       modbus_serial_new=TRUE; 
003F8:  BSF    xBC.0
....................    } 
....................    else 
003FA:  BRA    03FE
....................       modbus_serial_new=FALSE; 
003FC:  BCF    xBC.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003FE:  SETF   xBF
00400:  SETF   xBE
....................    modbus_serial_state=MODBUS_GETADDY; 
00402:  CLRF   xBD
....................    modbus_enable_timeout(FALSE); 
00404:  MOVLB  8
00406:  CLRF   xD7
00408:  MOVLB  0
0040A:  RCALL  03CC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0040C:  BCF    FF2.2
0040E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
006BC:  MOVLB  6
006BE:  MOVF   xBF,W
006C0:  MOVLB  8
006C2:  XORWF  xD7,W
006C4:  MOVWF  xD8
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
006C6:  CLRF   03
006C8:  MOVF   xD8,W
006CA:  MOVLB  0
006CC:  RCALL  01AC
006CE:  MOVWF  01
006D0:  MOVLB  6
006D2:  MOVF   xBE,W
006D4:  XORWF  01,W
006D6:  MOVWF  xBF
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006D8:  CLRF   03
006DA:  MOVLB  8
006DC:  MOVF   xD8,W
006DE:  MOVLB  0
006E0:  RCALL  02BC
006E2:  MOVFF  FE8,6BE
.................... } 
006E6:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
0102A:  MOVLB  7
0102C:  MOVF   xE4,W
0102E:  MOVLB  0
01030:  RCALL  1022
01032:  CLRF   19
01034:  BTFSC  FF2.6
01036:  BSF    19.6
01038:  BCF    FF2.6
0103A:  BTFSC  FF2.7
0103C:  BSF    19.7
0103E:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
01040:  MOVFF  7E4,8D7
01044:  CALL   06BC
01048:  BTFSC  19.6
0104A:  BSF    FF2.6
0104C:  BTFSC  19.7
0104E:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
01050:  CLRWDT
01052:  MOVLW  08
01054:  MOVWF  00
01056:  DECFSZ 00,F
01058:  BRA    1056
0105A:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
0105C:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
0105E:  MOVLB  6
01060:  SETF   xBF
01062:  SETF   xBE
....................    modbus_serial_new=FALSE; 
01064:  BCF    xBC.0
....................  
....................    RCV_OFF(); 
01066:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
01068:  CLRWDT
0106A:  MOVLW  3C
0106C:  MOVWF  00
0106E:  DECFSZ 00,F
01070:  BRA    106E
01072:  NOP   
....................  
....................    modbus_serial_putc(to); 
01074:  MOVFF  7E2,7E4
01078:  MOVLB  0
0107A:  RCALL  102A
....................    modbus_serial_putc(func); 
0107C:  MOVFF  7E3,7E4
01080:  RCALL  102A
.................... } 
01082:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
0108C:  MOVFF  6BF,7E3
....................    crc_low=modbus_serial_crc.b[0]; 
01090:  MOVFF  6BE,7E2
....................  
....................    modbus_serial_putc(crc_high); 
01094:  MOVFF  7E3,7E4
01098:  RCALL  102A
....................    modbus_serial_putc(crc_low); 
0109A:  MOVFF  7E2,7E4
0109E:  RCALL  102A
....................  
....................    WAIT_FOR_HW_BUFFER(); 
010A0:  BRA    1084
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
010A2:  CLRWDT
010A4:  MOVLW  3C
010A6:  MOVWF  00
010A8:  DECFSZ 00,F
010AA:  BRA    10A8
010AC:  NOP   
....................  
....................  
....................    RCV_ON(); 
010AE:  RCALL  0B68
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
010B0:  MOVLB  6
010B2:  SETF   xBF
010B4:  SETF   xBE
.................... } 
010B6:  MOVLB  0
010B8:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00F36:  MOVLB  6
00F38:  BTFSC  xBC.0
00F3A:  BRA    0F44
....................       return FALSE; 
00F3C:  MOVLW  00
00F3E:  MOVWF  01
00F40:  BRA    0F56
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00F42:  BRA    0F50
00F44:  BTFSS  xC2.7
00F46:  BRA    0F50
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00F48:  MOVFF  6C4,6C3
....................       modbus_rx.len = 1; 
00F4C:  MOVLW  01
00F4E:  MOVWF  xC1
....................    } 
....................    modbus_serial_new=FALSE; 
00F50:  BCF    xBC.0
....................    return TRUE; 
00F52:  MOVLW  01
00F54:  MOVWF  01
.................... } 
00F56:  MOVLB  0
00F58:  GOTO   2074 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01FE0:  MOVFF  7DA,7E2
01FE4:  MOVLW  06
01FE6:  MOVLB  7
01FE8:  MOVWF  xE3
01FEA:  MOVLB  0
01FEC:  CALL   105E
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01FF0:  MOVFF  7DC,7DF
01FF4:  MOVFF  7DC,7E4
01FF8:  CALL   102A
....................    modbus_serial_putc(make8(reg_address,0)); 
01FFC:  MOVFF  7DB,7DF
02000:  MOVFF  7DB,7E4
02004:  CALL   102A
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02008:  MOVFF  7DE,7DF
0200C:  MOVFF  7DE,7E4
02010:  CALL   102A
....................    modbus_serial_putc(make8(reg_value,0)); 
02014:  MOVFF  7DD,7DF
02018:  MOVFF  7DD,7E4
0201C:  CALL   102A
....................  
....................    modbus_serial_send_stop(); 
02020:  CALL   108C
.................... } 
02024:  GOTO   2258 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02028:  MOVFF  7D8,7E2
0202C:  MOVLW  10
0202E:  MOVLB  7
02030:  MOVWF  xE3
02032:  MOVLB  0
02034:  CALL   105E
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02038:  MOVFF  7DA,7DD
0203C:  MOVFF  7DA,7E4
02040:  CALL   102A
....................    modbus_serial_putc(make8(start_address,0)); 
02044:  MOVFF  7D9,7DD
02048:  MOVFF  7D9,7E4
0204C:  CALL   102A
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02050:  MOVFF  7DC,7DD
02054:  MOVFF  7DC,7E4
02058:  CALL   102A
....................    modbus_serial_putc(make8(quantity,0)); 
0205C:  MOVFF  7DB,7DD
02060:  MOVFF  7DB,7E4
02064:  CALL   102A
....................  
....................    modbus_serial_send_stop(); 
02068:  CALL   108C
.................... } 
0206C:  GOTO   231A (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
010BA:  MOVLB  7
010BC:  MOVF   xD9,W
010BE:  IORLW  80
010C0:  MOVWF  xDC
010C2:  MOVFF  7DA,7DD
010C6:  MOVFF  7D8,7E2
010CA:  MOVWF  xE3
010CC:  MOVLB  0
010CE:  RCALL  105E
....................    modbus_serial_putc(error); 
010D0:  MOVFF  7DB,7E4
010D4:  RCALL  102A
....................    modbus_serial_send_stop(); 
010D6:  RCALL  108C
.................... } 
010D8:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          51 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1012 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
011CC:  MOVLB  1
011CE:  CLRF   xCC
011D0:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
011D2:  CLRF   xCE
011D4:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
011D6:  CLRF   xD0
011D8:  CLRF   xCF
.................... } 
011DA:  MOVLB  0
011DC:  GOTO   1B82 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
01168:  BCF    FF2.6
0116A:  BCF    FF2.7
0116C:  BTFSC  FF2.7
0116E:  BRA    116A
....................  
.................... 	current.pulse_count[0]=0; 
01170:  CLRF   xA9
01172:  CLRF   xA8
.................... 	current.pulse_count[1]=0; 
01174:  CLRF   xAB
01176:  CLRF   xAA
.................... 	current.pulse_count[2]=0; 
01178:  CLRF   xAD
0117A:  CLRF   xAC
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
0117C:  SETF   x9D
0117E:  SETF   x9C
.................... 	current.pulse_min_period[1]=65535; 
01180:  SETF   x9F
01182:  SETF   x9E
.................... 	current.pulse_min_period[2]=65535; 
01184:  SETF   xA1
01186:  SETF   xA0
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
01188:  CLRF   xA3
0118A:  CLRF   xA2
.................... 	current.pulse_max_period[1]=0; 
0118C:  CLRF   xA5
0118E:  CLRF   xA4
.................... 	current.pulse_max_period[2]=0; 
01190:  CLRF   xA7
01192:  CLRF   xA6
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01194:  MOVLB  1
01196:  CLRF   xD6
01198:  CLRF   xD5
....................  
.................... 	enable_interrupts(GLOBAL); 
0119A:  MOVLW  C0
0119C:  IORWF  FF2,F
.................... } 
0119E:  MOVLB  0
011A0:  GOTO   1B32 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
011A4:  BCF    FF2.6
011A6:  BCF    FF2.7
011A8:  BTFSC  FF2.7
011AA:  BRA    11A6
.................... 	current.pulse_sum[0]=0; 
011AC:  CLRF   xB1
011AE:  CLRF   xB0
011B0:  CLRF   xAF
011B2:  CLRF   xAE
.................... 	current.pulse_sum[1]=0; 
011B4:  CLRF   xB5
011B6:  CLRF   xB4
011B8:  CLRF   xB3
011BA:  CLRF   xB2
.................... 	current.pulse_sum[2]=0; 
011BC:  CLRF   xB9
011BE:  CLRF   xB8
011C0:  CLRF   xB7
011C2:  CLRF   xB6
.................... 	enable_interrupts(GLOBAL); 
011C4:  MOVLW  C0
011C6:  IORWF  FF2,F
.................... } 
011C8:  GOTO   1B42 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01106:  BCF    FF2.6
01108:  BCF    FF2.7
0110A:  BTFSC  FF2.7
0110C:  BRA    1108
.................... 	l=current.pulse_sum[ch]; 
0110E:  MOVLB  7
01110:  CLRF   xEF
01112:  MOVFF  7E8,7EE
01116:  CLRF   xF1
01118:  MOVLW  04
0111A:  MOVWF  xF0
0111C:  MOVLB  0
0111E:  CALL   0778
01122:  MOVFF  02,03
01126:  MOVF   01,W
01128:  ADDLW  AE
0112A:  MOVWF  FE9
0112C:  MOVLW  00
0112E:  ADDWFC 02,W
01130:  MOVWF  FEA
01132:  MOVFF  FEF,00
01136:  MOVFF  FEC,01
0113A:  MOVFF  FEC,02
0113E:  MOVFF  FEC,03
01142:  MOVFF  03,7EC
01146:  MOVFF  02,7EB
0114A:  MOVFF  01,7EA
0114E:  MOVFF  00,7E9
.................... 	enable_interrupts(GLOBAL); 
01152:  MOVLW  C0
01154:  IORWF  FF2,F
....................  
.................... 	return l; 
01156:  MOVFF  7E9,00
0115A:  MOVFF  7EA,01
0115E:  MOVFF  7EB,02
01162:  MOVFF  7EC,03
.................... } 
01166:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
011E0:  MOVLB  7
011E2:  MOVF   xE5,W
011E4:  SUBLW  06
011E6:  BC    123C
011E8:  XORLW  FF
011EA:  BNZ   11F2
011EC:  MOVF   xE4,W
011EE:  SUBLW  CF
011F0:  BC    123C
011F2:  MOVF   xE5,W
011F4:  SUBLW  09
011F6:  BNC   123C
011F8:  BNZ   1200
011FA:  MOVF   xE4,W
011FC:  SUBLW  CF
011FE:  BNC   123C
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01200:  MOVLW  D0
01202:  SUBWF  xE4,W
01204:  MOVWF  xE8
01206:  MOVLW  07
01208:  SUBWFB xE5,W
0120A:  MOVWF  xE9
0120C:  MOVLW  02
0120E:  ADDWF  xE9,F
01210:  MOVFF  FF2,7EA
01214:  BCF    FF2.6
01216:  BCF    FF2.7
01218:  MOVFF  7E9,FAA
0121C:  MOVFF  7E8,FA9
01220:  BCF    FA6.6
01222:  BCF    FA6.7
01224:  BSF    FA6.0
01226:  MOVF   FA8,W
01228:  BTFSC  xEA.6
0122A:  BSF    FF2.6
0122C:  BTFSC  xEA.7
0122E:  BSF    FF2.7
01230:  CLRF   03
01232:  MOVWF  01
01234:  MOVF   03,W
01236:  MOVWF  02
01238:  GOTO   1C54
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MIN_NMEA0183_CONFIG_REGISTER ) { 
0123C:  MOVF   xE5,W
0123E:  SUBLW  03
01240:  BC    12BC
01242:  XORLW  FF
01244:  BNZ   124C
01246:  MOVF   xE4,W
01248:  SUBLW  4B
0124A:  BC    12BC
0124C:  MOVF   xE5,W
0124E:  SUBLW  04
01250:  BNC   12BC
01252:  BNZ   125A
01254:  MOVF   xE4,W
01256:  SUBLW  4B
01258:  BNC   12BC
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0125A:  MOVLW  4C
0125C:  SUBWF  xE4,W
0125E:  MOVWF  xE6
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01260:  MOVFF  7E6,7E8
01264:  MOVLW  06
01266:  MOVWF  xE9
01268:  MOVLB  0
0126A:  RCALL  10DA
0126C:  MOVFF  00,7E7
.................... 		n = n / 6; /* number of sentence */ 
01270:  MOVFF  7E6,7E8
01274:  MOVLW  06
01276:  MOVLB  7
01278:  MOVWF  xE9
0127A:  MOVLB  0
0127C:  RCALL  10DA
0127E:  MOVFF  01,7E6
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
01282:  MOVLB  7
01284:  MOVF   xE6,W
01286:  MULLW  06
01288:  MOVF   FF3,W
0128A:  CLRF   03
0128C:  ADDLW  18
0128E:  MOVWF  xE8
01290:  MOVLW  00
01292:  ADDWFC 03,W
01294:  MOVWF  xE9
01296:  CLRF   03
01298:  MOVF   xE7,W
0129A:  ADDWF  xE8,W
0129C:  MOVWF  01
0129E:  MOVF   xE9,W
012A0:  ADDWFC 03,F
012A2:  MOVF   01,W
012A4:  ADDLW  36
012A6:  MOVWF  FE9
012A8:  MOVLW  00
012AA:  ADDWFC 03,W
012AC:  MOVWF  FEA
012AE:  MOVF   FEF,W
012B0:  CLRF   03
012B2:  MOVWF  01
012B4:  MOVFF  03,02
012B8:  GOTO   1C54
.................... 	} 
....................  
.................... 	switch ( addr ) { 
012BC:  MOVF   xE4,W
012BE:  MOVWF  00
012C0:  MOVF   xE5,W
012C2:  MOVWF  03
012C4:  MOVF   03,W
012C6:  BNZ   12D2
012C8:  MOVF   00,F
012CA:  MOVLB  0
012CC:  BTFSC  FD8.2
012CE:  BRA    16EE
012D0:  MOVLB  7
012D2:  MOVF   03,W
012D4:  BNZ   12E2
012D6:  MOVLW  01
012D8:  SUBWF  00,W
012DA:  MOVLB  0
012DC:  BTFSC  FD8.2
012DE:  BRA    16FC
012E0:  MOVLB  7
012E2:  MOVF   03,W
012E4:  BNZ   12F2
012E6:  MOVLW  02
012E8:  SUBWF  00,W
012EA:  MOVLB  0
012EC:  BTFSC  FD8.2
012EE:  BRA    170A
012F0:  MOVLB  7
012F2:  MOVF   03,W
012F4:  BNZ   1302
012F6:  MOVLW  03
012F8:  SUBWF  00,W
012FA:  MOVLB  0
012FC:  BTFSC  FD8.2
012FE:  BRA    1718
01300:  MOVLB  7
01302:  MOVF   03,W
01304:  BNZ   1312
01306:  MOVLW  04
01308:  SUBWF  00,W
0130A:  MOVLB  0
0130C:  BTFSC  FD8.2
0130E:  BRA    1726
01310:  MOVLB  7
01312:  MOVF   03,W
01314:  BNZ   1322
01316:  MOVLW  05
01318:  SUBWF  00,W
0131A:  MOVLB  0
0131C:  BTFSC  FD8.2
0131E:  BRA    174C
01320:  MOVLB  7
01322:  MOVF   03,W
01324:  BNZ   1332
01326:  MOVLW  06
01328:  SUBWF  00,W
0132A:  MOVLB  0
0132C:  BTFSC  FD8.2
0132E:  BRA    175A
01330:  MOVLB  7
01332:  MOVF   03,W
01334:  BNZ   1342
01336:  MOVLW  07
01338:  SUBWF  00,W
0133A:  MOVLB  0
0133C:  BTFSC  FD8.2
0133E:  BRA    1768
01340:  MOVLB  7
01342:  MOVF   03,W
01344:  BNZ   1352
01346:  MOVLW  08
01348:  SUBWF  00,W
0134A:  MOVLB  0
0134C:  BTFSC  FD8.2
0134E:  BRA    1776
01350:  MOVLB  7
01352:  MOVF   03,W
01354:  BNZ   1362
01356:  MOVLW  09
01358:  SUBWF  00,W
0135A:  MOVLB  0
0135C:  BTFSC  FD8.2
0135E:  BRA    1784
01360:  MOVLB  7
01362:  MOVF   03,W
01364:  BNZ   1372
01366:  MOVLW  0A
01368:  SUBWF  00,W
0136A:  MOVLB  0
0136C:  BTFSC  FD8.2
0136E:  BRA    1792
01370:  MOVLB  7
01372:  MOVF   03,W
01374:  BNZ   1382
01376:  MOVLW  0B
01378:  SUBWF  00,W
0137A:  MOVLB  0
0137C:  BTFSC  FD8.2
0137E:  BRA    17BA
01380:  MOVLB  7
01382:  MOVF   03,W
01384:  BNZ   1392
01386:  MOVLW  0C
01388:  SUBWF  00,W
0138A:  MOVLB  0
0138C:  BTFSC  FD8.2
0138E:  BRA    17C8
01390:  MOVLB  7
01392:  MOVF   03,W
01394:  BNZ   13A2
01396:  MOVLW  0D
01398:  SUBWF  00,W
0139A:  MOVLB  0
0139C:  BTFSC  FD8.2
0139E:  BRA    17D6
013A0:  MOVLB  7
013A2:  MOVF   03,W
013A4:  BNZ   13B2
013A6:  MOVLW  0E
013A8:  SUBWF  00,W
013AA:  MOVLB  0
013AC:  BTFSC  FD8.2
013AE:  BRA    17E4
013B0:  MOVLB  7
013B2:  MOVF   03,W
013B4:  BNZ   13C2
013B6:  MOVLW  0F
013B8:  SUBWF  00,W
013BA:  MOVLB  0
013BC:  BTFSC  FD8.2
013BE:  BRA    17F2
013C0:  MOVLB  7
013C2:  MOVF   03,W
013C4:  BNZ   13D2
013C6:  MOVLW  10
013C8:  SUBWF  00,W
013CA:  MOVLB  0
013CC:  BTFSC  FD8.2
013CE:  BRA    1800
013D0:  MOVLB  7
013D2:  MOVF   03,W
013D4:  BNZ   13E2
013D6:  MOVLW  11
013D8:  SUBWF  00,W
013DA:  MOVLB  0
013DC:  BTFSC  FD8.2
013DE:  BRA    1828
013E0:  MOVLB  7
013E2:  MOVF   03,W
013E4:  BNZ   13F2
013E6:  MOVLW  12
013E8:  SUBWF  00,W
013EA:  MOVLB  0
013EC:  BTFSC  FD8.2
013EE:  BRA    1836
013F0:  MOVLB  7
013F2:  MOVF   03,W
013F4:  BNZ   1402
013F6:  MOVLW  13
013F8:  SUBWF  00,W
013FA:  MOVLB  0
013FC:  BTFSC  FD8.2
013FE:  BRA    1864
01400:  MOVLB  7
01402:  MOVF   03,W
01404:  BNZ   1412
01406:  MOVLW  14
01408:  SUBWF  00,W
0140A:  MOVLB  0
0140C:  BTFSC  FD8.2
0140E:  BRA    187C
01410:  MOVLB  7
01412:  MOVF   03,W
01414:  BNZ   1422
01416:  MOVLW  15
01418:  SUBWF  00,W
0141A:  MOVLB  0
0141C:  BTFSC  FD8.2
0141E:  BRA    188A
01420:  MOVLB  7
01422:  MOVF   03,W
01424:  BNZ   1432
01426:  MOVLW  16
01428:  SUBWF  00,W
0142A:  MOVLB  0
0142C:  BTFSC  FD8.2
0142E:  BRA    18B8
01430:  MOVLB  7
01432:  MOVF   03,W
01434:  BNZ   1442
01436:  MOVLW  17
01438:  SUBWF  00,W
0143A:  MOVLB  0
0143C:  BTFSC  FD8.2
0143E:  BRA    18D2
01440:  MOVLB  7
01442:  MOVF   03,W
01444:  BNZ   1452
01446:  MOVLW  18
01448:  SUBWF  00,W
0144A:  MOVLB  0
0144C:  BTFSC  FD8.2
0144E:  BRA    18E0
01450:  MOVLB  7
01452:  MOVF   03,W
01454:  BNZ   1462
01456:  MOVLW  19
01458:  SUBWF  00,W
0145A:  MOVLB  0
0145C:  BTFSC  FD8.2
0145E:  BRA    190E
01460:  MOVLB  7
01462:  MOVF   03,W
01464:  BNZ   1472
01466:  MOVLW  1A
01468:  SUBWF  00,W
0146A:  MOVLB  0
0146C:  BTFSC  FD8.2
0146E:  BRA    1928
01470:  MOVLB  7
01472:  MOVF   03,W
01474:  BNZ   1482
01476:  MOVLW  1B
01478:  SUBWF  00,W
0147A:  MOVLB  0
0147C:  BTFSC  FD8.2
0147E:  BRA    1936
01480:  MOVLB  7
01482:  MOVF   03,W
01484:  BNZ   1492
01486:  MOVLW  1C
01488:  SUBWF  00,W
0148A:  MOVLB  0
0148C:  BTFSC  FD8.2
0148E:  BRA    1964
01490:  MOVLB  7
01492:  MOVF   03,W
01494:  BNZ   14A2
01496:  MOVLW  1D
01498:  SUBWF  00,W
0149A:  MOVLB  0
0149C:  BTFSC  FD8.2
0149E:  BRA    197E
014A0:  MOVLB  7
014A2:  MOVF   03,W
014A4:  BNZ   14B2
014A6:  MOVLW  1E
014A8:  SUBWF  00,W
014AA:  MOVLB  0
014AC:  BTFSC  FD8.2
014AE:  BRA    198C
014B0:  MOVLB  7
014B2:  MOVF   03,W
014B4:  BNZ   14C2
014B6:  MOVLW  1F
014B8:  SUBWF  00,W
014BA:  MOVLB  0
014BC:  BTFSC  FD8.2
014BE:  BRA    19BA
014C0:  MOVLB  7
014C2:  MOVF   03,W
014C4:  BNZ   14D2
014C6:  MOVLW  20
014C8:  SUBWF  00,W
014CA:  MOVLB  0
014CC:  BTFSC  FD8.2
014CE:  BRA    19D4
014D0:  MOVLB  7
014D2:  MOVF   03,W
014D4:  BNZ   14E2
014D6:  MOVLW  21
014D8:  SUBWF  00,W
014DA:  MOVLB  0
014DC:  BTFSC  FD8.2
014DE:  BRA    19E2
014E0:  MOVLB  7
014E2:  MOVF   03,W
014E4:  BNZ   14F2
014E6:  MOVLW  22
014E8:  SUBWF  00,W
014EA:  MOVLB  0
014EC:  BTFSC  FD8.2
014EE:  BRA    1A10
014F0:  MOVLB  7
014F2:  MOVF   03,W
014F4:  BNZ   1502
014F6:  MOVLW  23
014F8:  SUBWF  00,W
014FA:  MOVLB  0
014FC:  BTFSC  FD8.2
014FE:  BRA    1A2A
01500:  MOVLB  7
01502:  MOVF   03,W
01504:  BNZ   1512
01506:  MOVLW  24
01508:  SUBWF  00,W
0150A:  MOVLB  0
0150C:  BTFSC  FD8.2
0150E:  BRA    1A38
01510:  MOVLB  7
01512:  MOVF   03,W
01514:  BNZ   1522
01516:  MOVLW  25
01518:  SUBWF  00,W
0151A:  MOVLB  0
0151C:  BTFSC  FD8.2
0151E:  BRA    1A66
01520:  MOVLB  7
01522:  MOVF   03,W
01524:  BNZ   1532
01526:  MOVLW  26
01528:  SUBWF  00,W
0152A:  MOVLB  0
0152C:  BTFSC  FD8.2
0152E:  BRA    1A80
01530:  MOVLB  7
01532:  MOVF   03,W
01534:  BNZ   1542
01536:  MOVLW  27
01538:  SUBWF  00,W
0153A:  MOVLB  0
0153C:  BTFSC  FD8.2
0153E:  BRA    1A8E
01540:  MOVLB  7
01542:  MOVF   03,W
01544:  BNZ   1552
01546:  MOVLW  28
01548:  SUBWF  00,W
0154A:  MOVLB  0
0154C:  BTFSC  FD8.2
0154E:  BRA    1ABC
01550:  MOVLB  7
01552:  MOVF   03,W
01554:  BNZ   1562
01556:  MOVLW  29
01558:  SUBWF  00,W
0155A:  MOVLB  0
0155C:  BTFSC  FD8.2
0155E:  BRA    1AD6
01560:  MOVLB  7
01562:  MOVF   03,W
01564:  BNZ   1572
01566:  MOVLW  2A
01568:  SUBWF  00,W
0156A:  MOVLB  0
0156C:  BTFSC  FD8.2
0156E:  BRA    1AE4
01570:  MOVLB  7
01572:  MOVF   03,W
01574:  BNZ   1582
01576:  MOVLW  2B
01578:  SUBWF  00,W
0157A:  MOVLB  0
0157C:  BTFSC  FD8.2
0157E:  BRA    1AFE
01580:  MOVLB  7
01582:  MOVF   03,W
01584:  BNZ   1592
01586:  MOVLW  2C
01588:  SUBWF  00,W
0158A:  MOVLB  0
0158C:  BTFSC  FD8.2
0158E:  BRA    1B0E
01590:  MOVLB  7
01592:  MOVF   03,W
01594:  BNZ   15A2
01596:  MOVLW  2D
01598:  SUBWF  00,W
0159A:  MOVLB  0
0159C:  BTFSC  FD8.2
0159E:  BRA    1B1E
015A0:  MOVLB  7
015A2:  MOVF   03,W
015A4:  BNZ   15B2
015A6:  MOVLW  2E
015A8:  SUBWF  00,W
015AA:  MOVLB  0
015AC:  BTFSC  FD8.2
015AE:  BRA    1B2E
015B0:  MOVLB  7
015B2:  MOVF   03,W
015B4:  BNZ   15C2
015B6:  MOVLW  2F
015B8:  SUBWF  00,W
015BA:  MOVLB  0
015BC:  BTFSC  FD8.2
015BE:  BRA    1B3E
015C0:  MOVLB  7
015C2:  MOVF   03,W
015C4:  BNZ   15D2
015C6:  MOVLW  30
015C8:  SUBWF  00,W
015CA:  MOVLB  0
015CC:  BTFSC  FD8.2
015CE:  BRA    1B4E
015D0:  MOVLB  7
015D2:  MOVF   03,W
015D4:  BNZ   15E2
015D6:  MOVLW  31
015D8:  SUBWF  00,W
015DA:  MOVLB  0
015DC:  BTFSC  FD8.2
015DE:  BRA    1B5E
015E0:  MOVLB  7
015E2:  MOVF   03,W
015E4:  BNZ   15F2
015E6:  MOVLW  32
015E8:  SUBWF  00,W
015EA:  MOVLB  0
015EC:  BTFSC  FD8.2
015EE:  BRA    1B6E
015F0:  MOVLB  7
015F2:  MOVF   03,W
015F4:  BNZ   1602
015F6:  MOVLW  33
015F8:  SUBWF  00,W
015FA:  MOVLB  0
015FC:  BTFSC  FD8.2
015FE:  BRA    1B7E
01600:  MOVLB  7
01602:  MOVLW  03
01604:  SUBWF  03,W
01606:  BNZ   1614
01608:  MOVLW  E8
0160A:  SUBWF  00,W
0160C:  MOVLB  0
0160E:  BTFSC  FD8.2
01610:  BRA    1B8E
01612:  MOVLB  7
01614:  MOVLW  03
01616:  SUBWF  03,W
01618:  BNZ   1626
0161A:  MOVLW  E9
0161C:  SUBWF  00,W
0161E:  MOVLB  0
01620:  BTFSC  FD8.2
01622:  BRA    1B9E
01624:  MOVLB  7
01626:  MOVLW  03
01628:  SUBWF  03,W
0162A:  BNZ   1638
0162C:  MOVLW  EA
0162E:  SUBWF  00,W
01630:  MOVLB  0
01632:  BTFSC  FD8.2
01634:  BRA    1BAC
01636:  MOVLB  7
01638:  MOVLW  03
0163A:  SUBWF  03,W
0163C:  BNZ   164A
0163E:  MOVLW  EB
01640:  SUBWF  00,W
01642:  MOVLB  0
01644:  BTFSC  FD8.2
01646:  BRA    1BBA
01648:  MOVLB  7
0164A:  MOVLW  03
0164C:  SUBWF  03,W
0164E:  BNZ   165C
01650:  MOVLW  EC
01652:  SUBWF  00,W
01654:  MOVLB  0
01656:  BTFSC  FD8.2
01658:  BRA    1BC8
0165A:  MOVLB  7
0165C:  MOVLW  03
0165E:  SUBWF  03,W
01660:  BNZ   166E
01662:  MOVLW  ED
01664:  SUBWF  00,W
01666:  MOVLB  0
01668:  BTFSC  FD8.2
0166A:  BRA    1BD6
0166C:  MOVLB  7
0166E:  MOVLW  03
01670:  SUBWF  03,W
01672:  BNZ   1680
01674:  MOVLW  EE
01676:  SUBWF  00,W
01678:  MOVLB  0
0167A:  BTFSC  FD8.2
0167C:  BRA    1BE4
0167E:  MOVLB  7
01680:  MOVLW  03
01682:  SUBWF  03,W
01684:  BNZ   1692
01686:  MOVLW  EF
01688:  SUBWF  00,W
0168A:  MOVLB  0
0168C:  BTFSC  FD8.2
0168E:  BRA    1BF4
01690:  MOVLB  7
01692:  MOVLW  03
01694:  SUBWF  03,W
01696:  BNZ   16A4
01698:  MOVLW  F0
0169A:  SUBWF  00,W
0169C:  MOVLB  0
0169E:  BTFSC  FD8.2
016A0:  BRA    1C02
016A2:  MOVLB  7
016A4:  MOVLW  03
016A6:  SUBWF  03,W
016A8:  BNZ   16B6
016AA:  MOVLW  F1
016AC:  SUBWF  00,W
016AE:  MOVLB  0
016B0:  BTFSC  FD8.2
016B2:  BRA    1C12
016B4:  MOVLB  7
016B6:  MOVLW  03
016B8:  SUBWF  03,W
016BA:  BNZ   16C8
016BC:  MOVLW  F2
016BE:  SUBWF  00,W
016C0:  MOVLB  0
016C2:  BTFSC  FD8.2
016C4:  BRA    1C20
016C6:  MOVLB  7
016C8:  MOVLW  03
016CA:  SUBWF  03,W
016CC:  BNZ   16DA
016CE:  MOVLW  F3
016D0:  SUBWF  00,W
016D2:  MOVLB  0
016D4:  BTFSC  FD8.2
016D6:  BRA    1C2E
016D8:  MOVLB  7
016DA:  MOVLW  03
016DC:  SUBWF  03,W
016DE:  BNZ   16EC
016E0:  MOVLW  F4
016E2:  SUBWF  00,W
016E4:  MOVLB  0
016E6:  BTFSC  FD8.2
016E8:  BRA    1C3E
016EA:  MOVLB  7
016EC:  BRA    1C4C
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
016EE:  MOVFF  A8,01
016F2:  MOVFF  A9,02
016F6:  MOVLB  7
016F8:  BRA    1C54
016FA:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
016FC:  MOVF   x96,W
016FE:  MOVWF  01
01700:  MOVF   x97,W
01702:  MOVWF  02
01704:  MOVLB  7
01706:  BRA    1C54
01708:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
0170A:  MOVF   x9C,W
0170C:  MOVWF  01
0170E:  MOVF   x9D,W
01710:  MOVWF  02
01712:  MOVLB  7
01714:  BRA    1C54
01716:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01718:  MOVF   xA2,W
0171A:  MOVWF  01
0171C:  MOVF   xA3,W
0171E:  MOVWF  02
01720:  MOVLB  7
01722:  BRA    1C54
01724:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01726:  MOVLB  7
01728:  CLRF   xE8
0172A:  MOVLB  0
0172C:  RCALL  1106
0172E:  MOVFF  03,7C6
01732:  MOVFF  02,7C5
01736:  MOVFF  01,7C4
0173A:  MOVFF  00,7C3
0173E:  MOVLB  7
01740:  MOVF   xC3,W
01742:  MOVWF  01
01744:  MOVF   xC4,W
01746:  MOVWF  02
01748:  BRA    1C54
0174A:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
0174C:  MOVLB  7
0174E:  MOVF   xC5,W
01750:  MOVWF  01
01752:  MOVF   xC6,W
01754:  MOVWF  02
01756:  BRA    1C54
01758:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
0175A:  MOVF   xAA,W
0175C:  MOVWF  01
0175E:  MOVF   xAB,W
01760:  MOVWF  02
01762:  MOVLB  7
01764:  BRA    1C54
01766:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01768:  MOVF   x98,W
0176A:  MOVWF  01
0176C:  MOVF   x99,W
0176E:  MOVWF  02
01770:  MOVLB  7
01772:  BRA    1C54
01774:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01776:  MOVF   x9E,W
01778:  MOVWF  01
0177A:  MOVF   x9F,W
0177C:  MOVWF  02
0177E:  MOVLB  7
01780:  BRA    1C54
01782:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01784:  MOVF   xA4,W
01786:  MOVWF  01
01788:  MOVF   xA5,W
0178A:  MOVWF  02
0178C:  MOVLB  7
0178E:  BRA    1C54
01790:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01792:  MOVLW  01
01794:  MOVLB  7
01796:  MOVWF  xE8
01798:  MOVLB  0
0179A:  RCALL  1106
0179C:  MOVFF  03,7C6
017A0:  MOVFF  02,7C5
017A4:  MOVFF  01,7C4
017A8:  MOVFF  00,7C3
017AC:  MOVLB  7
017AE:  MOVF   xC3,W
017B0:  MOVWF  01
017B2:  MOVF   xC4,W
017B4:  MOVWF  02
017B6:  BRA    1C54
017B8:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
017BA:  MOVLB  7
017BC:  MOVF   xC5,W
017BE:  MOVWF  01
017C0:  MOVF   xC6,W
017C2:  MOVWF  02
017C4:  BRA    1C54
017C6:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
017C8:  MOVF   xAC,W
017CA:  MOVWF  01
017CC:  MOVF   xAD,W
017CE:  MOVWF  02
017D0:  MOVLB  7
017D2:  BRA    1C54
017D4:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
017D6:  MOVF   x9A,W
017D8:  MOVWF  01
017DA:  MOVF   x9B,W
017DC:  MOVWF  02
017DE:  MOVLB  7
017E0:  BRA    1C54
017E2:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
017E4:  MOVF   xA0,W
017E6:  MOVWF  01
017E8:  MOVF   xA1,W
017EA:  MOVWF  02
017EC:  MOVLB  7
017EE:  BRA    1C54
017F0:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
017F2:  MOVF   xA6,W
017F4:  MOVWF  01
017F6:  MOVF   xA7,W
017F8:  MOVWF  02
017FA:  MOVLB  7
017FC:  BRA    1C54
017FE:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01800:  MOVLW  02
01802:  MOVLB  7
01804:  MOVWF  xE8
01806:  MOVLB  0
01808:  RCALL  1106
0180A:  MOVFF  03,7C6
0180E:  MOVFF  02,7C5
01812:  MOVFF  01,7C4
01816:  MOVFF  00,7C3
0181A:  MOVLB  7
0181C:  MOVF   xC3,W
0181E:  MOVWF  01
01820:  MOVF   xC4,W
01822:  MOVWF  02
01824:  BRA    1C54
01826:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01828:  MOVLB  7
0182A:  MOVF   xC5,W
0182C:  MOVWF  01
0182E:  MOVF   xC6,W
01830:  MOVWF  02
01832:  BRA    1C54
01834:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01836:  CLRF   03
01838:  MOVLB  1
0183A:  MOVF   xCA,W
0183C:  MOVWF  02
0183E:  BCF    FD8.0
01840:  RLCF   02,F
01842:  RLCF   03,F
01844:  MOVF   02,W
01846:  ADDLW  CA
01848:  MOVWF  FE9
0184A:  MOVLW  00
0184C:  ADDWFC 03,W
0184E:  MOVWF  FEA
01850:  MOVFF  FEC,03
01854:  MOVF   FED,F
01856:  MOVF   FEF,W
01858:  MOVWF  01
0185A:  MOVF   03,W
0185C:  MOVWF  02
0185E:  MOVLB  7
01860:  BRA    1C54
01862:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01864:  MOVLB  7
01866:  CLRF   xE8
01868:  MOVLB  0
0186A:  CALL   0D28
0186E:  MOVF   01,W
01870:  MOVWF  01
01872:  MOVF   02,W
01874:  MOVWF  02
01876:  MOVLB  7
01878:  BRA    1C54
0187A:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
0187C:  MOVF   xBA,W
0187E:  MOVWF  01
01880:  MOVF   xBB,W
01882:  MOVWF  02
01884:  MOVLB  7
01886:  BRA    1C54
01888:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
0188A:  CLRF   03
0188C:  MOVLB  1
0188E:  MOVF   xCA,W
01890:  MOVWF  02
01892:  BCF    FD8.0
01894:  RLCF   02,F
01896:  RLCF   03,F
01898:  MOVF   02,W
0189A:  ADDLW  EA
0189C:  MOVWF  FE9
0189E:  MOVLW  00
018A0:  ADDWFC 03,W
018A2:  MOVWF  FEA
018A4:  MOVFF  FEC,03
018A8:  MOVF   FED,F
018AA:  MOVF   FEF,W
018AC:  MOVWF  01
018AE:  MOVF   03,W
018B0:  MOVWF  02
018B2:  MOVLB  7
018B4:  BRA    1C54
018B6:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
018B8:  MOVLW  01
018BA:  MOVLB  7
018BC:  MOVWF  xE8
018BE:  MOVLB  0
018C0:  CALL   0D28
018C4:  MOVF   01,W
018C6:  MOVWF  01
018C8:  MOVF   02,W
018CA:  MOVWF  02
018CC:  MOVLB  7
018CE:  BRA    1C54
018D0:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
018D2:  MOVF   xBC,W
018D4:  MOVWF  01
018D6:  MOVF   xBD,W
018D8:  MOVWF  02
018DA:  MOVLB  7
018DC:  BRA    1C54
018DE:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
018E0:  CLRF   03
018E2:  MOVLB  1
018E4:  MOVF   xCA,W
018E6:  MOVWF  02
018E8:  BCF    FD8.0
018EA:  RLCF   02,F
018EC:  RLCF   03,F
018EE:  MOVF   02,W
018F0:  ADDLW  0A
018F2:  MOVWF  FE9
018F4:  MOVLW  01
018F6:  ADDWFC 03,W
018F8:  MOVWF  FEA
018FA:  MOVFF  FEC,03
018FE:  MOVF   FED,F
01900:  MOVF   FEF,W
01902:  MOVWF  01
01904:  MOVF   03,W
01906:  MOVWF  02
01908:  MOVLB  7
0190A:  BRA    1C54
0190C:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
0190E:  MOVLW  02
01910:  MOVLB  7
01912:  MOVWF  xE8
01914:  MOVLB  0
01916:  CALL   0D28
0191A:  MOVF   01,W
0191C:  MOVWF  01
0191E:  MOVF   02,W
01920:  MOVWF  02
01922:  MOVLB  7
01924:  BRA    1C54
01926:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01928:  MOVF   xBE,W
0192A:  MOVWF  01
0192C:  MOVF   xBF,W
0192E:  MOVWF  02
01930:  MOVLB  7
01932:  BRA    1C54
01934:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01936:  CLRF   03
01938:  MOVLB  1
0193A:  MOVF   xCA,W
0193C:  MOVWF  02
0193E:  BCF    FD8.0
01940:  RLCF   02,F
01942:  RLCF   03,F
01944:  MOVF   02,W
01946:  ADDLW  2A
01948:  MOVWF  FE9
0194A:  MOVLW  01
0194C:  ADDWFC 03,W
0194E:  MOVWF  FEA
01950:  MOVFF  FEC,03
01954:  MOVF   FED,F
01956:  MOVF   FEF,W
01958:  MOVWF  01
0195A:  MOVF   03,W
0195C:  MOVWF  02
0195E:  MOVLB  7
01960:  BRA    1C54
01962:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01964:  MOVLW  03
01966:  MOVLB  7
01968:  MOVWF  xE8
0196A:  MOVLB  0
0196C:  CALL   0D28
01970:  MOVF   01,W
01972:  MOVWF  01
01974:  MOVF   02,W
01976:  MOVWF  02
01978:  MOVLB  7
0197A:  BRA    1C54
0197C:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
0197E:  MOVF   xC0,W
01980:  MOVWF  01
01982:  MOVF   xC1,W
01984:  MOVWF  02
01986:  MOVLB  7
01988:  BRA    1C54
0198A:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
0198C:  CLRF   03
0198E:  MOVLB  1
01990:  MOVF   xCA,W
01992:  MOVWF  02
01994:  BCF    FD8.0
01996:  RLCF   02,F
01998:  RLCF   03,F
0199A:  MOVF   02,W
0199C:  ADDLW  4A
0199E:  MOVWF  FE9
019A0:  MOVLW  01
019A2:  ADDWFC 03,W
019A4:  MOVWF  FEA
019A6:  MOVFF  FEC,03
019AA:  MOVF   FED,F
019AC:  MOVF   FEF,W
019AE:  MOVWF  01
019B0:  MOVF   03,W
019B2:  MOVWF  02
019B4:  MOVLB  7
019B6:  BRA    1C54
019B8:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
019BA:  MOVLW  04
019BC:  MOVLB  7
019BE:  MOVWF  xE8
019C0:  MOVLB  0
019C2:  CALL   0D28
019C6:  MOVF   01,W
019C8:  MOVWF  01
019CA:  MOVF   02,W
019CC:  MOVWF  02
019CE:  MOVLB  7
019D0:  BRA    1C54
019D2:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
019D4:  MOVF   xC2,W
019D6:  MOVWF  01
019D8:  MOVF   xC3,W
019DA:  MOVWF  02
019DC:  MOVLB  7
019DE:  BRA    1C54
019E0:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
019E2:  CLRF   03
019E4:  MOVLB  1
019E6:  MOVF   xCA,W
019E8:  MOVWF  02
019EA:  BCF    FD8.0
019EC:  RLCF   02,F
019EE:  RLCF   03,F
019F0:  MOVF   02,W
019F2:  ADDLW  6A
019F4:  MOVWF  FE9
019F6:  MOVLW  01
019F8:  ADDWFC 03,W
019FA:  MOVWF  FEA
019FC:  MOVFF  FEC,03
01A00:  MOVF   FED,F
01A02:  MOVF   FEF,W
01A04:  MOVWF  01
01A06:  MOVF   03,W
01A08:  MOVWF  02
01A0A:  MOVLB  7
01A0C:  BRA    1C54
01A0E:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01A10:  MOVLW  05
01A12:  MOVLB  7
01A14:  MOVWF  xE8
01A16:  MOVLB  0
01A18:  CALL   0D28
01A1C:  MOVF   01,W
01A1E:  MOVWF  01
01A20:  MOVF   02,W
01A22:  MOVWF  02
01A24:  MOVLB  7
01A26:  BRA    1C54
01A28:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01A2A:  MOVF   xC4,W
01A2C:  MOVWF  01
01A2E:  MOVF   xC5,W
01A30:  MOVWF  02
01A32:  MOVLB  7
01A34:  BRA    1C54
01A36:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01A38:  CLRF   03
01A3A:  MOVLB  1
01A3C:  MOVF   xCA,W
01A3E:  MOVWF  02
01A40:  BCF    FD8.0
01A42:  RLCF   02,F
01A44:  RLCF   03,F
01A46:  MOVF   02,W
01A48:  ADDLW  8A
01A4A:  MOVWF  FE9
01A4C:  MOVLW  01
01A4E:  ADDWFC 03,W
01A50:  MOVWF  FEA
01A52:  MOVFF  FEC,03
01A56:  MOVF   FED,F
01A58:  MOVF   FEF,W
01A5A:  MOVWF  01
01A5C:  MOVF   03,W
01A5E:  MOVWF  02
01A60:  MOVLB  7
01A62:  BRA    1C54
01A64:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01A66:  MOVLW  06
01A68:  MOVLB  7
01A6A:  MOVWF  xE8
01A6C:  MOVLB  0
01A6E:  CALL   0D28
01A72:  MOVF   01,W
01A74:  MOVWF  01
01A76:  MOVF   02,W
01A78:  MOVWF  02
01A7A:  MOVLB  7
01A7C:  BRA    1C54
01A7E:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01A80:  MOVF   xC6,W
01A82:  MOVWF  01
01A84:  MOVF   xC7,W
01A86:  MOVWF  02
01A88:  MOVLB  7
01A8A:  BRA    1C54
01A8C:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01A8E:  CLRF   03
01A90:  MOVLB  1
01A92:  MOVF   xCA,W
01A94:  MOVWF  02
01A96:  BCF    FD8.0
01A98:  RLCF   02,F
01A9A:  RLCF   03,F
01A9C:  MOVF   02,W
01A9E:  ADDLW  AA
01AA0:  MOVWF  FE9
01AA2:  MOVLW  01
01AA4:  ADDWFC 03,W
01AA6:  MOVWF  FEA
01AA8:  MOVFF  FEC,03
01AAC:  MOVF   FED,F
01AAE:  MOVF   FEF,W
01AB0:  MOVWF  01
01AB2:  MOVF   03,W
01AB4:  MOVWF  02
01AB6:  MOVLB  7
01AB8:  BRA    1C54
01ABA:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01ABC:  MOVLW  07
01ABE:  MOVLB  7
01AC0:  MOVWF  xE8
01AC2:  MOVLB  0
01AC4:  CALL   0D28
01AC8:  MOVF   01,W
01ACA:  MOVWF  01
01ACC:  MOVF   02,W
01ACE:  MOVWF  02
01AD0:  MOVLB  7
01AD2:  BRA    1C54
01AD4:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01AD6:  MOVF   xC8,W
01AD8:  MOVWF  01
01ADA:  MOVF   xC9,W
01ADC:  MOVWF  02
01ADE:  MOVLB  7
01AE0:  BRA    1C54
01AE2:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01AE4:  MOVLB  1
01AE6:  MOVF   xD2,W
01AE8:  MOVWF  03
01AEA:  MOVF   xD1,W
01AEC:  INCF   xD1,F
01AEE:  BTFSC  FD8.2
01AF0:  INCF   xD2,F
01AF2:  MOVWF  01
01AF4:  MOVF   03,W
01AF6:  MOVWF  02
01AF8:  MOVLB  7
01AFA:  BRA    1C54
01AFC:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01AFE:  MOVLB  1
01B00:  MOVF   xD5,W
01B02:  MOVWF  01
01B04:  MOVF   xD6,W
01B06:  MOVWF  02
01B08:  MOVLB  7
01B0A:  BRA    1C54
01B0C:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01B0E:  MOVLB  1
01B10:  MOVF   xD3,W
01B12:  MOVWF  01
01B14:  MOVF   xD4,W
01B16:  MOVWF  02
01B18:  MOVLB  7
01B1A:  BRA    1C54
01B1C:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01B1E:  MOVLB  1
01B20:  MOVF   xD9,W
01B22:  MOVWF  01
01B24:  MOVF   xDA,W
01B26:  MOVWF  02
01B28:  MOVLB  7
01B2A:  BRA    1C54
01B2C:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01B2E:  GOTO   1168
01B32:  MOVLW  00
01B34:  MOVWF  01
01B36:  MOVWF  02
01B38:  MOVLB  7
01B3A:  BRA    1C54
01B3C:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01B3E:  GOTO   11A4
01B42:  MOVLW  00
01B44:  MOVWF  01
01B46:  MOVWF  02
01B48:  MOVLB  7
01B4A:  BRA    1C54
01B4C:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01B4E:  MOVLB  1
01B50:  MOVF   xCB,W
01B52:  MOVWF  01
01B54:  MOVF   xCC,W
01B56:  MOVWF  02
01B58:  MOVLB  7
01B5A:  BRA    1C54
01B5C:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01B5E:  MOVLB  1
01B60:  MOVF   xCD,W
01B62:  MOVWF  01
01B64:  MOVF   xCE,W
01B66:  MOVWF  02
01B68:  MOVLB  7
01B6A:  BRA    1C54
01B6C:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01B6E:  MOVLB  1
01B70:  MOVF   xCF,W
01B72:  MOVWF  01
01B74:  MOVF   xD0,W
01B76:  MOVWF  02
01B78:  MOVLB  7
01B7A:  BRA    1C54
01B7C:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01B7E:  GOTO   11CC
01B82:  MOVLW  00
01B84:  MOVWF  01
01B86:  MOVWF  02
01B88:  MOVLB  7
01B8A:  BRA    1C54
01B8C:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01B8E:  CLRF   03
01B90:  MOVF   39,W
01B92:  MOVWF  01
01B94:  MOVF   03,W
01B96:  MOVWF  02
01B98:  MOVLB  7
01B9A:  BRA    1C54
01B9C:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01B9E:  MOVF   3A,W
01BA0:  MOVWF  01
01BA2:  MOVF   3B,W
01BA4:  MOVWF  02
01BA6:  MOVLB  7
01BA8:  BRA    1C54
01BAA:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01BAC:  MOVLW  50
01BAE:  MOVWF  01
01BB0:  MOVLW  00
01BB2:  MOVWF  02
01BB4:  MOVLB  7
01BB6:  BRA    1C54
01BB8:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01BBA:  MOVLW  57
01BBC:  MOVWF  01
01BBE:  MOVLW  00
01BC0:  MOVWF  02
01BC2:  MOVLB  7
01BC4:  BRA    1C54
01BC6:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01BC8:  MOVLW  58
01BCA:  MOVWF  01
01BCC:  MOVLW  00
01BCE:  MOVWF  02
01BD0:  MOVLB  7
01BD2:  BRA    1C54
01BD4:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01BD6:  MOVLW  01
01BD8:  MOVWF  01
01BDA:  MOVLW  00
01BDC:  MOVWF  02
01BDE:  MOVLB  7
01BE0:  BRA    1C54
01BE2:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01BE4:  CLRF   03
01BE6:  MOVF   36,W
01BE8:  MOVWF  01
01BEA:  MOVF   03,W
01BEC:  MOVWF  02
01BEE:  MOVLB  7
01BF0:  BRA    1C54
01BF2:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01BF4:  MOVF   3C,W
01BF6:  MOVWF  01
01BF8:  MOVF   3D,W
01BFA:  MOVWF  02
01BFC:  MOVLB  7
01BFE:  BRA    1C54
01C00:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01C02:  CLRF   03
01C04:  MOVF   3E,W
01C06:  MOVWF  01
01C08:  MOVF   03,W
01C0A:  MOVWF  02
01C0C:  MOVLB  7
01C0E:  BRA    1C54
01C10:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01C12:  MOVF   3F,W
01C14:  MOVWF  01
01C16:  MOVF   40,W
01C18:  MOVWF  02
01C1A:  MOVLB  7
01C1C:  BRA    1C54
01C1E:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01C20:  MOVF   41,W
01C22:  MOVWF  01
01C24:  MOVF   42,W
01C26:  MOVWF  02
01C28:  MOVLB  7
01C2A:  BRA    1C54
01C2C:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01C2E:  CLRF   03
01C30:  MOVF   43,W
01C32:  MOVWF  01
01C34:  MOVF   03,W
01C36:  MOVWF  02
01C38:  MOVLB  7
01C3A:  BRA    1C54
01C3C:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01C3E:  CLRF   03
01C40:  MOVF   38,W
01C42:  MOVWF  01
01C44:  MOVF   03,W
01C46:  MOVWF  02
01C48:  MOVLB  7
01C4A:  BRA    1C54
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01C4C:  MOVLW  FF
01C4E:  MOVWF  01
01C50:  MOVWF  02
01C52:  BRA    1C54
.................... 	} 
....................  
.................... } 
01C54:  MOVLB  0
01C56:  GOTO   1CA8 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
00F7C:  MOVLB  7
00F7E:  MOVF   xDA,W
00F80:  SUBLW  1F
00F82:  BNZ   0F9C
00F84:  MOVF   xDB,W
00F86:  SUBLW  4E
00F88:  BNZ   0F9C
00F8A:  MOVF   xDC,W
00F8C:  SUBLW  20
00F8E:  BNZ   0F9C
00F90:  MOVF   xDD,W
00F92:  SUBLW  4E
00F94:  BNZ   0F9C
.................... 		return 1; 
00F96:  MOVLW  01
00F98:  MOVWF  01
00F9A:  BRA    101C
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
00F9C:  MOVF   xDB,W
00F9E:  SUBLW  03
00FA0:  BC    0FC0
00FA2:  XORLW  FF
00FA4:  BNZ   0FAC
00FA6:  MOVF   xDA,W
00FA8:  SUBLW  4B
00FAA:  BC    0FC0
00FAC:  MOVF   xDD,W
00FAE:  SUBLW  04
00FB0:  BNC   0FC0
00FB2:  BNZ   0FBA
00FB4:  MOVF   xDC,W
00FB6:  SUBLW  95
00FB8:  BNC   0FC0
.................... 		return 1; 
00FBA:  MOVLW  01
00FBC:  MOVWF  01
00FBE:  BRA    101C
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
00FC0:  MOVF   xDB,W
00FC2:  SUBLW  02
00FC4:  BC    0FE4
00FC6:  XORLW  FF
00FC8:  BNZ   0FD0
00FCA:  MOVF   xDA,W
00FCC:  SUBLW  E7
00FCE:  BC    0FE4
00FD0:  MOVF   xDD,W
00FD2:  SUBLW  03
00FD4:  BNC   0FE4
00FD6:  BNZ   0FDE
00FD8:  MOVF   xDC,W
00FDA:  SUBLW  F5
00FDC:  BNC   0FE4
.................... 		return 1; 
00FDE:  MOVLW  01
00FE0:  MOVWF  01
00FE2:  BRA    101C
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
00FE4:  MOVF   xDB,W
00FE6:  SUBLW  06
00FE8:  BC    1008
00FEA:  XORLW  FF
00FEC:  BNZ   0FF4
00FEE:  MOVF   xDA,W
00FF0:  SUBLW  CF
00FF2:  BC    1008
00FF4:  MOVF   xDD,W
00FF6:  SUBLW  09
00FF8:  BNC   1008
00FFA:  BNZ   1002
00FFC:  MOVF   xDC,W
00FFE:  SUBLW  D1
01000:  BNC   1008
.................... 		return 1; 
01002:  MOVLW  01
01004:  MOVWF  01
01006:  BRA    101C
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01008:  MOVF   xDD,F
0100A:  BNZ   1018
0100C:  MOVF   xDC,W
0100E:  SUBLW  34
01010:  BNC   1018
.................... 		return 1; 
01012:  MOVLW  01
01014:  MOVWF  01
01016:  BRA    101C
....................  
.................... 	return 0; 
01018:  MOVLW  00
0101A:  MOVWF  01
.................... } 
0101C:  MOVLB  0
0101E:  GOTO   21A4 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01C5A:  MOVFF  7D9,7E2
01C5E:  MOVFF  7D8,7E3
01C62:  CALL   105E
.................... 	modbus_serial_putc(register_count*2); 
01C66:  BCF    FD8.0
01C68:  MOVLB  7
01C6A:  RLCF   xDC,W
01C6C:  MOVWF  xE2
01C6E:  RLCF   xDD,W
01C70:  MOVWF  xE3
01C72:  MOVFF  7E2,7E4
01C76:  MOVLB  0
01C78:  CALL   102A
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01C7C:  MOVLB  7
01C7E:  CLRF   xDF
01C80:  CLRF   xDE
01C82:  MOVF   xDF,W
01C84:  SUBWF  xDD,W
01C86:  BNC   1CD2
01C88:  BNZ   1C90
01C8A:  MOVF   xDC,W
01C8C:  SUBWF  xDE,W
01C8E:  BC    1CD2
.................... 		l=map_modbus(start_address+i); 
01C90:  MOVF   xDE,W
01C92:  ADDWF  xDA,W
01C94:  MOVWF  xE2
01C96:  MOVF   xDF,W
01C98:  ADDWFC xDB,W
01C9A:  MOVWF  xE3
01C9C:  MOVWF  xE5
01C9E:  MOVFF  7E2,7E4
01CA2:  MOVLB  0
01CA4:  GOTO   11E0
01CA8:  MOVFF  02,7E1
01CAC:  MOVFF  01,7E0
.................... 		modbus_serial_putc(make8(l,1)); 
01CB0:  MOVFF  7E1,7E2
01CB4:  MOVFF  7E1,7E4
01CB8:  CALL   102A
....................   		modbus_serial_putc(make8(l,0)); 
01CBC:  MOVFF  7E0,7E2
01CC0:  MOVFF  7E0,7E4
01CC4:  CALL   102A
.................... 	} 
01CC8:  MOVLB  7
01CCA:  INCF   xDE,F
01CCC:  BTFSC  FD8.2
01CCE:  INCF   xDF,F
01CD0:  BRA    1C82
....................  
.................... 	modbus_serial_send_stop(); 
01CD2:  MOVLB  0
01CD4:  CALL   108C
.................... } 
01CD8:  GOTO   21E6 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01CDC:  MOVLB  7
01CDE:  MOVF   xDF,W
01CE0:  SUBLW  06
01CE2:  BC    1D5A
01CE4:  XORLW  FF
01CE6:  BNZ   1CEE
01CE8:  MOVF   xDE,W
01CEA:  SUBLW  CF
01CEC:  BC    1D5A
01CEE:  MOVF   xDF,W
01CF0:  SUBLW  09
01CF2:  BNC   1D5A
01CF4:  BNZ   1CFC
01CF6:  MOVF   xDE,W
01CF8:  SUBLW  CF
01CFA:  BNC   1D5A
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01CFC:  MOVF   xE1,W
01CFE:  SUBLW  00
01D00:  BC    1D12
01D02:  XORLW  FF
01D04:  BNZ   1D0C
01D06:  MOVF   xE0,W
01D08:  SUBLW  00
01D0A:  BC    1D12
01D0C:  MOVLW  03
01D0E:  MOVWF  01
01D10:  BRA    1FDC
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01D12:  MOVLW  D0
01D14:  SUBWF  xDE,W
01D16:  MOVWF  xE4
01D18:  MOVLW  07
01D1A:  SUBWFB xDF,W
01D1C:  MOVWF  xE5
01D1E:  MOVLW  02
01D20:  ADDWF  xE5,F
01D22:  MOVFF  7E5,FAA
01D26:  MOVFF  7E4,FA9
01D2A:  MOVFF  7E0,FA8
01D2E:  BCF    FA6.6
01D30:  BCF    FA6.7
01D32:  BSF    FA6.2
01D34:  MOVF   FF2,W
01D36:  MOVWF  00
01D38:  BCF    FF2.6
01D3A:  BCF    FF2.7
01D3C:  MOVLB  F
01D3E:  MOVLW  55
01D40:  MOVWF  FA7
01D42:  MOVLW  AA
01D44:  MOVWF  FA7
01D46:  BSF    FA6.1
01D48:  BTFSC  FA6.1
01D4A:  BRA    1D48
01D4C:  BCF    FA6.2
01D4E:  MOVF   00,W
01D50:  IORWF  FF2,F
.................... 		return 0; 
01D52:  MOVLW  00
01D54:  MOVWF  01
01D56:  MOVLB  7
01D58:  BRA    1FDC
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
01D5A:  MOVF   xDF,W
01D5C:  SUBLW  03
01D5E:  BC    1DF0
01D60:  XORLW  FF
01D62:  BNZ   1D6A
01D64:  MOVF   xDE,W
01D66:  SUBLW  4B
01D68:  BC    1DF0
01D6A:  MOVF   xDF,W
01D6C:  SUBLW  04
01D6E:  BNC   1DF0
01D70:  BNZ   1D78
01D72:  MOVF   xDE,W
01D74:  SUBLW  93
01D76:  BNC   1DF0
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01D78:  MOVF   xE1,W
01D7A:  SUBLW  00
01D7C:  BC    1D8E
01D7E:  XORLW  FF
01D80:  BNZ   1D88
01D82:  MOVF   xE0,W
01D84:  SUBLW  00
01D86:  BC    1D8E
01D88:  MOVLW  03
01D8A:  MOVWF  01
01D8C:  BRA    1FDC
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
01D8E:  MOVLW  4C
01D90:  SUBWF  xDE,W
01D92:  MOVWF  xE2
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01D94:  MOVFF  7E2,7E8
01D98:  MOVLW  06
01D9A:  MOVWF  xE9
01D9C:  MOVLB  0
01D9E:  CALL   10DA
01DA2:  MOVFF  00,7E3
.................... 		n = n / 6; /* number of sentence */ 
01DA6:  MOVFF  7E2,7E8
01DAA:  MOVLW  06
01DAC:  MOVLB  7
01DAE:  MOVWF  xE9
01DB0:  MOVLB  0
01DB2:  CALL   10DA
01DB6:  MOVFF  01,7E2
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
01DBA:  MOVLB  7
01DBC:  MOVF   xE2,W
01DBE:  MULLW  06
01DC0:  MOVF   FF3,W
01DC2:  CLRF   03
01DC4:  ADDLW  18
01DC6:  MOVWF  xE4
01DC8:  MOVLW  00
01DCA:  ADDWFC 03,W
01DCC:  MOVWF  xE5
01DCE:  CLRF   03
01DD0:  MOVF   xE3,W
01DD2:  ADDWF  xE4,W
01DD4:  MOVWF  01
01DD6:  MOVF   xE5,W
01DD8:  ADDWFC 03,F
01DDA:  MOVF   01,W
01DDC:  ADDLW  36
01DDE:  MOVWF  FE9
01DE0:  MOVLW  00
01DE2:  ADDWFC 03,W
01DE4:  MOVWF  FEA
01DE6:  MOVFF  7E0,FEF
.................... 		 
.................... 		return 0; 
01DEA:  MOVLW  00
01DEC:  MOVWF  01
01DEE:  BRA    1FDC
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01DF0:  MOVLB  1
01DF2:  MOVF   xD7,F
01DF4:  BZ    1E2C
.................... 		if ( 1000 == address ) { 
01DF6:  MOVLB  7
01DF8:  MOVF   xDE,W
01DFA:  SUBLW  E8
01DFC:  BNZ   1E10
01DFE:  MOVF   xDF,W
01E00:  SUBLW  03
01E02:  BNZ   1E10
.................... 			config.serial_prefix=value; 
01E04:  MOVFF  7E0,39
.................... 			return 0; 
01E08:  MOVLW  00
01E0A:  MOVWF  01
01E0C:  BRA    1FDC
.................... 		} else if ( 1001 == address ) { 
01E0E:  BRA    1E2A
01E10:  MOVF   xDE,W
01E12:  SUBLW  E9
01E14:  BNZ   1E2A
01E16:  MOVF   xDF,W
01E18:  SUBLW  03
01E1A:  BNZ   1E2A
.................... 			config.serial_number=value; 
01E1C:  MOVFF  7E1,3B
01E20:  MOVFF  7E0,3A
.................... 			return 0; 
01E24:  MOVLW  00
01E26:  MOVWF  01
01E28:  BRA    1FDC
01E2A:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01E2C:  MOVLB  7
01E2E:  MOVF   xDE,W
01E30:  MOVWF  00
01E32:  MOVF   xDF,W
01E34:  MOVWF  03
01E36:  MOVLW  03
01E38:  SUBWF  03,W
01E3A:  BNZ   1E46
01E3C:  MOVLW  EE
01E3E:  SUBWF  00,W
01E40:  MOVLB  0
01E42:  BZ    1EE0
01E44:  MOVLB  7
01E46:  MOVLW  03
01E48:  SUBWF  03,W
01E4A:  BNZ   1E56
01E4C:  MOVLW  EF
01E4E:  SUBWF  00,W
01E50:  MOVLB  0
01E52:  BZ    1EF8
01E54:  MOVLB  7
01E56:  MOVLW  03
01E58:  SUBWF  03,W
01E5A:  BNZ   1E66
01E5C:  MOVLW  F0
01E5E:  SUBWF  00,W
01E60:  MOVLB  0
01E62:  BZ    1F08
01E64:  MOVLB  7
01E66:  MOVLW  03
01E68:  SUBWF  03,W
01E6A:  BNZ   1E76
01E6C:  MOVLW  F1
01E6E:  SUBWF  00,W
01E70:  MOVLB  0
01E72:  BZ    1F20
01E74:  MOVLB  7
01E76:  MOVLW  03
01E78:  SUBWF  03,W
01E7A:  BNZ   1E86
01E7C:  MOVLW  F2
01E7E:  SUBWF  00,W
01E80:  MOVLB  0
01E82:  BZ    1F2C
01E84:  MOVLB  7
01E86:  MOVLW  03
01E88:  SUBWF  03,W
01E8A:  BNZ   1E96
01E8C:  MOVLW  F3
01E8E:  SUBWF  00,W
01E90:  MOVLB  0
01E92:  BZ    1F46
01E94:  MOVLB  7
01E96:  MOVLW  03
01E98:  SUBWF  03,W
01E9A:  BNZ   1EA8
01E9C:  MOVLW  F4
01E9E:  SUBWF  00,W
01EA0:  MOVLB  0
01EA2:  BTFSC  FD8.2
01EA4:  BRA    1F5E
01EA6:  MOVLB  7
01EA8:  MOVLW  07
01EAA:  SUBWF  03,W
01EAC:  BNZ   1EBA
01EAE:  MOVLW  CE
01EB0:  SUBWF  00,W
01EB2:  MOVLB  0
01EB4:  BTFSC  FD8.2
01EB6:  BRA    1F76
01EB8:  MOVLB  7
01EBA:  MOVLW  07
01EBC:  SUBWF  03,W
01EBE:  BNZ   1ECC
01EC0:  MOVLW  CF
01EC2:  SUBWF  00,W
01EC4:  MOVLB  0
01EC6:  BTFSC  FD8.2
01EC8:  BRA    1F90
01ECA:  MOVLB  7
01ECC:  MOVLW  4E
01ECE:  SUBWF  03,W
01ED0:  BNZ   1EDE
01ED2:  MOVLW  1F
01ED4:  SUBWF  00,W
01ED6:  MOVLB  0
01ED8:  BTFSC  FD8.2
01EDA:  BRA    1FAA
01EDC:  MOVLB  7
01EDE:  BRA    1FD2
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01EE0:  MOVLB  7
01EE2:  MOVF   xE1,F
01EE4:  BNZ   1EEC
01EE6:  MOVF   xE0,W
01EE8:  SUBLW  80
01EEA:  BC    1EF2
01EEC:  MOVLW  03
01EEE:  MOVWF  01
01EF0:  BRA    1FDC
.................... 			config.modbus_address=value; 
01EF2:  MOVFF  7E0,36
.................... 			break; 
01EF6:  BRA    1FD8
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01EF8:  MOVLB  1
01EFA:  BSF    xF6.1
.................... 			config.adc_sample_ticks=value; 
01EFC:  MOVFF  7E1,3D
01F00:  MOVFF  7E0,3C
.................... 			break; 
01F04:  MOVLB  7
01F06:  BRA    1FD8
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01F08:  MOVLB  7
01F0A:  MOVF   xE1,F
01F0C:  BNZ   1F14
01F0E:  MOVF   xE0,W
01F10:  SUBLW  01
01F12:  BC    1F1A
01F14:  MOVLW  03
01F16:  MOVWF  01
01F18:  BRA    1FDC
.................... 			config.allow_bootload_request=value; 
01F1A:  MOVFF  7E0,3E
.................... 			break; 
01F1E:  BRA    1FD8
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01F20:  MOVFF  7E1,40
01F24:  MOVFF  7E0,3F
.................... 			break; 
01F28:  MOVLB  7
01F2A:  BRA    1FD8
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01F2C:  MOVLB  7
01F2E:  MOVF   xE0,F
01F30:  BNZ   1F3C
01F32:  MOVF   xE1,F
01F34:  BNZ   1F3C
01F36:  MOVLW  03
01F38:  MOVWF  01
01F3A:  BRA    1FDC
.................... 			config.pi_offtime_seconds=value; 
01F3C:  MOVFF  7E1,42
01F40:  MOVFF  7E0,41
.................... 			break; 
01F44:  BRA    1FD8
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01F46:  MOVLB  7
01F48:  MOVF   xE1,F
01F4A:  BNZ   1F52
01F4C:  MOVF   xE0,W
01F4E:  SUBLW  01
01F50:  BC    1F58
01F52:  MOVLW  03
01F54:  MOVWF  01
01F56:  BRA    1FDC
.................... 			config.power_startup=value; 
01F58:  MOVFF  7E0,43
.................... 			break; 
01F5C:  BRA    1FD8
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
01F5E:  MOVLB  7
01F60:  MOVF   xE1,F
01F62:  BNZ   1F6A
01F64:  MOVF   xE0,W
01F66:  SUBLW  02
01F68:  BC    1F70
01F6A:  MOVLW  03
01F6C:  MOVWF  01
01F6E:  BRA    1FDC
.................... 			config.rs485_port_mode=value; 
01F70:  MOVFF  7E0,38
.................... 			break; 
01F74:  BRA    1FD8
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01F76:  MOVLB  7
01F78:  DECFSZ xE0,W
01F7A:  BRA    1F80
01F7C:  MOVF   xE1,F
01F7E:  BZ    1F86
01F80:  MOVLW  03
01F82:  MOVWF  01
01F84:  BRA    1FDC
.................... 			write_default_param_file(); 
01F86:  MOVLB  0
01F88:  CALL   0A9E
.................... 			break; 
01F8C:  MOVLB  7
01F8E:  BRA    1FD8
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01F90:  MOVLB  7
01F92:  DECFSZ xE0,W
01F94:  BRA    1F9A
01F96:  MOVF   xE1,F
01F98:  BZ    1FA0
01F9A:  MOVLW  03
01F9C:  MOVWF  01
01F9E:  BRA    1FDC
.................... 			write_param_file(); 
01FA0:  MOVLB  0
01FA2:  CALL   0A4A
.................... 			break; 
01FA6:  MOVLB  7
01FA8:  BRA    1FD8
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01FAA:  MOVLB  7
01FAC:  MOVF   xE0,W
01FAE:  SUBLW  0A
01FB0:  BNZ   1FB8
01FB2:  MOVF   xE1,W
01FB4:  SUBLW  07
01FB6:  BZ    1FC4
.................... 				current.factory_unlocked=0; 
01FB8:  MOVLB  1
01FBA:  CLRF   xD7
.................... 				return ILLEGAL_DATA_VALUE; 
01FBC:  MOVLW  03
01FBE:  MOVWF  01
01FC0:  MOVLB  7
01FC2:  BRA    1FDC
.................... 			} 
.................... 			current.factory_unlocked=1; 
01FC4:  MOVLW  01
01FC6:  MOVLB  1
01FC8:  MOVWF  xD7
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01FCA:  MOVLW  C8
01FCC:  MOVWF  xF3
.................... 			break; 
01FCE:  MOVLB  7
01FD0:  BRA    1FD8
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01FD2:  MOVLW  02
01FD4:  MOVWF  01
01FD6:  BRA    1FDC
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01FD8:  MOVLW  00
01FDA:  MOVWF  01
.................... } 
01FDC:  MOVLB  0
01FDE:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02070:  GOTO   0F36
02074:  MOVF   01,F
02076:  BTFSC  FD8.2
02078:  BRA    235C
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
0207A:  DECFSZ 38,W
0207C:  BRA    2130
0207E:  MOVF   36,W
02080:  MOVLB  6
02082:  SUBWF  xC0,W
02084:  BTFSS  FD8.2
02086:  BRA    208C
02088:  MOVLB  0
0208A:  BRA    2130
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
0208C:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
0208E:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02090:  CLRWDT
02092:  MOVLW  02
02094:  MOVLB  7
02096:  MOVWF  xD8
02098:  MOVLW  B5
0209A:  MOVWF  xD9
0209C:  MOVLB  0
0209E:  CALL   0F5C
020A2:  MOVLB  7
020A4:  DECFSZ xD8,F
020A6:  BRA    2098
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
020A8:  MOVLB  6
020AA:  MOVF   xC0,W
020AC:  MOVLB  0
020AE:  CALL   06B4
.................... 			delay_us(104); //one stop bit @ 9600 baud 
020B2:  CLRWDT
020B4:  MOVLW  67
020B6:  MOVWF  00
020B8:  DECFSZ 00,F
020BA:  BRA    20B8
020BC:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
020BE:  MOVLB  6
020C0:  MOVF   xC2,W
020C2:  MOVLB  0
020C4:  CALL   06B4
.................... 			delay_us(104); //one stop bit @ 9600 baud 
020C8:  CLRWDT
020CA:  MOVLW  67
020CC:  MOVWF  00
020CE:  DECFSZ 00,F
020D0:  BRA    20CE
020D2:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
020D4:  MOVLB  7
020D6:  CLRF   xD7
020D8:  MOVLW  02
020DA:  MOVLB  6
020DC:  ADDWF  xC1,W
020DE:  MOVLB  7
020E0:  SUBWF  xD7,W
020E2:  BC    2110
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
020E4:  MOVLW  C4
020E6:  ADDWF  xD7,W
020E8:  MOVWF  FE9
020EA:  MOVLW  06
020EC:  MOVWF  FEA
020EE:  BTFSC  FD8.0
020F0:  INCF   FEA,F
020F2:  MOVFF  FEF,7D8
020F6:  MOVF   xD8,W
020F8:  MOVLB  0
020FA:  CALL   06B4
.................... 				delay_us(104); //one stop bit @ 9600 baud 
020FE:  CLRWDT
02100:  MOVLW  67
02102:  MOVWF  00
02104:  DECFSZ 00,F
02106:  BRA    2104
02108:  NOP   
.................... 			} 
0210A:  MOVLB  7
0210C:  INCF   xD7,F
0210E:  BRA    20D8
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02110:  BTFSS  F72.1
02112:  BRA    2110
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02114:  CLRWDT
02116:  MOVLW  02
02118:  MOVWF  xD8
0211A:  MOVLW  B5
0211C:  MOVWF  xD9
0211E:  MOVLB  0
02120:  CALL   0F5C
02124:  MOVLB  7
02126:  DECFSZ xD8,F
02128:  BRA    211A
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
0212A:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
0212C:  BCF    F8C.0
0212E:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02130:  MOVF   36,W
02132:  SUBLW  80
02134:  BZ    2142
02136:  MOVF   36,W
02138:  MOVLB  6
0213A:  SUBWF  xC0,W
0213C:  BTFSS  FD8.2
0213E:  BRA    2346
02140:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02142:  MOVLB  1
02144:  INCFSZ xCB,W
02146:  BRA    214E
02148:  INCFSZ xCC,W
0214A:  BRA    214E
0214C:  BRA    2154
.................... 				current.modbus_our_packets++; 
0214E:  INCF   xCB,F
02150:  BTFSC  FD8.2
02152:  INCF   xCC,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02154:  MOVLW  14
02156:  MOVWF  xF3
....................  
.................... 			switch(modbus_rx.func) { 
02158:  MOVLB  6
0215A:  MOVF   xC2,W
0215C:  XORLW  03
0215E:  MOVLB  0
02160:  BZ    2172
02162:  XORLW  07
02164:  BZ    2172
02166:  XORLW  02
02168:  BZ    21EA
0216A:  XORLW  16
0216C:  BTFSC  FD8.2
0216E:  BRA    225C
02170:  BRA    231E
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02172:  MOVFF  6C4,7D3
02176:  MOVFF  6C5,7D2
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
0217A:  MOVFF  6C6,7D5
0217E:  MOVFF  6C7,7D4
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02182:  MOVLB  7
02184:  MOVF   xD4,W
02186:  ADDWF  xD2,W
02188:  MOVWF  xD8
0218A:  MOVF   xD5,W
0218C:  ADDWFC xD3,W
0218E:  MOVWF  xD9
02190:  MOVFF  7D3,7DB
02194:  MOVFF  7D2,7DA
02198:  MOVWF  xDD
0219A:  MOVFF  7D8,7DC
0219E:  MOVLB  0
021A0:  GOTO   0F7C
021A4:  MOVF   01,F
021A6:  BNZ   21CC
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
021A8:  MOVFF  6C0,7D8
021AC:  MOVLB  7
021AE:  CLRF   xDA
021B0:  MOVFF  6C2,7D9
021B4:  MOVLW  02
021B6:  MOVWF  xDB
021B8:  MOVLB  0
021BA:  CALL   10BA
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
021BE:  MOVLB  1
021C0:  CLRF   xD0
021C2:  MOVLW  02
021C4:  MOVWF  xCF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
021C6:  CLRF   xF3
.................... 					} else { 
021C8:  BRA    21E8
021CA:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
021CC:  MOVFF  6C2,7D8
021D0:  MOVFF  6C0,7D9
021D4:  MOVFF  7D3,7DB
021D8:  MOVFF  7D2,7DA
021DC:  MOVFF  7D5,7DD
021E0:  MOVFF  7D4,7DC
021E4:  BRA    1C5A
021E6:  MOVLB  1
.................... 					} 
.................... 					break; 
021E8:  BRA    233E
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
021EA:  MOVFF  6C4,7D3
021EE:  MOVFF  6C5,7D2
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
021F2:  MOVFF  6C6,7D9
021F6:  MOVFF  6C7,7D8
021FA:  MOVFF  7D3,7DF
021FE:  MOVFF  7D2,7DE
02202:  MOVFF  6C6,7E1
02206:  MOVFF  6C7,7E0
0220A:  RCALL  1CDC
0220C:  MOVFF  01,7D6
....................  
.................... 					if ( result ) { 
02210:  MOVLB  7
02212:  MOVF   xD6,F
02214:  BZ    2238
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02216:  MOVFF  6C0,7D8
0221A:  CLRF   xDA
0221C:  MOVFF  6C2,7D9
02220:  MOVFF  7D6,7DB
02224:  MOVLB  0
02226:  CALL   10BA
.................... 						current.modbus_last_error=result; 
0222A:  MOVLB  1
0222C:  CLRF   xD0
0222E:  MOVFF  7D6,1CF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02232:  CLRF   xF3
.................... 					}  else { 
02234:  BRA    225A
02236:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02238:  MOVFF  6C6,7D9
0223C:  MOVFF  6C7,7D8
02240:  MOVFF  6C0,7DA
02244:  MOVFF  7D3,7DC
02248:  MOVFF  7D2,7DB
0224C:  MOVFF  6C6,7DE
02250:  MOVFF  6C7,7DD
02254:  MOVLB  0
02256:  BRA    1FE0
02258:  MOVLB  1
.................... 					} 
.................... 					break; 
0225A:  BRA    233E
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0225C:  MOVFF  6C4,7D3
02260:  MOVFF  6C5,7D2
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02264:  MOVFF  6C6,7D5
02268:  MOVFF  6C7,7D4
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
0226C:  MOVLB  7
0226E:  CLRF   xD7
02270:  MOVF   xD5,F
02272:  BNZ   227A
02274:  MOVF   xD4,W
02276:  SUBWF  xD7,W
02278:  BC    22FE
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
0227A:  MOVF   xD7,W
0227C:  ADDWF  xD2,W
0227E:  MOVWF  xD8
02280:  MOVLW  00
02282:  ADDWFC xD3,W
02284:  MOVWF  xD9
02286:  BCF    FD8.0
02288:  RLCF   xD7,W
0228A:  ADDLW  05
0228C:  ADDLW  C4
0228E:  MOVWF  FE9
02290:  MOVLW  06
02292:  MOVWF  FEA
02294:  BTFSC  FD8.0
02296:  INCF   FEA,F
02298:  MOVFF  FEF,7DA
0229C:  BCF    FD8.0
0229E:  RLCF   xD7,W
022A0:  ADDLW  06
022A2:  ADDLW  C4
022A4:  MOVWF  FE9
022A6:  MOVLW  06
022A8:  MOVWF  FEA
022AA:  BTFSC  FD8.0
022AC:  INCF   FEA,F
022AE:  MOVFF  FEF,7DB
022B2:  MOVFF  7DA,7DD
022B6:  MOVFF  7DB,7DC
022BA:  MOVFF  7D9,7DF
022BE:  MOVFF  7D8,7DE
022C2:  MOVFF  7DA,7E1
022C6:  MOVFF  7DB,7E0
022CA:  MOVLB  0
022CC:  RCALL  1CDC
022CE:  MOVFF  01,7D6
....................  
.................... 						if ( result ) { 
022D2:  MOVLB  7
022D4:  MOVF   xD6,F
022D6:  BZ    22FA
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
022D8:  MOVFF  6C0,7D8
022DC:  CLRF   xDA
022DE:  MOVFF  6C2,7D9
022E2:  MOVFF  7D6,7DB
022E6:  MOVLB  0
022E8:  CALL   10BA
.................... 							current.modbus_last_error=result; 
022EC:  MOVLB  1
022EE:  CLRF   xD0
022F0:  MOVFF  7D6,1CF
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
022F4:  CLRF   xF3
.................... 			 
.................... 							break; 
022F6:  MOVLB  7
022F8:  BRA    22FE
.................... 						} 
.................... 					} 
022FA:  INCF   xD7,F
022FC:  BRA    2270
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
022FE:  MOVF   xD6,F
02300:  BNZ   231A
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02302:  MOVFF  6C0,7D8
02306:  MOVFF  7D3,7DA
0230A:  MOVFF  7D2,7D9
0230E:  MOVFF  7D5,7DC
02312:  MOVFF  7D4,7DB
02316:  MOVLB  0
02318:  BRA    2028
.................... 					} 
....................  
.................... 					break;   
0231A:  MOVLB  1
0231C:  BRA    233E
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
0231E:  MOVFF  6C0,7D8
02322:  MOVLB  7
02324:  CLRF   xDA
02326:  MOVFF  6C2,7D9
0232A:  MOVLW  01
0232C:  MOVWF  xDB
0232E:  MOVLB  0
02330:  CALL   10BA
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02334:  MOVLB  1
02336:  CLRF   xD0
02338:  MOVLW  01
0233A:  MOVWF  xCF
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
0233C:  CLRF   xF3
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
0233E:  CLRF   xDA
02340:  CLRF   xD9
....................  
.................... 		} else { 
02342:  BRA    235C
02344:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02346:  MOVLB  1
02348:  INCFSZ xCD,W
0234A:  BRA    2352
0234C:  INCFSZ xCE,W
0234E:  BRA    2352
02350:  BRA    2358
.................... 				current.modbus_other_packets++; 
02352:  INCF   xCD,F
02354:  BTFSC  FD8.2
02356:  INCF   xCE,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02358:  MOVLW  0A
0235A:  MOVWF  xF3
0235C:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
0235E:  GOTO   24F8 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00412:  MOVLB  8
00414:  BTFSS  xD9.0
00416:  BRA    0430
00418:  MOVLB  1
0041A:  INCFSZ xE2,W
0041C:  BRA    0428
0041E:  INCFSZ xE3,W
00420:  BRA    0428
00422:  MOVLB  8
00424:  BRA    0430
00426:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00428:  INCF   xE2,F
0042A:  BTFSC  FD8.2
0042C:  INCF   xE3,F
0042E:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00430:  BTFSS  xD9.2
00432:  BRA    044C
00434:  MOVLB  1
00436:  INCFSZ xE4,W
00438:  BRA    0444
0043A:  INCFSZ xE5,W
0043C:  BRA    0444
0043E:  MOVLB  8
00440:  BRA    044C
00442:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00444:  INCF   xE4,F
00446:  BTFSC  FD8.2
00448:  INCF   xE5,F
0044A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0044C:  BTFSS  xD9.4
0044E:  BRA    0468
00450:  MOVLB  1
00452:  INCFSZ xE6,W
00454:  BRA    0460
00456:  INCFSZ xE7,W
00458:  BRA    0460
0045A:  MOVLB  8
0045C:  BRA    0468
0045E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00460:  INCF   xE6,F
00462:  BTFSC  FD8.2
00464:  INCF   xE7,F
00466:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00468:  BCF    xD9.1
0046A:  BTFSC  F81.0
0046C:  BSF    xD9.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0046E:  BTFSC  xD9.1
00470:  BRA    04F4
00472:  MOVLB  6
00474:  BTFSC  xBC.1
00476:  BRA    047C
00478:  MOVLB  8
0047A:  BRA    04F4
.................... 		current.pulse_count[0]++; 
0047C:  MOVLB  0
0047E:  INCF   xA8,F
00480:  BTFSC  FD8.2
00482:  INCF   xA9,F
.................... 		current.pulse_sum[0]++; 
00484:  MOVLW  01
00486:  ADDWF  xAE,F
00488:  BTFSC  FD8.0
0048A:  INCF   xAF,F
0048C:  BTFSC  FD8.2
0048E:  INCF   xB0,F
00490:  BTFSC  FD8.2
00492:  INCF   xB1,F
.................... 		if ( 1 == ext0_state ) { 
00494:  MOVLB  6
00496:  BTFSS  xBC.2
00498:  BRA    04E2
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0049A:  MOVLB  8
0049C:  BCF    xD9.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0049E:  MOVFF  1E3,97
004A2:  MOVFF  1E2,96
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004A6:  MOVLB  0
004A8:  MOVF   x97,W
004AA:  SUBWF  x9D,W
004AC:  BNC   04BE
004AE:  BNZ   04B6
004B0:  MOVF   x9C,W
004B2:  SUBWF  x96,W
004B4:  BC    04BE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004B6:  MOVFF  97,9D
004BA:  MOVFF  96,9C
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004BE:  MOVF   xA3,W
004C0:  SUBWF  x97,W
004C2:  BNC   04DE
004C4:  BNZ   04CC
004C6:  MOVF   x96,W
004C8:  SUBWF  xA2,W
004CA:  BC    04DE
004CC:  INCFSZ x96,W
004CE:  BRA    04D6
004D0:  INCFSZ x97,W
004D2:  BRA    04D6
004D4:  BRA    04DE
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004D6:  MOVFF  97,A3
004DA:  MOVFF  96,A2
.................... 			} 
.................... 			ext0_state=0; 
004DE:  MOVLB  6
004E0:  BCF    xBC.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004E2:  BTFSC  xBC.2
004E4:  BRA    04F4
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004E6:  MOVLB  1
004E8:  CLRF   xE3
004EA:  CLRF   xE2
.................... 			ext0_count=1; 
004EC:  MOVLB  8
004EE:  BSF    xD9.0
.................... 			ext0_state=1; 
004F0:  MOVLB  6
004F2:  BSF    xBC.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004F4:  MOVLB  6
004F6:  BCF    xBC.1
004F8:  MOVLB  8
004FA:  BTFSS  xD9.1
004FC:  BRA    0504
004FE:  MOVLB  6
00500:  BSF    xBC.1
00502:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00504:  BCF    xD9.3
00506:  BTFSC  F81.1
00508:  BSF    xD9.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0050A:  BTFSC  xD9.3
0050C:  BRA    0590
0050E:  MOVLB  6
00510:  BTFSC  xBC.3
00512:  BRA    0518
00514:  MOVLB  8
00516:  BRA    0590
.................... 		current.pulse_count[1]++; 
00518:  MOVLB  0
0051A:  INCF   xAA,F
0051C:  BTFSC  FD8.2
0051E:  INCF   xAB,F
.................... 		current.pulse_sum[1]++; 
00520:  MOVLW  01
00522:  ADDWF  xB2,F
00524:  BTFSC  FD8.0
00526:  INCF   xB3,F
00528:  BTFSC  FD8.2
0052A:  INCF   xB4,F
0052C:  BTFSC  FD8.2
0052E:  INCF   xB5,F
.................... 		if ( 1 == ext1_state ) { 
00530:  MOVLB  6
00532:  BTFSS  xBC.4
00534:  BRA    057E
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00536:  MOVLB  8
00538:  BCF    xD9.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0053A:  MOVFF  1E5,99
0053E:  MOVFF  1E4,98
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00542:  MOVLB  0
00544:  MOVF   x99,W
00546:  SUBWF  x9F,W
00548:  BNC   055A
0054A:  BNZ   0552
0054C:  MOVF   x9E,W
0054E:  SUBWF  x98,W
00550:  BC    055A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00552:  MOVFF  99,9F
00556:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0055A:  MOVF   xA5,W
0055C:  SUBWF  x99,W
0055E:  BNC   057A
00560:  BNZ   0568
00562:  MOVF   x98,W
00564:  SUBWF  xA4,W
00566:  BC    057A
00568:  INCFSZ x98,W
0056A:  BRA    0572
0056C:  INCFSZ x99,W
0056E:  BRA    0572
00570:  BRA    057A
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
00572:  MOVFF  99,A5
00576:  MOVFF  98,A4
.................... 			} 
.................... 			ext1_state=0; 
0057A:  MOVLB  6
0057C:  BCF    xBC.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0057E:  BTFSC  xBC.4
00580:  BRA    0590
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
00582:  MOVLB  1
00584:  CLRF   xE5
00586:  CLRF   xE4
.................... 			ext1_count=1; 
00588:  MOVLB  8
0058A:  BSF    xD9.2
.................... 			ext1_state=1; 
0058C:  MOVLB  6
0058E:  BSF    xBC.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
00590:  MOVLB  6
00592:  BCF    xBC.3
00594:  MOVLB  8
00596:  BTFSS  xD9.3
00598:  BRA    05A0
0059A:  MOVLB  6
0059C:  BSF    xBC.3
0059E:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005A0:  BCF    xD9.5
005A2:  BTFSC  F81.2
005A4:  BSF    xD9.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005A6:  BTFSC  xD9.5
005A8:  BRA    062C
005AA:  MOVLB  6
005AC:  BTFSC  xBC.5
005AE:  BRA    05B4
005B0:  MOVLB  8
005B2:  BRA    062C
.................... 		current.pulse_count[2]++; 
005B4:  MOVLB  0
005B6:  INCF   xAC,F
005B8:  BTFSC  FD8.2
005BA:  INCF   xAD,F
.................... 		current.pulse_sum[2]++; 
005BC:  MOVLW  01
005BE:  ADDWF  xB6,F
005C0:  BTFSC  FD8.0
005C2:  INCF   xB7,F
005C4:  BTFSC  FD8.2
005C6:  INCF   xB8,F
005C8:  BTFSC  FD8.2
005CA:  INCF   xB9,F
.................... 		if ( 1 == ext2_state ) { 
005CC:  MOVLB  6
005CE:  BTFSS  xBC.6
005D0:  BRA    061A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
005D2:  MOVLB  8
005D4:  BCF    xD9.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005D6:  MOVFF  1E7,9B
005DA:  MOVFF  1E6,9A
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005DE:  MOVLB  0
005E0:  MOVF   x9B,W
005E2:  SUBWF  xA1,W
005E4:  BNC   05F6
005E6:  BNZ   05EE
005E8:  MOVF   xA0,W
005EA:  SUBWF  x9A,W
005EC:  BC    05F6
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005EE:  MOVFF  9B,A1
005F2:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005F6:  MOVF   xA7,W
005F8:  SUBWF  x9B,W
005FA:  BNC   0616
005FC:  BNZ   0604
005FE:  MOVF   x9A,W
00600:  SUBWF  xA6,W
00602:  BC    0616
00604:  INCFSZ x9A,W
00606:  BRA    060E
00608:  INCFSZ x9B,W
0060A:  BRA    060E
0060C:  BRA    0616
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0060E:  MOVFF  9B,A7
00612:  MOVFF  9A,A6
.................... 			} 
.................... 			ext2_state=0; 
00616:  MOVLB  6
00618:  BCF    xBC.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0061A:  BTFSC  xBC.6
0061C:  BRA    062C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0061E:  MOVLB  1
00620:  CLRF   xE7
00622:  CLRF   xE6
.................... 			ext2_count=1; 
00624:  MOVLB  8
00626:  BSF    xD9.4
.................... 			ext2_state=1; 
00628:  MOVLB  6
0062A:  BSF    xBC.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0062C:  MOVLB  6
0062E:  BCF    xBC.5
00630:  MOVLB  8
00632:  BTFSS  xD9.5
00634:  BRA    063C
00636:  MOVLB  6
00638:  BSF    xBC.5
0063A:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0063C:  MOVLB  7
0063E:  INCF   xC7,F
.................... 	if ( 10 == tick ) { 
00640:  MOVF   xC7,W
00642:  SUBLW  0A
00644:  BNZ   064E
.................... 		tick=0; 
00646:  CLRF   xC7
.................... 		timers.now_millisecond=1; 
00648:  MOVLB  1
0064A:  BSF    xF6.2
0064C:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0064E:  BCF    F9E.1
00650:  MOVLB  0
00652:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0066E:  BRA    0656
00670:  MOVFF  01,8D6
....................  
.................... 	if ( RS485_MODE_OFF != config.rs485_port_mode ) { 
00674:  MOVF   38,F
00676:  BZ    0698
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
00678:  MOVLB  2
0067A:  CLRF   xFB
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
0067C:  INCFSZ xFA,W
0067E:  BRA    0682
00680:  BRA    0696
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
00682:  MOVLW  FA
00684:  ADDWF  xFA,W
00686:  MOVWF  FE9
00688:  MOVLW  01
0068A:  MOVWF  FEA
0068C:  BTFSC  FD8.0
0068E:  INCF   FEA,F
00690:  MOVFF  8D6,FEF
.................... 			timers.rda2_buff_pos++; 
00694:  INCF   xFA,F
00696:  MOVLB  0
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00698:  BCF    FA4.5
0069A:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
006E8:  RCALL  069E
006EA:  MOVFF  01,8D6
....................  
.................... 	if ( current.bridged_uarts ) { 
006EE:  MOVLB  1
006F0:  BTFSS  xD8.0
006F2:  BRA    06FE
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,STREAM_RS485); 
006F4:  MOVLB  8
006F6:  MOVF   xD6,W
006F8:  MOVLB  0
006FA:  RCALL  06B4
.................... 		return; 
006FC:  BRA    0758
.................... 	} 
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006FE:  MOVLB  6
00700:  BTFSC  xBC.0
00702:  BRA    075A
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00704:  MOVF   xBD,F
00706:  BNZ   0718
.................... 			modbus_serial_crc.d = 0xFFFF; 
00708:  SETF   xBF
0070A:  SETF   xBE
.................... 			modbus_rx.address = c; 
0070C:  MOVFF  8D6,6C0
.................... 			modbus_serial_state++; 
00710:  INCF   xBD,F
.................... 			modbus_rx.len = 0; 
00712:  CLRF   xC1
.................... 			modbus_rx.error=0; 
00714:  CLRF   xC3
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00716:  BRA    0746
00718:  DECFSZ xBD,W
0071A:  BRA    0724
.................... 			modbus_rx.func = c; 
0071C:  MOVFF  8D6,6C2
.................... 			modbus_serial_state++; 
00720:  INCF   xBD,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00722:  BRA    0746
00724:  MOVF   xBD,W
00726:  SUBLW  02
00728:  BNZ   0746
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0072A:  INCFSZ xC1,W
0072C:  BRA    0732
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0072E:  MOVLW  FE
00730:  MOVWF  xC1
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
00732:  MOVLW  C4
00734:  ADDWF  xC1,W
00736:  MOVWF  FE9
00738:  MOVLW  06
0073A:  MOVWF  FEA
0073C:  BTFSC  FD8.0
0073E:  INCF   FEA,F
00740:  MOVFF  8D6,FEF
.................... 			modbus_rx.len++; 
00744:  INCF   xC1,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00746:  MOVFF  8D6,8D7
0074A:  MOVLB  0
0074C:  RCALL  06BC
.................... 		modbus_enable_timeout(TRUE); 
0074E:  MOVLW  01
00750:  MOVLB  8
00752:  MOVWF  xD7
00754:  MOVLB  0
00756:  RCALL  03CC
00758:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
....................  
0075A:  BCF    F9E.5
0075C:  MOVLB  0
0075E:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
007B4:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
007B6:  MOVLW  08
007B8:  MOVWF  F61
007BA:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
007BC:  MOVLW  00
007BE:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
007C0:  MOVLW  FF
007C2:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
007C4:  MOVLW  92
007C6:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
007C8:  MOVLW  80
007CA:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
007CC:  BCF    F96.0
007CE:  BCF    F96.1
007D0:  BCF    F96.2
007D2:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
007D4:  MOVLB  1
007D6:  CLRF   xF3
.................... 	timers.load_off_seconds=2; 
007D8:  CLRF   xF5
007DA:  MOVLW  02
007DC:  MOVWF  xF4
.................... 	timers.now_adc_sample=0; 
007DE:  BCF    xF6.0
.................... 	timers.now_adc_reset_count=0; 
007E0:  BCF    xF6.1
.................... 	timers.now_millisecond=0; 
007E2:  BCF    xF6.2
.................... 	timers.port_b=0b11111111; 
007E4:  SETF   xF7
.................... 	timers.port_c=0b11111111; 
007E6:  SETF   xF8
....................  
.................... 	timers.rda2_buff_pos=0; 
007E8:  MOVLB  2
007EA:  CLRF   xFA
.................... 	timers.rda2_buff_gap=255; 
007EC:  SETF   xFB
.................... 	timers.now_parse_rda2=0; 
007EE:  MOVLB  1
007F0:  BCF    xF9.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
007F2:  MOVLB  7
007F4:  CLRF   xD2
007F6:  MOVF   xD2,W
007F8:  SUBLW  02
007FA:  BNC   08A8
.................... 		current.pulse_period[i]=0; 
007FC:  CLRF   03
007FE:  MOVFF  7D2,02
00802:  BCF    FD8.0
00804:  RLCF   02,F
00806:  RLCF   03,F
00808:  MOVF   02,W
0080A:  ADDLW  96
0080C:  MOVWF  FE9
0080E:  MOVLW  00
00810:  ADDWFC 03,W
00812:  MOVWF  FEA
00814:  CLRF   FEC
00816:  MOVF   FED,F
00818:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
0081A:  CLRF   03
0081C:  MOVFF  7D2,02
00820:  BCF    FD8.0
00822:  RLCF   02,F
00824:  RLCF   03,F
00826:  MOVF   02,W
00828:  ADDLW  9C
0082A:  MOVWF  FE9
0082C:  MOVLW  00
0082E:  ADDWFC 03,W
00830:  MOVWF  FEA
00832:  SETF   FEC
00834:  MOVF   FED,F
00836:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00838:  CLRF   03
0083A:  MOVFF  7D2,02
0083E:  BCF    FD8.0
00840:  RLCF   02,F
00842:  RLCF   03,F
00844:  MOVF   02,W
00846:  ADDLW  A2
00848:  MOVWF  FE9
0084A:  MOVLW  00
0084C:  ADDWFC 03,W
0084E:  MOVWF  FEA
00850:  CLRF   FEC
00852:  MOVF   FED,F
00854:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00856:  CLRF   03
00858:  MOVFF  7D2,02
0085C:  BCF    FD8.0
0085E:  RLCF   02,F
00860:  RLCF   03,F
00862:  MOVF   02,W
00864:  ADDLW  A8
00866:  MOVWF  FE9
00868:  MOVLW  00
0086A:  ADDWFC 03,W
0086C:  MOVWF  FEA
0086E:  CLRF   FEC
00870:  MOVF   FED,F
00872:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00874:  CLRF   xEF
00876:  MOVFF  7D2,7EE
0087A:  CLRF   xF1
0087C:  MOVLW  04
0087E:  MOVWF  xF0
00880:  MOVLB  0
00882:  RCALL  0778
00884:  MOVF   01,W
00886:  ADDLW  AE
00888:  MOVWF  FE9
0088A:  MOVLW  00
0088C:  ADDWFC 02,W
0088E:  MOVWF  FEA
00890:  MOVF   FEE,F
00892:  MOVF   FEE,F
00894:  CLRF   FEC
00896:  MOVF   FED,F
00898:  CLRF   FEF
0089A:  MOVF   FED,F
0089C:  CLRF   FEF
0089E:  MOVF   FED,F
008A0:  CLRF   FEF
.................... 	} 
008A2:  MOVLB  7
008A4:  INCF   xD2,F
008A6:  BRA    07F6
....................  
.................... 	current.modbus_our_packets=0; 
008A8:  MOVLB  1
008AA:  CLRF   xCC
008AC:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
008AE:  CLRF   xCE
008B0:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
008B2:  CLRF   xD0
008B4:  CLRF   xCF
.................... 	current.sequence_number=0; 
008B6:  CLRF   xD2
008B8:  CLRF   xD1
.................... 	current.uptime_minutes=0; 
008BA:  CLRF   xD4
008BC:  CLRF   xD3
.................... 	current.interval_milliseconds=0; 
008BE:  CLRF   xD6
008C0:  CLRF   xD5
.................... 	current.adc_buffer_index=0; 
008C2:  CLRF   xCA
.................... 	current.factory_unlocked=0; 
008C4:  CLRF   xD7
.................... 	current.bridged_uarts=0; 
008C6:  BCF    xD8.0
.................... 	current.watchdog_seconds=0; 
008C8:  CLRF   xDA
008CA:  CLRF   xD9
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
008CC:  MOVLW  02
008CE:  MOVWF  FEA
008D0:  MOVLW  FC
008D2:  MOVWF  FE9
008D4:  CLRF   00
008D6:  MOVLW  03
008D8:  MOVWF  02
008DA:  MOVLW  C0
008DC:  MOVWF  01
008DE:  MOVLB  0
008E0:  RCALL  079A
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
008E2:  MOVFF  4B,1DD
008E6:  MOVFF  4A,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
008EA:  MOVFF  47,1DF
008EE:  MOVFF  46,1DE
.................... 	current.power_override_timeout=0; 
008F2:  MOVLB  1
008F4:  CLRF   xE1
008F6:  CLRF   xE0
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
008F8:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
008FA:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
008FC:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
008FE:  MOVLW  00
00900:  IORLW  05
00902:  MOVWF  FBA
00904:  MOVLW  4A
00906:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00908:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
0090A:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
0090C:  MOVLB  0
0090E:  GOTO   247A (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00DB0:  MOVLB  1
00DB2:  BCF    xF6.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00DB4:  BCF    FD8.0
00DB6:  MOVLB  7
00DB8:  RLCF   xCD,W
00DBA:  MOVWF  xD2
00DBC:  RLCF   xCE,W
00DBE:  MOVWF  xD3
00DC0:  MOVLW  00
00DC2:  MOVLB  1
00DC4:  BTFSS  xF8.5
00DC6:  MOVLW  01
00DC8:  MOVLB  7
00DCA:  IORWF  xD2,F
00DCC:  MOVFF  7D2,7CD
00DD0:  MOVF   xD3,W
00DD2:  IORLW  E0
00DD4:  MOVWF  xCE
.................... 	if ( b2_state==0xf000) { 
00DD6:  MOVF   xCD,F
00DD8:  BNZ   0DE0
00DDA:  MOVF   xCE,W
00DDC:  SUBLW  F0
00DDE:  BNZ   0DE0
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00DE0:  MOVLB  1
00DE2:  INCFSZ xE2,W
00DE4:  BRA    0DF2
00DE6:  INCFSZ xE3,W
00DE8:  BRA    0DF2
.................... 				current.pulse_period[0]=0; 
00DEA:  MOVLB  0
00DEC:  CLRF   x97
00DEE:  CLRF   x96
00DF0:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00DF2:  INCFSZ xE4,W
00DF4:  BRA    0E02
00DF6:  INCFSZ xE5,W
00DF8:  BRA    0E02
.................... 				current.pulse_period[1]=0; 
00DFA:  MOVLB  0
00DFC:  CLRF   x99
00DFE:  CLRF   x98
00E00:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00E02:  INCFSZ xE6,W
00E04:  BRA    0E12
00E06:  INCFSZ xE7,W
00E08:  BRA    0E12
.................... 				current.pulse_period[2]=0; 
00E0A:  MOVLB  0
00E0C:  CLRF   x9B
00E0E:  CLRF   x9A
00E10:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00E12:  MOVFF  F81,1F7
.................... 	timers.port_c=port_c; 
00E16:  MOVFF  F82,1F8
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00E1A:  BTFSS  xD8.0
00E1C:  BRA    0E22
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00E1E:  BSF    F89.3
.................... 	} else { 
00E20:  BRA    0E2E
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00E22:  MOVF   xF3,F
00E24:  BNZ   0E2A
.................... 			output_low(LED_GREEN); 
00E26:  BCF    F89.3
.................... 		} else { 
00E28:  BRA    0E2E
.................... 			output_high(LED_GREEN); 
00E2A:  BSF    F89.3
.................... 			timers.led_on_green--; 
00E2C:  DECF   xF3,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00E2E:  INCFSZ xD5,W
00E30:  BRA    0E38
00E32:  INCFSZ xD6,W
00E34:  BRA    0E38
00E36:  BRA    0E3E
.................... 		current.interval_milliseconds++; 
00E38:  INCF   xD5,F
00E3A:  BTFSC  FD8.2
00E3C:  INCF   xD6,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00E3E:  MOVLB  7
00E40:  INCF   xCB,F
00E42:  BTFSC  FD8.2
00E44:  INCF   xCC,F
.................... 	if ( 1000 == ticks ) { 
00E46:  MOVF   xCB,W
00E48:  SUBLW  E8
00E4A:  BNZ   0ED0
00E4C:  MOVF   xCC,W
00E4E:  SUBLW  03
00E50:  BNZ   0ED0
.................... 		ticks=0; 
00E52:  CLRF   xCC
00E54:  CLRF   xCB
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00E56:  MOVLB  1
00E58:  INCFSZ xD9,W
00E5A:  BRA    0E62
00E5C:  INCFSZ xDA,W
00E5E:  BRA    0E62
00E60:  BRA    0E68
.................... 			current.watchdog_seconds++; 
00E62:  INCF   xD9,F
00E64:  BTFSC  FD8.2
00E66:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00E68:  MOVF   3F,F
00E6A:  BNZ   0E70
00E6C:  MOVF   40,F
00E6E:  BZ    0E8E
00E70:  MOVF   40,W
00E72:  SUBWF  xDA,W
00E74:  BNC   0E8E
00E76:  BNZ   0E7E
00E78:  MOVF   xD9,W
00E7A:  SUBWF  3F,W
00E7C:  BC    0E8E
00E7E:  MOVF   xF4,F
00E80:  BNZ   0E8E
00E82:  MOVF   xF5,F
00E84:  BNZ   0E8E
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00E86:  MOVFF  42,1F5
00E8A:  MOVFF  41,1F4
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00E8E:  MOVF   xF4,F
00E90:  BNZ   0E9A
00E92:  MOVF   xF5,F
00E94:  BNZ   0E9A
.................... 			output_high(PI_POWER_EN); 
00E96:  BSF    F8B.0
.................... 		} else { 
00E98:  BRA    0EB0
.................... 			output_low(PI_POWER_EN); 
00E9A:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00E9C:  MOVF   xF4,W
00E9E:  BTFSC  FD8.2
00EA0:  DECF   xF5,F
00EA2:  DECF   xF4,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00EA4:  MOVF   xF4,F
00EA6:  BNZ   0EB0
00EA8:  MOVF   xF5,F
00EAA:  BNZ   0EB0
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00EAC:  CLRF   xDA
00EAE:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00EB0:  MOVLB  7
00EB2:  INCF   xC8,F
.................... 		if ( 60 == uptimeTicks ) { 
00EB4:  MOVF   xC8,W
00EB6:  SUBLW  3C
00EB8:  BNZ   0ED0
.................... 			uptimeTicks=0; 
00EBA:  CLRF   xC8
.................... 			if ( current.uptime_minutes < 65535 )  
00EBC:  MOVLB  1
00EBE:  INCFSZ xD3,W
00EC0:  BRA    0EC8
00EC2:  INCFSZ xD4,W
00EC4:  BRA    0EC8
00EC6:  BRA    0ECE
.................... 				current.uptime_minutes++; 
00EC8:  INCF   xD3,F
00ECA:  BTFSC  FD8.2
00ECC:  INCF   xD4,F
00ECE:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00ED0:  INCFSZ xCF,W
00ED2:  BRA    0EE6
00ED4:  INCFSZ xD0,W
00ED6:  BRA    0EE6
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00ED8:  CLRF   xE8
00EDA:  MOVLB  0
00EDC:  RCALL  0D28
00EDE:  MOVFF  02,7D0
00EE2:  MOVFF  01,7CF
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00EE6:  MOVLB  1
00EE8:  BTFSS  xF6.1
00EEA:  BRA    0EF4
.................... 		timers.now_adc_reset_count=0; 
00EEC:  BCF    xF6.1
.................... 		adcTicks=0; 
00EEE:  MOVLB  7
00EF0:  CLRF   xCA
00EF2:  CLRF   xC9
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00EF4:  MOVLB  7
00EF6:  INCF   xC9,F
00EF8:  BTFSC  FD8.2
00EFA:  INCF   xCA,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00EFC:  MOVF   3C,W
00EFE:  SUBWF  xC9,W
00F00:  BNZ   0F16
00F02:  MOVF   3D,W
00F04:  SUBWF  xCA,W
00F06:  BNZ   0F16
.................... 		adcTicks=0; 
00F08:  CLRF   xCA
00F0A:  CLRF   xC9
.................... 		timers.now_adc_sample=1; 
00F0C:  MOVLB  1
00F0E:  BSF    xF6.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00F10:  MOVLB  7
00F12:  SETF   xD0
00F14:  SETF   xCF
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
00F16:  MOVLB  2
00F18:  INCFSZ xFB,W
00F1A:  BRA    0F1E
00F1C:  BRA    0F20
.................... 		timers.rda2_buff_gap++; 
00F1E:  INCF   xFB,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
00F20:  MOVF   xFB,W
00F22:  SUBLW  09
00F24:  BC    0F30
00F26:  MOVF   xFA,F
00F28:  BZ    0F30
.................... 		timers.now_parse_rda2=1;	 
00F2A:  MOVLB  1
00F2C:  BSF    xF9.0
00F2E:  MOVLB  2
.................... 	} 
.................... } 
00F30:  MOVLB  0
00F32:  GOTO   24E6 (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02362:  MOVFF  2FA,8D2
.................... 	timers.rda2_buff_pos=255; /* stop getting more data for a second */ 
02366:  MOVLB  2
02368:  SETF   xFA
.................... 	memcpy(buff,timers.rda2_buff,length); 
0236A:  MOVLW  07
0236C:  MOVWF  FEA
0236E:  MOVLW  D2
02370:  MOVWF  FE9
02372:  MOVLW  01
02374:  MOVWF  FE2
02376:  MOVLW  FA
02378:  MOVWF  FE1
0237A:  MOVLB  8
0237C:  MOVF   xD2,W
0237E:  MOVWF  01
02380:  BZ    238A
02382:  MOVFF  FE6,FEE
02386:  DECFSZ 01,F
02388:  BRA    2382
.................... 	timers.rda2_buff_gap=0; 
0238A:  MOVLB  2
0238C:  CLRF   xFB
.................... 	timers.rda2_buff_pos=0; 
0238E:  CLRF   xFA
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02390:  DECFSZ 38,W
02392:  BRA    23CA
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02394:  MOVLB  8
02396:  CLRF   xD4
02398:  CLRF   xD3
0239A:  MOVF   xD4,F
0239C:  BNZ   23C6
0239E:  MOVF   xD2,W
023A0:  SUBWF  xD3,W
023A2:  BC    23C6
.................... 			fputc(buff[l],STREAM_PI); 
023A4:  MOVLW  D2
023A6:  ADDWF  xD3,W
023A8:  MOVWF  FE9
023AA:  MOVLW  07
023AC:  ADDWFC xD4,W
023AE:  MOVWF  FEA
023B0:  MOVFF  FEF,8D5
023B4:  MOVF   xD5,W
023B6:  MOVLB  0
023B8:  CALL   1022
.................... 		} 
023BC:  MOVLB  8
023BE:  INCF   xD3,F
023C0:  BTFSC  FD8.2
023C2:  INCF   xD4,F
023C4:  BRA    239A
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
023C6:  BRA    23D2
023C8:  MOVLB  2
023CA:  MOVF   38,W
023CC:  SUBLW  02
023CE:  BNZ   23D0
023D0:  MOVLB  8
.................... 		/* do something */ 
.................... 	} 
.................... } 
023D2:  MOVLB  0
023D4:  GOTO   2504 (RETURN)
....................  
....................  
.................... void main(void) { 
023D8:  CLRF   FF8
023DA:  BCF    FF1.2
023DC:  BSF    F9F.1
023DE:  BCF    F9F.5
023E0:  BCF    FA5.5
023E2:  BSF    FD0.7
023E4:  BSF    07.7
023E6:  CLRF   FEA
023E8:  CLRF   FE9
023EA:  CLRF   35
023EC:  BCF    FB8.3
023EE:  MOVLW  0C
023F0:  MOVWF  FAF
023F2:  MOVLW  A6
023F4:  MOVWF  FAC
023F6:  MOVLW  90
023F8:  MOVWF  FAB
023FA:  BCF    F70.3
023FC:  MOVLW  4D
023FE:  MOVWF  F75
02400:  MOVLW  A6
02402:  MOVWF  F72
02404:  MOVLW  90
02406:  MOVWF  F71
02408:  MOVLB  6
0240A:  BCF    xBC.0
0240C:  CLRF   xBD
0240E:  MOVLB  7
02410:  CLRF   xC7
02412:  MOVLB  6
02414:  BCF    xBC.1
02416:  BCF    xBC.2
02418:  BCF    xBC.3
0241A:  BCF    xBC.4
0241C:  BCF    xBC.5
0241E:  BCF    xBC.6
02420:  MOVLB  7
02422:  CLRF   xC8
02424:  CLRF   xCA
02426:  CLRF   xC9
02428:  CLRF   xCC
0242A:  CLRF   xCB
0242C:  CLRF   xCE
0242E:  CLRF   xCD
02430:  MOVF   FC1,W
02432:  ANDLW  F0
02434:  MOVWF  FC1
02436:  MOVLW  00
02438:  MOVLB  F
0243A:  MOVWF  x38
0243C:  MOVWF  x3C
0243E:  MOVWF  x39
02440:  MOVWF  x3A
02442:  MOVWF  x3B
02444:  MOVLB  1
02446:  CLRF   x88
02448:  CLRF   F77
0244A:  CLRF   F78
0244C:  CLRF   F79
0244E:  CLRF   2F
02450:  CLRF   30
02452:  MOVLB  7
02454:  CLRF   xC3
02456:  CLRF   xC4
02458:  CLRF   xC5
0245A:  CLRF   xC6
0245C:  CLRF   xCF
0245E:  CLRF   xD0
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02460:  MOVF   FD0,W
02462:  ANDLW  0F
02464:  BTFSS  FD0.4
02466:  MOVLW  00
02468:  BSF    FD0.0
0246A:  BSF    FD0.1
0246C:  BSF    FD0.4
0246E:  BSF    FD8.3
02470:  BSF    FD8.4
02472:  MOVWF  xD1
....................  
.................... 	init(); 
02474:  MOVLB  0
02476:  GOTO   07B4
....................  
....................  
.................... #if 0 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
.................... 	output_high(RS485_NRE); 
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
....................  
.................... 	switch ( i ) { 
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
0247A:  GOTO   0B16
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
0247E:  MOVF   36,W
02480:  SUBLW  80
02482:  BC    2488
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02484:  CALL   0A9E
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02488:  BSF    FAB.7
0248A:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
0248C:  GOTO   0B74
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02490:  MOVLB  7
02492:  CLRF   xD1
02494:  MOVF   xD1,W
02496:  SUBLW  1D
02498:  BNC   24A6
.................... 		adc_update(); 
0249A:  MOVLB  0
0249C:  CALL   0C32
.................... 	} 
024A0:  MOVLB  7
024A2:  INCF   xD1,F
024A4:  BRA    2494
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
024A6:  MOVFF  43,1DB
....................  
....................  
.................... #if 0 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
.................... 	output_low(RS485_DE); 
.................... 	output_low(RS485_NRE); 
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
024AA:  MOVLW  62
024AC:  MOVWF  FF6
024AE:  MOVLW  07
024B0:  MOVWF  FF7
024B2:  MOVLW  07
024B4:  MOVWF  xD2
024B6:  MOVLB  0
024B8:  GOTO   0CD8
024BC:  MOVLW  6E
024BE:  MOVWF  FF6
024C0:  MOVLW  07
024C2:  MOVWF  FF7
024C4:  GOTO   0D04
024C8:  MOVLW  0D
024CA:  BTFSS  F9E.4
024CC:  BRA    24CA
024CE:  MOVWF  FAD
024D0:  MOVLW  0A
024D2:  BTFSS  F9E.4
024D4:  BRA    24D2
024D6:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
024D8:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(STREAM_RS485) ) { 
.................... 				fputc(fgetc(STREAM_RS485),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
024DA:  MOVLB  1
024DC:  BTFSS  xF6.2
024DE:  BRA    24E8
.................... 			periodic_millisecond(); 
024E0:  MOVLB  0
024E2:  GOTO   0DB0
024E6:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
024E8:  BTFSS  xF6.0
024EA:  BRA    24F4
.................... 			timers.now_adc_sample=0; 
024EC:  BCF    xF6.0
.................... 			adc_update(); 
024EE:  MOVLB  0
024F0:  CALL   0C32
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
024F4:  MOVLB  0
024F6:  BRA    2070
.................... //		} 
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
024F8:  MOVLB  1
024FA:  BTFSS  xF9.0
024FC:  BRA    2506
.................... 			timers.now_parse_rda2=0; 
024FE:  BCF    xF9.0
.................... 			rs485_to_host(); 
02500:  MOVLB  0
02502:  BRA    2362
02504:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
02506:  MOVLB  0
02508:  BRA    24D8
.................... } 
0250A:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
