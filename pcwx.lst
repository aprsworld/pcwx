CCS PCH C Compiler, Version 4.135, 4375               20-Nov-15 13:25

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 8964 bytes (14%)
                         Largest free fragment is 56568
               RAM used: 2253 (58%) at main() level
                         2517 (65%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   21D4
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03B0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   06B2
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   0638
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   03E2
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
00ECE:  MOVLW  05
00ED0:  MOVLB  8
00ED2:  SUBWF  xD4,F
00ED4:  BNC   0EEA
00ED6:  MOVLW  08
00ED8:  MOVWF  FEA
00EDA:  MOVLW  D4
00EDC:  MOVWF  FE9
00EDE:  MOVF   FEF,W
00EE0:  BZ    0EEA
00EE2:  BRA    0EE6
00EE4:  CLRWDT
00EE6:  DECFSZ FEF,F
00EE8:  BRA    0EE4
00EEA:  MOVLB  0
00EEC:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00668:  BTFSS  F9E.5
0066A:  BRA    0668
0066C:  MOVFF  FAB,35
00670:  MOVFF  FAE,01
00674:  BTFSS  35.1
00676:  BRA    067C
00678:  BCF    FAB.4
0067A:  BSF    FAB.4
0067C:  RETURN 0
*
00F70:  BTFSS  F9E.4
00F72:  BRA    0F70
00F74:  MOVWF  FAD
00F76:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00620:  BTFSS  FA4.5
00622:  BRA    0620
00624:  MOVFF  F71,35
00628:  MOVFF  F74,01
0062C:  BTFSS  35.1
0062E:  BRA    0634
00630:  BCF    F71.4
00632:  BSF    F71.4
00634:  GOTO   063A (RETURN)
*
0067E:  BTFSS  FA4.4
00680:  BRA    067E
00682:  MOVWF  F73
00684:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda; 
.................... 	int8 rda_buff[256]; 
.................... 	int8 rda_buff_pos; 
.................... 	int8 rda_buff_gap; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
.................... typedef struct { 
.................... 	int8 buff[1024]; 
.................... } struct_nmea; 
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00B84:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00AE4:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00AE6:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00AE8:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00AEA:  MOVLB  8
00AEC:  MOVF   xD0,F
00AEE:  BNZ   0AF6
.................... 		c=0b00011; 
00AF0:  MOVLW  03
00AF2:  MOVWF  xD4
.................... 	else if ( 1 == ch )  
00AF4:  BRA    0B40
00AF6:  DECFSZ xD0,W
00AF8:  BRA    0B00
.................... 		c=0b10011; 
00AFA:  MOVLW  13
00AFC:  MOVWF  xD4
.................... 	else if ( 2 == ch )  
00AFE:  BRA    0B40
00B00:  MOVF   xD0,W
00B02:  SUBLW  02
00B04:  BNZ   0B0C
.................... 		c=0b01011; 
00B06:  MOVLW  0B
00B08:  MOVWF  xD4
.................... 	else if ( 3 == ch )  
00B0A:  BRA    0B40
00B0C:  MOVF   xD0,W
00B0E:  SUBLW  03
00B10:  BNZ   0B18
.................... 		c=0b11011; 
00B12:  MOVLW  1B
00B14:  MOVWF  xD4
.................... 	else if ( 4 == ch ) 
00B16:  BRA    0B40
00B18:  MOVF   xD0,W
00B1A:  SUBLW  04
00B1C:  BNZ   0B24
.................... 		c=0b00111; 
00B1E:  MOVLW  07
00B20:  MOVWF  xD4
.................... 	else if ( 5 == ch )  
00B22:  BRA    0B40
00B24:  MOVF   xD0,W
00B26:  SUBLW  05
00B28:  BNZ   0B30
.................... 		c=0b10111; 
00B2A:  MOVLW  17
00B2C:  MOVWF  xD4
.................... 	else if ( 6 == ch ) 
00B2E:  BRA    0B40
00B30:  MOVF   xD0,W
00B32:  SUBLW  06
00B34:  BNZ   0B3C
.................... 		c=0b01111; 
00B36:  MOVLW  0F
00B38:  MOVWF  xD4
.................... 	else 
00B3A:  BRA    0B40
.................... 		c=0b11111; 
00B3C:  MOVLW  1F
00B3E:  MOVWF  xD4
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00B40:  CLRF   xD3
00B42:  MOVF   xD3,W
00B44:  SUBLW  04
00B46:  BNC   0B5E
.................... 		output_low(MCP3208_CLK); 
00B48:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00B4A:  BTFSC  xD4.0
00B4C:  BRA    0B52
00B4E:  BCF    F8B.5
00B50:  BRA    0B54
00B52:  BSF    F8B.5
.................... 		c=c>>1; 
00B54:  BCF    FD8.0
00B56:  RRCF   xD4,F
.................... 		output_high(MCP3208_CLK); 
00B58:  BSF    F8B.3
.................... 	} 
00B5A:  INCF   xD3,F
00B5C:  BRA    0B42
....................  
....................  
.................... 	value=0; 
00B5E:  CLRF   xD2
00B60:  CLRF   xD1
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00B62:  CLRF   xD3
00B64:  MOVF   xD3,W
00B66:  SUBLW  0D
00B68:  BNC   0B80
.................... 		output_low(MCP3208_CLK); 
00B6A:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00B6C:  BTFSC  F82.4
00B6E:  BRA    0B74
00B70:  BCF    FD8.0
00B72:  BRA    0B76
00B74:  BSF    FD8.0
00B76:  RLCF   xD1,F
00B78:  RLCF   xD2,F
.................... 		output_high(MCP3208_CLK); 
00B7A:  BSF    F8B.3
.................... 	} 
00B7C:  INCF   xD3,F
00B7E:  BRA    0B64
....................  
.................... 	bit_clear(value,13); 
00B80:  BCF    xD2.5
.................... 	bit_clear(value,12); 
00B82:  BCF    xD2.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00B86:  MOVFF  8D1,01
00B8A:  MOVFF  8D2,02
.................... } 
00B8E:  MOVLB  0
00B90:  GOTO   0C00 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00C8A:  MOVLB  8
00C8C:  CLRF   xE8
00C8E:  MOVFF  8E1,8E7
00C92:  CLRF   xEA
00C94:  MOVLW  20
00C96:  MOVWF  xE9
00C98:  MOVLB  0
00C9A:  RCALL  0742
00C9C:  MOVFF  02,03
00CA0:  MOVF   01,W
00CA2:  ADDLW  82
00CA4:  MOVWF  01
00CA6:  MOVLW  00
00CA8:  ADDWFC 03,F
00CAA:  MOVFF  01,8E5
00CAE:  MOVLB  8
00CB0:  MOVFF  03,8E6
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00CB4:  CLRF   xE3
00CB6:  CLRF   xE2
.................... 	for( i = 0; i < 16 ; i++ ) { 
00CB8:  CLRF   xE4
00CBA:  MOVF   xE4,W
00CBC:  SUBLW  0F
00CBE:  BNC   0CE2
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00CC0:  BCF    FD8.0
00CC2:  RLCF   xE4,W
00CC4:  CLRF   03
00CC6:  ADDWF  xE5,W
00CC8:  MOVWF  FE9
00CCA:  MOVF   xE6,W
00CCC:  ADDWFC 03,W
00CCE:  MOVWF  FEA
00CD0:  MOVFF  FEC,03
00CD4:  MOVF   FED,F
00CD6:  MOVF   FEF,W
00CD8:  ADDWF  xE2,F
00CDA:  MOVF   03,W
00CDC:  ADDWFC xE3,F
.................... 	} 
00CDE:  INCF   xE4,F
00CE0:  BRA    0CBA
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00CE2:  MOVLW  08
00CE4:  ADDWF  xE2,W
00CE6:  MOVWF  xE7
00CE8:  MOVLW  00
00CEA:  ADDWFC xE3,W
00CEC:  MOVWF  xE8
00CEE:  RRCF   xE8,W
00CF0:  MOVWF  03
00CF2:  RRCF   xE7,W
00CF4:  MOVWF  02
00CF6:  RRCF   03,F
00CF8:  RRCF   02,F
00CFA:  RRCF   03,F
00CFC:  RRCF   02,F
00CFE:  RRCF   03,F
00D00:  RRCF   02,F
00D02:  MOVLW  0F
00D04:  ANDWF  03,F
00D06:  MOVFF  02,01
00D0A:  MOVFF  03,02
.................... } 
00D0E:  MOVLB  0
00D10:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00B94:  MOVLB  1
00B96:  INCF   x82,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00B98:  MOVF   x82,W
00B9A:  SUBLW  0F
00B9C:  BC    0BA0
.................... 		current.adc_buffer_index=0; 
00B9E:  CLRF   x82
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00BA0:  MOVLB  8
00BA2:  CLRF   xCD
00BA4:  MOVF   xCD,W
00BA6:  SUBLW  07
00BA8:  BNC   0C36
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00BAA:  CLRF   xE8
00BAC:  MOVFF  8CD,8E7
00BB0:  CLRF   xEA
00BB2:  MOVLW  20
00BB4:  MOVWF  xE9
00BB6:  MOVLB  0
00BB8:  RCALL  0742
00BBA:  MOVFF  02,03
00BBE:  MOVF   01,W
00BC0:  ADDLW  34
00BC2:  MOVLB  8
00BC4:  MOVWF  xCE
00BC6:  MOVLW  00
00BC8:  ADDWFC 02,W
00BCA:  MOVWF  xCF
00BCC:  CLRF   03
00BCE:  MOVLB  1
00BD0:  MOVFF  182,02
00BD4:  BCF    FD8.0
00BD6:  RLCF   02,F
00BD8:  RLCF   03,F
00BDA:  MOVF   02,W
00BDC:  MOVLB  8
00BDE:  ADDWF  xCE,W
00BE0:  MOVWF  01
00BE2:  MOVF   xCF,W
00BE4:  ADDWFC 03,F
00BE6:  MOVF   01,W
00BE8:  ADDLW  4E
00BEA:  MOVWF  01
00BEC:  MOVLW  00
00BEE:  ADDWFC 03,F
00BF0:  MOVFF  01,8CE
00BF4:  MOVFF  03,8CF
00BF8:  MOVFF  8CD,8D0
00BFC:  MOVLB  0
00BFE:  BRA    0AE4
00C00:  MOVFF  8CF,FEA
00C04:  MOVFF  8CE,FE9
00C08:  MOVFF  02,FEC
00C0C:  MOVF   FED,F
00C0E:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00C12:  CLRF   03
00C14:  MOVLB  8
00C16:  MOVFF  8CD,02
00C1A:  BCF    FD8.0
00C1C:  RLCF   02,F
00C1E:  RLCF   03,F
00C20:  MOVF   02,W
00C22:  ADDLW  72
00C24:  MOVWF  FE9
00C26:  MOVLW  00
00C28:  ADDWFC 03,W
00C2A:  MOVWF  FEA
00C2C:  CLRF   FEC
00C2E:  MOVF   FED,F
00C30:  CLRF   FEF
....................  
.................... 	} 
00C32:  INCF   xCD,F
00C34:  BRA    0BA4
.................... } 
00C36:  MOVLB  0
00C38:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
0092A:  MOVF   xE8,W
0092C:  XORWF  xE9,W
0092E:  MOVWF  01
*
0097C:  MOVF   xE8,W
0097E:  XORWF  xE9,W
00980:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
008B4:  MOVLB  8
008B6:  CLRF   xD6
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
008B8:  MOVFF  8D5,03
008BC:  MOVF   xD4,W
008BE:  BTFSC  FD8.2
008C0:  DECF   xD5,F
008C2:  DECF   xD4,F
008C4:  MOVWF  xD7
008C6:  MOVFF  03,8D8
008CA:  MOVF   xD7,F
008CC:  BNZ   08D2
008CE:  MOVF   xD8,F
008D0:  BZ    093C
.................... 		*data = read_eeprom( address++ ); 
008D2:  MOVFF  8D3,03
008D6:  MOVF   xD2,W
008D8:  MOVWF  FE9
008DA:  MOVFF  03,FEA
008DE:  MOVF   xD1,W
008E0:  MOVWF  03
008E2:  MOVF   xD0,W
008E4:  INCF   xD0,F
008E6:  BTFSC  FD8.2
008E8:  INCF   xD1,F
008EA:  MOVWF  xD9
008EC:  MOVFF  03,8DA
008F0:  MOVFF  FF2,8DB
008F4:  BCF    FF2.6
008F6:  BCF    FF2.7
008F8:  MOVFF  8DA,FAA
008FC:  MOVFF  8D9,FA9
00900:  BCF    FA6.6
00902:  BCF    FA6.7
00904:  BSF    FA6.0
00906:  MOVF   FA8,W
00908:  BTFSC  xDB.6
0090A:  BSF    FF2.6
0090C:  BTFSC  xDB.7
0090E:  BSF    FF2.7
00910:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00912:  MOVFF  8D3,03
00916:  MOVF   xD2,W
00918:  MOVWF  FE9
0091A:  MOVFF  03,FEA
0091E:  MOVFF  FEF,8D7
00922:  MOVFF  8D6,8E8
00926:  MOVFF  8D7,8E9
*
00930:  MOVFF  01,8D6
.................... 		data++; 
00934:  INCF   xD2,F
00936:  BTFSC  FD8.2
00938:  INCF   xD3,F
.................... 	} 
0093A:  BRA    08B8
.................... 	return crc; 
0093C:  MOVFF  8D6,01
.................... } 
00940:  MOVLB  0
00942:  GOTO   0A98 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00946:  MOVLB  8
00948:  CLRF   xE6
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
0094A:  MOVFF  8E5,03
0094E:  MOVF   xE4,W
00950:  BTFSC  FD8.2
00952:  DECF   xE5,F
00954:  DECF   xE4,F
00956:  MOVWF  xE7
00958:  MOVFF  03,8E8
0095C:  MOVF   xE7,F
0095E:  BNZ   0964
00960:  MOVF   xE8,F
00962:  BZ    09E2
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00964:  MOVFF  8E3,03
00968:  MOVF   xE2,W
0096A:  MOVWF  FE9
0096C:  MOVFF  03,FEA
00970:  MOVFF  FEF,8E7
00974:  MOVFF  8E6,8E8
00978:  MOVFF  8E7,8E9
*
00982:  MOVFF  01,8E6
.................... 		write_eeprom( address++, *data++ ); 
00986:  MOVF   xE1,W
00988:  MOVWF  03
0098A:  MOVF   xE0,W
0098C:  INCF   xE0,F
0098E:  BTFSC  FD8.2
00990:  INCF   xE1,F
00992:  MOVWF  xE7
00994:  MOVFF  03,8E8
00998:  MOVF   xE3,W
0099A:  MOVWF  03
0099C:  MOVF   xE2,W
0099E:  INCF   xE2,F
009A0:  BTFSC  FD8.2
009A2:  INCF   xE3,F
009A4:  MOVWF  FE9
009A6:  MOVFF  03,FEA
009AA:  MOVFF  FEF,8E9
009AE:  MOVFF  8E8,FAA
009B2:  MOVFF  8E7,FA9
009B6:  MOVFF  8E9,FA8
009BA:  BCF    FA6.6
009BC:  BCF    FA6.7
009BE:  BSF    FA6.2
009C0:  MOVF   FF2,W
009C2:  MOVWF  00
009C4:  BCF    FF2.6
009C6:  BCF    FF2.7
009C8:  MOVLB  F
009CA:  MOVLW  55
009CC:  MOVWF  FA7
009CE:  MOVLW  AA
009D0:  MOVWF  FA7
009D2:  BSF    FA6.1
009D4:  BTFSC  FA6.1
009D6:  BRA    09D4
009D8:  BCF    FA6.2
009DA:  MOVF   00,W
009DC:  IORWF  FF2,F
.................... 	} 
009DE:  MOVLB  8
009E0:  BRA    094A
....................  
.................... 	return crc; 
009E2:  MOVFF  8E6,01
.................... } 
009E6:  MOVLB  0
009E8:  GOTO   0A0C (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
009EC:  MOVLB  8
009EE:  CLRF   xDF
009F0:  MOVLW  36
009F2:  MOVWF  xDE
009F4:  CLRF   xE1
009F6:  MOVLW  02
009F8:  MOVWF  xE0
009FA:  MOVFF  8DF,8E3
009FE:  MOVFF  8DE,8E2
00A02:  CLRF   xE5
00A04:  MOVLW  18
00A06:  MOVWF  xE4
00A08:  MOVLB  0
00A0A:  BRA    0946
00A0C:  MOVFF  01,8DD
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00A10:  CLRF   FAA
00A12:  CLRF   FA9
00A14:  MOVFF  8DD,FA8
00A18:  BCF    FA6.6
00A1A:  BCF    FA6.7
00A1C:  BSF    FA6.2
00A1E:  MOVF   FF2,W
00A20:  MOVWF  00
00A22:  BCF    FF2.6
00A24:  BCF    FF2.7
00A26:  MOVLB  F
00A28:  MOVLW  55
00A2A:  MOVWF  FA7
00A2C:  MOVLW  AA
00A2E:  MOVWF  FA7
00A30:  BSF    FA6.1
00A32:  BTFSC  FA6.1
00A34:  BRA    0A32
00A36:  BCF    FA6.2
00A38:  MOVF   00,W
00A3A:  IORWF  FF2,F
.................... } 
00A3C:  MOVLB  0
00A3E:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00A40:  MOVLW  96
00A42:  MOVLB  1
00A44:  MOVWF  xAB
....................  
.................... 	config.modbus_address=38; 
00A46:  MOVLW  26
00A48:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_MODBUS_BRIDGE; 
00A4A:  MOVLW  01
00A4C:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00A4E:  MOVLW  50
00A50:  MOVWF  39
.................... 	config.serial_number=9876; 
00A52:  MOVLW  26
00A54:  MOVWF  3B
00A56:  MOVLW  94
00A58:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00A5A:  CLRF   3D
00A5C:  MOVLW  14
00A5E:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00A60:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00A62:  MOVLW  02
00A64:  MOVWF  40
00A66:  MOVLW  76
00A68:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00A6A:  CLRF   42
00A6C:  MOVLW  02
00A6E:  MOVWF  41
.................... 	config.power_startup=0; 
00A70:  CLRF   43
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00A72:  MOVLB  0
00A74:  RCALL  09EC
....................  
.................... } 
00A76:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00A78:  MOVLB  8
00A7A:  CLRF   xCF
00A7C:  MOVLW  36
00A7E:  MOVWF  xCE
00A80:  CLRF   xD1
00A82:  MOVLW  02
00A84:  MOVWF  xD0
00A86:  MOVFF  8CF,8D3
00A8A:  MOVFF  8CE,8D2
00A8E:  CLRF   xD5
00A90:  MOVLW  18
00A92:  MOVWF  xD4
00A94:  MOVLB  0
00A96:  BRA    08B4
00A98:  MOVFF  01,8CD
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00A9C:  MOVFF  FF2,8CE
00AA0:  BCF    FF2.6
00AA2:  BCF    FF2.7
00AA4:  CLRF   FAA
00AA6:  CLRF   FA9
00AA8:  BCF    FA6.6
00AAA:  BCF    FA6.7
00AAC:  BSF    FA6.0
00AAE:  MOVF   FA8,W
00AB0:  MOVLB  8
00AB2:  BTFSC  xCE.6
00AB4:  BSF    FF2.6
00AB6:  BTFSC  xCE.7
00AB8:  BSF    FF2.7
00ABA:  SUBWF  xCD,W
00ABC:  BZ    0AC4
.................... 		write_default_param_file(); 
00ABE:  MOVLB  0
00AC0:  RCALL  0A40
00AC2:  MOVLB  8
.................... 	} 
.................... } 
00AC4:  MOVLB  0
00AC6:  GOTO   227A (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
00FD2:  BTFSS  FAC.1
00FD4:  BRA    0FD2
.................... } 
00FD6:  GOTO   0FF0 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00ACA:  BTFSS  F9E.5
00ACC:  BRA    0AD2
.................... 		fgetc(STREAM_PI); 
00ACE:  RCALL  0668
.................... 	} 
00AD0:  BRA    0ACA
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00AD2:  BSF    F9D.5
.................... } 
00AD4:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00AD6:  RCALL  0ACA
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00AD8:  MOVLW  C6
00ADA:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00ADC:  MOVLW  C0
00ADE:  IORWF  FF2,F
.................... } 
00AE0:  GOTO   228C (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0039C:  BCF    FF2.5
.................... 	if (enable) { 
0039E:  MOVLB  9
003A0:  MOVF   xD2,F
003A2:  BZ    03AC
.................... 		set_timer0(0); 
003A4:  CLRF   FD7
003A6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003A8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003AA:  BSF    FF2.5
.................... 	} 
.................... } 
003AC:  MOVLB  0
003AE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003B0:  MOVLB  7
003B2:  MOVF   xB8,W
003B4:  SUBLW  02
003B6:  BNZ   03CC
003B8:  MOVF   xB9,F
003BA:  BNZ   03CC
003BC:  MOVF   xBA,F
003BE:  BNZ   03CC
003C0:  BTFSC  xB7.0
003C2:  BRA    03CC
....................    { 
....................       modbus_rx.len-=2; 
003C4:  MOVLW  02
003C6:  SUBWF  xBC,F
....................       modbus_serial_new=TRUE; 
003C8:  BSF    xB7.0
....................    } 
....................    else 
003CA:  BRA    03CE
....................       modbus_serial_new=FALSE; 
003CC:  BCF    xB7.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003CE:  SETF   xBA
003D0:  SETF   xB9
....................    modbus_serial_state=MODBUS_GETADDY; 
003D2:  CLRF   xB8
....................    modbus_enable_timeout(FALSE); 
003D4:  MOVLB  9
003D6:  CLRF   xD2
003D8:  MOVLB  0
003DA:  RCALL  039C
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003DC:  BCF    FF2.2
003DE:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00686:  MOVLB  7
00688:  MOVF   xBA,W
0068A:  MOVLB  9
0068C:  XORWF  xD2,W
0068E:  MOVWF  xD3
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00690:  CLRF   03
00692:  MOVF   xD3,W
00694:  MOVLB  0
00696:  RCALL  017C
00698:  MOVWF  01
0069A:  MOVLB  7
0069C:  MOVF   xB9,W
0069E:  XORWF  01,W
006A0:  MOVWF  xBA
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006A2:  CLRF   03
006A4:  MOVLB  9
006A6:  MOVF   xD3,W
006A8:  MOVLB  0
006AA:  RCALL  028C
006AC:  MOVFF  FE8,7B9
.................... } 
006B0:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
00F78:  MOVLB  8
00F7A:  MOVF   xDF,W
00F7C:  MOVLB  0
00F7E:  RCALL  0F70
00F80:  CLRF   19
00F82:  BTFSC  FF2.6
00F84:  BSF    19.6
00F86:  BCF    FF2.6
00F88:  BTFSC  FF2.7
00F8A:  BSF    19.7
00F8C:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
00F8E:  MOVFF  8DF,9D2
00F92:  CALL   0686
00F96:  BTFSC  19.6
00F98:  BSF    FF2.6
00F9A:  BTFSC  19.7
00F9C:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
00F9E:  CLRWDT
00FA0:  MOVLW  08
00FA2:  MOVWF  00
00FA4:  DECFSZ 00,F
00FA6:  BRA    0FA4
00FA8:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
00FAA:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
00FAC:  MOVLB  7
00FAE:  SETF   xBA
00FB0:  SETF   xB9
....................    modbus_serial_new=FALSE; 
00FB2:  BCF    xB7.0
....................  
....................    RCV_OFF(); 
00FB4:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
00FB6:  CLRWDT
00FB8:  MOVLW  3C
00FBA:  MOVWF  00
00FBC:  DECFSZ 00,F
00FBE:  BRA    0FBC
00FC0:  NOP   
....................  
....................    modbus_serial_putc(to); 
00FC2:  MOVFF  8DD,8DF
00FC6:  MOVLB  0
00FC8:  RCALL  0F78
....................    modbus_serial_putc(func); 
00FCA:  MOVFF  8DE,8DF
00FCE:  RCALL  0F78
.................... } 
00FD0:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
00FDA:  MOVFF  7BA,8DE
....................    crc_low=modbus_serial_crc.b[0]; 
00FDE:  MOVFF  7B9,8DD
....................  
....................    modbus_serial_putc(crc_high); 
00FE2:  MOVFF  8DE,8DF
00FE6:  RCALL  0F78
....................    modbus_serial_putc(crc_low); 
00FE8:  MOVFF  8DD,8DF
00FEC:  RCALL  0F78
....................  
....................    WAIT_FOR_HW_BUFFER(); 
00FEE:  BRA    0FD2
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
00FF0:  CLRWDT
00FF2:  MOVLW  3C
00FF4:  MOVWF  00
00FF6:  DECFSZ 00,F
00FF8:  BRA    0FF6
00FFA:  NOP   
....................  
....................  
....................    RCV_ON(); 
00FFC:  RCALL  0ACA
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
00FFE:  MOVLB  7
01000:  SETF   xBA
01002:  SETF   xB9
.................... } 
01004:  MOVLB  0
01006:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
00EA8:  MOVLB  7
00EAA:  BTFSC  xB7.0
00EAC:  BRA    0EB6
....................       return FALSE; 
00EAE:  MOVLW  00
00EB0:  MOVWF  01
00EB2:  BRA    0EC8
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00EB4:  BRA    0EC2
00EB6:  BTFSS  xBD.7
00EB8:  BRA    0EC2
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00EBA:  MOVFF  7BF,7BE
....................       modbus_rx.len = 1; 
00EBE:  MOVLW  01
00EC0:  MOVWF  xBC
....................    } 
....................    modbus_serial_new=FALSE; 
00EC2:  BCF    xB7.0
....................    return TRUE; 
00EC4:  MOVLW  01
00EC6:  MOVWF  01
.................... } 
00EC8:  MOVLB  0
00ECA:  GOTO   1E80 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01DEC:  MOVFF  8D5,8DD
01DF0:  MOVLW  06
01DF2:  MOVLB  8
01DF4:  MOVWF  xDE
01DF6:  MOVLB  0
01DF8:  CALL   0FAC
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01DFC:  MOVFF  8D7,8DA
01E00:  MOVFF  8D7,8DF
01E04:  CALL   0F78
....................    modbus_serial_putc(make8(reg_address,0)); 
01E08:  MOVFF  8D6,8DA
01E0C:  MOVFF  8D6,8DF
01E10:  CALL   0F78
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01E14:  MOVFF  8D9,8DA
01E18:  MOVFF  8D9,8DF
01E1C:  CALL   0F78
....................    modbus_serial_putc(make8(reg_value,0)); 
01E20:  MOVFF  8D8,8DA
01E24:  MOVFF  8D8,8DF
01E28:  CALL   0F78
....................  
....................    modbus_serial_send_stop(); 
01E2C:  CALL   0FDA
.................... } 
01E30:  GOTO   2064 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01E34:  MOVFF  8D3,8DD
01E38:  MOVLW  10
01E3A:  MOVLB  8
01E3C:  MOVWF  xDE
01E3E:  MOVLB  0
01E40:  CALL   0FAC
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01E44:  MOVFF  8D5,8D8
01E48:  MOVFF  8D5,8DF
01E4C:  CALL   0F78
....................    modbus_serial_putc(make8(start_address,0)); 
01E50:  MOVFF  8D4,8D8
01E54:  MOVFF  8D4,8DF
01E58:  CALL   0F78
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01E5C:  MOVFF  8D7,8D8
01E60:  MOVFF  8D7,8DF
01E64:  CALL   0F78
....................    modbus_serial_putc(make8(quantity,0)); 
01E68:  MOVFF  8D6,8D8
01E6C:  MOVFF  8D6,8DF
01E70:  CALL   0F78
....................  
....................    modbus_serial_send_stop(); 
01E74:  CALL   0FDA
.................... } 
01E78:  GOTO   2126 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01008:  MOVLB  8
0100A:  MOVF   xD4,W
0100C:  IORLW  80
0100E:  MOVWF  xD7
01010:  MOVFF  8D5,8D8
01014:  MOVFF  8D3,8DD
01018:  MOVWF  xDE
0101A:  MOVLB  0
0101C:  RCALL  0FAC
....................    modbus_serial_putc(error); 
0101E:  MOVFF  8D6,8DF
01022:  RCALL  0F78
....................    modbus_serial_send_stop(); 
01024:  RCALL  0FDA
.................... } 
01026:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1012 
....................  
.................... #define MIN_EE_REGISTER      2000 
.................... #define MAX_EE_REGISTER      MIN_EE_REGISTER + 512 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
010EE:  MOVLB  1
010F0:  CLRF   x84
010F2:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
010F4:  CLRF   x86
010F6:  CLRF   x85
.................... 	current.modbus_last_error=0; 
010F8:  CLRF   x88
010FA:  CLRF   x87
.................... } 
010FC:  MOVLB  0
010FE:  GOTO   1A24 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0108A:  BCF    FF2.6
0108C:  BCF    FF2.7
0108E:  BTFSC  FF2.7
01090:  BRA    108C
....................  
.................... 	current.pulse_count[0]=0; 
01092:  CLRF   x61
01094:  CLRF   x60
.................... 	current.pulse_count[1]=0; 
01096:  CLRF   x63
01098:  CLRF   x62
.................... 	current.pulse_count[2]=0; 
0109A:  CLRF   x65
0109C:  CLRF   x64
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
0109E:  SETF   55
010A0:  SETF   54
.................... 	current.pulse_min_period[1]=65535; 
010A2:  SETF   57
010A4:  SETF   56
.................... 	current.pulse_min_period[2]=65535; 
010A6:  SETF   59
010A8:  SETF   58
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
010AA:  CLRF   5B
010AC:  CLRF   5A
.................... 	current.pulse_max_period[1]=0; 
010AE:  CLRF   5D
010B0:  CLRF   5C
.................... 	current.pulse_max_period[2]=0; 
010B2:  CLRF   5F
010B4:  CLRF   5E
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
010B6:  MOVLB  1
010B8:  CLRF   x8E
010BA:  CLRF   x8D
....................  
.................... 	enable_interrupts(GLOBAL); 
010BC:  MOVLW  C0
010BE:  IORWF  FF2,F
.................... } 
010C0:  MOVLB  0
010C2:  GOTO   19D4 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
010C6:  BCF    FF2.6
010C8:  BCF    FF2.7
010CA:  BTFSC  FF2.7
010CC:  BRA    10C8
.................... 	current.pulse_sum[0]=0; 
010CE:  CLRF   x69
010D0:  CLRF   x68
010D2:  CLRF   x67
010D4:  CLRF   x66
.................... 	current.pulse_sum[1]=0; 
010D6:  CLRF   x6D
010D8:  CLRF   x6C
010DA:  CLRF   x6B
010DC:  CLRF   x6A
.................... 	current.pulse_sum[2]=0; 
010DE:  CLRF   x71
010E0:  CLRF   x70
010E2:  CLRF   x6F
010E4:  CLRF   x6E
.................... 	enable_interrupts(GLOBAL); 
010E6:  MOVLW  C0
010E8:  IORWF  FF2,F
.................... } 
010EA:  GOTO   19E4 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01028:  BCF    FF2.6
0102A:  BCF    FF2.7
0102C:  BTFSC  FF2.7
0102E:  BRA    102A
.................... 	l=current.pulse_sum[ch]; 
01030:  MOVLB  8
01032:  CLRF   xE8
01034:  MOVFF  8E1,8E7
01038:  CLRF   xEA
0103A:  MOVLW  04
0103C:  MOVWF  xE9
0103E:  MOVLB  0
01040:  CALL   0742
01044:  MOVFF  02,03
01048:  MOVF   01,W
0104A:  ADDLW  66
0104C:  MOVWF  FE9
0104E:  MOVLW  00
01050:  ADDWFC 02,W
01052:  MOVWF  FEA
01054:  MOVFF  FEF,00
01058:  MOVFF  FEC,01
0105C:  MOVFF  FEC,02
01060:  MOVFF  FEC,03
01064:  MOVFF  03,8E5
01068:  MOVFF  02,8E4
0106C:  MOVFF  01,8E3
01070:  MOVFF  00,8E2
.................... 	enable_interrupts(GLOBAL); 
01074:  MOVLW  C0
01076:  IORWF  FF2,F
....................  
.................... 	return l; 
01078:  MOVFF  8E2,00
0107C:  MOVFF  8E3,01
01080:  MOVFF  8E4,02
01084:  MOVFF  8E5,03
.................... } 
01088:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01102:  MOVLB  8
01104:  MOVF   xE0,W
01106:  SUBLW  06
01108:  BC    115E
0110A:  XORLW  FF
0110C:  BNZ   1114
0110E:  MOVF   xDF,W
01110:  SUBLW  CF
01112:  BC    115E
01114:  MOVF   xE0,W
01116:  SUBLW  09
01118:  BNC   115E
0111A:  BNZ   1122
0111C:  MOVF   xDF,W
0111E:  SUBLW  CF
01120:  BNC   115E
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01122:  MOVLW  D0
01124:  SUBWF  xDF,W
01126:  MOVWF  xE1
01128:  MOVLW  07
0112A:  SUBWFB xE0,W
0112C:  MOVWF  xE2
0112E:  MOVLW  02
01130:  ADDWF  xE2,F
01132:  MOVFF  FF2,8E3
01136:  BCF    FF2.6
01138:  BCF    FF2.7
0113A:  MOVFF  8E2,FAA
0113E:  MOVFF  8E1,FA9
01142:  BCF    FA6.6
01144:  BCF    FA6.7
01146:  BSF    FA6.0
01148:  MOVF   FA8,W
0114A:  BTFSC  xE3.6
0114C:  BSF    FF2.6
0114E:  BTFSC  xE3.7
01150:  BSF    FF2.7
01152:  CLRF   03
01154:  MOVWF  01
01156:  MOVF   03,W
01158:  MOVWF  02
0115A:  GOTO   1AF6
.................... 	} 
....................  
.................... 	switch ( addr ) { 
0115E:  MOVF   xDF,W
01160:  MOVWF  00
01162:  MOVF   xE0,W
01164:  MOVWF  03
01166:  MOVF   03,W
01168:  BNZ   1174
0116A:  MOVF   00,F
0116C:  MOVLB  0
0116E:  BTFSC  FD8.2
01170:  BRA    1590
01172:  MOVLB  8
01174:  MOVF   03,W
01176:  BNZ   1184
01178:  MOVLW  01
0117A:  SUBWF  00,W
0117C:  MOVLB  0
0117E:  BTFSC  FD8.2
01180:  BRA    159E
01182:  MOVLB  8
01184:  MOVF   03,W
01186:  BNZ   1194
01188:  MOVLW  02
0118A:  SUBWF  00,W
0118C:  MOVLB  0
0118E:  BTFSC  FD8.2
01190:  BRA    15AC
01192:  MOVLB  8
01194:  MOVF   03,W
01196:  BNZ   11A4
01198:  MOVLW  03
0119A:  SUBWF  00,W
0119C:  MOVLB  0
0119E:  BTFSC  FD8.2
011A0:  BRA    15BA
011A2:  MOVLB  8
011A4:  MOVF   03,W
011A6:  BNZ   11B4
011A8:  MOVLW  04
011AA:  SUBWF  00,W
011AC:  MOVLB  0
011AE:  BTFSC  FD8.2
011B0:  BRA    15C8
011B2:  MOVLB  8
011B4:  MOVF   03,W
011B6:  BNZ   11C4
011B8:  MOVLW  05
011BA:  SUBWF  00,W
011BC:  MOVLB  0
011BE:  BTFSC  FD8.2
011C0:  BRA    15EE
011C2:  MOVLB  8
011C4:  MOVF   03,W
011C6:  BNZ   11D4
011C8:  MOVLW  06
011CA:  SUBWF  00,W
011CC:  MOVLB  0
011CE:  BTFSC  FD8.2
011D0:  BRA    15FC
011D2:  MOVLB  8
011D4:  MOVF   03,W
011D6:  BNZ   11E4
011D8:  MOVLW  07
011DA:  SUBWF  00,W
011DC:  MOVLB  0
011DE:  BTFSC  FD8.2
011E0:  BRA    160A
011E2:  MOVLB  8
011E4:  MOVF   03,W
011E6:  BNZ   11F4
011E8:  MOVLW  08
011EA:  SUBWF  00,W
011EC:  MOVLB  0
011EE:  BTFSC  FD8.2
011F0:  BRA    1618
011F2:  MOVLB  8
011F4:  MOVF   03,W
011F6:  BNZ   1204
011F8:  MOVLW  09
011FA:  SUBWF  00,W
011FC:  MOVLB  0
011FE:  BTFSC  FD8.2
01200:  BRA    1626
01202:  MOVLB  8
01204:  MOVF   03,W
01206:  BNZ   1214
01208:  MOVLW  0A
0120A:  SUBWF  00,W
0120C:  MOVLB  0
0120E:  BTFSC  FD8.2
01210:  BRA    1634
01212:  MOVLB  8
01214:  MOVF   03,W
01216:  BNZ   1224
01218:  MOVLW  0B
0121A:  SUBWF  00,W
0121C:  MOVLB  0
0121E:  BTFSC  FD8.2
01220:  BRA    165C
01222:  MOVLB  8
01224:  MOVF   03,W
01226:  BNZ   1234
01228:  MOVLW  0C
0122A:  SUBWF  00,W
0122C:  MOVLB  0
0122E:  BTFSC  FD8.2
01230:  BRA    166A
01232:  MOVLB  8
01234:  MOVF   03,W
01236:  BNZ   1244
01238:  MOVLW  0D
0123A:  SUBWF  00,W
0123C:  MOVLB  0
0123E:  BTFSC  FD8.2
01240:  BRA    1678
01242:  MOVLB  8
01244:  MOVF   03,W
01246:  BNZ   1254
01248:  MOVLW  0E
0124A:  SUBWF  00,W
0124C:  MOVLB  0
0124E:  BTFSC  FD8.2
01250:  BRA    1686
01252:  MOVLB  8
01254:  MOVF   03,W
01256:  BNZ   1264
01258:  MOVLW  0F
0125A:  SUBWF  00,W
0125C:  MOVLB  0
0125E:  BTFSC  FD8.2
01260:  BRA    1694
01262:  MOVLB  8
01264:  MOVF   03,W
01266:  BNZ   1274
01268:  MOVLW  10
0126A:  SUBWF  00,W
0126C:  MOVLB  0
0126E:  BTFSC  FD8.2
01270:  BRA    16A2
01272:  MOVLB  8
01274:  MOVF   03,W
01276:  BNZ   1284
01278:  MOVLW  11
0127A:  SUBWF  00,W
0127C:  MOVLB  0
0127E:  BTFSC  FD8.2
01280:  BRA    16CA
01282:  MOVLB  8
01284:  MOVF   03,W
01286:  BNZ   1294
01288:  MOVLW  12
0128A:  SUBWF  00,W
0128C:  MOVLB  0
0128E:  BTFSC  FD8.2
01290:  BRA    16D8
01292:  MOVLB  8
01294:  MOVF   03,W
01296:  BNZ   12A4
01298:  MOVLW  13
0129A:  SUBWF  00,W
0129C:  MOVLB  0
0129E:  BTFSC  FD8.2
012A0:  BRA    1706
012A2:  MOVLB  8
012A4:  MOVF   03,W
012A6:  BNZ   12B4
012A8:  MOVLW  14
012AA:  SUBWF  00,W
012AC:  MOVLB  0
012AE:  BTFSC  FD8.2
012B0:  BRA    171E
012B2:  MOVLB  8
012B4:  MOVF   03,W
012B6:  BNZ   12C4
012B8:  MOVLW  15
012BA:  SUBWF  00,W
012BC:  MOVLB  0
012BE:  BTFSC  FD8.2
012C0:  BRA    172C
012C2:  MOVLB  8
012C4:  MOVF   03,W
012C6:  BNZ   12D4
012C8:  MOVLW  16
012CA:  SUBWF  00,W
012CC:  MOVLB  0
012CE:  BTFSC  FD8.2
012D0:  BRA    175A
012D2:  MOVLB  8
012D4:  MOVF   03,W
012D6:  BNZ   12E4
012D8:  MOVLW  17
012DA:  SUBWF  00,W
012DC:  MOVLB  0
012DE:  BTFSC  FD8.2
012E0:  BRA    1774
012E2:  MOVLB  8
012E4:  MOVF   03,W
012E6:  BNZ   12F4
012E8:  MOVLW  18
012EA:  SUBWF  00,W
012EC:  MOVLB  0
012EE:  BTFSC  FD8.2
012F0:  BRA    1782
012F2:  MOVLB  8
012F4:  MOVF   03,W
012F6:  BNZ   1304
012F8:  MOVLW  19
012FA:  SUBWF  00,W
012FC:  MOVLB  0
012FE:  BTFSC  FD8.2
01300:  BRA    17B0
01302:  MOVLB  8
01304:  MOVF   03,W
01306:  BNZ   1314
01308:  MOVLW  1A
0130A:  SUBWF  00,W
0130C:  MOVLB  0
0130E:  BTFSC  FD8.2
01310:  BRA    17CA
01312:  MOVLB  8
01314:  MOVF   03,W
01316:  BNZ   1324
01318:  MOVLW  1B
0131A:  SUBWF  00,W
0131C:  MOVLB  0
0131E:  BTFSC  FD8.2
01320:  BRA    17D8
01322:  MOVLB  8
01324:  MOVF   03,W
01326:  BNZ   1334
01328:  MOVLW  1C
0132A:  SUBWF  00,W
0132C:  MOVLB  0
0132E:  BTFSC  FD8.2
01330:  BRA    1806
01332:  MOVLB  8
01334:  MOVF   03,W
01336:  BNZ   1344
01338:  MOVLW  1D
0133A:  SUBWF  00,W
0133C:  MOVLB  0
0133E:  BTFSC  FD8.2
01340:  BRA    1820
01342:  MOVLB  8
01344:  MOVF   03,W
01346:  BNZ   1354
01348:  MOVLW  1E
0134A:  SUBWF  00,W
0134C:  MOVLB  0
0134E:  BTFSC  FD8.2
01350:  BRA    182E
01352:  MOVLB  8
01354:  MOVF   03,W
01356:  BNZ   1364
01358:  MOVLW  1F
0135A:  SUBWF  00,W
0135C:  MOVLB  0
0135E:  BTFSC  FD8.2
01360:  BRA    185C
01362:  MOVLB  8
01364:  MOVF   03,W
01366:  BNZ   1374
01368:  MOVLW  20
0136A:  SUBWF  00,W
0136C:  MOVLB  0
0136E:  BTFSC  FD8.2
01370:  BRA    1876
01372:  MOVLB  8
01374:  MOVF   03,W
01376:  BNZ   1384
01378:  MOVLW  21
0137A:  SUBWF  00,W
0137C:  MOVLB  0
0137E:  BTFSC  FD8.2
01380:  BRA    1884
01382:  MOVLB  8
01384:  MOVF   03,W
01386:  BNZ   1394
01388:  MOVLW  22
0138A:  SUBWF  00,W
0138C:  MOVLB  0
0138E:  BTFSC  FD8.2
01390:  BRA    18B2
01392:  MOVLB  8
01394:  MOVF   03,W
01396:  BNZ   13A4
01398:  MOVLW  23
0139A:  SUBWF  00,W
0139C:  MOVLB  0
0139E:  BTFSC  FD8.2
013A0:  BRA    18CC
013A2:  MOVLB  8
013A4:  MOVF   03,W
013A6:  BNZ   13B4
013A8:  MOVLW  24
013AA:  SUBWF  00,W
013AC:  MOVLB  0
013AE:  BTFSC  FD8.2
013B0:  BRA    18DA
013B2:  MOVLB  8
013B4:  MOVF   03,W
013B6:  BNZ   13C4
013B8:  MOVLW  25
013BA:  SUBWF  00,W
013BC:  MOVLB  0
013BE:  BTFSC  FD8.2
013C0:  BRA    1908
013C2:  MOVLB  8
013C4:  MOVF   03,W
013C6:  BNZ   13D4
013C8:  MOVLW  26
013CA:  SUBWF  00,W
013CC:  MOVLB  0
013CE:  BTFSC  FD8.2
013D0:  BRA    1922
013D2:  MOVLB  8
013D4:  MOVF   03,W
013D6:  BNZ   13E4
013D8:  MOVLW  27
013DA:  SUBWF  00,W
013DC:  MOVLB  0
013DE:  BTFSC  FD8.2
013E0:  BRA    1930
013E2:  MOVLB  8
013E4:  MOVF   03,W
013E6:  BNZ   13F4
013E8:  MOVLW  28
013EA:  SUBWF  00,W
013EC:  MOVLB  0
013EE:  BTFSC  FD8.2
013F0:  BRA    195E
013F2:  MOVLB  8
013F4:  MOVF   03,W
013F6:  BNZ   1404
013F8:  MOVLW  29
013FA:  SUBWF  00,W
013FC:  MOVLB  0
013FE:  BTFSC  FD8.2
01400:  BRA    1978
01402:  MOVLB  8
01404:  MOVF   03,W
01406:  BNZ   1414
01408:  MOVLW  2A
0140A:  SUBWF  00,W
0140C:  MOVLB  0
0140E:  BTFSC  FD8.2
01410:  BRA    1986
01412:  MOVLB  8
01414:  MOVF   03,W
01416:  BNZ   1424
01418:  MOVLW  2B
0141A:  SUBWF  00,W
0141C:  MOVLB  0
0141E:  BTFSC  FD8.2
01420:  BRA    19A0
01422:  MOVLB  8
01424:  MOVF   03,W
01426:  BNZ   1434
01428:  MOVLW  2C
0142A:  SUBWF  00,W
0142C:  MOVLB  0
0142E:  BTFSC  FD8.2
01430:  BRA    19B0
01432:  MOVLB  8
01434:  MOVF   03,W
01436:  BNZ   1444
01438:  MOVLW  2D
0143A:  SUBWF  00,W
0143C:  MOVLB  0
0143E:  BTFSC  FD8.2
01440:  BRA    19C0
01442:  MOVLB  8
01444:  MOVF   03,W
01446:  BNZ   1454
01448:  MOVLW  2E
0144A:  SUBWF  00,W
0144C:  MOVLB  0
0144E:  BTFSC  FD8.2
01450:  BRA    19D0
01452:  MOVLB  8
01454:  MOVF   03,W
01456:  BNZ   1464
01458:  MOVLW  2F
0145A:  SUBWF  00,W
0145C:  MOVLB  0
0145E:  BTFSC  FD8.2
01460:  BRA    19E0
01462:  MOVLB  8
01464:  MOVF   03,W
01466:  BNZ   1474
01468:  MOVLW  30
0146A:  SUBWF  00,W
0146C:  MOVLB  0
0146E:  BTFSC  FD8.2
01470:  BRA    19F0
01472:  MOVLB  8
01474:  MOVF   03,W
01476:  BNZ   1484
01478:  MOVLW  31
0147A:  SUBWF  00,W
0147C:  MOVLB  0
0147E:  BTFSC  FD8.2
01480:  BRA    1A00
01482:  MOVLB  8
01484:  MOVF   03,W
01486:  BNZ   1494
01488:  MOVLW  32
0148A:  SUBWF  00,W
0148C:  MOVLB  0
0148E:  BTFSC  FD8.2
01490:  BRA    1A10
01492:  MOVLB  8
01494:  MOVF   03,W
01496:  BNZ   14A4
01498:  MOVLW  33
0149A:  SUBWF  00,W
0149C:  MOVLB  0
0149E:  BTFSC  FD8.2
014A0:  BRA    1A20
014A2:  MOVLB  8
014A4:  MOVLW  03
014A6:  SUBWF  03,W
014A8:  BNZ   14B6
014AA:  MOVLW  E8
014AC:  SUBWF  00,W
014AE:  MOVLB  0
014B0:  BTFSC  FD8.2
014B2:  BRA    1A30
014B4:  MOVLB  8
014B6:  MOVLW  03
014B8:  SUBWF  03,W
014BA:  BNZ   14C8
014BC:  MOVLW  E9
014BE:  SUBWF  00,W
014C0:  MOVLB  0
014C2:  BTFSC  FD8.2
014C4:  BRA    1A40
014C6:  MOVLB  8
014C8:  MOVLW  03
014CA:  SUBWF  03,W
014CC:  BNZ   14DA
014CE:  MOVLW  EA
014D0:  SUBWF  00,W
014D2:  MOVLB  0
014D4:  BTFSC  FD8.2
014D6:  BRA    1A4E
014D8:  MOVLB  8
014DA:  MOVLW  03
014DC:  SUBWF  03,W
014DE:  BNZ   14EC
014E0:  MOVLW  EB
014E2:  SUBWF  00,W
014E4:  MOVLB  0
014E6:  BTFSC  FD8.2
014E8:  BRA    1A5C
014EA:  MOVLB  8
014EC:  MOVLW  03
014EE:  SUBWF  03,W
014F0:  BNZ   14FE
014F2:  MOVLW  EC
014F4:  SUBWF  00,W
014F6:  MOVLB  0
014F8:  BTFSC  FD8.2
014FA:  BRA    1A6A
014FC:  MOVLB  8
014FE:  MOVLW  03
01500:  SUBWF  03,W
01502:  BNZ   1510
01504:  MOVLW  ED
01506:  SUBWF  00,W
01508:  MOVLB  0
0150A:  BTFSC  FD8.2
0150C:  BRA    1A78
0150E:  MOVLB  8
01510:  MOVLW  03
01512:  SUBWF  03,W
01514:  BNZ   1522
01516:  MOVLW  EE
01518:  SUBWF  00,W
0151A:  MOVLB  0
0151C:  BTFSC  FD8.2
0151E:  BRA    1A86
01520:  MOVLB  8
01522:  MOVLW  03
01524:  SUBWF  03,W
01526:  BNZ   1534
01528:  MOVLW  EF
0152A:  SUBWF  00,W
0152C:  MOVLB  0
0152E:  BTFSC  FD8.2
01530:  BRA    1A96
01532:  MOVLB  8
01534:  MOVLW  03
01536:  SUBWF  03,W
01538:  BNZ   1546
0153A:  MOVLW  F0
0153C:  SUBWF  00,W
0153E:  MOVLB  0
01540:  BTFSC  FD8.2
01542:  BRA    1AA4
01544:  MOVLB  8
01546:  MOVLW  03
01548:  SUBWF  03,W
0154A:  BNZ   1558
0154C:  MOVLW  F1
0154E:  SUBWF  00,W
01550:  MOVLB  0
01552:  BTFSC  FD8.2
01554:  BRA    1AB4
01556:  MOVLB  8
01558:  MOVLW  03
0155A:  SUBWF  03,W
0155C:  BNZ   156A
0155E:  MOVLW  F2
01560:  SUBWF  00,W
01562:  MOVLB  0
01564:  BTFSC  FD8.2
01566:  BRA    1AC2
01568:  MOVLB  8
0156A:  MOVLW  03
0156C:  SUBWF  03,W
0156E:  BNZ   157C
01570:  MOVLW  F3
01572:  SUBWF  00,W
01574:  MOVLB  0
01576:  BTFSC  FD8.2
01578:  BRA    1AD0
0157A:  MOVLB  8
0157C:  MOVLW  03
0157E:  SUBWF  03,W
01580:  BNZ   158E
01582:  MOVLW  F4
01584:  SUBWF  00,W
01586:  MOVLB  0
01588:  BTFSC  FD8.2
0158A:  BRA    1AE0
0158C:  MOVLB  8
0158E:  BRA    1AEE
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01590:  MOVFF  60,01
01594:  MOVFF  61,02
01598:  MOVLB  8
0159A:  BRA    1AF6
0159C:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
0159E:  MOVF   4E,W
015A0:  MOVWF  01
015A2:  MOVF   4F,W
015A4:  MOVWF  02
015A6:  MOVLB  8
015A8:  BRA    1AF6
015AA:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
015AC:  MOVF   54,W
015AE:  MOVWF  01
015B0:  MOVF   55,W
015B2:  MOVWF  02
015B4:  MOVLB  8
015B6:  BRA    1AF6
015B8:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
015BA:  MOVF   5A,W
015BC:  MOVWF  01
015BE:  MOVF   5B,W
015C0:  MOVWF  02
015C2:  MOVLB  8
015C4:  BRA    1AF6
015C6:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
015C8:  MOVLB  8
015CA:  CLRF   xE1
015CC:  MOVLB  0
015CE:  RCALL  1028
015D0:  MOVFF  03,8C1
015D4:  MOVFF  02,8C0
015D8:  MOVFF  01,8BF
015DC:  MOVFF  00,8BE
015E0:  MOVLB  8
015E2:  MOVF   xBE,W
015E4:  MOVWF  01
015E6:  MOVF   xBF,W
015E8:  MOVWF  02
015EA:  BRA    1AF6
015EC:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
015EE:  MOVLB  8
015F0:  MOVF   xC0,W
015F2:  MOVWF  01
015F4:  MOVF   xC1,W
015F6:  MOVWF  02
015F8:  BRA    1AF6
015FA:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
015FC:  MOVF   x62,W
015FE:  MOVWF  01
01600:  MOVF   x63,W
01602:  MOVWF  02
01604:  MOVLB  8
01606:  BRA    1AF6
01608:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
0160A:  MOVF   50,W
0160C:  MOVWF  01
0160E:  MOVF   51,W
01610:  MOVWF  02
01612:  MOVLB  8
01614:  BRA    1AF6
01616:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01618:  MOVF   56,W
0161A:  MOVWF  01
0161C:  MOVF   57,W
0161E:  MOVWF  02
01620:  MOVLB  8
01622:  BRA    1AF6
01624:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01626:  MOVF   5C,W
01628:  MOVWF  01
0162A:  MOVF   5D,W
0162C:  MOVWF  02
0162E:  MOVLB  8
01630:  BRA    1AF6
01632:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01634:  MOVLW  01
01636:  MOVLB  8
01638:  MOVWF  xE1
0163A:  MOVLB  0
0163C:  RCALL  1028
0163E:  MOVFF  03,8C1
01642:  MOVFF  02,8C0
01646:  MOVFF  01,8BF
0164A:  MOVFF  00,8BE
0164E:  MOVLB  8
01650:  MOVF   xBE,W
01652:  MOVWF  01
01654:  MOVF   xBF,W
01656:  MOVWF  02
01658:  BRA    1AF6
0165A:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
0165C:  MOVLB  8
0165E:  MOVF   xC0,W
01660:  MOVWF  01
01662:  MOVF   xC1,W
01664:  MOVWF  02
01666:  BRA    1AF6
01668:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
0166A:  MOVF   x64,W
0166C:  MOVWF  01
0166E:  MOVF   x65,W
01670:  MOVWF  02
01672:  MOVLB  8
01674:  BRA    1AF6
01676:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01678:  MOVF   52,W
0167A:  MOVWF  01
0167C:  MOVF   53,W
0167E:  MOVWF  02
01680:  MOVLB  8
01682:  BRA    1AF6
01684:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01686:  MOVF   58,W
01688:  MOVWF  01
0168A:  MOVF   59,W
0168C:  MOVWF  02
0168E:  MOVLB  8
01690:  BRA    1AF6
01692:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01694:  MOVF   5E,W
01696:  MOVWF  01
01698:  MOVF   5F,W
0169A:  MOVWF  02
0169C:  MOVLB  8
0169E:  BRA    1AF6
016A0:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
016A2:  MOVLW  02
016A4:  MOVLB  8
016A6:  MOVWF  xE1
016A8:  MOVLB  0
016AA:  RCALL  1028
016AC:  MOVFF  03,8C1
016B0:  MOVFF  02,8C0
016B4:  MOVFF  01,8BF
016B8:  MOVFF  00,8BE
016BC:  MOVLB  8
016BE:  MOVF   xBE,W
016C0:  MOVWF  01
016C2:  MOVF   xBF,W
016C4:  MOVWF  02
016C6:  BRA    1AF6
016C8:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
016CA:  MOVLB  8
016CC:  MOVF   xC0,W
016CE:  MOVWF  01
016D0:  MOVF   xC1,W
016D2:  MOVWF  02
016D4:  BRA    1AF6
016D6:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
016D8:  CLRF   03
016DA:  MOVLB  1
016DC:  MOVF   x82,W
016DE:  MOVWF  02
016E0:  BCF    FD8.0
016E2:  RLCF   02,F
016E4:  RLCF   03,F
016E6:  MOVF   02,W
016E8:  ADDLW  82
016EA:  MOVWF  FE9
016EC:  MOVLW  00
016EE:  ADDWFC 03,W
016F0:  MOVWF  FEA
016F2:  MOVFF  FEC,03
016F6:  MOVF   FED,F
016F8:  MOVF   FEF,W
016FA:  MOVWF  01
016FC:  MOVF   03,W
016FE:  MOVWF  02
01700:  MOVLB  8
01702:  BRA    1AF6
01704:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01706:  MOVLB  8
01708:  CLRF   xE1
0170A:  MOVLB  0
0170C:  CALL   0C8A
01710:  MOVF   01,W
01712:  MOVWF  01
01714:  MOVF   02,W
01716:  MOVWF  02
01718:  MOVLB  8
0171A:  BRA    1AF6
0171C:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
0171E:  MOVF   x72,W
01720:  MOVWF  01
01722:  MOVF   x73,W
01724:  MOVWF  02
01726:  MOVLB  8
01728:  BRA    1AF6
0172A:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
0172C:  CLRF   03
0172E:  MOVLB  1
01730:  MOVF   x82,W
01732:  MOVWF  02
01734:  BCF    FD8.0
01736:  RLCF   02,F
01738:  RLCF   03,F
0173A:  MOVF   02,W
0173C:  ADDLW  A2
0173E:  MOVWF  FE9
01740:  MOVLW  00
01742:  ADDWFC 03,W
01744:  MOVWF  FEA
01746:  MOVFF  FEC,03
0174A:  MOVF   FED,F
0174C:  MOVF   FEF,W
0174E:  MOVWF  01
01750:  MOVF   03,W
01752:  MOVWF  02
01754:  MOVLB  8
01756:  BRA    1AF6
01758:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
0175A:  MOVLW  01
0175C:  MOVLB  8
0175E:  MOVWF  xE1
01760:  MOVLB  0
01762:  CALL   0C8A
01766:  MOVF   01,W
01768:  MOVWF  01
0176A:  MOVF   02,W
0176C:  MOVWF  02
0176E:  MOVLB  8
01770:  BRA    1AF6
01772:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01774:  MOVF   x74,W
01776:  MOVWF  01
01778:  MOVF   x75,W
0177A:  MOVWF  02
0177C:  MOVLB  8
0177E:  BRA    1AF6
01780:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01782:  CLRF   03
01784:  MOVLB  1
01786:  MOVF   x82,W
01788:  MOVWF  02
0178A:  BCF    FD8.0
0178C:  RLCF   02,F
0178E:  RLCF   03,F
01790:  MOVF   02,W
01792:  ADDLW  C2
01794:  MOVWF  FE9
01796:  MOVLW  00
01798:  ADDWFC 03,W
0179A:  MOVWF  FEA
0179C:  MOVFF  FEC,03
017A0:  MOVF   FED,F
017A2:  MOVF   FEF,W
017A4:  MOVWF  01
017A6:  MOVF   03,W
017A8:  MOVWF  02
017AA:  MOVLB  8
017AC:  BRA    1AF6
017AE:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
017B0:  MOVLW  02
017B2:  MOVLB  8
017B4:  MOVWF  xE1
017B6:  MOVLB  0
017B8:  CALL   0C8A
017BC:  MOVF   01,W
017BE:  MOVWF  01
017C0:  MOVF   02,W
017C2:  MOVWF  02
017C4:  MOVLB  8
017C6:  BRA    1AF6
017C8:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
017CA:  MOVF   x76,W
017CC:  MOVWF  01
017CE:  MOVF   x77,W
017D0:  MOVWF  02
017D2:  MOVLB  8
017D4:  BRA    1AF6
017D6:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
017D8:  CLRF   03
017DA:  MOVLB  1
017DC:  MOVF   x82,W
017DE:  MOVWF  02
017E0:  BCF    FD8.0
017E2:  RLCF   02,F
017E4:  RLCF   03,F
017E6:  MOVF   02,W
017E8:  ADDLW  E2
017EA:  MOVWF  FE9
017EC:  MOVLW  00
017EE:  ADDWFC 03,W
017F0:  MOVWF  FEA
017F2:  MOVFF  FEC,03
017F6:  MOVF   FED,F
017F8:  MOVF   FEF,W
017FA:  MOVWF  01
017FC:  MOVF   03,W
017FE:  MOVWF  02
01800:  MOVLB  8
01802:  BRA    1AF6
01804:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01806:  MOVLW  03
01808:  MOVLB  8
0180A:  MOVWF  xE1
0180C:  MOVLB  0
0180E:  CALL   0C8A
01812:  MOVF   01,W
01814:  MOVWF  01
01816:  MOVF   02,W
01818:  MOVWF  02
0181A:  MOVLB  8
0181C:  BRA    1AF6
0181E:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01820:  MOVF   x78,W
01822:  MOVWF  01
01824:  MOVF   x79,W
01826:  MOVWF  02
01828:  MOVLB  8
0182A:  BRA    1AF6
0182C:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
0182E:  CLRF   03
01830:  MOVLB  1
01832:  MOVF   x82,W
01834:  MOVWF  02
01836:  BCF    FD8.0
01838:  RLCF   02,F
0183A:  RLCF   03,F
0183C:  MOVF   02,W
0183E:  ADDLW  02
01840:  MOVWF  FE9
01842:  MOVLW  01
01844:  ADDWFC 03,W
01846:  MOVWF  FEA
01848:  MOVFF  FEC,03
0184C:  MOVF   FED,F
0184E:  MOVF   FEF,W
01850:  MOVWF  01
01852:  MOVF   03,W
01854:  MOVWF  02
01856:  MOVLB  8
01858:  BRA    1AF6
0185A:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
0185C:  MOVLW  04
0185E:  MOVLB  8
01860:  MOVWF  xE1
01862:  MOVLB  0
01864:  CALL   0C8A
01868:  MOVF   01,W
0186A:  MOVWF  01
0186C:  MOVF   02,W
0186E:  MOVWF  02
01870:  MOVLB  8
01872:  BRA    1AF6
01874:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01876:  MOVF   x7A,W
01878:  MOVWF  01
0187A:  MOVF   x7B,W
0187C:  MOVWF  02
0187E:  MOVLB  8
01880:  BRA    1AF6
01882:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01884:  CLRF   03
01886:  MOVLB  1
01888:  MOVF   x82,W
0188A:  MOVWF  02
0188C:  BCF    FD8.0
0188E:  RLCF   02,F
01890:  RLCF   03,F
01892:  MOVF   02,W
01894:  ADDLW  22
01896:  MOVWF  FE9
01898:  MOVLW  01
0189A:  ADDWFC 03,W
0189C:  MOVWF  FEA
0189E:  MOVFF  FEC,03
018A2:  MOVF   FED,F
018A4:  MOVF   FEF,W
018A6:  MOVWF  01
018A8:  MOVF   03,W
018AA:  MOVWF  02
018AC:  MOVLB  8
018AE:  BRA    1AF6
018B0:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
018B2:  MOVLW  05
018B4:  MOVLB  8
018B6:  MOVWF  xE1
018B8:  MOVLB  0
018BA:  CALL   0C8A
018BE:  MOVF   01,W
018C0:  MOVWF  01
018C2:  MOVF   02,W
018C4:  MOVWF  02
018C6:  MOVLB  8
018C8:  BRA    1AF6
018CA:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
018CC:  MOVF   x7C,W
018CE:  MOVWF  01
018D0:  MOVF   x7D,W
018D2:  MOVWF  02
018D4:  MOVLB  8
018D6:  BRA    1AF6
018D8:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
018DA:  CLRF   03
018DC:  MOVLB  1
018DE:  MOVF   x82,W
018E0:  MOVWF  02
018E2:  BCF    FD8.0
018E4:  RLCF   02,F
018E6:  RLCF   03,F
018E8:  MOVF   02,W
018EA:  ADDLW  42
018EC:  MOVWF  FE9
018EE:  MOVLW  01
018F0:  ADDWFC 03,W
018F2:  MOVWF  FEA
018F4:  MOVFF  FEC,03
018F8:  MOVF   FED,F
018FA:  MOVF   FEF,W
018FC:  MOVWF  01
018FE:  MOVF   03,W
01900:  MOVWF  02
01902:  MOVLB  8
01904:  BRA    1AF6
01906:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01908:  MOVLW  06
0190A:  MOVLB  8
0190C:  MOVWF  xE1
0190E:  MOVLB  0
01910:  CALL   0C8A
01914:  MOVF   01,W
01916:  MOVWF  01
01918:  MOVF   02,W
0191A:  MOVWF  02
0191C:  MOVLB  8
0191E:  BRA    1AF6
01920:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01922:  MOVF   x7E,W
01924:  MOVWF  01
01926:  MOVF   x7F,W
01928:  MOVWF  02
0192A:  MOVLB  8
0192C:  BRA    1AF6
0192E:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01930:  CLRF   03
01932:  MOVLB  1
01934:  MOVF   x82,W
01936:  MOVWF  02
01938:  BCF    FD8.0
0193A:  RLCF   02,F
0193C:  RLCF   03,F
0193E:  MOVF   02,W
01940:  ADDLW  62
01942:  MOVWF  FE9
01944:  MOVLW  01
01946:  ADDWFC 03,W
01948:  MOVWF  FEA
0194A:  MOVFF  FEC,03
0194E:  MOVF   FED,F
01950:  MOVF   FEF,W
01952:  MOVWF  01
01954:  MOVF   03,W
01956:  MOVWF  02
01958:  MOVLB  8
0195A:  BRA    1AF6
0195C:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
0195E:  MOVLW  07
01960:  MOVLB  8
01962:  MOVWF  xE1
01964:  MOVLB  0
01966:  CALL   0C8A
0196A:  MOVF   01,W
0196C:  MOVWF  01
0196E:  MOVF   02,W
01970:  MOVWF  02
01972:  MOVLB  8
01974:  BRA    1AF6
01976:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01978:  MOVF   x80,W
0197A:  MOVWF  01
0197C:  MOVF   x81,W
0197E:  MOVWF  02
01980:  MOVLB  8
01982:  BRA    1AF6
01984:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01986:  MOVLB  1
01988:  MOVF   x8A,W
0198A:  MOVWF  03
0198C:  MOVF   x89,W
0198E:  INCF   x89,F
01990:  BTFSC  FD8.2
01992:  INCF   x8A,F
01994:  MOVWF  01
01996:  MOVF   03,W
01998:  MOVWF  02
0199A:  MOVLB  8
0199C:  BRA    1AF6
0199E:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
019A0:  MOVLB  1
019A2:  MOVF   x8D,W
019A4:  MOVWF  01
019A6:  MOVF   x8E,W
019A8:  MOVWF  02
019AA:  MOVLB  8
019AC:  BRA    1AF6
019AE:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
019B0:  MOVLB  1
019B2:  MOVF   x8B,W
019B4:  MOVWF  01
019B6:  MOVF   x8C,W
019B8:  MOVWF  02
019BA:  MOVLB  8
019BC:  BRA    1AF6
019BE:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
019C0:  MOVLB  1
019C2:  MOVF   x91,W
019C4:  MOVWF  01
019C6:  MOVF   x92,W
019C8:  MOVWF  02
019CA:  MOVLB  8
019CC:  BRA    1AF6
019CE:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
019D0:  GOTO   108A
019D4:  MOVLW  00
019D6:  MOVWF  01
019D8:  MOVWF  02
019DA:  MOVLB  8
019DC:  BRA    1AF6
019DE:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
019E0:  GOTO   10C6
019E4:  MOVLW  00
019E6:  MOVWF  01
019E8:  MOVWF  02
019EA:  MOVLB  8
019EC:  BRA    1AF6
019EE:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
019F0:  MOVLB  1
019F2:  MOVF   x83,W
019F4:  MOVWF  01
019F6:  MOVF   x84,W
019F8:  MOVWF  02
019FA:  MOVLB  8
019FC:  BRA    1AF6
019FE:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01A00:  MOVLB  1
01A02:  MOVF   x85,W
01A04:  MOVWF  01
01A06:  MOVF   x86,W
01A08:  MOVWF  02
01A0A:  MOVLB  8
01A0C:  BRA    1AF6
01A0E:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01A10:  MOVLB  1
01A12:  MOVF   x87,W
01A14:  MOVWF  01
01A16:  MOVF   x88,W
01A18:  MOVWF  02
01A1A:  MOVLB  8
01A1C:  BRA    1AF6
01A1E:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01A20:  GOTO   10EE
01A24:  MOVLW  00
01A26:  MOVWF  01
01A28:  MOVWF  02
01A2A:  MOVLB  8
01A2C:  BRA    1AF6
01A2E:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01A30:  CLRF   03
01A32:  MOVF   39,W
01A34:  MOVWF  01
01A36:  MOVF   03,W
01A38:  MOVWF  02
01A3A:  MOVLB  8
01A3C:  BRA    1AF6
01A3E:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01A40:  MOVF   3A,W
01A42:  MOVWF  01
01A44:  MOVF   3B,W
01A46:  MOVWF  02
01A48:  MOVLB  8
01A4A:  BRA    1AF6
01A4C:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01A4E:  MOVLW  50
01A50:  MOVWF  01
01A52:  MOVLW  00
01A54:  MOVWF  02
01A56:  MOVLB  8
01A58:  BRA    1AF6
01A5A:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01A5C:  MOVLW  57
01A5E:  MOVWF  01
01A60:  MOVLW  00
01A62:  MOVWF  02
01A64:  MOVLB  8
01A66:  BRA    1AF6
01A68:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01A6A:  MOVLW  58
01A6C:  MOVWF  01
01A6E:  MOVLW  00
01A70:  MOVWF  02
01A72:  MOVLB  8
01A74:  BRA    1AF6
01A76:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01A78:  MOVLW  01
01A7A:  MOVWF  01
01A7C:  MOVLW  00
01A7E:  MOVWF  02
01A80:  MOVLB  8
01A82:  BRA    1AF6
01A84:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01A86:  CLRF   03
01A88:  MOVF   36,W
01A8A:  MOVWF  01
01A8C:  MOVF   03,W
01A8E:  MOVWF  02
01A90:  MOVLB  8
01A92:  BRA    1AF6
01A94:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01A96:  MOVF   3C,W
01A98:  MOVWF  01
01A9A:  MOVF   3D,W
01A9C:  MOVWF  02
01A9E:  MOVLB  8
01AA0:  BRA    1AF6
01AA2:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01AA4:  CLRF   03
01AA6:  MOVF   3E,W
01AA8:  MOVWF  01
01AAA:  MOVF   03,W
01AAC:  MOVWF  02
01AAE:  MOVLB  8
01AB0:  BRA    1AF6
01AB2:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01AB4:  MOVF   3F,W
01AB6:  MOVWF  01
01AB8:  MOVF   40,W
01ABA:  MOVWF  02
01ABC:  MOVLB  8
01ABE:  BRA    1AF6
01AC0:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01AC2:  MOVF   41,W
01AC4:  MOVWF  01
01AC6:  MOVF   42,W
01AC8:  MOVWF  02
01ACA:  MOVLB  8
01ACC:  BRA    1AF6
01ACE:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01AD0:  CLRF   03
01AD2:  MOVF   43,W
01AD4:  MOVWF  01
01AD6:  MOVF   03,W
01AD8:  MOVWF  02
01ADA:  MOVLB  8
01ADC:  BRA    1AF6
01ADE:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01AE0:  CLRF   03
01AE2:  MOVF   38,W
01AE4:  MOVWF  01
01AE6:  MOVF   03,W
01AE8:  MOVWF  02
01AEA:  MOVLB  8
01AEC:  BRA    1AF6
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01AEE:  MOVLW  FF
01AF0:  MOVWF  01
01AF2:  MOVWF  02
01AF4:  BRA    1AF6
.................... 	} 
....................  
.................... } 
01AF6:  MOVLB  0
01AF8:  GOTO   1B4A (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
00EEE:  MOVLB  8
00EF0:  MOVF   xD5,W
00EF2:  SUBLW  1F
00EF4:  BNZ   0F0E
00EF6:  MOVF   xD6,W
00EF8:  SUBLW  4E
00EFA:  BNZ   0F0E
00EFC:  MOVF   xD7,W
00EFE:  SUBLW  20
00F00:  BNZ   0F0E
00F02:  MOVF   xD8,W
00F04:  SUBLW  4E
00F06:  BNZ   0F0E
.................... 		return 1; 
00F08:  MOVLW  01
00F0A:  MOVWF  01
00F0C:  BRA    0F6A
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
00F0E:  MOVF   xD6,W
00F10:  SUBLW  02
00F12:  BC    0F32
00F14:  XORLW  FF
00F16:  BNZ   0F1E
00F18:  MOVF   xD5,W
00F1A:  SUBLW  E7
00F1C:  BC    0F32
00F1E:  MOVF   xD8,W
00F20:  SUBLW  03
00F22:  BNC   0F32
00F24:  BNZ   0F2C
00F26:  MOVF   xD7,W
00F28:  SUBLW  F5
00F2A:  BNC   0F32
.................... 		return 1; 
00F2C:  MOVLW  01
00F2E:  MOVWF  01
00F30:  BRA    0F6A
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
00F32:  MOVF   xD6,W
00F34:  SUBLW  06
00F36:  BC    0F56
00F38:  XORLW  FF
00F3A:  BNZ   0F42
00F3C:  MOVF   xD5,W
00F3E:  SUBLW  CF
00F40:  BC    0F56
00F42:  MOVF   xD8,W
00F44:  SUBLW  09
00F46:  BNC   0F56
00F48:  BNZ   0F50
00F4A:  MOVF   xD7,W
00F4C:  SUBLW  D1
00F4E:  BNC   0F56
.................... 		return 1; 
00F50:  MOVLW  01
00F52:  MOVWF  01
00F54:  BRA    0F6A
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
00F56:  MOVF   xD8,F
00F58:  BNZ   0F66
00F5A:  MOVF   xD7,W
00F5C:  SUBLW  34
00F5E:  BNC   0F66
.................... 		return 1; 
00F60:  MOVLW  01
00F62:  MOVWF  01
00F64:  BRA    0F6A
....................  
.................... 	return 0; 
00F66:  MOVLW  00
00F68:  MOVWF  01
.................... } 
00F6A:  MOVLB  0
00F6C:  GOTO   1FB0 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01AFC:  MOVFF  8D4,8DD
01B00:  MOVFF  8D3,8DE
01B04:  CALL   0FAC
.................... 	modbus_serial_putc(register_count*2); 
01B08:  BCF    FD8.0
01B0A:  MOVLB  8
01B0C:  RLCF   xD7,W
01B0E:  MOVWF  xDD
01B10:  RLCF   xD8,W
01B12:  MOVWF  xDE
01B14:  MOVFF  8DD,8DF
01B18:  MOVLB  0
01B1A:  CALL   0F78
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01B1E:  MOVLB  8
01B20:  CLRF   xDA
01B22:  CLRF   xD9
01B24:  MOVF   xDA,W
01B26:  SUBWF  xD8,W
01B28:  BNC   1B74
01B2A:  BNZ   1B32
01B2C:  MOVF   xD7,W
01B2E:  SUBWF  xD9,W
01B30:  BC    1B74
.................... 		l=map_modbus(start_address+i); 
01B32:  MOVF   xD9,W
01B34:  ADDWF  xD5,W
01B36:  MOVWF  xDD
01B38:  MOVF   xDA,W
01B3A:  ADDWFC xD6,W
01B3C:  MOVWF  xDE
01B3E:  MOVWF  xE0
01B40:  MOVFF  8DD,8DF
01B44:  MOVLB  0
01B46:  GOTO   1102
01B4A:  MOVFF  02,8DC
01B4E:  MOVFF  01,8DB
.................... 		modbus_serial_putc(make8(l,1)); 
01B52:  MOVFF  8DC,8DD
01B56:  MOVFF  8DC,8DF
01B5A:  CALL   0F78
....................   		modbus_serial_putc(make8(l,0)); 
01B5E:  MOVFF  8DB,8DD
01B62:  MOVFF  8DB,8DF
01B66:  CALL   0F78
.................... 	} 
01B6A:  MOVLB  8
01B6C:  INCF   xD9,F
01B6E:  BTFSC  FD8.2
01B70:  INCF   xDA,F
01B72:  BRA    1B24
....................  
.................... 	modbus_serial_send_stop(); 
01B74:  MOVLB  0
01B76:  CALL   0FDA
.................... } 
01B7A:  GOTO   1FF2 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01B7E:  MOVLB  8
01B80:  MOVF   xDA,W
01B82:  SUBLW  06
01B84:  BC    1BFC
01B86:  XORLW  FF
01B88:  BNZ   1B90
01B8A:  MOVF   xD9,W
01B8C:  SUBLW  CF
01B8E:  BC    1BFC
01B90:  MOVF   xDA,W
01B92:  SUBLW  09
01B94:  BNC   1BFC
01B96:  BNZ   1B9E
01B98:  MOVF   xD9,W
01B9A:  SUBLW  CF
01B9C:  BNC   1BFC
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01B9E:  MOVF   xDC,W
01BA0:  SUBLW  00
01BA2:  BC    1BB4
01BA4:  XORLW  FF
01BA6:  BNZ   1BAE
01BA8:  MOVF   xDB,W
01BAA:  SUBLW  00
01BAC:  BC    1BB4
01BAE:  MOVLW  03
01BB0:  MOVWF  01
01BB2:  BRA    1DE8
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01BB4:  MOVLW  D0
01BB6:  SUBWF  xD9,W
01BB8:  MOVWF  xDD
01BBA:  MOVLW  07
01BBC:  SUBWFB xDA,W
01BBE:  MOVWF  xDE
01BC0:  MOVLW  02
01BC2:  ADDWF  xDE,F
01BC4:  MOVFF  8DE,FAA
01BC8:  MOVFF  8DD,FA9
01BCC:  MOVFF  8DB,FA8
01BD0:  BCF    FA6.6
01BD2:  BCF    FA6.7
01BD4:  BSF    FA6.2
01BD6:  MOVF   FF2,W
01BD8:  MOVWF  00
01BDA:  BCF    FF2.6
01BDC:  BCF    FF2.7
01BDE:  MOVLB  F
01BE0:  MOVLW  55
01BE2:  MOVWF  FA7
01BE4:  MOVLW  AA
01BE6:  MOVWF  FA7
01BE8:  BSF    FA6.1
01BEA:  BTFSC  FA6.1
01BEC:  BRA    1BEA
01BEE:  BCF    FA6.2
01BF0:  MOVF   00,W
01BF2:  IORWF  FF2,F
.................... 		return 0; 
01BF4:  MOVLW  00
01BF6:  MOVWF  01
01BF8:  MOVLB  8
01BFA:  BRA    1DE8
.................... 	} 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01BFC:  MOVLB  1
01BFE:  MOVF   x8F,F
01C00:  BZ    1C38
.................... 		if ( 1000 == address ) { 
01C02:  MOVLB  8
01C04:  MOVF   xD9,W
01C06:  SUBLW  E8
01C08:  BNZ   1C1C
01C0A:  MOVF   xDA,W
01C0C:  SUBLW  03
01C0E:  BNZ   1C1C
.................... 			config.serial_prefix=value; 
01C10:  MOVFF  8DB,39
.................... 			return 0; 
01C14:  MOVLW  00
01C16:  MOVWF  01
01C18:  BRA    1DE8
.................... 		} else if ( 1001 == address ) { 
01C1A:  BRA    1C36
01C1C:  MOVF   xD9,W
01C1E:  SUBLW  E9
01C20:  BNZ   1C36
01C22:  MOVF   xDA,W
01C24:  SUBLW  03
01C26:  BNZ   1C36
.................... 			config.serial_number=value; 
01C28:  MOVFF  8DC,3B
01C2C:  MOVFF  8DB,3A
.................... 			return 0; 
01C30:  MOVLW  00
01C32:  MOVWF  01
01C34:  BRA    1DE8
01C36:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01C38:  MOVLB  8
01C3A:  MOVF   xD9,W
01C3C:  MOVWF  00
01C3E:  MOVF   xDA,W
01C40:  MOVWF  03
01C42:  MOVLW  03
01C44:  SUBWF  03,W
01C46:  BNZ   1C52
01C48:  MOVLW  EE
01C4A:  SUBWF  00,W
01C4C:  MOVLB  0
01C4E:  BZ    1CEC
01C50:  MOVLB  8
01C52:  MOVLW  03
01C54:  SUBWF  03,W
01C56:  BNZ   1C62
01C58:  MOVLW  EF
01C5A:  SUBWF  00,W
01C5C:  MOVLB  0
01C5E:  BZ    1D04
01C60:  MOVLB  8
01C62:  MOVLW  03
01C64:  SUBWF  03,W
01C66:  BNZ   1C72
01C68:  MOVLW  F0
01C6A:  SUBWF  00,W
01C6C:  MOVLB  0
01C6E:  BZ    1D14
01C70:  MOVLB  8
01C72:  MOVLW  03
01C74:  SUBWF  03,W
01C76:  BNZ   1C82
01C78:  MOVLW  F1
01C7A:  SUBWF  00,W
01C7C:  MOVLB  0
01C7E:  BZ    1D2C
01C80:  MOVLB  8
01C82:  MOVLW  03
01C84:  SUBWF  03,W
01C86:  BNZ   1C92
01C88:  MOVLW  F2
01C8A:  SUBWF  00,W
01C8C:  MOVLB  0
01C8E:  BZ    1D38
01C90:  MOVLB  8
01C92:  MOVLW  03
01C94:  SUBWF  03,W
01C96:  BNZ   1CA2
01C98:  MOVLW  F3
01C9A:  SUBWF  00,W
01C9C:  MOVLB  0
01C9E:  BZ    1D52
01CA0:  MOVLB  8
01CA2:  MOVLW  03
01CA4:  SUBWF  03,W
01CA6:  BNZ   1CB4
01CA8:  MOVLW  F4
01CAA:  SUBWF  00,W
01CAC:  MOVLB  0
01CAE:  BTFSC  FD8.2
01CB0:  BRA    1D6A
01CB2:  MOVLB  8
01CB4:  MOVLW  07
01CB6:  SUBWF  03,W
01CB8:  BNZ   1CC6
01CBA:  MOVLW  CE
01CBC:  SUBWF  00,W
01CBE:  MOVLB  0
01CC0:  BTFSC  FD8.2
01CC2:  BRA    1D82
01CC4:  MOVLB  8
01CC6:  MOVLW  07
01CC8:  SUBWF  03,W
01CCA:  BNZ   1CD8
01CCC:  MOVLW  CF
01CCE:  SUBWF  00,W
01CD0:  MOVLB  0
01CD2:  BTFSC  FD8.2
01CD4:  BRA    1D9C
01CD6:  MOVLB  8
01CD8:  MOVLW  4E
01CDA:  SUBWF  03,W
01CDC:  BNZ   1CEA
01CDE:  MOVLW  1F
01CE0:  SUBWF  00,W
01CE2:  MOVLB  0
01CE4:  BTFSC  FD8.2
01CE6:  BRA    1DB6
01CE8:  MOVLB  8
01CEA:  BRA    1DDE
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01CEC:  MOVLB  8
01CEE:  MOVF   xDC,F
01CF0:  BNZ   1CF8
01CF2:  MOVF   xDB,W
01CF4:  SUBLW  80
01CF6:  BC    1CFE
01CF8:  MOVLW  03
01CFA:  MOVWF  01
01CFC:  BRA    1DE8
.................... 			config.modbus_address=value; 
01CFE:  MOVFF  8DB,36
.................... 			break; 
01D02:  BRA    1DE4
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01D04:  MOVLB  1
01D06:  BSF    xAE.1
.................... 			config.adc_sample_ticks=value; 
01D08:  MOVFF  8DC,3D
01D0C:  MOVFF  8DB,3C
.................... 			break; 
01D10:  MOVLB  8
01D12:  BRA    1DE4
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01D14:  MOVLB  8
01D16:  MOVF   xDC,F
01D18:  BNZ   1D20
01D1A:  MOVF   xDB,W
01D1C:  SUBLW  01
01D1E:  BC    1D26
01D20:  MOVLW  03
01D22:  MOVWF  01
01D24:  BRA    1DE8
.................... 			config.allow_bootload_request=value; 
01D26:  MOVFF  8DB,3E
.................... 			break; 
01D2A:  BRA    1DE4
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01D2C:  MOVFF  8DC,40
01D30:  MOVFF  8DB,3F
.................... 			break; 
01D34:  MOVLB  8
01D36:  BRA    1DE4
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01D38:  MOVLB  8
01D3A:  MOVF   xDB,F
01D3C:  BNZ   1D48
01D3E:  MOVF   xDC,F
01D40:  BNZ   1D48
01D42:  MOVLW  03
01D44:  MOVWF  01
01D46:  BRA    1DE8
.................... 			config.pi_offtime_seconds=value; 
01D48:  MOVFF  8DC,42
01D4C:  MOVFF  8DB,41
.................... 			break; 
01D50:  BRA    1DE4
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01D52:  MOVLB  8
01D54:  MOVF   xDC,F
01D56:  BNZ   1D5E
01D58:  MOVF   xDB,W
01D5A:  SUBLW  01
01D5C:  BC    1D64
01D5E:  MOVLW  03
01D60:  MOVWF  01
01D62:  BRA    1DE8
.................... 			config.power_startup=value; 
01D64:  MOVFF  8DB,43
.................... 			break; 
01D68:  BRA    1DE4
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
01D6A:  MOVLB  8
01D6C:  MOVF   xDC,F
01D6E:  BNZ   1D76
01D70:  MOVF   xDB,W
01D72:  SUBLW  02
01D74:  BC    1D7C
01D76:  MOVLW  03
01D78:  MOVWF  01
01D7A:  BRA    1DE8
.................... 			config.rs485_port_mode=value; 
01D7C:  MOVFF  8DB,38
.................... 			break; 
01D80:  BRA    1DE4
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01D82:  MOVLB  8
01D84:  DECFSZ xDB,W
01D86:  BRA    1D8C
01D88:  MOVF   xDC,F
01D8A:  BZ    1D92
01D8C:  MOVLW  03
01D8E:  MOVWF  01
01D90:  BRA    1DE8
.................... 			write_default_param_file(); 
01D92:  MOVLB  0
01D94:  CALL   0A40
.................... 			break; 
01D98:  MOVLB  8
01D9A:  BRA    1DE4
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01D9C:  MOVLB  8
01D9E:  DECFSZ xDB,W
01DA0:  BRA    1DA6
01DA2:  MOVF   xDC,F
01DA4:  BZ    1DAC
01DA6:  MOVLW  03
01DA8:  MOVWF  01
01DAA:  BRA    1DE8
.................... 			write_param_file(); 
01DAC:  MOVLB  0
01DAE:  CALL   09EC
.................... 			break; 
01DB2:  MOVLB  8
01DB4:  BRA    1DE4
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01DB6:  MOVLB  8
01DB8:  MOVF   xDB,W
01DBA:  SUBLW  0A
01DBC:  BNZ   1DC4
01DBE:  MOVF   xDC,W
01DC0:  SUBLW  07
01DC2:  BZ    1DD0
.................... 				current.factory_unlocked=0; 
01DC4:  MOVLB  1
01DC6:  CLRF   x8F
.................... 				return ILLEGAL_DATA_VALUE; 
01DC8:  MOVLW  03
01DCA:  MOVWF  01
01DCC:  MOVLB  8
01DCE:  BRA    1DE8
.................... 			} 
.................... 			current.factory_unlocked=1; 
01DD0:  MOVLW  01
01DD2:  MOVLB  1
01DD4:  MOVWF  x8F
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01DD6:  MOVLW  C8
01DD8:  MOVWF  xAB
.................... 			break; 
01DDA:  MOVLB  8
01DDC:  BRA    1DE4
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01DDE:  MOVLW  02
01DE0:  MOVWF  01
01DE2:  BRA    1DE8
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01DE4:  MOVLW  00
01DE6:  MOVWF  01
.................... } 
01DE8:  MOVLB  0
01DEA:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
01E7C:  GOTO   0EA8
01E80:  MOVF   01,F
01E82:  BTFSC  FD8.2
01E84:  BRA    2168
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
01E86:  DECFSZ 38,W
01E88:  BRA    1F3C
01E8A:  MOVF   36,W
01E8C:  MOVLB  7
01E8E:  SUBWF  xBB,W
01E90:  BTFSS  FD8.2
01E92:  BRA    1E98
01E94:  MOVLB  0
01E96:  BRA    1F3C
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
01E98:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
01E9A:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
01E9C:  CLRWDT
01E9E:  MOVLW  02
01EA0:  MOVLB  8
01EA2:  MOVWF  xD3
01EA4:  MOVLW  B5
01EA6:  MOVWF  xD4
01EA8:  MOVLB  0
01EAA:  CALL   0ECE
01EAE:  MOVLB  8
01EB0:  DECFSZ xD3,F
01EB2:  BRA    1EA4
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
01EB4:  MOVLB  7
01EB6:  MOVF   xBB,W
01EB8:  MOVLB  0
01EBA:  CALL   067E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
01EBE:  CLRWDT
01EC0:  MOVLW  67
01EC2:  MOVWF  00
01EC4:  DECFSZ 00,F
01EC6:  BRA    1EC4
01EC8:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
01ECA:  MOVLB  7
01ECC:  MOVF   xBD,W
01ECE:  MOVLB  0
01ED0:  CALL   067E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
01ED4:  CLRWDT
01ED6:  MOVLW  67
01ED8:  MOVWF  00
01EDA:  DECFSZ 00,F
01EDC:  BRA    1EDA
01EDE:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
01EE0:  MOVLB  8
01EE2:  CLRF   xD2
01EE4:  MOVLW  02
01EE6:  MOVLB  7
01EE8:  ADDWF  xBC,W
01EEA:  MOVLB  8
01EEC:  SUBWF  xD2,W
01EEE:  BC    1F1C
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
01EF0:  MOVLW  BF
01EF2:  ADDWF  xD2,W
01EF4:  MOVWF  FE9
01EF6:  MOVLW  07
01EF8:  MOVWF  FEA
01EFA:  BTFSC  FD8.0
01EFC:  INCF   FEA,F
01EFE:  MOVFF  FEF,8D3
01F02:  MOVF   xD3,W
01F04:  MOVLB  0
01F06:  CALL   067E
.................... 				delay_us(104); //one stop bit @ 9600 baud 
01F0A:  CLRWDT
01F0C:  MOVLW  67
01F0E:  MOVWF  00
01F10:  DECFSZ 00,F
01F12:  BRA    1F10
01F14:  NOP   
.................... 			} 
01F16:  MOVLB  8
01F18:  INCF   xD2,F
01F1A:  BRA    1EE4
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
01F1C:  BTFSS  F72.1
01F1E:  BRA    1F1C
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
01F20:  CLRWDT
01F22:  MOVLW  02
01F24:  MOVWF  xD3
01F26:  MOVLW  B5
01F28:  MOVWF  xD4
01F2A:  MOVLB  0
01F2C:  CALL   0ECE
01F30:  MOVLB  8
01F32:  DECFSZ xD3,F
01F34:  BRA    1F26
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
01F36:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
01F38:  BCF    F8C.0
01F3A:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
01F3C:  MOVF   36,W
01F3E:  SUBLW  80
01F40:  BZ    1F4E
01F42:  MOVF   36,W
01F44:  MOVLB  7
01F46:  SUBWF  xBB,W
01F48:  BTFSS  FD8.2
01F4A:  BRA    2152
01F4C:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
01F4E:  MOVLB  1
01F50:  INCFSZ x83,W
01F52:  BRA    1F5A
01F54:  INCFSZ x84,W
01F56:  BRA    1F5A
01F58:  BRA    1F60
.................... 				current.modbus_our_packets++; 
01F5A:  INCF   x83,F
01F5C:  BTFSC  FD8.2
01F5E:  INCF   x84,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
01F60:  MOVLW  14
01F62:  MOVWF  xAB
....................  
.................... 			switch(modbus_rx.func) { 
01F64:  MOVLB  7
01F66:  MOVF   xBD,W
01F68:  XORLW  03
01F6A:  MOVLB  0
01F6C:  BZ    1F7E
01F6E:  XORLW  07
01F70:  BZ    1F7E
01F72:  XORLW  02
01F74:  BZ    1FF6
01F76:  XORLW  16
01F78:  BTFSC  FD8.2
01F7A:  BRA    2068
01F7C:  BRA    212A
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01F7E:  MOVFF  7BF,8CE
01F82:  MOVFF  7C0,8CD
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
01F86:  MOVFF  7C1,8D0
01F8A:  MOVFF  7C2,8CF
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
01F8E:  MOVLB  8
01F90:  MOVF   xCF,W
01F92:  ADDWF  xCD,W
01F94:  MOVWF  xD3
01F96:  MOVF   xD0,W
01F98:  ADDWFC xCE,W
01F9A:  MOVWF  xD4
01F9C:  MOVFF  8CE,8D6
01FA0:  MOVFF  8CD,8D5
01FA4:  MOVWF  xD8
01FA6:  MOVFF  8D3,8D7
01FAA:  MOVLB  0
01FAC:  GOTO   0EEE
01FB0:  MOVF   01,F
01FB2:  BNZ   1FD8
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
01FB4:  MOVFF  7BB,8D3
01FB8:  MOVLB  8
01FBA:  CLRF   xD5
01FBC:  MOVFF  7BD,8D4
01FC0:  MOVLW  02
01FC2:  MOVWF  xD6
01FC4:  MOVLB  0
01FC6:  CALL   1008
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
01FCA:  MOVLB  1
01FCC:  CLRF   x88
01FCE:  MOVLW  02
01FD0:  MOVWF  x87
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
01FD2:  CLRF   xAB
.................... 					} else { 
01FD4:  BRA    1FF4
01FD6:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
01FD8:  MOVFF  7BD,8D3
01FDC:  MOVFF  7BB,8D4
01FE0:  MOVFF  8CE,8D6
01FE4:  MOVFF  8CD,8D5
01FE8:  MOVFF  8D0,8D8
01FEC:  MOVFF  8CF,8D7
01FF0:  BRA    1AFC
01FF2:  MOVLB  1
.................... 					} 
.................... 					break; 
01FF4:  BRA    214A
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
01FF6:  MOVFF  7BF,8CE
01FFA:  MOVFF  7C0,8CD
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
01FFE:  MOVFF  7C1,8D4
02002:  MOVFF  7C2,8D3
02006:  MOVFF  8CE,8DA
0200A:  MOVFF  8CD,8D9
0200E:  MOVFF  7C1,8DC
02012:  MOVFF  7C2,8DB
02016:  RCALL  1B7E
02018:  MOVFF  01,8D1
....................  
.................... 					if ( result ) { 
0201C:  MOVLB  8
0201E:  MOVF   xD1,F
02020:  BZ    2044
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02022:  MOVFF  7BB,8D3
02026:  CLRF   xD5
02028:  MOVFF  7BD,8D4
0202C:  MOVFF  8D1,8D6
02030:  MOVLB  0
02032:  CALL   1008
.................... 						current.modbus_last_error=result; 
02036:  MOVLB  1
02038:  CLRF   x88
0203A:  MOVFF  8D1,187
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0203E:  CLRF   xAB
.................... 					}  else { 
02040:  BRA    2066
02042:  MOVLB  8
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02044:  MOVFF  7C1,8D4
02048:  MOVFF  7C2,8D3
0204C:  MOVFF  7BB,8D5
02050:  MOVFF  8CE,8D7
02054:  MOVFF  8CD,8D6
02058:  MOVFF  7C1,8D9
0205C:  MOVFF  7C2,8D8
02060:  MOVLB  0
02062:  BRA    1DEC
02064:  MOVLB  1
.................... 					} 
.................... 					break; 
02066:  BRA    214A
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02068:  MOVFF  7BF,8CE
0206C:  MOVFF  7C0,8CD
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02070:  MOVFF  7C1,8D0
02074:  MOVFF  7C2,8CF
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02078:  MOVLB  8
0207A:  CLRF   xD2
0207C:  MOVF   xD0,F
0207E:  BNZ   2086
02080:  MOVF   xCF,W
02082:  SUBWF  xD2,W
02084:  BC    210A
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02086:  MOVF   xD2,W
02088:  ADDWF  xCD,W
0208A:  MOVWF  xD3
0208C:  MOVLW  00
0208E:  ADDWFC xCE,W
02090:  MOVWF  xD4
02092:  BCF    FD8.0
02094:  RLCF   xD2,W
02096:  ADDLW  05
02098:  ADDLW  BF
0209A:  MOVWF  FE9
0209C:  MOVLW  07
0209E:  MOVWF  FEA
020A0:  BTFSC  FD8.0
020A2:  INCF   FEA,F
020A4:  MOVFF  FEF,8D5
020A8:  BCF    FD8.0
020AA:  RLCF   xD2,W
020AC:  ADDLW  06
020AE:  ADDLW  BF
020B0:  MOVWF  FE9
020B2:  MOVLW  07
020B4:  MOVWF  FEA
020B6:  BTFSC  FD8.0
020B8:  INCF   FEA,F
020BA:  MOVFF  FEF,8D6
020BE:  MOVFF  8D5,8D8
020C2:  MOVFF  8D6,8D7
020C6:  MOVFF  8D4,8DA
020CA:  MOVFF  8D3,8D9
020CE:  MOVFF  8D5,8DC
020D2:  MOVFF  8D6,8DB
020D6:  MOVLB  0
020D8:  RCALL  1B7E
020DA:  MOVFF  01,8D1
....................  
.................... 						if ( result ) { 
020DE:  MOVLB  8
020E0:  MOVF   xD1,F
020E2:  BZ    2106
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
020E4:  MOVFF  7BB,8D3
020E8:  CLRF   xD5
020EA:  MOVFF  7BD,8D4
020EE:  MOVFF  8D1,8D6
020F2:  MOVLB  0
020F4:  CALL   1008
.................... 							current.modbus_last_error=result; 
020F8:  MOVLB  1
020FA:  CLRF   x88
020FC:  MOVFF  8D1,187
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02100:  CLRF   xAB
.................... 			 
.................... 							break; 
02102:  MOVLB  8
02104:  BRA    210A
.................... 						} 
.................... 					} 
02106:  INCF   xD2,F
02108:  BRA    207C
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
0210A:  MOVF   xD1,F
0210C:  BNZ   2126
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
0210E:  MOVFF  7BB,8D3
02112:  MOVFF  8CE,8D5
02116:  MOVFF  8CD,8D4
0211A:  MOVFF  8D0,8D7
0211E:  MOVFF  8CF,8D6
02122:  MOVLB  0
02124:  BRA    1E34
.................... 					} 
....................  
.................... 					break;   
02126:  MOVLB  1
02128:  BRA    214A
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
0212A:  MOVFF  7BB,8D3
0212E:  MOVLB  8
02130:  CLRF   xD5
02132:  MOVFF  7BD,8D4
02136:  MOVLW  01
02138:  MOVWF  xD6
0213A:  MOVLB  0
0213C:  CALL   1008
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02140:  MOVLB  1
02142:  CLRF   x88
02144:  MOVLW  01
02146:  MOVWF  x87
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02148:  CLRF   xAB
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
0214A:  CLRF   x92
0214C:  CLRF   x91
....................  
.................... 		} else { 
0214E:  BRA    2168
02150:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02152:  MOVLB  1
02154:  INCFSZ x85,W
02156:  BRA    215E
02158:  INCFSZ x86,W
0215A:  BRA    215E
0215C:  BRA    2164
.................... 				current.modbus_other_packets++; 
0215E:  INCF   x85,F
02160:  BTFSC  FD8.2
02162:  INCF   x86,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02164:  MOVLW  0A
02166:  MOVWF  xAB
02168:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
0216A:  GOTO   22F4 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003E2:  MOVLB  9
003E4:  BTFSS  xD4.0
003E6:  BRA    0400
003E8:  MOVLB  1
003EA:  INCFSZ x9A,W
003EC:  BRA    03F8
003EE:  INCFSZ x9B,W
003F0:  BRA    03F8
003F2:  MOVLB  9
003F4:  BRA    0400
003F6:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
003F8:  INCF   x9A,F
003FA:  BTFSC  FD8.2
003FC:  INCF   x9B,F
003FE:  MOVLB  9
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00400:  BTFSS  xD4.2
00402:  BRA    041C
00404:  MOVLB  1
00406:  INCFSZ x9C,W
00408:  BRA    0414
0040A:  INCFSZ x9D,W
0040C:  BRA    0414
0040E:  MOVLB  9
00410:  BRA    041C
00412:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00414:  INCF   x9C,F
00416:  BTFSC  FD8.2
00418:  INCF   x9D,F
0041A:  MOVLB  9
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0041C:  BTFSS  xD4.4
0041E:  BRA    0438
00420:  MOVLB  1
00422:  INCFSZ x9E,W
00424:  BRA    0430
00426:  INCFSZ x9F,W
00428:  BRA    0430
0042A:  MOVLB  9
0042C:  BRA    0438
0042E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00430:  INCF   x9E,F
00432:  BTFSC  FD8.2
00434:  INCF   x9F,F
00436:  MOVLB  9
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00438:  BCF    xD4.1
0043A:  BTFSC  F81.0
0043C:  BSF    xD4.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0043E:  BTFSC  xD4.1
00440:  BRA    04C2
00442:  MOVLB  7
00444:  BTFSC  xB7.1
00446:  BRA    044C
00448:  MOVLB  9
0044A:  BRA    04C2
.................... 		current.pulse_count[0]++; 
0044C:  MOVLB  0
0044E:  INCF   x60,F
00450:  BTFSC  FD8.2
00452:  INCF   x61,F
.................... 		current.pulse_sum[0]++; 
00454:  MOVLW  01
00456:  ADDWF  x66,F
00458:  BTFSC  FD8.0
0045A:  INCF   x67,F
0045C:  BTFSC  FD8.2
0045E:  INCF   x68,F
00460:  BTFSC  FD8.2
00462:  INCF   x69,F
.................... 		if ( 1 == ext0_state ) { 
00464:  MOVLB  7
00466:  BTFSS  xB7.2
00468:  BRA    04B0
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0046A:  MOVLB  9
0046C:  BCF    xD4.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0046E:  MOVFF  19B,4F
00472:  MOVFF  19A,4E
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
00476:  MOVF   4F,W
00478:  SUBWF  55,W
0047A:  BNC   048C
0047C:  BNZ   0484
0047E:  MOVF   54,W
00480:  SUBWF  4E,W
00482:  BC    048C
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00484:  MOVFF  4F,55
00488:  MOVFF  4E,54
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0048C:  MOVF   5B,W
0048E:  SUBWF  4F,W
00490:  BNC   04AC
00492:  BNZ   049A
00494:  MOVF   4E,W
00496:  SUBWF  5A,W
00498:  BC    04AC
0049A:  INCFSZ 4E,W
0049C:  BRA    04A4
0049E:  INCFSZ 4F,W
004A0:  BRA    04A4
004A2:  BRA    04AC
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004A4:  MOVFF  4F,5B
004A8:  MOVFF  4E,5A
.................... 			} 
.................... 			ext0_state=0; 
004AC:  MOVLB  7
004AE:  BCF    xB7.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004B0:  BTFSC  xB7.2
004B2:  BRA    04C2
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004B4:  MOVLB  1
004B6:  CLRF   x9B
004B8:  CLRF   x9A
.................... 			ext0_count=1; 
004BA:  MOVLB  9
004BC:  BSF    xD4.0
.................... 			ext0_state=1; 
004BE:  MOVLB  7
004C0:  BSF    xB7.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004C2:  MOVLB  7
004C4:  BCF    xB7.1
004C6:  MOVLB  9
004C8:  BTFSS  xD4.1
004CA:  BRA    04D2
004CC:  MOVLB  7
004CE:  BSF    xB7.1
004D0:  MOVLB  9
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004D2:  BCF    xD4.3
004D4:  BTFSC  F81.1
004D6:  BSF    xD4.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004D8:  BTFSC  xD4.3
004DA:  BRA    055C
004DC:  MOVLB  7
004DE:  BTFSC  xB7.3
004E0:  BRA    04E6
004E2:  MOVLB  9
004E4:  BRA    055C
.................... 		current.pulse_count[1]++; 
004E6:  MOVLB  0
004E8:  INCF   x62,F
004EA:  BTFSC  FD8.2
004EC:  INCF   x63,F
.................... 		current.pulse_sum[1]++; 
004EE:  MOVLW  01
004F0:  ADDWF  x6A,F
004F2:  BTFSC  FD8.0
004F4:  INCF   x6B,F
004F6:  BTFSC  FD8.2
004F8:  INCF   x6C,F
004FA:  BTFSC  FD8.2
004FC:  INCF   x6D,F
.................... 		if ( 1 == ext1_state ) { 
004FE:  MOVLB  7
00500:  BTFSS  xB7.4
00502:  BRA    054A
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00504:  MOVLB  9
00506:  BCF    xD4.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00508:  MOVFF  19D,51
0050C:  MOVFF  19C,50
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00510:  MOVF   51,W
00512:  SUBWF  57,W
00514:  BNC   0526
00516:  BNZ   051E
00518:  MOVF   56,W
0051A:  SUBWF  50,W
0051C:  BC    0526
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0051E:  MOVFF  51,57
00522:  MOVFF  50,56
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00526:  MOVF   5D,W
00528:  SUBWF  51,W
0052A:  BNC   0546
0052C:  BNZ   0534
0052E:  MOVF   50,W
00530:  SUBWF  5C,W
00532:  BC    0546
00534:  INCFSZ 50,W
00536:  BRA    053E
00538:  INCFSZ 51,W
0053A:  BRA    053E
0053C:  BRA    0546
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
0053E:  MOVFF  51,5D
00542:  MOVFF  50,5C
.................... 			} 
.................... 			ext1_state=0; 
00546:  MOVLB  7
00548:  BCF    xB7.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0054A:  BTFSC  xB7.4
0054C:  BRA    055C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
0054E:  MOVLB  1
00550:  CLRF   x9D
00552:  CLRF   x9C
.................... 			ext1_count=1; 
00554:  MOVLB  9
00556:  BSF    xD4.2
.................... 			ext1_state=1; 
00558:  MOVLB  7
0055A:  BSF    xB7.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
0055C:  MOVLB  7
0055E:  BCF    xB7.3
00560:  MOVLB  9
00562:  BTFSS  xD4.3
00564:  BRA    056C
00566:  MOVLB  7
00568:  BSF    xB7.3
0056A:  MOVLB  9
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0056C:  BCF    xD4.5
0056E:  BTFSC  F81.2
00570:  BSF    xD4.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00572:  BTFSC  xD4.5
00574:  BRA    05F6
00576:  MOVLB  7
00578:  BTFSC  xB7.5
0057A:  BRA    0580
0057C:  MOVLB  9
0057E:  BRA    05F6
.................... 		current.pulse_count[2]++; 
00580:  MOVLB  0
00582:  INCF   x64,F
00584:  BTFSC  FD8.2
00586:  INCF   x65,F
.................... 		current.pulse_sum[2]++; 
00588:  MOVLW  01
0058A:  ADDWF  x6E,F
0058C:  BTFSC  FD8.0
0058E:  INCF   x6F,F
00590:  BTFSC  FD8.2
00592:  INCF   x70,F
00594:  BTFSC  FD8.2
00596:  INCF   x71,F
.................... 		if ( 1 == ext2_state ) { 
00598:  MOVLB  7
0059A:  BTFSS  xB7.6
0059C:  BRA    05E4
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0059E:  MOVLB  9
005A0:  BCF    xD4.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005A2:  MOVFF  19F,53
005A6:  MOVFF  19E,52
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005AA:  MOVF   53,W
005AC:  SUBWF  59,W
005AE:  BNC   05C0
005B0:  BNZ   05B8
005B2:  MOVF   58,W
005B4:  SUBWF  52,W
005B6:  BC    05C0
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005B8:  MOVFF  53,59
005BC:  MOVFF  52,58
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005C0:  MOVF   5F,W
005C2:  SUBWF  53,W
005C4:  BNC   05E0
005C6:  BNZ   05CE
005C8:  MOVF   52,W
005CA:  SUBWF  5E,W
005CC:  BC    05E0
005CE:  INCFSZ 52,W
005D0:  BRA    05D8
005D2:  INCFSZ 53,W
005D4:  BRA    05D8
005D6:  BRA    05E0
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005D8:  MOVFF  53,5F
005DC:  MOVFF  52,5E
.................... 			} 
.................... 			ext2_state=0; 
005E0:  MOVLB  7
005E2:  BCF    xB7.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005E4:  BTFSC  xB7.6
005E6:  BRA    05F6
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005E8:  MOVLB  1
005EA:  CLRF   x9F
005EC:  CLRF   x9E
.................... 			ext2_count=1; 
005EE:  MOVLB  9
005F0:  BSF    xD4.4
.................... 			ext2_state=1; 
005F2:  MOVLB  7
005F4:  BSF    xB7.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
005F6:  MOVLB  7
005F8:  BCF    xB7.5
005FA:  MOVLB  9
005FC:  BTFSS  xD4.5
005FE:  BRA    0606
00600:  MOVLB  7
00602:  BSF    xB7.5
00604:  MOVLB  9
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00606:  MOVLB  8
00608:  INCF   xC2,F
.................... 	if ( 10 == tick ) { 
0060A:  MOVF   xC2,W
0060C:  SUBLW  0A
0060E:  BNZ   0618
.................... 		tick=0; 
00610:  CLRF   xC2
.................... 		timers.now_millisecond=1; 
00612:  MOVLB  1
00614:  BSF    xAE.2
00616:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
00618:  BCF    F9E.1
0061A:  MOVLB  0
0061C:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
00638:  BRA    0620
0063A:  MOVFF  01,9D1
....................  
.................... 	if ( RS485_MODE_OFF != config.rs485_port_mode ) { 
0063E:  MOVF   38,F
00640:  BZ    0662
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
00642:  MOVLB  3
00644:  CLRF   xB6
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
00646:  INCFSZ xB5,W
00648:  BRA    064C
0064A:  BRA    0660
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
0064C:  MOVLW  B5
0064E:  ADDWF  xB5,W
00650:  MOVWF  FE9
00652:  MOVLW  02
00654:  MOVWF  FEA
00656:  BTFSC  FD8.0
00658:  INCF   FEA,F
0065A:  MOVFF  9D1,FEF
.................... 			timers.rda2_buff_pos++; 
0065E:  INCF   xB5,F
00660:  MOVLB  0
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00662:  BCF    FA4.5
00664:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
006B2:  RCALL  0668
006B4:  MOVFF  01,9D1
....................  
.................... 	if ( current.bridged_uarts ) { 
006B8:  MOVLB  1
006BA:  BTFSS  x90.0
006BC:  BRA    06C8
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,STREAM_RS485); 
006BE:  MOVLB  9
006C0:  MOVF   xD1,W
006C2:  MOVLB  0
006C4:  RCALL  067E
.................... 		return; 
006C6:  BRA    0722
.................... 	} 
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006C8:  MOVLB  7
006CA:  BTFSC  xB7.0
006CC:  BRA    0724
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
006CE:  MOVF   xB8,F
006D0:  BNZ   06E2
.................... 			modbus_serial_crc.d = 0xFFFF; 
006D2:  SETF   xBA
006D4:  SETF   xB9
.................... 			modbus_rx.address = c; 
006D6:  MOVFF  9D1,7BB
.................... 			modbus_serial_state++; 
006DA:  INCF   xB8,F
.................... 			modbus_rx.len = 0; 
006DC:  CLRF   xBC
.................... 			modbus_rx.error=0; 
006DE:  CLRF   xBE
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
006E0:  BRA    0710
006E2:  DECFSZ xB8,W
006E4:  BRA    06EE
.................... 			modbus_rx.func = c; 
006E6:  MOVFF  9D1,7BD
.................... 			modbus_serial_state++; 
006EA:  INCF   xB8,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
006EC:  BRA    0710
006EE:  MOVF   xB8,W
006F0:  SUBLW  02
006F2:  BNZ   0710
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
006F4:  INCFSZ xBC,W
006F6:  BRA    06FC
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
006F8:  MOVLW  FE
006FA:  MOVWF  xBC
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
006FC:  MOVLW  BF
006FE:  ADDWF  xBC,W
00700:  MOVWF  FE9
00702:  MOVLW  07
00704:  MOVWF  FEA
00706:  BTFSC  FD8.0
00708:  INCF   FEA,F
0070A:  MOVFF  9D1,FEF
.................... 			modbus_rx.len++; 
0070E:  INCF   xBC,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00710:  MOVFF  9D1,9D2
00714:  MOVLB  0
00716:  RCALL  0686
.................... 		modbus_enable_timeout(TRUE); 
00718:  MOVLW  01
0071A:  MOVLB  9
0071C:  MOVWF  xD2
0071E:  MOVLB  0
00720:  RCALL  039C
00722:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
....................  
00724:  BCF    F9E.5
00726:  MOVLB  0
00728:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00764:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00766:  MOVLW  08
00768:  MOVWF  F61
0076A:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
0076C:  MOVLW  00
0076E:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
00770:  MOVLW  FF
00772:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00774:  MOVLW  92
00776:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00778:  MOVLW  80
0077A:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
0077C:  BCF    F96.0
0077E:  BCF    F96.1
00780:  BCF    F96.2
00782:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00784:  MOVLB  1
00786:  CLRF   xAB
.................... 	timers.load_off_seconds=2; 
00788:  CLRF   xAD
0078A:  MOVLW  02
0078C:  MOVWF  xAC
.................... 	timers.now_adc_sample=0; 
0078E:  BCF    xAE.0
.................... 	timers.now_adc_reset_count=0; 
00790:  BCF    xAE.1
.................... 	timers.now_millisecond=0; 
00792:  BCF    xAE.2
.................... 	timers.port_b=0b11111111; 
00794:  SETF   xAF
.................... 	timers.port_c=0b11111111; 
00796:  SETF   xB0
....................  
.................... 	timers.rda_buff_pos=0; 
00798:  MOVLB  2
0079A:  CLRF   xB2
.................... 	timers.rda_buff_gap=255; 
0079C:  SETF   xB3
.................... 	timers.now_parse_rda=0; 
0079E:  MOVLB  1
007A0:  BCF    xB1.0
....................  
.................... 	timers.rda2_buff_pos=0; 
007A2:  MOVLB  3
007A4:  CLRF   xB5
.................... 	timers.rda2_buff_gap=255; 
007A6:  SETF   xB6
.................... 	timers.now_parse_rda2=0; 
007A8:  MOVLB  2
007AA:  BCF    xB4.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
007AC:  MOVLB  8
007AE:  CLRF   xCD
007B0:  MOVF   xCD,W
007B2:  SUBLW  02
007B4:  BNC   0862
.................... 		current.pulse_period[i]=0; 
007B6:  CLRF   03
007B8:  MOVFF  8CD,02
007BC:  BCF    FD8.0
007BE:  RLCF   02,F
007C0:  RLCF   03,F
007C2:  MOVF   02,W
007C4:  ADDLW  4E
007C6:  MOVWF  FE9
007C8:  MOVLW  00
007CA:  ADDWFC 03,W
007CC:  MOVWF  FEA
007CE:  CLRF   FEC
007D0:  MOVF   FED,F
007D2:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
007D4:  CLRF   03
007D6:  MOVFF  8CD,02
007DA:  BCF    FD8.0
007DC:  RLCF   02,F
007DE:  RLCF   03,F
007E0:  MOVF   02,W
007E2:  ADDLW  54
007E4:  MOVWF  FE9
007E6:  MOVLW  00
007E8:  ADDWFC 03,W
007EA:  MOVWF  FEA
007EC:  SETF   FEC
007EE:  MOVF   FED,F
007F0:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
007F2:  CLRF   03
007F4:  MOVFF  8CD,02
007F8:  BCF    FD8.0
007FA:  RLCF   02,F
007FC:  RLCF   03,F
007FE:  MOVF   02,W
00800:  ADDLW  5A
00802:  MOVWF  FE9
00804:  MOVLW  00
00806:  ADDWFC 03,W
00808:  MOVWF  FEA
0080A:  CLRF   FEC
0080C:  MOVF   FED,F
0080E:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00810:  CLRF   03
00812:  MOVFF  8CD,02
00816:  BCF    FD8.0
00818:  RLCF   02,F
0081A:  RLCF   03,F
0081C:  MOVF   02,W
0081E:  ADDLW  60
00820:  MOVWF  FE9
00822:  MOVLW  00
00824:  ADDWFC 03,W
00826:  MOVWF  FEA
00828:  CLRF   FEC
0082A:  MOVF   FED,F
0082C:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
0082E:  CLRF   xE8
00830:  MOVFF  8CD,8E7
00834:  CLRF   xEA
00836:  MOVLW  04
00838:  MOVWF  xE9
0083A:  MOVLB  0
0083C:  RCALL  0742
0083E:  MOVF   01,W
00840:  ADDLW  66
00842:  MOVWF  FE9
00844:  MOVLW  00
00846:  ADDWFC 02,W
00848:  MOVWF  FEA
0084A:  MOVF   FEE,F
0084C:  MOVF   FEE,F
0084E:  CLRF   FEC
00850:  MOVF   FED,F
00852:  CLRF   FEF
00854:  MOVF   FED,F
00856:  CLRF   FEF
00858:  MOVF   FED,F
0085A:  CLRF   FEF
.................... 	} 
0085C:  MOVLB  8
0085E:  INCF   xCD,F
00860:  BRA    07B0
....................  
.................... 	current.modbus_our_packets=0; 
00862:  MOVLB  1
00864:  CLRF   x84
00866:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
00868:  CLRF   x86
0086A:  CLRF   x85
.................... 	current.modbus_last_error=0; 
0086C:  CLRF   x88
0086E:  CLRF   x87
.................... 	current.sequence_number=0; 
00870:  CLRF   x8A
00872:  CLRF   x89
.................... 	current.uptime_minutes=0; 
00874:  CLRF   x8C
00876:  CLRF   x8B
.................... 	current.interval_milliseconds=0; 
00878:  CLRF   x8E
0087A:  CLRF   x8D
.................... 	current.adc_buffer_index=0; 
0087C:  CLRF   x82
.................... 	current.factory_unlocked=0; 
0087E:  CLRF   x8F
.................... 	current.bridged_uarts=0; 
00880:  BCF    x90.0
.................... 	current.watchdog_seconds=0; 
00882:  CLRF   x92
00884:  CLRF   x91
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00886:  MOVFF  4B,195
0088A:  MOVFF  4A,194
.................... 	current.power_off_delay=config.power_off_below_delay; 
0088E:  MOVFF  47,197
00892:  MOVFF  46,196
.................... 	current.power_override_timeout=0; 
00896:  CLRF   x99
00898:  CLRF   x98
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
0089A:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
0089C:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
0089E:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
008A0:  MOVLW  00
008A2:  IORLW  05
008A4:  MOVWF  FBA
008A6:  MOVLW  4A
008A8:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
008AA:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
008AC:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
008AE:  MOVLB  0
008B0:  GOTO   2276 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00D12:  MOVLB  1
00D14:  BCF    xAE.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00D16:  BCF    FD8.0
00D18:  MOVLB  8
00D1A:  RLCF   xC8,W
00D1C:  MOVWF  xCD
00D1E:  RLCF   xC9,W
00D20:  MOVWF  xCE
00D22:  MOVLW  00
00D24:  MOVLB  1
00D26:  BTFSS  xB0.5
00D28:  MOVLW  01
00D2A:  MOVLB  8
00D2C:  IORWF  xCD,F
00D2E:  MOVFF  8CD,8C8
00D32:  MOVF   xCE,W
00D34:  IORLW  E0
00D36:  MOVWF  xC9
.................... 	if ( b2_state==0xf000) { 
00D38:  MOVF   xC8,F
00D3A:  BNZ   0D42
00D3C:  MOVF   xC9,W
00D3E:  SUBLW  F0
00D40:  BNZ   0D42
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00D42:  MOVLB  1
00D44:  INCFSZ x9A,W
00D46:  BRA    0D50
00D48:  INCFSZ x9B,W
00D4A:  BRA    0D50
.................... 				current.pulse_period[0]=0; 
00D4C:  CLRF   4F
00D4E:  CLRF   4E
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00D50:  INCFSZ x9C,W
00D52:  BRA    0D5C
00D54:  INCFSZ x9D,W
00D56:  BRA    0D5C
.................... 				current.pulse_period[1]=0; 
00D58:  CLRF   51
00D5A:  CLRF   50
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00D5C:  INCFSZ x9E,W
00D5E:  BRA    0D68
00D60:  INCFSZ x9F,W
00D62:  BRA    0D68
.................... 				current.pulse_period[2]=0; 
00D64:  CLRF   53
00D66:  CLRF   52
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00D68:  MOVFF  F81,1AF
.................... 	timers.port_c=port_c; 
00D6C:  MOVFF  F82,1B0
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00D70:  BTFSS  x90.0
00D72:  BRA    0D78
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00D74:  BSF    F89.3
.................... 	} else { 
00D76:  BRA    0D84
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00D78:  MOVF   xAB,F
00D7A:  BNZ   0D80
.................... 			output_low(LED_GREEN); 
00D7C:  BCF    F89.3
.................... 		} else { 
00D7E:  BRA    0D84
.................... 			output_high(LED_GREEN); 
00D80:  BSF    F89.3
.................... 			timers.led_on_green--; 
00D82:  DECF   xAB,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00D84:  INCFSZ x8D,W
00D86:  BRA    0D8E
00D88:  INCFSZ x8E,W
00D8A:  BRA    0D8E
00D8C:  BRA    0D94
.................... 		current.interval_milliseconds++; 
00D8E:  INCF   x8D,F
00D90:  BTFSC  FD8.2
00D92:  INCF   x8E,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00D94:  MOVLB  8
00D96:  INCF   xC6,F
00D98:  BTFSC  FD8.2
00D9A:  INCF   xC7,F
.................... 	if ( 1000 == ticks ) { 
00D9C:  MOVF   xC6,W
00D9E:  SUBLW  E8
00DA0:  BNZ   0E26
00DA2:  MOVF   xC7,W
00DA4:  SUBLW  03
00DA6:  BNZ   0E26
.................... 		ticks=0; 
00DA8:  CLRF   xC7
00DAA:  CLRF   xC6
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00DAC:  MOVLB  1
00DAE:  INCFSZ x91,W
00DB0:  BRA    0DB8
00DB2:  INCFSZ x92,W
00DB4:  BRA    0DB8
00DB6:  BRA    0DBE
.................... 			current.watchdog_seconds++; 
00DB8:  INCF   x91,F
00DBA:  BTFSC  FD8.2
00DBC:  INCF   x92,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00DBE:  MOVF   3F,F
00DC0:  BNZ   0DC6
00DC2:  MOVF   40,F
00DC4:  BZ    0DE4
00DC6:  MOVF   40,W
00DC8:  SUBWF  x92,W
00DCA:  BNC   0DE4
00DCC:  BNZ   0DD4
00DCE:  MOVF   x91,W
00DD0:  SUBWF  3F,W
00DD2:  BC    0DE4
00DD4:  MOVF   xAC,F
00DD6:  BNZ   0DE4
00DD8:  MOVF   xAD,F
00DDA:  BNZ   0DE4
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00DDC:  MOVFF  42,1AD
00DE0:  MOVFF  41,1AC
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00DE4:  MOVF   xAC,F
00DE6:  BNZ   0DF0
00DE8:  MOVF   xAD,F
00DEA:  BNZ   0DF0
.................... 			output_high(PI_POWER_EN); 
00DEC:  BSF    F8B.0
.................... 		} else { 
00DEE:  BRA    0E06
.................... 			output_low(PI_POWER_EN); 
00DF0:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00DF2:  MOVF   xAC,W
00DF4:  BTFSC  FD8.2
00DF6:  DECF   xAD,F
00DF8:  DECF   xAC,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00DFA:  MOVF   xAC,F
00DFC:  BNZ   0E06
00DFE:  MOVF   xAD,F
00E00:  BNZ   0E06
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00E02:  CLRF   x92
00E04:  CLRF   x91
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00E06:  MOVLB  8
00E08:  INCF   xC3,F
.................... 		if ( 60 == uptimeTicks ) { 
00E0A:  MOVF   xC3,W
00E0C:  SUBLW  3C
00E0E:  BNZ   0E26
.................... 			uptimeTicks=0; 
00E10:  CLRF   xC3
.................... 			if ( current.uptime_minutes < 65535 )  
00E12:  MOVLB  1
00E14:  INCFSZ x8B,W
00E16:  BRA    0E1E
00E18:  INCFSZ x8C,W
00E1A:  BRA    0E1E
00E1C:  BRA    0E24
.................... 				current.uptime_minutes++; 
00E1E:  INCF   x8B,F
00E20:  BTFSC  FD8.2
00E22:  INCF   x8C,F
00E24:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
00E26:  INCFSZ xCA,W
00E28:  BRA    0E3C
00E2A:  INCFSZ xCB,W
00E2C:  BRA    0E3C
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
00E2E:  CLRF   xE1
00E30:  MOVLB  0
00E32:  RCALL  0C8A
00E34:  MOVFF  02,8CB
00E38:  MOVFF  01,8CA
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
00E3C:  MOVLB  1
00E3E:  BTFSS  xAE.1
00E40:  BRA    0E4A
.................... 		timers.now_adc_reset_count=0; 
00E42:  BCF    xAE.1
.................... 		adcTicks=0; 
00E44:  MOVLB  8
00E46:  CLRF   xC5
00E48:  CLRF   xC4
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
00E4A:  MOVLB  8
00E4C:  INCF   xC4,F
00E4E:  BTFSC  FD8.2
00E50:  INCF   xC5,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
00E52:  MOVF   3C,W
00E54:  SUBWF  xC4,W
00E56:  BNZ   0E6C
00E58:  MOVF   3D,W
00E5A:  SUBWF  xC5,W
00E5C:  BNZ   0E6C
.................... 		adcTicks=0; 
00E5E:  CLRF   xC5
00E60:  CLRF   xC4
.................... 		timers.now_adc_sample=1; 
00E62:  MOVLB  1
00E64:  BSF    xAE.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
00E66:  MOVLB  8
00E68:  SETF   xCB
00E6A:  SETF   xCA
.................... 	} 
....................  
.................... 	/* for xbee */		 
.................... 	if ( timers.rda_buff_gap < 255 ) { 
00E6C:  MOVLB  2
00E6E:  INCFSZ xB3,W
00E70:  BRA    0E74
00E72:  BRA    0E76
.................... 		timers.rda_buff_gap++; 
00E74:  INCF   xB3,F
.................... 	} 
.................... 	/* for bluetooth */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
00E76:  MOVLB  3
00E78:  INCFSZ xB6,W
00E7A:  BRA    0E7E
00E7C:  BRA    0E80
.................... 		timers.rda2_buff_gap++; 
00E7E:  INCF   xB6,F
.................... 	} 
....................  
.................... 	/* xbee: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda_buff_gap >= 10 && timers.rda_buff_pos>0 ) { 
00E80:  MOVLB  2
00E82:  MOVF   xB3,W
00E84:  SUBLW  09
00E86:  BC    0E90
00E88:  MOVF   xB2,F
00E8A:  BZ    0E90
.................... 		timers.now_parse_rda=1;	 
00E8C:  MOVLB  1
00E8E:  BSF    xB1.0
.................... 	} 
.................... 	/* bluetooth: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
00E90:  MOVLB  3
00E92:  MOVF   xB6,W
00E94:  SUBLW  09
00E96:  BC    0EA2
00E98:  MOVF   xB5,F
00E9A:  BZ    0EA2
.................... 		timers.now_parse_rda2=1;	 
00E9C:  MOVLB  2
00E9E:  BSF    xB4.0
00EA0:  MOVLB  3
.................... 	} 
.................... } 
00EA2:  MOVLB  0
00EA4:  GOTO   22E2 (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
0216E:  MOVFF  3B5,9CD
.................... 	timers.rda2_buff_pos=255; /* stop getting more data for a second */ 
02172:  MOVLB  3
02174:  SETF   xB5
.................... 	memcpy(buff,timers.rda2_buff,length); 
02176:  MOVLW  08
02178:  MOVWF  FEA
0217A:  MOVLW  CD
0217C:  MOVWF  FE9
0217E:  MOVLW  02
02180:  MOVWF  FE2
02182:  MOVLW  B5
02184:  MOVWF  FE1
02186:  MOVLB  9
02188:  MOVF   xCD,W
0218A:  MOVWF  01
0218C:  BZ    2196
0218E:  MOVFF  FE6,FEE
02192:  DECFSZ 01,F
02194:  BRA    218E
.................... 	timers.rda2_buff_gap=0; 
02196:  MOVLB  3
02198:  CLRF   xB6
.................... 	timers.rda2_buff_pos=0; 
0219A:  CLRF   xB5
....................  
.................... 	/* transmit back out to the PI */ 
.................... 	for ( l=0 ; l<length ; l++ ) { 
0219C:  MOVLB  9
0219E:  CLRF   xCF
021A0:  CLRF   xCE
021A2:  MOVF   xCF,F
021A4:  BNZ   21CE
021A6:  MOVF   xCD,W
021A8:  SUBWF  xCE,W
021AA:  BC    21CE
.................... 		fputc(buff[l],STREAM_PI); 
021AC:  MOVLW  CD
021AE:  ADDWF  xCE,W
021B0:  MOVWF  FE9
021B2:  MOVLW  08
021B4:  ADDWFC xCF,W
021B6:  MOVWF  FEA
021B8:  MOVFF  FEF,9D0
021BC:  MOVF   xD0,W
021BE:  MOVLB  0
021C0:  CALL   0F70
.................... 	} 
021C4:  MOVLB  9
021C6:  INCF   xCE,F
021C8:  BTFSC  FD8.2
021CA:  INCF   xCF,F
021CC:  BRA    21A2
.................... } 
021CE:  MOVLB  0
021D0:  GOTO   2300 (RETURN)
....................  
....................  
.................... void main(void) { 
021D4:  CLRF   FF8
021D6:  BCF    FF1.2
021D8:  BSF    F9F.1
021DA:  BCF    F9F.5
021DC:  BCF    FA5.5
021DE:  BSF    FD0.7
021E0:  BSF    07.7
021E2:  CLRF   FEA
021E4:  CLRF   FE9
021E6:  CLRF   35
021E8:  BCF    FB8.3
021EA:  MOVLW  0C
021EC:  MOVWF  FAF
021EE:  MOVLW  A6
021F0:  MOVWF  FAC
021F2:  MOVLW  90
021F4:  MOVWF  FAB
021F6:  BCF    F70.3
021F8:  MOVLW  4D
021FA:  MOVWF  F75
021FC:  MOVLW  A6
021FE:  MOVWF  F72
02200:  MOVLW  90
02202:  MOVWF  F71
02204:  MOVLB  7
02206:  BCF    xB7.0
02208:  CLRF   xB8
0220A:  MOVLB  8
0220C:  CLRF   xC2
0220E:  MOVLB  7
02210:  BCF    xB7.1
02212:  BCF    xB7.2
02214:  BCF    xB7.3
02216:  BCF    xB7.4
02218:  BCF    xB7.5
0221A:  BCF    xB7.6
0221C:  MOVLB  8
0221E:  CLRF   xC3
02220:  CLRF   xC5
02222:  CLRF   xC4
02224:  CLRF   xC7
02226:  CLRF   xC6
02228:  CLRF   xC9
0222A:  CLRF   xC8
0222C:  MOVF   FC1,W
0222E:  ANDLW  F0
02230:  MOVWF  FC1
02232:  MOVLW  00
02234:  MOVLB  F
02236:  MOVWF  x38
02238:  MOVWF  x3C
0223A:  MOVWF  x39
0223C:  MOVWF  x3A
0223E:  MOVWF  x3B
02240:  MOVLB  1
02242:  CLRF   x88
02244:  CLRF   F77
02246:  CLRF   F78
02248:  CLRF   F79
0224A:  CLRF   2F
0224C:  CLRF   30
0224E:  MOVLB  8
02250:  CLRF   xBE
02252:  CLRF   xBF
02254:  CLRF   xC0
02256:  CLRF   xC1
02258:  CLRF   xCA
0225A:  CLRF   xCB
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
0225C:  MOVF   FD0,W
0225E:  ANDLW  0F
02260:  BTFSS  FD0.4
02262:  MOVLW  00
02264:  BSF    FD0.0
02266:  BSF    FD0.1
02268:  BSF    FD0.4
0226A:  BSF    FD8.3
0226C:  BSF    FD8.4
0226E:  MOVWF  xCC
....................  
.................... 	init(); 
02270:  MOVLB  0
02272:  GOTO   0764
....................  
....................  
.................... #if 0 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
.................... 	output_high(RS485_NRE); 
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
....................  
.................... 	switch ( i ) { 
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02276:  GOTO   0A78
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
0227A:  MOVF   36,W
0227C:  SUBLW  80
0227E:  BC    2284
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02280:  CALL   0A40
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02284:  BSF    FAB.7
02286:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02288:  GOTO   0AD6
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
0228C:  MOVLB  8
0228E:  CLRF   xCC
02290:  MOVF   xCC,W
02292:  SUBLW  1D
02294:  BNC   22A2
.................... 		adc_update(); 
02296:  MOVLB  0
02298:  CALL   0B94
.................... 	} 
0229C:  MOVLB  8
0229E:  INCF   xCC,F
022A0:  BRA    2290
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
022A2:  MOVFF  43,193
....................  
....................  
.................... #if 0 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
.................... 	output_low(RS485_DE); 
.................... 	output_low(RS485_NRE); 
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
022A6:  MOVLW  2C
022A8:  MOVWF  FF6
022AA:  MOVLW  07
022AC:  MOVWF  FF7
022AE:  MOVLW  07
022B0:  MOVWF  xCD
022B2:  MOVLB  0
022B4:  GOTO   0C3A
022B8:  MOVLW  38
022BA:  MOVWF  FF6
022BC:  MOVLW  07
022BE:  MOVWF  FF7
022C0:  GOTO   0C66
022C4:  MOVLW  0D
022C6:  BTFSS  F9E.4
022C8:  BRA    22C6
022CA:  MOVWF  FAD
022CC:  MOVLW  0A
022CE:  BTFSS  F9E.4
022D0:  BRA    22CE
022D2:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
022D4:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(STREAM_RS485) ) { 
.................... 				fputc(fgetc(STREAM_RS485),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
022D6:  MOVLB  1
022D8:  BTFSS  xAE.2
022DA:  BRA    22E4
.................... 			periodic_millisecond(); 
022DC:  MOVLB  0
022DE:  GOTO   0D12
022E2:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
022E4:  BTFSS  xAE.0
022E6:  BRA    22F0
.................... 			timers.now_adc_sample=0; 
022E8:  BCF    xAE.0
.................... 			adc_update(); 
022EA:  MOVLB  0
022EC:  CALL   0B94
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
022F0:  MOVLB  0
022F2:  BRA    1E7C
.................... //		} 
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
022F4:  MOVLB  2
022F6:  BTFSS  xB4.0
022F8:  BRA    2302
.................... 			timers.now_parse_rda2=0; 
022FA:  BCF    xB4.0
.................... 			rs485_to_host(); 
022FC:  MOVLB  0
022FE:  BRA    216E
02300:  MOVLB  2
.................... 		} 
....................  
.................... 	} 
02302:  MOVLB  0
02304:  BRA    22D4
.................... } 
02306:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
