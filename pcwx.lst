CCS PCH C Compiler, Version 4.135, 4375               23-Nov-15 11:08

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 11052 bytes (17%)
                         Largest free fragment is 54480
               RAM used: 2005 (51%) at main() level
                         2280 (59%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   28F6
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   0410
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0738
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   069E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0442
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02736:  MOVLB  8
02738:  MOVF   xDF,F
0273A:  BNZ   2740
0273C:  MOVF   xE0,F
0273E:  BZ    27C4
....................       if (*s1 != *s2) 
02740:  MOVFF  8DB,FE9
02744:  MOVFF  8DC,FEA
02748:  MOVFF  FEF,8E1
0274C:  MOVFF  8DE,03
02750:  MOVFF  8DD,FE9
02754:  MOVFF  8DE,FEA
02758:  MOVF   FEF,W
0275A:  SUBWF  xE1,W
0275C:  BZ    278C
....................          return((*s1 <*s2) ? -1: 1); 
0275E:  MOVFF  8DC,03
02762:  MOVFF  8DB,FE9
02766:  MOVFF  8DC,FEA
0276A:  MOVFF  FEF,8E1
0276E:  MOVFF  8DE,03
02772:  MOVFF  8DD,FE9
02776:  MOVFF  8DE,FEA
0277A:  MOVF   FEF,W
0277C:  SUBWF  xE1,W
0277E:  BC    2784
02780:  MOVLW  FF
02782:  BRA    2786
02784:  MOVLW  01
02786:  MOVWF  01
02788:  BRA    27C8
....................       else if (*s1 == '\0') 
0278A:  BRA    27A2
0278C:  MOVFF  8DC,03
02790:  MOVFF  8DB,FE9
02794:  MOVFF  8DC,FEA
02798:  MOVF   FEF,F
0279A:  BNZ   27A2
....................          return(0); 
0279C:  MOVLW  00
0279E:  MOVWF  01
027A0:  BRA    27C8
027A2:  MOVFF  8DC,03
027A6:  MOVF   xDB,W
027A8:  INCF   xDB,F
027AA:  BTFSC  FD8.2
027AC:  INCF   xDC,F
027AE:  MOVFF  8DE,03
027B2:  MOVF   xDD,W
027B4:  INCF   xDD,F
027B6:  BTFSC  FD8.2
027B8:  INCF   xDE,F
027BA:  MOVF   xDF,W
027BC:  BTFSC  FD8.2
027BE:  DECF   xE0,F
027C0:  DECF   xDF,F
027C2:  BRA    2738
....................    return(0); 
027C4:  MOVLW  00
027C6:  MOVWF  01
.................... } 
027C8:  MOVLB  0
027CA:  GOTO   289E (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
0116E:  MOVLW  05
01170:  MOVLB  7
01172:  SUBWF  xDC,F
01174:  BNC   118A
01176:  MOVLW  07
01178:  MOVWF  FEA
0117A:  MOVLW  DC
0117C:  MOVWF  FE9
0117E:  MOVF   FEF,W
01180:  BZ    118A
01182:  BRA    1186
01184:  CLRWDT
01186:  DECFSZ FEF,F
01188:  BRA    1184
0118A:  MOVLB  0
0118C:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
006F6:  BTFSS  F9E.5
006F8:  BRA    06F6
006FA:  MOVFF  FAB,35
006FE:  MOVFF  FAE,01
00702:  BTFSS  35.1
00704:  BRA    070A
00706:  BCF    FAB.4
00708:  BSF    FAB.4
0070A:  RETURN 0
*
01284:  BTFSS  F9E.4
01286:  BRA    1284
01288:  MOVWF  FAD
0128A:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00686:  BTFSS  FA4.5
00688:  BRA    0686
0068A:  MOVFF  F71,35
0068E:  MOVFF  F74,01
00692:  BTFSS  35.1
00694:  BRA    069A
00696:  BCF    F71.4
00698:  BSF    F71.4
0069A:  GOTO   06A0 (RETURN)
*
0118E:  BTFSS  FA4.4
01190:  BRA    118E
01192:  MOVWF  F73
01194:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00E3A:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00D9A:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00D9C:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00D9E:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00DA0:  MOVLB  7
00DA2:  MOVF   xD8,F
00DA4:  BNZ   0DAC
.................... 		c=0b00011; 
00DA6:  MOVLW  03
00DA8:  MOVWF  xDC
.................... 	else if ( 1 == ch )  
00DAA:  BRA    0DF6
00DAC:  DECFSZ xD8,W
00DAE:  BRA    0DB6
.................... 		c=0b10011; 
00DB0:  MOVLW  13
00DB2:  MOVWF  xDC
.................... 	else if ( 2 == ch )  
00DB4:  BRA    0DF6
00DB6:  MOVF   xD8,W
00DB8:  SUBLW  02
00DBA:  BNZ   0DC2
.................... 		c=0b01011; 
00DBC:  MOVLW  0B
00DBE:  MOVWF  xDC
.................... 	else if ( 3 == ch )  
00DC0:  BRA    0DF6
00DC2:  MOVF   xD8,W
00DC4:  SUBLW  03
00DC6:  BNZ   0DCE
.................... 		c=0b11011; 
00DC8:  MOVLW  1B
00DCA:  MOVWF  xDC
.................... 	else if ( 4 == ch ) 
00DCC:  BRA    0DF6
00DCE:  MOVF   xD8,W
00DD0:  SUBLW  04
00DD2:  BNZ   0DDA
.................... 		c=0b00111; 
00DD4:  MOVLW  07
00DD6:  MOVWF  xDC
.................... 	else if ( 5 == ch )  
00DD8:  BRA    0DF6
00DDA:  MOVF   xD8,W
00DDC:  SUBLW  05
00DDE:  BNZ   0DE6
.................... 		c=0b10111; 
00DE0:  MOVLW  17
00DE2:  MOVWF  xDC
.................... 	else if ( 6 == ch ) 
00DE4:  BRA    0DF6
00DE6:  MOVF   xD8,W
00DE8:  SUBLW  06
00DEA:  BNZ   0DF2
.................... 		c=0b01111; 
00DEC:  MOVLW  0F
00DEE:  MOVWF  xDC
.................... 	else 
00DF0:  BRA    0DF6
.................... 		c=0b11111; 
00DF2:  MOVLW  1F
00DF4:  MOVWF  xDC
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00DF6:  CLRF   xDB
00DF8:  MOVF   xDB,W
00DFA:  SUBLW  04
00DFC:  BNC   0E14
.................... 		output_low(MCP3208_CLK); 
00DFE:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00E00:  BTFSC  xDC.0
00E02:  BRA    0E08
00E04:  BCF    F8B.5
00E06:  BRA    0E0A
00E08:  BSF    F8B.5
.................... 		c=c>>1; 
00E0A:  BCF    FD8.0
00E0C:  RRCF   xDC,F
.................... 		output_high(MCP3208_CLK); 
00E0E:  BSF    F8B.3
.................... 	} 
00E10:  INCF   xDB,F
00E12:  BRA    0DF8
....................  
....................  
.................... 	value=0; 
00E14:  CLRF   xDA
00E16:  CLRF   xD9
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00E18:  CLRF   xDB
00E1A:  MOVF   xDB,W
00E1C:  SUBLW  0D
00E1E:  BNC   0E36
.................... 		output_low(MCP3208_CLK); 
00E20:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00E22:  BTFSC  F82.4
00E24:  BRA    0E2A
00E26:  BCF    FD8.0
00E28:  BRA    0E2C
00E2A:  BSF    FD8.0
00E2C:  RLCF   xD9,F
00E2E:  RLCF   xDA,F
.................... 		output_high(MCP3208_CLK); 
00E30:  BSF    F8B.3
.................... 	} 
00E32:  INCF   xDB,F
00E34:  BRA    0E1A
....................  
.................... 	bit_clear(value,13); 
00E36:  BCF    xDA.5
.................... 	bit_clear(value,12); 
00E38:  BCF    xDA.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00E3C:  MOVFF  7D9,01
00E40:  MOVFF  7DA,02
.................... } 
00E44:  MOVLB  0
00E46:  GOTO   0EB8 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00F42:  MOVLB  8
00F44:  CLRF   xDA
00F46:  MOVFF  7ED,8D9
00F4A:  CLRF   xDC
00F4C:  MOVLW  20
00F4E:  MOVWF  xDB
00F50:  MOVLB  0
00F52:  RCALL  0868
00F54:  MOVFF  02,03
00F58:  MOVF   01,W
00F5A:  ADDLW  CA
00F5C:  MOVWF  01
00F5E:  MOVLW  00
00F60:  ADDWFC 03,F
00F62:  MOVFF  01,7F1
00F66:  MOVLB  7
00F68:  MOVFF  03,7F2
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00F6C:  CLRF   xEF
00F6E:  CLRF   xEE
.................... 	for( i = 0; i < 16 ; i++ ) { 
00F70:  CLRF   xF0
00F72:  MOVF   xF0,W
00F74:  SUBLW  0F
00F76:  BNC   0F9A
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00F78:  BCF    FD8.0
00F7A:  RLCF   xF0,W
00F7C:  CLRF   03
00F7E:  ADDWF  xF1,W
00F80:  MOVWF  FE9
00F82:  MOVF   xF2,W
00F84:  ADDWFC 03,W
00F86:  MOVWF  FEA
00F88:  MOVFF  FEC,03
00F8C:  MOVF   FED,F
00F8E:  MOVF   FEF,W
00F90:  ADDWF  xEE,F
00F92:  MOVF   03,W
00F94:  ADDWFC xEF,F
.................... 	} 
00F96:  INCF   xF0,F
00F98:  BRA    0F72
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00F9A:  MOVLW  08
00F9C:  ADDWF  xEE,W
00F9E:  MOVWF  xF3
00FA0:  MOVLW  00
00FA2:  ADDWFC xEF,W
00FA4:  MOVWF  xF4
00FA6:  RRCF   xF4,W
00FA8:  MOVWF  03
00FAA:  RRCF   xF3,W
00FAC:  MOVWF  02
00FAE:  RRCF   03,F
00FB0:  RRCF   02,F
00FB2:  RRCF   03,F
00FB4:  RRCF   02,F
00FB6:  RRCF   03,F
00FB8:  RRCF   02,F
00FBA:  MOVLW  0F
00FBC:  ANDWF  03,F
00FBE:  MOVFF  02,01
00FC2:  MOVFF  03,02
.................... } 
00FC6:  MOVLB  0
00FC8:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00E4A:  MOVLB  1
00E4C:  INCF   xCA,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00E4E:  MOVF   xCA,W
00E50:  SUBLW  0F
00E52:  BC    0E56
.................... 		current.adc_buffer_index=0; 
00E54:  CLRF   xCA
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00E56:  MOVLB  7
00E58:  CLRF   xD5
00E5A:  MOVF   xD5,W
00E5C:  SUBLW  07
00E5E:  BNC   0EEE
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00E60:  MOVLB  8
00E62:  CLRF   xDA
00E64:  MOVFF  7D5,8D9
00E68:  CLRF   xDC
00E6A:  MOVLW  20
00E6C:  MOVWF  xDB
00E6E:  MOVLB  0
00E70:  RCALL  0868
00E72:  MOVFF  02,03
00E76:  MOVF   01,W
00E78:  ADDLW  34
00E7A:  MOVLB  7
00E7C:  MOVWF  xD6
00E7E:  MOVLW  00
00E80:  ADDWFC 02,W
00E82:  MOVWF  xD7
00E84:  CLRF   03
00E86:  MOVLB  1
00E88:  MOVFF  1CA,02
00E8C:  BCF    FD8.0
00E8E:  RLCF   02,F
00E90:  RLCF   03,F
00E92:  MOVF   02,W
00E94:  MOVLB  7
00E96:  ADDWF  xD6,W
00E98:  MOVWF  01
00E9A:  MOVF   xD7,W
00E9C:  ADDWFC 03,F
00E9E:  MOVF   01,W
00EA0:  ADDLW  96
00EA2:  MOVWF  01
00EA4:  MOVLW  00
00EA6:  ADDWFC 03,F
00EA8:  MOVFF  01,7D6
00EAC:  MOVFF  03,7D7
00EB0:  MOVFF  7D5,7D8
00EB4:  MOVLB  0
00EB6:  BRA    0D9A
00EB8:  MOVFF  7D7,FEA
00EBC:  MOVFF  7D6,FE9
00EC0:  MOVFF  02,FEC
00EC4:  MOVF   FED,F
00EC6:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00ECA:  CLRF   03
00ECC:  MOVLB  7
00ECE:  MOVFF  7D5,02
00ED2:  BCF    FD8.0
00ED4:  RLCF   02,F
00ED6:  RLCF   03,F
00ED8:  MOVF   02,W
00EDA:  ADDLW  BA
00EDC:  MOVWF  FE9
00EDE:  MOVLW  00
00EE0:  ADDWFC 03,W
00EE2:  MOVWF  FEA
00EE4:  CLRF   FEC
00EE6:  MOVF   FED,F
00EE8:  CLRF   FEF
....................  
.................... 	} 
00EEA:  INCF   xD5,F
00EEC:  BRA    0E5A
.................... } 
00EEE:  MOVLB  0
00EF0:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00B70:  MOVF   xF2,W
00B72:  XORWF  xF3,W
00B74:  MOVWF  01
*
00BC2:  MOVF   xF2,W
00BC4:  XORWF  xF3,W
00BC6:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00AFA:  MOVLB  7
00AFC:  CLRF   xDE
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00AFE:  MOVFF  7DD,03
00B02:  MOVF   xDC,W
00B04:  BTFSC  FD8.2
00B06:  DECF   xDD,F
00B08:  DECF   xDC,F
00B0A:  MOVWF  xDF
00B0C:  MOVFF  03,7E0
00B10:  MOVF   xDF,F
00B12:  BNZ   0B18
00B14:  MOVF   xE0,F
00B16:  BZ    0B82
.................... 		*data = read_eeprom( address++ ); 
00B18:  MOVFF  7DB,03
00B1C:  MOVF   xDA,W
00B1E:  MOVWF  FE9
00B20:  MOVFF  03,FEA
00B24:  MOVF   xD9,W
00B26:  MOVWF  03
00B28:  MOVF   xD8,W
00B2A:  INCF   xD8,F
00B2C:  BTFSC  FD8.2
00B2E:  INCF   xD9,F
00B30:  MOVWF  xE1
00B32:  MOVFF  03,7E2
00B36:  MOVFF  FF2,7E3
00B3A:  BCF    FF2.6
00B3C:  BCF    FF2.7
00B3E:  MOVFF  7E2,FAA
00B42:  MOVFF  7E1,FA9
00B46:  BCF    FA6.6
00B48:  BCF    FA6.7
00B4A:  BSF    FA6.0
00B4C:  MOVF   FA8,W
00B4E:  BTFSC  xE3.6
00B50:  BSF    FF2.6
00B52:  BTFSC  xE3.7
00B54:  BSF    FF2.7
00B56:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00B58:  MOVFF  7DB,03
00B5C:  MOVF   xDA,W
00B5E:  MOVWF  FE9
00B60:  MOVFF  03,FEA
00B64:  MOVFF  FEF,7DF
00B68:  MOVFF  7DE,7F2
00B6C:  MOVFF  7DF,7F3
*
00B76:  MOVFF  01,7DE
.................... 		data++; 
00B7A:  INCF   xDA,F
00B7C:  BTFSC  FD8.2
00B7E:  INCF   xDB,F
.................... 	} 
00B80:  BRA    0AFE
.................... 	return crc; 
00B82:  MOVFF  7DE,01
.................... } 
00B86:  MOVLB  0
00B88:  GOTO   0D4E (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00B8C:  MOVLB  7
00B8E:  CLRF   xF0
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B90:  MOVFF  7EF,03
00B94:  MOVF   xEE,W
00B96:  BTFSC  FD8.2
00B98:  DECF   xEF,F
00B9A:  DECF   xEE,F
00B9C:  MOVWF  xF1
00B9E:  MOVFF  03,7F2
00BA2:  MOVF   xF1,F
00BA4:  BNZ   0BAA
00BA6:  MOVF   xF2,F
00BA8:  BZ    0C28
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00BAA:  MOVFF  7ED,03
00BAE:  MOVF   xEC,W
00BB0:  MOVWF  FE9
00BB2:  MOVFF  03,FEA
00BB6:  MOVFF  FEF,7F1
00BBA:  MOVFF  7F0,7F2
00BBE:  MOVFF  7F1,7F3
*
00BC8:  MOVFF  01,7F0
.................... 		write_eeprom( address++, *data++ ); 
00BCC:  MOVF   xEB,W
00BCE:  MOVWF  03
00BD0:  MOVF   xEA,W
00BD2:  INCF   xEA,F
00BD4:  BTFSC  FD8.2
00BD6:  INCF   xEB,F
00BD8:  MOVWF  xF1
00BDA:  MOVFF  03,7F2
00BDE:  MOVF   xED,W
00BE0:  MOVWF  03
00BE2:  MOVF   xEC,W
00BE4:  INCF   xEC,F
00BE6:  BTFSC  FD8.2
00BE8:  INCF   xED,F
00BEA:  MOVWF  FE9
00BEC:  MOVFF  03,FEA
00BF0:  MOVFF  FEF,7F3
00BF4:  MOVFF  7F2,FAA
00BF8:  MOVFF  7F1,FA9
00BFC:  MOVFF  7F3,FA8
00C00:  BCF    FA6.6
00C02:  BCF    FA6.7
00C04:  BSF    FA6.2
00C06:  MOVF   FF2,W
00C08:  MOVWF  00
00C0A:  BCF    FF2.6
00C0C:  BCF    FF2.7
00C0E:  MOVLB  F
00C10:  MOVLW  55
00C12:  MOVWF  FA7
00C14:  MOVLW  AA
00C16:  MOVWF  FA7
00C18:  BSF    FA6.1
00C1A:  BTFSC  FA6.1
00C1C:  BRA    0C1A
00C1E:  BCF    FA6.2
00C20:  MOVF   00,W
00C22:  IORWF  FF2,F
.................... 	} 
00C24:  MOVLB  7
00C26:  BRA    0B90
....................  
.................... 	return crc; 
00C28:  MOVFF  7F0,01
.................... } 
00C2C:  MOVLB  0
00C2E:  GOTO   0C52 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00C32:  MOVLB  7
00C34:  CLRF   xE9
00C36:  MOVLW  36
00C38:  MOVWF  xE8
00C3A:  CLRF   xEB
00C3C:  MOVLW  02
00C3E:  MOVWF  xEA
00C40:  MOVFF  7E9,7ED
00C44:  MOVFF  7E8,7EC
00C48:  CLRF   xEF
00C4A:  MOVLW  60
00C4C:  MOVWF  xEE
00C4E:  MOVLB  0
00C50:  BRA    0B8C
00C52:  MOVFF  01,7E7
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00C56:  CLRF   FAA
00C58:  CLRF   FA9
00C5A:  MOVFF  7E7,FA8
00C5E:  BCF    FA6.6
00C60:  BCF    FA6.7
00C62:  BSF    FA6.2
00C64:  MOVF   FF2,W
00C66:  MOVWF  00
00C68:  BCF    FF2.6
00C6A:  BCF    FF2.7
00C6C:  MOVLB  F
00C6E:  MOVLW  55
00C70:  MOVWF  FA7
00C72:  MOVLW  AA
00C74:  MOVWF  FA7
00C76:  BSF    FA6.1
00C78:  BTFSC  FA6.1
00C7A:  BRA    0C78
00C7C:  BCF    FA6.2
00C7E:  MOVF   00,W
00C80:  IORWF  FF2,F
.................... } 
00C82:  MOVLB  0
00C84:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00C86:  MOVLW  96
00C88:  MOVLB  1
00C8A:  MOVWF  xF6
....................  
.................... 	config.modbus_address=38; 
00C8C:  MOVLW  26
00C8E:  MOVWF  36
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00C90:  MOVLW  02
00C92:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00C94:  MOVLW  50
00C96:  MOVWF  39
.................... 	config.serial_number=9876; 
00C98:  MOVLW  26
00C9A:  MOVWF  3B
00C9C:  MOVLW  94
00C9E:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00CA0:  CLRF   3D
00CA2:  MOVLW  14
00CA4:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00CA6:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00CA8:  MOVLW  02
00CAA:  MOVWF  40
00CAC:  MOVLW  76
00CAE:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00CB0:  CLRF   42
00CB2:  MOVLW  02
00CB4:  MOVWF  41
.................... 	config.power_startup=0; 
00CB6:  CLRF   43
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00CB8:  CLRF   FEA
00CBA:  MOVLW  4E
00CBC:  MOVWF  FE9
00CBE:  CLRF   00
00CC0:  CLRF   02
00CC2:  MOVLW  48
00CC4:  MOVWF  01
00CC6:  MOVLB  0
00CC8:  RCALL  088A
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00CCA:  CLRF   FEA
00CCC:  MOVLW  4E
00CCE:  MOVWF  FE9
00CD0:  MOVLW  00
00CD2:  CALL   017C
00CD6:  TBLRD*-
00CD8:  TBLRD*+
00CDA:  MOVF   FF5,W
00CDC:  MOVWF  FEE
00CDE:  IORLW  00
00CE0:  BNZ   0CD8
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00CE2:  CLRF   FEA
00CE4:  MOVLW  54
00CE6:  MOVWF  FE9
00CE8:  MOVLW  00
00CEA:  CALL   0194
00CEE:  TBLRD*-
00CF0:  TBLRD*+
00CF2:  MOVF   FF5,W
00CF4:  MOVWF  FEE
00CF6:  IORLW  00
00CF8:  BNZ   0CF0
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00CFA:  CLRF   FEA
00CFC:  MOVLW  5A
00CFE:  MOVWF  FE9
00D00:  MOVLW  00
00D02:  CALL   01AC
00D06:  TBLRD*-
00D08:  TBLRD*+
00D0A:  MOVF   FF5,W
00D0C:  MOVWF  FEE
00D0E:  IORLW  00
00D10:  BNZ   0D08
....................  
.................... 	strcpy(config.nmea0183_sentence[10],"$WIMDA"); 
00D12:  CLRF   FEA
00D14:  MOVLW  8A
00D16:  MOVWF  FE9
00D18:  MOVLW  00
00D1A:  CALL   01C4
00D1E:  TBLRD*-
00D20:  TBLRD*+
00D22:  MOVF   FF5,W
00D24:  MOVWF  FEE
00D26:  IORLW  00
00D28:  BNZ   0D20
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00D2A:  RCALL  0C32
....................  
.................... } 
00D2C:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00D2E:  MOVLB  7
00D30:  CLRF   xD7
00D32:  MOVLW  36
00D34:  MOVWF  xD6
00D36:  CLRF   xD9
00D38:  MOVLW  02
00D3A:  MOVWF  xD8
00D3C:  MOVFF  7D7,7DB
00D40:  MOVFF  7D6,7DA
00D44:  CLRF   xDD
00D46:  MOVLW  60
00D48:  MOVWF  xDC
00D4A:  MOVLB  0
00D4C:  BRA    0AFA
00D4E:  MOVFF  01,7D5
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00D52:  MOVFF  FF2,7D6
00D56:  BCF    FF2.6
00D58:  BCF    FF2.7
00D5A:  CLRF   FAA
00D5C:  CLRF   FA9
00D5E:  BCF    FA6.6
00D60:  BCF    FA6.7
00D62:  BSF    FA6.0
00D64:  MOVF   FA8,W
00D66:  MOVLB  7
00D68:  BTFSC  xD6.6
00D6A:  BSF    FF2.6
00D6C:  BTFSC  xD6.7
00D6E:  BSF    FF2.7
00D70:  SUBWF  xD5,W
00D72:  BZ    0D7A
.................... 		write_default_param_file(); 
00D74:  MOVLB  0
00D76:  RCALL  0C86
00D78:  MOVLB  7
.................... 	} 
.................... } 
00D7A:  MOVLB  0
00D7C:  GOTO   2A9A (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
012E6:  BTFSS  FAC.1
012E8:  BRA    12E6
.................... } 
012EA:  GOTO   1304 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00D80:  BTFSS  F9E.5
00D82:  BRA    0D88
.................... 		fgetc(STREAM_PI); 
00D84:  RCALL  06F6
.................... 	} 
00D86:  BRA    0D80
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00D88:  BSF    F9D.5
.................... } 
00D8A:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00D8C:  RCALL  0D80
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00D8E:  MOVLW  C6
00D90:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00D92:  MOVLW  C0
00D94:  IORWF  FF2,F
.................... } 
00D96:  GOTO   2AAC (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003FC:  BCF    FF2.5
.................... 	if (enable) { 
003FE:  MOVLB  8
00400:  MOVF   xE5,F
00402:  BZ    040C
.................... 		set_timer0(0); 
00404:  CLRF   FD7
00406:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00408:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
0040A:  BSF    FF2.5
.................... 	} 
.................... } 
0040C:  MOVLB  0
0040E:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
00410:  MOVLB  6
00412:  MOVF   xC0,W
00414:  SUBLW  02
00416:  BNZ   042C
00418:  MOVF   xC1,F
0041A:  BNZ   042C
0041C:  MOVF   xC2,F
0041E:  BNZ   042C
00420:  BTFSC  xBF.0
00422:  BRA    042C
....................    { 
....................       modbus_rx.len-=2; 
00424:  MOVLW  02
00426:  SUBWF  xC4,F
....................       modbus_serial_new=TRUE; 
00428:  BSF    xBF.0
....................    } 
....................    else 
0042A:  BRA    042E
....................       modbus_serial_new=FALSE; 
0042C:  BCF    xBF.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0042E:  SETF   xC2
00430:  SETF   xC1
....................    modbus_serial_state=MODBUS_GETADDY; 
00432:  CLRF   xC0
....................    modbus_enable_timeout(FALSE); 
00434:  MOVLB  8
00436:  CLRF   xE5
00438:  MOVLB  0
0043A:  RCALL  03FC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0043C:  BCF    FF2.2
0043E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
0070C:  MOVLB  6
0070E:  MOVF   xC2,W
00710:  MOVLB  8
00712:  XORWF  xE5,W
00714:  MOVWF  xE6
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00716:  CLRF   03
00718:  MOVF   xE6,W
0071A:  MOVLB  0
0071C:  RCALL  01DC
0071E:  MOVWF  01
00720:  MOVLB  6
00722:  MOVF   xC1,W
00724:  XORWF  01,W
00726:  MOVWF  xC2
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00728:  CLRF   03
0072A:  MOVLB  8
0072C:  MOVF   xE6,W
0072E:  MOVLB  0
00730:  RCALL  02EC
00732:  MOVFF  FE8,6C1
.................... } 
00736:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
0128C:  MOVLB  7
0128E:  MOVF   xE7,W
01290:  MOVLB  0
01292:  RCALL  1284
01294:  CLRF   19
01296:  BTFSC  FF2.6
01298:  BSF    19.6
0129A:  BCF    FF2.6
0129C:  BTFSC  FF2.7
0129E:  BSF    19.7
012A0:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
012A2:  MOVFF  7E7,8E5
012A6:  CALL   070C
012AA:  BTFSC  19.6
012AC:  BSF    FF2.6
012AE:  BTFSC  19.7
012B0:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
012B2:  CLRWDT
012B4:  MOVLW  08
012B6:  MOVWF  00
012B8:  DECFSZ 00,F
012BA:  BRA    12B8
012BC:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
012BE:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
012C0:  MOVLB  6
012C2:  SETF   xC2
012C4:  SETF   xC1
....................    modbus_serial_new=FALSE; 
012C6:  BCF    xBF.0
....................  
....................    RCV_OFF(); 
012C8:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
012CA:  CLRWDT
012CC:  MOVLW  3C
012CE:  MOVWF  00
012D0:  DECFSZ 00,F
012D2:  BRA    12D0
012D4:  NOP   
....................  
....................    modbus_serial_putc(to); 
012D6:  MOVFF  7E5,7E7
012DA:  MOVLB  0
012DC:  RCALL  128C
....................    modbus_serial_putc(func); 
012DE:  MOVFF  7E6,7E7
012E2:  RCALL  128C
.................... } 
012E4:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
012EE:  MOVFF  6C2,7E6
....................    crc_low=modbus_serial_crc.b[0]; 
012F2:  MOVFF  6C1,7E5
....................  
....................    modbus_serial_putc(crc_high); 
012F6:  MOVFF  7E6,7E7
012FA:  RCALL  128C
....................    modbus_serial_putc(crc_low); 
012FC:  MOVFF  7E5,7E7
01300:  RCALL  128C
....................  
....................    WAIT_FOR_HW_BUFFER(); 
01302:  BRA    12E6
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
01304:  CLRWDT
01306:  MOVLW  3C
01308:  MOVWF  00
0130A:  DECFSZ 00,F
0130C:  BRA    130A
0130E:  NOP   
....................  
....................  
....................    RCV_ON(); 
01310:  RCALL  0D80
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
01312:  MOVLB  6
01314:  SETF   xC2
01316:  SETF   xC1
.................... } 
01318:  MOVLB  0
0131A:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
01148:  MOVLB  6
0114A:  BTFSC  xBF.0
0114C:  BRA    1156
....................       return FALSE; 
0114E:  MOVLW  00
01150:  MOVWF  01
01152:  BRA    1168
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
01154:  BRA    1162
01156:  BTFSS  xC5.7
01158:  BRA    1162
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0115A:  MOVFF  6C7,6C6
....................       modbus_rx.len = 1; 
0115E:  MOVLW  01
01160:  MOVWF  xC4
....................    } 
....................    modbus_serial_new=FALSE; 
01162:  BCF    xBF.0
....................    return TRUE; 
01164:  MOVLW  01
01166:  MOVWF  01
.................... } 
01168:  MOVLB  0
0116A:  GOTO   23A2 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
0230E:  MOVFF  7DD,7E5
02312:  MOVLW  06
02314:  MOVLB  7
02316:  MOVWF  xE6
02318:  MOVLB  0
0231A:  CALL   12C0
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
0231E:  MOVFF  7DF,7E2
02322:  MOVFF  7DF,7E7
02326:  CALL   128C
....................    modbus_serial_putc(make8(reg_address,0)); 
0232A:  MOVFF  7DE,7E2
0232E:  MOVFF  7DE,7E7
02332:  CALL   128C
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02336:  MOVFF  7E1,7E2
0233A:  MOVFF  7E1,7E7
0233E:  CALL   128C
....................    modbus_serial_putc(make8(reg_value,0)); 
02342:  MOVFF  7E0,7E2
02346:  MOVFF  7E0,7E7
0234A:  CALL   128C
....................  
....................    modbus_serial_send_stop(); 
0234E:  CALL   12EE
.................... } 
02352:  GOTO   2586 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02356:  MOVFF  7DB,7E5
0235A:  MOVLW  10
0235C:  MOVLB  7
0235E:  MOVWF  xE6
02360:  MOVLB  0
02362:  CALL   12C0
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02366:  MOVFF  7DD,7E0
0236A:  MOVFF  7DD,7E7
0236E:  CALL   128C
....................    modbus_serial_putc(make8(start_address,0)); 
02372:  MOVFF  7DC,7E0
02376:  MOVFF  7DC,7E7
0237A:  CALL   128C
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0237E:  MOVFF  7DF,7E0
02382:  MOVFF  7DF,7E7
02386:  CALL   128C
....................    modbus_serial_putc(make8(quantity,0)); 
0238A:  MOVFF  7DE,7E0
0238E:  MOVFF  7DE,7E7
02392:  CALL   128C
....................  
....................    modbus_serial_send_stop(); 
02396:  CALL   12EE
.................... } 
0239A:  GOTO   2648 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0131C:  MOVLB  7
0131E:  MOVF   xDC,W
01320:  IORLW  80
01322:  MOVWF  xDF
01324:  MOVFF  7DD,7E0
01328:  MOVFF  7DB,7E5
0132C:  MOVWF  xE6
0132E:  MOVLB  0
01330:  RCALL  12C0
....................    modbus_serial_putc(error); 
01332:  MOVFF  7DE,7E7
01336:  RCALL  128C
....................    modbus_serial_send_stop(); 
01338:  RCALL  12EE
.................... } 
0133A:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          53 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1012 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
01402:  MOVLB  1
01404:  CLRF   xCC
01406:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
01408:  CLRF   xCE
0140A:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
0140C:  CLRF   xD0
0140E:  CLRF   xCF
.................... } 
01410:  MOVLB  0
01412:  GOTO   1E90 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0139E:  BCF    FF2.6
013A0:  BCF    FF2.7
013A2:  BTFSC  FF2.7
013A4:  BRA    13A0
....................  
.................... 	current.pulse_count[0]=0; 
013A6:  CLRF   xA9
013A8:  CLRF   xA8
.................... 	current.pulse_count[1]=0; 
013AA:  CLRF   xAB
013AC:  CLRF   xAA
.................... 	current.pulse_count[2]=0; 
013AE:  CLRF   xAD
013B0:  CLRF   xAC
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
013B2:  SETF   x9D
013B4:  SETF   x9C
.................... 	current.pulse_min_period[1]=65535; 
013B6:  SETF   x9F
013B8:  SETF   x9E
.................... 	current.pulse_min_period[2]=65535; 
013BA:  SETF   xA1
013BC:  SETF   xA0
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
013BE:  CLRF   xA3
013C0:  CLRF   xA2
.................... 	current.pulse_max_period[1]=0; 
013C2:  CLRF   xA5
013C4:  CLRF   xA4
.................... 	current.pulse_max_period[2]=0; 
013C6:  CLRF   xA7
013C8:  CLRF   xA6
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
013CA:  MOVLB  1
013CC:  CLRF   xD6
013CE:  CLRF   xD5
....................  
.................... 	enable_interrupts(GLOBAL); 
013D0:  MOVLW  C0
013D2:  IORWF  FF2,F
.................... } 
013D4:  MOVLB  0
013D6:  GOTO   1E40 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
013DA:  BCF    FF2.6
013DC:  BCF    FF2.7
013DE:  BTFSC  FF2.7
013E0:  BRA    13DC
.................... 	current.pulse_sum[0]=0; 
013E2:  CLRF   xB1
013E4:  CLRF   xB0
013E6:  CLRF   xAF
013E8:  CLRF   xAE
.................... 	current.pulse_sum[1]=0; 
013EA:  CLRF   xB5
013EC:  CLRF   xB4
013EE:  CLRF   xB3
013F0:  CLRF   xB2
.................... 	current.pulse_sum[2]=0; 
013F2:  CLRF   xB9
013F4:  CLRF   xB8
013F6:  CLRF   xB7
013F8:  CLRF   xB6
.................... 	enable_interrupts(GLOBAL); 
013FA:  MOVLW  C0
013FC:  IORWF  FF2,F
.................... } 
013FE:  GOTO   1E50 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
0133C:  BCF    FF2.6
0133E:  BCF    FF2.7
01340:  BTFSC  FF2.7
01342:  BRA    133E
.................... 	l=current.pulse_sum[ch]; 
01344:  MOVLB  8
01346:  CLRF   xDA
01348:  MOVFF  7ED,8D9
0134C:  CLRF   xDC
0134E:  MOVLW  04
01350:  MOVWF  xDB
01352:  MOVLB  0
01354:  CALL   0868
01358:  MOVFF  02,03
0135C:  MOVF   01,W
0135E:  ADDLW  AE
01360:  MOVWF  FE9
01362:  MOVLW  00
01364:  ADDWFC 02,W
01366:  MOVWF  FEA
01368:  MOVFF  FEF,00
0136C:  MOVFF  FEC,01
01370:  MOVFF  FEC,02
01374:  MOVFF  FEC,03
01378:  MOVFF  03,7F1
0137C:  MOVFF  02,7F0
01380:  MOVFF  01,7EF
01384:  MOVFF  00,7EE
.................... 	enable_interrupts(GLOBAL); 
01388:  MOVLW  C0
0138A:  IORWF  FF2,F
....................  
.................... 	return l; 
0138C:  MOVFF  7EE,00
01390:  MOVFF  7EF,01
01394:  MOVFF  7F0,02
01398:  MOVFF  7F1,03
.................... } 
0139C:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01416:  MOVLB  7
01418:  MOVF   xE8,W
0141A:  SUBLW  06
0141C:  BC    1472
0141E:  XORLW  FF
01420:  BNZ   1428
01422:  MOVF   xE7,W
01424:  SUBLW  CF
01426:  BC    1472
01428:  MOVF   xE8,W
0142A:  SUBLW  09
0142C:  BNC   1472
0142E:  BNZ   1436
01430:  MOVF   xE7,W
01432:  SUBLW  CF
01434:  BNC   1472
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01436:  MOVLW  D0
01438:  SUBWF  xE7,W
0143A:  MOVWF  xED
0143C:  MOVLW  07
0143E:  SUBWFB xE8,W
01440:  MOVWF  xEE
01442:  MOVLW  02
01444:  ADDWF  xEE,F
01446:  MOVFF  FF2,7EF
0144A:  BCF    FF2.6
0144C:  BCF    FF2.7
0144E:  MOVFF  7EE,FAA
01452:  MOVFF  7ED,FA9
01456:  BCF    FA6.6
01458:  BCF    FA6.7
0145A:  BSF    FA6.0
0145C:  MOVF   FA8,W
0145E:  BTFSC  xEF.6
01460:  BSF    FF2.6
01462:  BTFSC  xEF.7
01464:  BSF    FF2.7
01466:  CLRF   03
01468:  MOVWF  01
0146A:  MOVF   03,W
0146C:  MOVWF  02
0146E:  GOTO   1F82
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
01472:  MOVF   xE8,W
01474:  SUBLW  03
01476:  BC    14F6
01478:  XORLW  FF
0147A:  BNZ   1482
0147C:  MOVF   xE7,W
0147E:  SUBLW  4B
01480:  BC    14F6
01482:  MOVF   xE8,W
01484:  SUBLW  04
01486:  BNC   14F6
01488:  BNZ   1490
0148A:  MOVF   xE7,W
0148C:  SUBLW  93
0148E:  BNC   14F6
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
01490:  MOVLW  4C
01492:  SUBWF  xE7,W
01494:  MOVWF  xE9
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01496:  MOVFF  7E9,7ED
0149A:  MOVLW  06
0149C:  MOVWF  xEE
0149E:  MOVLB  0
014A0:  CALL   0A4E
014A4:  MOVFF  00,7EA
.................... 		n = n / 6; /* number of sentence */ 
014A8:  MOVFF  7E9,7ED
014AC:  MOVLW  06
014AE:  MOVLB  7
014B0:  MOVWF  xEE
014B2:  MOVLB  0
014B4:  CALL   0A4E
014B8:  MOVFF  01,7E9
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
014BC:  MOVLB  7
014BE:  MOVF   xE9,W
014C0:  MULLW  06
014C2:  MOVF   FF3,W
014C4:  CLRF   03
014C6:  ADDLW  18
014C8:  MOVWF  xED
014CA:  MOVLW  00
014CC:  ADDWFC 03,W
014CE:  MOVWF  xEE
014D0:  CLRF   03
014D2:  MOVF   xEA,W
014D4:  ADDWF  xED,W
014D6:  MOVWF  01
014D8:  MOVF   xEE,W
014DA:  ADDWFC 03,F
014DC:  MOVF   01,W
014DE:  ADDLW  36
014E0:  MOVWF  FE9
014E2:  MOVLW  00
014E4:  ADDWFC 03,W
014E6:  MOVWF  FEA
014E8:  MOVF   FEF,W
014EA:  CLRF   03
014EC:  MOVWF  01
014EE:  MOVFF  03,02
014F2:  GOTO   1F82
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
014F6:  MOVF   xE8,W
014F8:  SUBLW  12
014FA:  BC    153C
014FC:  XORLW  FF
014FE:  BNZ   1506
01500:  MOVF   xE7,W
01502:  SUBLW  87
01504:  BC    153C
01506:  MOVF   xE8,W
01508:  SUBLW  17
0150A:  BNC   153C
0150C:  BNZ   1514
0150E:  MOVF   xE7,W
01510:  SUBLW  47
01512:  BNC   153C
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
01514:  MOVLW  88
01516:  SUBWF  xE7,F
01518:  MOVLW  13
0151A:  SUBWFB xE8,F
....................  
....................  		p  = nmea.sentence[0]; 
0151C:  MOVLW  02
0151E:  MOVWF  xEC
01520:  SETF   xEB
.................... 		return (int16) p[addr]; 
01522:  MOVF   xEB,W
01524:  ADDWF  xE7,W
01526:  MOVWF  FE9
01528:  MOVF   xEC,W
0152A:  ADDWFC xE8,W
0152C:  MOVWF  FEA
0152E:  MOVF   FEF,W
01530:  CLRF   03
01532:  MOVWF  01
01534:  MOVFF  03,02
01538:  GOTO   1F82
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
0153C:  MOVF   xE8,W
0153E:  SUBLW  16
01540:  BC    15AA
01542:  XORLW  FF
01544:  BNZ   154C
01546:  MOVF   xE7,W
01548:  SUBLW  6F
0154A:  BC    15AA
0154C:  MOVF   xE8,W
0154E:  SUBLW  19
01550:  BNC   15AA
01552:  BNZ   155A
01554:  MOVF   xE7,W
01556:  SUBLW  4F
01558:  BNC   15AA
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
0155A:  MOVLW  70
0155C:  SUBWF  xE7,F
0155E:  MOVLW  17
01560:  SUBWFB xE8,F
.................... 		addr = addr * 2; 
01562:  BCF    FD8.0
01564:  RLCF   xE7,F
01566:  RLCF   xE8,F
....................  
....................  		p  = nmea.sentence[0]; 
01568:  MOVLW  02
0156A:  MOVWF  xEC
0156C:  SETF   xEB
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0156E:  MOVF   xEB,W
01570:  ADDWF  xE7,W
01572:  MOVWF  FE9
01574:  MOVF   xEC,W
01576:  ADDWFC xE8,W
01578:  MOVWF  FEA
0157A:  MOVFF  FEF,7ED
0157E:  MOVLW  01
01580:  ADDWF  xE7,W
01582:  MOVWF  xEE
01584:  MOVLW  00
01586:  ADDWFC xE8,W
01588:  MOVWF  xEF
0158A:  MOVF   xEB,W
0158C:  ADDWF  xEE,W
0158E:  MOVWF  FE9
01590:  MOVF   xEC,W
01592:  ADDWFC xEF,W
01594:  MOVWF  FEA
01596:  MOVFF  FEF,7F0
0159A:  MOVFF  7ED,03
0159E:  MOVFF  7F0,01
015A2:  MOVFF  7ED,02
015A6:  GOTO   1F82
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
015AA:  MOVF   xE7,W
015AC:  MOVWF  00
015AE:  MOVF   xE8,W
015B0:  MOVWF  03
015B2:  MOVF   03,W
015B4:  BNZ   15C0
015B6:  MOVF   00,F
015B8:  MOVLB  0
015BA:  BTFSC  FD8.2
015BC:  BRA    19FC
015BE:  MOVLB  7
015C0:  MOVF   03,W
015C2:  BNZ   15D0
015C4:  MOVLW  01
015C6:  SUBWF  00,W
015C8:  MOVLB  0
015CA:  BTFSC  FD8.2
015CC:  BRA    1A0A
015CE:  MOVLB  7
015D0:  MOVF   03,W
015D2:  BNZ   15E0
015D4:  MOVLW  02
015D6:  SUBWF  00,W
015D8:  MOVLB  0
015DA:  BTFSC  FD8.2
015DC:  BRA    1A18
015DE:  MOVLB  7
015E0:  MOVF   03,W
015E2:  BNZ   15F0
015E4:  MOVLW  03
015E6:  SUBWF  00,W
015E8:  MOVLB  0
015EA:  BTFSC  FD8.2
015EC:  BRA    1A26
015EE:  MOVLB  7
015F0:  MOVF   03,W
015F2:  BNZ   1600
015F4:  MOVLW  04
015F6:  SUBWF  00,W
015F8:  MOVLB  0
015FA:  BTFSC  FD8.2
015FC:  BRA    1A34
015FE:  MOVLB  7
01600:  MOVF   03,W
01602:  BNZ   1610
01604:  MOVLW  05
01606:  SUBWF  00,W
01608:  MOVLB  0
0160A:  BTFSC  FD8.2
0160C:  BRA    1A5A
0160E:  MOVLB  7
01610:  MOVF   03,W
01612:  BNZ   1620
01614:  MOVLW  06
01616:  SUBWF  00,W
01618:  MOVLB  0
0161A:  BTFSC  FD8.2
0161C:  BRA    1A68
0161E:  MOVLB  7
01620:  MOVF   03,W
01622:  BNZ   1630
01624:  MOVLW  07
01626:  SUBWF  00,W
01628:  MOVLB  0
0162A:  BTFSC  FD8.2
0162C:  BRA    1A76
0162E:  MOVLB  7
01630:  MOVF   03,W
01632:  BNZ   1640
01634:  MOVLW  08
01636:  SUBWF  00,W
01638:  MOVLB  0
0163A:  BTFSC  FD8.2
0163C:  BRA    1A84
0163E:  MOVLB  7
01640:  MOVF   03,W
01642:  BNZ   1650
01644:  MOVLW  09
01646:  SUBWF  00,W
01648:  MOVLB  0
0164A:  BTFSC  FD8.2
0164C:  BRA    1A92
0164E:  MOVLB  7
01650:  MOVF   03,W
01652:  BNZ   1660
01654:  MOVLW  0A
01656:  SUBWF  00,W
01658:  MOVLB  0
0165A:  BTFSC  FD8.2
0165C:  BRA    1AA0
0165E:  MOVLB  7
01660:  MOVF   03,W
01662:  BNZ   1670
01664:  MOVLW  0B
01666:  SUBWF  00,W
01668:  MOVLB  0
0166A:  BTFSC  FD8.2
0166C:  BRA    1AC8
0166E:  MOVLB  7
01670:  MOVF   03,W
01672:  BNZ   1680
01674:  MOVLW  0C
01676:  SUBWF  00,W
01678:  MOVLB  0
0167A:  BTFSC  FD8.2
0167C:  BRA    1AD6
0167E:  MOVLB  7
01680:  MOVF   03,W
01682:  BNZ   1690
01684:  MOVLW  0D
01686:  SUBWF  00,W
01688:  MOVLB  0
0168A:  BTFSC  FD8.2
0168C:  BRA    1AE4
0168E:  MOVLB  7
01690:  MOVF   03,W
01692:  BNZ   16A0
01694:  MOVLW  0E
01696:  SUBWF  00,W
01698:  MOVLB  0
0169A:  BTFSC  FD8.2
0169C:  BRA    1AF2
0169E:  MOVLB  7
016A0:  MOVF   03,W
016A2:  BNZ   16B0
016A4:  MOVLW  0F
016A6:  SUBWF  00,W
016A8:  MOVLB  0
016AA:  BTFSC  FD8.2
016AC:  BRA    1B00
016AE:  MOVLB  7
016B0:  MOVF   03,W
016B2:  BNZ   16C0
016B4:  MOVLW  10
016B6:  SUBWF  00,W
016B8:  MOVLB  0
016BA:  BTFSC  FD8.2
016BC:  BRA    1B0E
016BE:  MOVLB  7
016C0:  MOVF   03,W
016C2:  BNZ   16D0
016C4:  MOVLW  11
016C6:  SUBWF  00,W
016C8:  MOVLB  0
016CA:  BTFSC  FD8.2
016CC:  BRA    1B36
016CE:  MOVLB  7
016D0:  MOVF   03,W
016D2:  BNZ   16E0
016D4:  MOVLW  12
016D6:  SUBWF  00,W
016D8:  MOVLB  0
016DA:  BTFSC  FD8.2
016DC:  BRA    1B44
016DE:  MOVLB  7
016E0:  MOVF   03,W
016E2:  BNZ   16F0
016E4:  MOVLW  13
016E6:  SUBWF  00,W
016E8:  MOVLB  0
016EA:  BTFSC  FD8.2
016EC:  BRA    1B72
016EE:  MOVLB  7
016F0:  MOVF   03,W
016F2:  BNZ   1700
016F4:  MOVLW  14
016F6:  SUBWF  00,W
016F8:  MOVLB  0
016FA:  BTFSC  FD8.2
016FC:  BRA    1B8A
016FE:  MOVLB  7
01700:  MOVF   03,W
01702:  BNZ   1710
01704:  MOVLW  15
01706:  SUBWF  00,W
01708:  MOVLB  0
0170A:  BTFSC  FD8.2
0170C:  BRA    1B98
0170E:  MOVLB  7
01710:  MOVF   03,W
01712:  BNZ   1720
01714:  MOVLW  16
01716:  SUBWF  00,W
01718:  MOVLB  0
0171A:  BTFSC  FD8.2
0171C:  BRA    1BC6
0171E:  MOVLB  7
01720:  MOVF   03,W
01722:  BNZ   1730
01724:  MOVLW  17
01726:  SUBWF  00,W
01728:  MOVLB  0
0172A:  BTFSC  FD8.2
0172C:  BRA    1BE0
0172E:  MOVLB  7
01730:  MOVF   03,W
01732:  BNZ   1740
01734:  MOVLW  18
01736:  SUBWF  00,W
01738:  MOVLB  0
0173A:  BTFSC  FD8.2
0173C:  BRA    1BEE
0173E:  MOVLB  7
01740:  MOVF   03,W
01742:  BNZ   1750
01744:  MOVLW  19
01746:  SUBWF  00,W
01748:  MOVLB  0
0174A:  BTFSC  FD8.2
0174C:  BRA    1C1C
0174E:  MOVLB  7
01750:  MOVF   03,W
01752:  BNZ   1760
01754:  MOVLW  1A
01756:  SUBWF  00,W
01758:  MOVLB  0
0175A:  BTFSC  FD8.2
0175C:  BRA    1C36
0175E:  MOVLB  7
01760:  MOVF   03,W
01762:  BNZ   1770
01764:  MOVLW  1B
01766:  SUBWF  00,W
01768:  MOVLB  0
0176A:  BTFSC  FD8.2
0176C:  BRA    1C44
0176E:  MOVLB  7
01770:  MOVF   03,W
01772:  BNZ   1780
01774:  MOVLW  1C
01776:  SUBWF  00,W
01778:  MOVLB  0
0177A:  BTFSC  FD8.2
0177C:  BRA    1C72
0177E:  MOVLB  7
01780:  MOVF   03,W
01782:  BNZ   1790
01784:  MOVLW  1D
01786:  SUBWF  00,W
01788:  MOVLB  0
0178A:  BTFSC  FD8.2
0178C:  BRA    1C8C
0178E:  MOVLB  7
01790:  MOVF   03,W
01792:  BNZ   17A0
01794:  MOVLW  1E
01796:  SUBWF  00,W
01798:  MOVLB  0
0179A:  BTFSC  FD8.2
0179C:  BRA    1C9A
0179E:  MOVLB  7
017A0:  MOVF   03,W
017A2:  BNZ   17B0
017A4:  MOVLW  1F
017A6:  SUBWF  00,W
017A8:  MOVLB  0
017AA:  BTFSC  FD8.2
017AC:  BRA    1CC8
017AE:  MOVLB  7
017B0:  MOVF   03,W
017B2:  BNZ   17C0
017B4:  MOVLW  20
017B6:  SUBWF  00,W
017B8:  MOVLB  0
017BA:  BTFSC  FD8.2
017BC:  BRA    1CE2
017BE:  MOVLB  7
017C0:  MOVF   03,W
017C2:  BNZ   17D0
017C4:  MOVLW  21
017C6:  SUBWF  00,W
017C8:  MOVLB  0
017CA:  BTFSC  FD8.2
017CC:  BRA    1CF0
017CE:  MOVLB  7
017D0:  MOVF   03,W
017D2:  BNZ   17E0
017D4:  MOVLW  22
017D6:  SUBWF  00,W
017D8:  MOVLB  0
017DA:  BTFSC  FD8.2
017DC:  BRA    1D1E
017DE:  MOVLB  7
017E0:  MOVF   03,W
017E2:  BNZ   17F0
017E4:  MOVLW  23
017E6:  SUBWF  00,W
017E8:  MOVLB  0
017EA:  BTFSC  FD8.2
017EC:  BRA    1D38
017EE:  MOVLB  7
017F0:  MOVF   03,W
017F2:  BNZ   1800
017F4:  MOVLW  24
017F6:  SUBWF  00,W
017F8:  MOVLB  0
017FA:  BTFSC  FD8.2
017FC:  BRA    1D46
017FE:  MOVLB  7
01800:  MOVF   03,W
01802:  BNZ   1810
01804:  MOVLW  25
01806:  SUBWF  00,W
01808:  MOVLB  0
0180A:  BTFSC  FD8.2
0180C:  BRA    1D74
0180E:  MOVLB  7
01810:  MOVF   03,W
01812:  BNZ   1820
01814:  MOVLW  26
01816:  SUBWF  00,W
01818:  MOVLB  0
0181A:  BTFSC  FD8.2
0181C:  BRA    1D8E
0181E:  MOVLB  7
01820:  MOVF   03,W
01822:  BNZ   1830
01824:  MOVLW  27
01826:  SUBWF  00,W
01828:  MOVLB  0
0182A:  BTFSC  FD8.2
0182C:  BRA    1D9C
0182E:  MOVLB  7
01830:  MOVF   03,W
01832:  BNZ   1840
01834:  MOVLW  28
01836:  SUBWF  00,W
01838:  MOVLB  0
0183A:  BTFSC  FD8.2
0183C:  BRA    1DCA
0183E:  MOVLB  7
01840:  MOVF   03,W
01842:  BNZ   1850
01844:  MOVLW  29
01846:  SUBWF  00,W
01848:  MOVLB  0
0184A:  BTFSC  FD8.2
0184C:  BRA    1DE4
0184E:  MOVLB  7
01850:  MOVF   03,W
01852:  BNZ   1860
01854:  MOVLW  2A
01856:  SUBWF  00,W
01858:  MOVLB  0
0185A:  BTFSC  FD8.2
0185C:  BRA    1DF2
0185E:  MOVLB  7
01860:  MOVF   03,W
01862:  BNZ   1870
01864:  MOVLW  2B
01866:  SUBWF  00,W
01868:  MOVLB  0
0186A:  BTFSC  FD8.2
0186C:  BRA    1E0C
0186E:  MOVLB  7
01870:  MOVF   03,W
01872:  BNZ   1880
01874:  MOVLW  2C
01876:  SUBWF  00,W
01878:  MOVLB  0
0187A:  BTFSC  FD8.2
0187C:  BRA    1E1C
0187E:  MOVLB  7
01880:  MOVF   03,W
01882:  BNZ   1890
01884:  MOVLW  2D
01886:  SUBWF  00,W
01888:  MOVLB  0
0188A:  BTFSC  FD8.2
0188C:  BRA    1E2C
0188E:  MOVLB  7
01890:  MOVF   03,W
01892:  BNZ   18A0
01894:  MOVLW  2E
01896:  SUBWF  00,W
01898:  MOVLB  0
0189A:  BTFSC  FD8.2
0189C:  BRA    1E3C
0189E:  MOVLB  7
018A0:  MOVF   03,W
018A2:  BNZ   18B0
018A4:  MOVLW  2F
018A6:  SUBWF  00,W
018A8:  MOVLB  0
018AA:  BTFSC  FD8.2
018AC:  BRA    1E4C
018AE:  MOVLB  7
018B0:  MOVF   03,W
018B2:  BNZ   18C0
018B4:  MOVLW  30
018B6:  SUBWF  00,W
018B8:  MOVLB  0
018BA:  BTFSC  FD8.2
018BC:  BRA    1E5C
018BE:  MOVLB  7
018C0:  MOVF   03,W
018C2:  BNZ   18D0
018C4:  MOVLW  31
018C6:  SUBWF  00,W
018C8:  MOVLB  0
018CA:  BTFSC  FD8.2
018CC:  BRA    1E6C
018CE:  MOVLB  7
018D0:  MOVF   03,W
018D2:  BNZ   18E0
018D4:  MOVLW  32
018D6:  SUBWF  00,W
018D8:  MOVLB  0
018DA:  BTFSC  FD8.2
018DC:  BRA    1E7C
018DE:  MOVLB  7
018E0:  MOVF   03,W
018E2:  BNZ   18F0
018E4:  MOVLW  33
018E6:  SUBWF  00,W
018E8:  MOVLB  0
018EA:  BTFSC  FD8.2
018EC:  BRA    1E8C
018EE:  MOVLB  7
018F0:  MOVF   03,W
018F2:  BNZ   1900
018F4:  MOVLW  34
018F6:  SUBWF  00,W
018F8:  MOVLB  0
018FA:  BTFSC  FD8.2
018FC:  BRA    1E9C
018FE:  MOVLB  7
01900:  MOVF   03,W
01902:  BNZ   1910
01904:  MOVLW  35
01906:  SUBWF  00,W
01908:  MOVLB  0
0190A:  BTFSC  FD8.2
0190C:  BRA    1EAC
0190E:  MOVLB  7
01910:  MOVLW  03
01912:  SUBWF  03,W
01914:  BNZ   1922
01916:  MOVLW  E8
01918:  SUBWF  00,W
0191A:  MOVLB  0
0191C:  BTFSC  FD8.2
0191E:  BRA    1EBC
01920:  MOVLB  7
01922:  MOVLW  03
01924:  SUBWF  03,W
01926:  BNZ   1934
01928:  MOVLW  E9
0192A:  SUBWF  00,W
0192C:  MOVLB  0
0192E:  BTFSC  FD8.2
01930:  BRA    1ECC
01932:  MOVLB  7
01934:  MOVLW  03
01936:  SUBWF  03,W
01938:  BNZ   1946
0193A:  MOVLW  EA
0193C:  SUBWF  00,W
0193E:  MOVLB  0
01940:  BTFSC  FD8.2
01942:  BRA    1EDA
01944:  MOVLB  7
01946:  MOVLW  03
01948:  SUBWF  03,W
0194A:  BNZ   1958
0194C:  MOVLW  EB
0194E:  SUBWF  00,W
01950:  MOVLB  0
01952:  BTFSC  FD8.2
01954:  BRA    1EE8
01956:  MOVLB  7
01958:  MOVLW  03
0195A:  SUBWF  03,W
0195C:  BNZ   196A
0195E:  MOVLW  EC
01960:  SUBWF  00,W
01962:  MOVLB  0
01964:  BTFSC  FD8.2
01966:  BRA    1EF6
01968:  MOVLB  7
0196A:  MOVLW  03
0196C:  SUBWF  03,W
0196E:  BNZ   197C
01970:  MOVLW  ED
01972:  SUBWF  00,W
01974:  MOVLB  0
01976:  BTFSC  FD8.2
01978:  BRA    1F04
0197A:  MOVLB  7
0197C:  MOVLW  03
0197E:  SUBWF  03,W
01980:  BNZ   198E
01982:  MOVLW  EE
01984:  SUBWF  00,W
01986:  MOVLB  0
01988:  BTFSC  FD8.2
0198A:  BRA    1F12
0198C:  MOVLB  7
0198E:  MOVLW  03
01990:  SUBWF  03,W
01992:  BNZ   19A0
01994:  MOVLW  EF
01996:  SUBWF  00,W
01998:  MOVLB  0
0199A:  BTFSC  FD8.2
0199C:  BRA    1F22
0199E:  MOVLB  7
019A0:  MOVLW  03
019A2:  SUBWF  03,W
019A4:  BNZ   19B2
019A6:  MOVLW  F0
019A8:  SUBWF  00,W
019AA:  MOVLB  0
019AC:  BTFSC  FD8.2
019AE:  BRA    1F30
019B0:  MOVLB  7
019B2:  MOVLW  03
019B4:  SUBWF  03,W
019B6:  BNZ   19C4
019B8:  MOVLW  F1
019BA:  SUBWF  00,W
019BC:  MOVLB  0
019BE:  BTFSC  FD8.2
019C0:  BRA    1F40
019C2:  MOVLB  7
019C4:  MOVLW  03
019C6:  SUBWF  03,W
019C8:  BNZ   19D6
019CA:  MOVLW  F2
019CC:  SUBWF  00,W
019CE:  MOVLB  0
019D0:  BTFSC  FD8.2
019D2:  BRA    1F4E
019D4:  MOVLB  7
019D6:  MOVLW  03
019D8:  SUBWF  03,W
019DA:  BNZ   19E8
019DC:  MOVLW  F3
019DE:  SUBWF  00,W
019E0:  MOVLB  0
019E2:  BTFSC  FD8.2
019E4:  BRA    1F5C
019E6:  MOVLB  7
019E8:  MOVLW  03
019EA:  SUBWF  03,W
019EC:  BNZ   19FA
019EE:  MOVLW  F4
019F0:  SUBWF  00,W
019F2:  MOVLB  0
019F4:  BTFSC  FD8.2
019F6:  BRA    1F6C
019F8:  MOVLB  7
019FA:  BRA    1F7A
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
019FC:  MOVFF  A8,01
01A00:  MOVFF  A9,02
01A04:  MOVLB  7
01A06:  BRA    1F82
01A08:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01A0A:  MOVF   x96,W
01A0C:  MOVWF  01
01A0E:  MOVF   x97,W
01A10:  MOVWF  02
01A12:  MOVLB  7
01A14:  BRA    1F82
01A16:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01A18:  MOVF   x9C,W
01A1A:  MOVWF  01
01A1C:  MOVF   x9D,W
01A1E:  MOVWF  02
01A20:  MOVLB  7
01A22:  BRA    1F82
01A24:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01A26:  MOVF   xA2,W
01A28:  MOVWF  01
01A2A:  MOVF   xA3,W
01A2C:  MOVWF  02
01A2E:  MOVLB  7
01A30:  BRA    1F82
01A32:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01A34:  MOVLB  7
01A36:  CLRF   xED
01A38:  MOVLB  0
01A3A:  RCALL  133C
01A3C:  MOVFF  03,7C9
01A40:  MOVFF  02,7C8
01A44:  MOVFF  01,7C7
01A48:  MOVFF  00,7C6
01A4C:  MOVLB  7
01A4E:  MOVF   xC6,W
01A50:  MOVWF  01
01A52:  MOVF   xC7,W
01A54:  MOVWF  02
01A56:  BRA    1F82
01A58:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01A5A:  MOVLB  7
01A5C:  MOVF   xC8,W
01A5E:  MOVWF  01
01A60:  MOVF   xC9,W
01A62:  MOVWF  02
01A64:  BRA    1F82
01A66:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01A68:  MOVF   xAA,W
01A6A:  MOVWF  01
01A6C:  MOVF   xAB,W
01A6E:  MOVWF  02
01A70:  MOVLB  7
01A72:  BRA    1F82
01A74:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01A76:  MOVF   x98,W
01A78:  MOVWF  01
01A7A:  MOVF   x99,W
01A7C:  MOVWF  02
01A7E:  MOVLB  7
01A80:  BRA    1F82
01A82:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01A84:  MOVF   x9E,W
01A86:  MOVWF  01
01A88:  MOVF   x9F,W
01A8A:  MOVWF  02
01A8C:  MOVLB  7
01A8E:  BRA    1F82
01A90:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01A92:  MOVF   xA4,W
01A94:  MOVWF  01
01A96:  MOVF   xA5,W
01A98:  MOVWF  02
01A9A:  MOVLB  7
01A9C:  BRA    1F82
01A9E:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01AA0:  MOVLW  01
01AA2:  MOVLB  7
01AA4:  MOVWF  xED
01AA6:  MOVLB  0
01AA8:  RCALL  133C
01AAA:  MOVFF  03,7C9
01AAE:  MOVFF  02,7C8
01AB2:  MOVFF  01,7C7
01AB6:  MOVFF  00,7C6
01ABA:  MOVLB  7
01ABC:  MOVF   xC6,W
01ABE:  MOVWF  01
01AC0:  MOVF   xC7,W
01AC2:  MOVWF  02
01AC4:  BRA    1F82
01AC6:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01AC8:  MOVLB  7
01ACA:  MOVF   xC8,W
01ACC:  MOVWF  01
01ACE:  MOVF   xC9,W
01AD0:  MOVWF  02
01AD2:  BRA    1F82
01AD4:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01AD6:  MOVF   xAC,W
01AD8:  MOVWF  01
01ADA:  MOVF   xAD,W
01ADC:  MOVWF  02
01ADE:  MOVLB  7
01AE0:  BRA    1F82
01AE2:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01AE4:  MOVF   x9A,W
01AE6:  MOVWF  01
01AE8:  MOVF   x9B,W
01AEA:  MOVWF  02
01AEC:  MOVLB  7
01AEE:  BRA    1F82
01AF0:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01AF2:  MOVF   xA0,W
01AF4:  MOVWF  01
01AF6:  MOVF   xA1,W
01AF8:  MOVWF  02
01AFA:  MOVLB  7
01AFC:  BRA    1F82
01AFE:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01B00:  MOVF   xA6,W
01B02:  MOVWF  01
01B04:  MOVF   xA7,W
01B06:  MOVWF  02
01B08:  MOVLB  7
01B0A:  BRA    1F82
01B0C:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01B0E:  MOVLW  02
01B10:  MOVLB  7
01B12:  MOVWF  xED
01B14:  MOVLB  0
01B16:  RCALL  133C
01B18:  MOVFF  03,7C9
01B1C:  MOVFF  02,7C8
01B20:  MOVFF  01,7C7
01B24:  MOVFF  00,7C6
01B28:  MOVLB  7
01B2A:  MOVF   xC6,W
01B2C:  MOVWF  01
01B2E:  MOVF   xC7,W
01B30:  MOVWF  02
01B32:  BRA    1F82
01B34:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01B36:  MOVLB  7
01B38:  MOVF   xC8,W
01B3A:  MOVWF  01
01B3C:  MOVF   xC9,W
01B3E:  MOVWF  02
01B40:  BRA    1F82
01B42:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01B44:  CLRF   03
01B46:  MOVLB  1
01B48:  MOVF   xCA,W
01B4A:  MOVWF  02
01B4C:  BCF    FD8.0
01B4E:  RLCF   02,F
01B50:  RLCF   03,F
01B52:  MOVF   02,W
01B54:  ADDLW  CA
01B56:  MOVWF  FE9
01B58:  MOVLW  00
01B5A:  ADDWFC 03,W
01B5C:  MOVWF  FEA
01B5E:  MOVFF  FEC,03
01B62:  MOVF   FED,F
01B64:  MOVF   FEF,W
01B66:  MOVWF  01
01B68:  MOVF   03,W
01B6A:  MOVWF  02
01B6C:  MOVLB  7
01B6E:  BRA    1F82
01B70:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01B72:  MOVLB  7
01B74:  CLRF   xED
01B76:  MOVLB  0
01B78:  CALL   0F42
01B7C:  MOVF   01,W
01B7E:  MOVWF  01
01B80:  MOVF   02,W
01B82:  MOVWF  02
01B84:  MOVLB  7
01B86:  BRA    1F82
01B88:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01B8A:  MOVF   xBA,W
01B8C:  MOVWF  01
01B8E:  MOVF   xBB,W
01B90:  MOVWF  02
01B92:  MOVLB  7
01B94:  BRA    1F82
01B96:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01B98:  CLRF   03
01B9A:  MOVLB  1
01B9C:  MOVF   xCA,W
01B9E:  MOVWF  02
01BA0:  BCF    FD8.0
01BA2:  RLCF   02,F
01BA4:  RLCF   03,F
01BA6:  MOVF   02,W
01BA8:  ADDLW  EA
01BAA:  MOVWF  FE9
01BAC:  MOVLW  00
01BAE:  ADDWFC 03,W
01BB0:  MOVWF  FEA
01BB2:  MOVFF  FEC,03
01BB6:  MOVF   FED,F
01BB8:  MOVF   FEF,W
01BBA:  MOVWF  01
01BBC:  MOVF   03,W
01BBE:  MOVWF  02
01BC0:  MOVLB  7
01BC2:  BRA    1F82
01BC4:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01BC6:  MOVLW  01
01BC8:  MOVLB  7
01BCA:  MOVWF  xED
01BCC:  MOVLB  0
01BCE:  CALL   0F42
01BD2:  MOVF   01,W
01BD4:  MOVWF  01
01BD6:  MOVF   02,W
01BD8:  MOVWF  02
01BDA:  MOVLB  7
01BDC:  BRA    1F82
01BDE:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01BE0:  MOVF   xBC,W
01BE2:  MOVWF  01
01BE4:  MOVF   xBD,W
01BE6:  MOVWF  02
01BE8:  MOVLB  7
01BEA:  BRA    1F82
01BEC:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01BEE:  CLRF   03
01BF0:  MOVLB  1
01BF2:  MOVF   xCA,W
01BF4:  MOVWF  02
01BF6:  BCF    FD8.0
01BF8:  RLCF   02,F
01BFA:  RLCF   03,F
01BFC:  MOVF   02,W
01BFE:  ADDLW  0A
01C00:  MOVWF  FE9
01C02:  MOVLW  01
01C04:  ADDWFC 03,W
01C06:  MOVWF  FEA
01C08:  MOVFF  FEC,03
01C0C:  MOVF   FED,F
01C0E:  MOVF   FEF,W
01C10:  MOVWF  01
01C12:  MOVF   03,W
01C14:  MOVWF  02
01C16:  MOVLB  7
01C18:  BRA    1F82
01C1A:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01C1C:  MOVLW  02
01C1E:  MOVLB  7
01C20:  MOVWF  xED
01C22:  MOVLB  0
01C24:  CALL   0F42
01C28:  MOVF   01,W
01C2A:  MOVWF  01
01C2C:  MOVF   02,W
01C2E:  MOVWF  02
01C30:  MOVLB  7
01C32:  BRA    1F82
01C34:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01C36:  MOVF   xBE,W
01C38:  MOVWF  01
01C3A:  MOVF   xBF,W
01C3C:  MOVWF  02
01C3E:  MOVLB  7
01C40:  BRA    1F82
01C42:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01C44:  CLRF   03
01C46:  MOVLB  1
01C48:  MOVF   xCA,W
01C4A:  MOVWF  02
01C4C:  BCF    FD8.0
01C4E:  RLCF   02,F
01C50:  RLCF   03,F
01C52:  MOVF   02,W
01C54:  ADDLW  2A
01C56:  MOVWF  FE9
01C58:  MOVLW  01
01C5A:  ADDWFC 03,W
01C5C:  MOVWF  FEA
01C5E:  MOVFF  FEC,03
01C62:  MOVF   FED,F
01C64:  MOVF   FEF,W
01C66:  MOVWF  01
01C68:  MOVF   03,W
01C6A:  MOVWF  02
01C6C:  MOVLB  7
01C6E:  BRA    1F82
01C70:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01C72:  MOVLW  03
01C74:  MOVLB  7
01C76:  MOVWF  xED
01C78:  MOVLB  0
01C7A:  CALL   0F42
01C7E:  MOVF   01,W
01C80:  MOVWF  01
01C82:  MOVF   02,W
01C84:  MOVWF  02
01C86:  MOVLB  7
01C88:  BRA    1F82
01C8A:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01C8C:  MOVF   xC0,W
01C8E:  MOVWF  01
01C90:  MOVF   xC1,W
01C92:  MOVWF  02
01C94:  MOVLB  7
01C96:  BRA    1F82
01C98:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01C9A:  CLRF   03
01C9C:  MOVLB  1
01C9E:  MOVF   xCA,W
01CA0:  MOVWF  02
01CA2:  BCF    FD8.0
01CA4:  RLCF   02,F
01CA6:  RLCF   03,F
01CA8:  MOVF   02,W
01CAA:  ADDLW  4A
01CAC:  MOVWF  FE9
01CAE:  MOVLW  01
01CB0:  ADDWFC 03,W
01CB2:  MOVWF  FEA
01CB4:  MOVFF  FEC,03
01CB8:  MOVF   FED,F
01CBA:  MOVF   FEF,W
01CBC:  MOVWF  01
01CBE:  MOVF   03,W
01CC0:  MOVWF  02
01CC2:  MOVLB  7
01CC4:  BRA    1F82
01CC6:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01CC8:  MOVLW  04
01CCA:  MOVLB  7
01CCC:  MOVWF  xED
01CCE:  MOVLB  0
01CD0:  CALL   0F42
01CD4:  MOVF   01,W
01CD6:  MOVWF  01
01CD8:  MOVF   02,W
01CDA:  MOVWF  02
01CDC:  MOVLB  7
01CDE:  BRA    1F82
01CE0:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01CE2:  MOVF   xC2,W
01CE4:  MOVWF  01
01CE6:  MOVF   xC3,W
01CE8:  MOVWF  02
01CEA:  MOVLB  7
01CEC:  BRA    1F82
01CEE:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01CF0:  CLRF   03
01CF2:  MOVLB  1
01CF4:  MOVF   xCA,W
01CF6:  MOVWF  02
01CF8:  BCF    FD8.0
01CFA:  RLCF   02,F
01CFC:  RLCF   03,F
01CFE:  MOVF   02,W
01D00:  ADDLW  6A
01D02:  MOVWF  FE9
01D04:  MOVLW  01
01D06:  ADDWFC 03,W
01D08:  MOVWF  FEA
01D0A:  MOVFF  FEC,03
01D0E:  MOVF   FED,F
01D10:  MOVF   FEF,W
01D12:  MOVWF  01
01D14:  MOVF   03,W
01D16:  MOVWF  02
01D18:  MOVLB  7
01D1A:  BRA    1F82
01D1C:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01D1E:  MOVLW  05
01D20:  MOVLB  7
01D22:  MOVWF  xED
01D24:  MOVLB  0
01D26:  CALL   0F42
01D2A:  MOVF   01,W
01D2C:  MOVWF  01
01D2E:  MOVF   02,W
01D30:  MOVWF  02
01D32:  MOVLB  7
01D34:  BRA    1F82
01D36:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01D38:  MOVF   xC4,W
01D3A:  MOVWF  01
01D3C:  MOVF   xC5,W
01D3E:  MOVWF  02
01D40:  MOVLB  7
01D42:  BRA    1F82
01D44:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01D46:  CLRF   03
01D48:  MOVLB  1
01D4A:  MOVF   xCA,W
01D4C:  MOVWF  02
01D4E:  BCF    FD8.0
01D50:  RLCF   02,F
01D52:  RLCF   03,F
01D54:  MOVF   02,W
01D56:  ADDLW  8A
01D58:  MOVWF  FE9
01D5A:  MOVLW  01
01D5C:  ADDWFC 03,W
01D5E:  MOVWF  FEA
01D60:  MOVFF  FEC,03
01D64:  MOVF   FED,F
01D66:  MOVF   FEF,W
01D68:  MOVWF  01
01D6A:  MOVF   03,W
01D6C:  MOVWF  02
01D6E:  MOVLB  7
01D70:  BRA    1F82
01D72:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01D74:  MOVLW  06
01D76:  MOVLB  7
01D78:  MOVWF  xED
01D7A:  MOVLB  0
01D7C:  CALL   0F42
01D80:  MOVF   01,W
01D82:  MOVWF  01
01D84:  MOVF   02,W
01D86:  MOVWF  02
01D88:  MOVLB  7
01D8A:  BRA    1F82
01D8C:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01D8E:  MOVF   xC6,W
01D90:  MOVWF  01
01D92:  MOVF   xC7,W
01D94:  MOVWF  02
01D96:  MOVLB  7
01D98:  BRA    1F82
01D9A:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01D9C:  CLRF   03
01D9E:  MOVLB  1
01DA0:  MOVF   xCA,W
01DA2:  MOVWF  02
01DA4:  BCF    FD8.0
01DA6:  RLCF   02,F
01DA8:  RLCF   03,F
01DAA:  MOVF   02,W
01DAC:  ADDLW  AA
01DAE:  MOVWF  FE9
01DB0:  MOVLW  01
01DB2:  ADDWFC 03,W
01DB4:  MOVWF  FEA
01DB6:  MOVFF  FEC,03
01DBA:  MOVF   FED,F
01DBC:  MOVF   FEF,W
01DBE:  MOVWF  01
01DC0:  MOVF   03,W
01DC2:  MOVWF  02
01DC4:  MOVLB  7
01DC6:  BRA    1F82
01DC8:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01DCA:  MOVLW  07
01DCC:  MOVLB  7
01DCE:  MOVWF  xED
01DD0:  MOVLB  0
01DD2:  CALL   0F42
01DD6:  MOVF   01,W
01DD8:  MOVWF  01
01DDA:  MOVF   02,W
01DDC:  MOVWF  02
01DDE:  MOVLB  7
01DE0:  BRA    1F82
01DE2:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01DE4:  MOVF   xC8,W
01DE6:  MOVWF  01
01DE8:  MOVF   xC9,W
01DEA:  MOVWF  02
01DEC:  MOVLB  7
01DEE:  BRA    1F82
01DF0:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01DF2:  MOVLB  1
01DF4:  MOVF   xD2,W
01DF6:  MOVWF  03
01DF8:  MOVF   xD1,W
01DFA:  INCF   xD1,F
01DFC:  BTFSC  FD8.2
01DFE:  INCF   xD2,F
01E00:  MOVWF  01
01E02:  MOVF   03,W
01E04:  MOVWF  02
01E06:  MOVLB  7
01E08:  BRA    1F82
01E0A:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01E0C:  MOVLB  1
01E0E:  MOVF   xD5,W
01E10:  MOVWF  01
01E12:  MOVF   xD6,W
01E14:  MOVWF  02
01E16:  MOVLB  7
01E18:  BRA    1F82
01E1A:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01E1C:  MOVLB  1
01E1E:  MOVF   xD3,W
01E20:  MOVWF  01
01E22:  MOVF   xD4,W
01E24:  MOVWF  02
01E26:  MOVLB  7
01E28:  BRA    1F82
01E2A:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01E2C:  MOVLB  1
01E2E:  MOVF   xD8,W
01E30:  MOVWF  01
01E32:  MOVF   xD9,W
01E34:  MOVWF  02
01E36:  MOVLB  7
01E38:  BRA    1F82
01E3A:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01E3C:  GOTO   139E
01E40:  MOVLW  00
01E42:  MOVWF  01
01E44:  MOVWF  02
01E46:  MOVLB  7
01E48:  BRA    1F82
01E4A:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01E4C:  GOTO   13DA
01E50:  MOVLW  00
01E52:  MOVWF  01
01E54:  MOVWF  02
01E56:  MOVLB  7
01E58:  BRA    1F82
01E5A:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01E5C:  MOVLB  1
01E5E:  MOVF   xCB,W
01E60:  MOVWF  01
01E62:  MOVF   xCC,W
01E64:  MOVWF  02
01E66:  MOVLB  7
01E68:  BRA    1F82
01E6A:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01E6C:  MOVLB  1
01E6E:  MOVF   xCD,W
01E70:  MOVWF  01
01E72:  MOVF   xCE,W
01E74:  MOVWF  02
01E76:  MOVLB  7
01E78:  BRA    1F82
01E7A:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01E7C:  MOVLB  1
01E7E:  MOVF   xCF,W
01E80:  MOVWF  01
01E82:  MOVF   xD0,W
01E84:  MOVWF  02
01E86:  MOVLB  7
01E88:  BRA    1F82
01E8A:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01E8C:  GOTO   1402
01E90:  MOVLW  00
01E92:  MOVWF  01
01E94:  MOVWF  02
01E96:  MOVLB  7
01E98:  BRA    1F82
01E9A:  MOVLB  0
.................... 		case 52: return (int16) current.rda_bytes_received; 
01E9C:  MOVLB  1
01E9E:  MOVF   xE1,W
01EA0:  MOVWF  01
01EA2:  MOVF   xE2,W
01EA4:  MOVWF  02
01EA6:  MOVLB  7
01EA8:  BRA    1F82
01EAA:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
01EAC:  MOVLB  1
01EAE:  MOVF   xE3,W
01EB0:  MOVWF  01
01EB2:  MOVF   xE4,W
01EB4:  MOVWF  02
01EB6:  MOVLB  7
01EB8:  BRA    1F82
01EBA:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01EBC:  CLRF   03
01EBE:  MOVF   39,W
01EC0:  MOVWF  01
01EC2:  MOVF   03,W
01EC4:  MOVWF  02
01EC6:  MOVLB  7
01EC8:  BRA    1F82
01ECA:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01ECC:  MOVF   3A,W
01ECE:  MOVWF  01
01ED0:  MOVF   3B,W
01ED2:  MOVWF  02
01ED4:  MOVLB  7
01ED6:  BRA    1F82
01ED8:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01EDA:  MOVLW  50
01EDC:  MOVWF  01
01EDE:  MOVLW  00
01EE0:  MOVWF  02
01EE2:  MOVLB  7
01EE4:  BRA    1F82
01EE6:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01EE8:  MOVLW  57
01EEA:  MOVWF  01
01EEC:  MOVLW  00
01EEE:  MOVWF  02
01EF0:  MOVLB  7
01EF2:  BRA    1F82
01EF4:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01EF6:  MOVLW  58
01EF8:  MOVWF  01
01EFA:  MOVLW  00
01EFC:  MOVWF  02
01EFE:  MOVLB  7
01F00:  BRA    1F82
01F02:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01F04:  MOVLW  01
01F06:  MOVWF  01
01F08:  MOVLW  00
01F0A:  MOVWF  02
01F0C:  MOVLB  7
01F0E:  BRA    1F82
01F10:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01F12:  CLRF   03
01F14:  MOVF   36,W
01F16:  MOVWF  01
01F18:  MOVF   03,W
01F1A:  MOVWF  02
01F1C:  MOVLB  7
01F1E:  BRA    1F82
01F20:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01F22:  MOVF   3C,W
01F24:  MOVWF  01
01F26:  MOVF   3D,W
01F28:  MOVWF  02
01F2A:  MOVLB  7
01F2C:  BRA    1F82
01F2E:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01F30:  CLRF   03
01F32:  MOVF   3E,W
01F34:  MOVWF  01
01F36:  MOVF   03,W
01F38:  MOVWF  02
01F3A:  MOVLB  7
01F3C:  BRA    1F82
01F3E:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01F40:  MOVF   3F,W
01F42:  MOVWF  01
01F44:  MOVF   40,W
01F46:  MOVWF  02
01F48:  MOVLB  7
01F4A:  BRA    1F82
01F4C:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01F4E:  MOVF   41,W
01F50:  MOVWF  01
01F52:  MOVF   42,W
01F54:  MOVWF  02
01F56:  MOVLB  7
01F58:  BRA    1F82
01F5A:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01F5C:  CLRF   03
01F5E:  MOVF   43,W
01F60:  MOVWF  01
01F62:  MOVF   03,W
01F64:  MOVWF  02
01F66:  MOVLB  7
01F68:  BRA    1F82
01F6A:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
01F6C:  CLRF   03
01F6E:  MOVF   38,W
01F70:  MOVWF  01
01F72:  MOVF   03,W
01F74:  MOVWF  02
01F76:  MOVLB  7
01F78:  BRA    1F82
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01F7A:  MOVLW  FF
01F7C:  MOVWF  01
01F7E:  MOVWF  02
01F80:  BRA    1F82
.................... 	} 
....................  
.................... } 
01F82:  MOVLB  0
01F84:  GOTO   1FD6 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01196:  MOVLB  7
01198:  MOVF   xDD,W
0119A:  SUBLW  1F
0119C:  BNZ   11B6
0119E:  MOVF   xDE,W
011A0:  SUBLW  4E
011A2:  BNZ   11B6
011A4:  MOVF   xDF,W
011A6:  SUBLW  20
011A8:  BNZ   11B6
011AA:  MOVF   xE0,W
011AC:  SUBLW  4E
011AE:  BNZ   11B6
.................... 		return 1; 
011B0:  MOVLW  01
011B2:  MOVWF  01
011B4:  BRA    127E
....................  
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
011B6:  MOVF   xDE,W
011B8:  SUBLW  16
011BA:  BC    11DA
011BC:  XORLW  FF
011BE:  BNZ   11C6
011C0:  MOVF   xDD,W
011C2:  SUBLW  6F
011C4:  BC    11DA
011C6:  MOVF   xE0,W
011C8:  SUBLW  19
011CA:  BNC   11DA
011CC:  BNZ   11D4
011CE:  MOVF   xDF,W
011D0:  SUBLW  50
011D2:  BNC   11DA
.................... 		return 1; 
011D4:  MOVLW  01
011D6:  MOVWF  01
011D8:  BRA    127E
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
011DA:  MOVF   xDE,W
011DC:  SUBLW  12
011DE:  BC    11FE
011E0:  XORLW  FF
011E2:  BNZ   11EA
011E4:  MOVF   xDD,W
011E6:  SUBLW  87
011E8:  BC    11FE
011EA:  MOVF   xE0,W
011EC:  SUBLW  17
011EE:  BNC   11FE
011F0:  BNZ   11F8
011F2:  MOVF   xDF,W
011F4:  SUBLW  48
011F6:  BNC   11FE
.................... 		return 1; 
011F8:  MOVLW  01
011FA:  MOVWF  01
011FC:  BRA    127E
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
011FE:  MOVF   xDE,W
01200:  SUBLW  03
01202:  BC    1222
01204:  XORLW  FF
01206:  BNZ   120E
01208:  MOVF   xDD,W
0120A:  SUBLW  4B
0120C:  BC    1222
0120E:  MOVF   xE0,W
01210:  SUBLW  04
01212:  BNC   1222
01214:  BNZ   121C
01216:  MOVF   xDF,W
01218:  SUBLW  94
0121A:  BNC   1222
.................... 		return 1; 
0121C:  MOVLW  01
0121E:  MOVWF  01
01220:  BRA    127E
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
01222:  MOVF   xDE,W
01224:  SUBLW  02
01226:  BC    1246
01228:  XORLW  FF
0122A:  BNZ   1232
0122C:  MOVF   xDD,W
0122E:  SUBLW  E7
01230:  BC    1246
01232:  MOVF   xE0,W
01234:  SUBLW  03
01236:  BNC   1246
01238:  BNZ   1240
0123A:  MOVF   xDF,W
0123C:  SUBLW  F5
0123E:  BNC   1246
.................... 		return 1; 
01240:  MOVLW  01
01242:  MOVWF  01
01244:  BRA    127E
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
01246:  MOVF   xDE,W
01248:  SUBLW  06
0124A:  BC    126A
0124C:  XORLW  FF
0124E:  BNZ   1256
01250:  MOVF   xDD,W
01252:  SUBLW  CF
01254:  BC    126A
01256:  MOVF   xE0,W
01258:  SUBLW  09
0125A:  BNC   126A
0125C:  BNZ   1264
0125E:  MOVF   xDF,W
01260:  SUBLW  D1
01262:  BNC   126A
.................... 		return 1; 
01264:  MOVLW  01
01266:  MOVWF  01
01268:  BRA    127E
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
0126A:  MOVF   xE0,F
0126C:  BNZ   127A
0126E:  MOVF   xDF,W
01270:  SUBLW  36
01272:  BNC   127A
.................... 		return 1; 
01274:  MOVLW  01
01276:  MOVWF  01
01278:  BRA    127E
....................  
.................... 	return 0; 
0127A:  MOVLW  00
0127C:  MOVWF  01
.................... } 
0127E:  MOVLB  0
01280:  GOTO   24D2 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01F88:  MOVFF  7DC,7E5
01F8C:  MOVFF  7DB,7E6
01F90:  CALL   12C0
.................... 	modbus_serial_putc(register_count*2); 
01F94:  BCF    FD8.0
01F96:  MOVLB  7
01F98:  RLCF   xDF,W
01F9A:  MOVWF  xE5
01F9C:  RLCF   xE0,W
01F9E:  MOVWF  xE6
01FA0:  MOVFF  7E5,7E7
01FA4:  MOVLB  0
01FA6:  CALL   128C
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01FAA:  MOVLB  7
01FAC:  CLRF   xE2
01FAE:  CLRF   xE1
01FB0:  MOVF   xE2,W
01FB2:  SUBWF  xE0,W
01FB4:  BNC   2000
01FB6:  BNZ   1FBE
01FB8:  MOVF   xDF,W
01FBA:  SUBWF  xE1,W
01FBC:  BC    2000
.................... 		l=map_modbus(start_address+i); 
01FBE:  MOVF   xE1,W
01FC0:  ADDWF  xDD,W
01FC2:  MOVWF  xE5
01FC4:  MOVF   xE2,W
01FC6:  ADDWFC xDE,W
01FC8:  MOVWF  xE6
01FCA:  MOVWF  xE8
01FCC:  MOVFF  7E5,7E7
01FD0:  MOVLB  0
01FD2:  GOTO   1416
01FD6:  MOVFF  02,7E4
01FDA:  MOVFF  01,7E3
.................... 		modbus_serial_putc(make8(l,1)); 
01FDE:  MOVFF  7E4,7E5
01FE2:  MOVFF  7E4,7E7
01FE6:  CALL   128C
....................   		modbus_serial_putc(make8(l,0)); 
01FEA:  MOVFF  7E3,7E5
01FEE:  MOVFF  7E3,7E7
01FF2:  CALL   128C
.................... 	} 
01FF6:  MOVLB  7
01FF8:  INCF   xE1,F
01FFA:  BTFSC  FD8.2
01FFC:  INCF   xE2,F
01FFE:  BRA    1FB0
....................  
.................... 	modbus_serial_send_stop(); 
02000:  MOVLB  0
02002:  CALL   12EE
.................... } 
02006:  GOTO   2514 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
0200A:  MOVLB  7
0200C:  MOVF   xE2,W
0200E:  SUBLW  06
02010:  BC    2088
02012:  XORLW  FF
02014:  BNZ   201C
02016:  MOVF   xE1,W
02018:  SUBLW  CF
0201A:  BC    2088
0201C:  MOVF   xE2,W
0201E:  SUBLW  09
02020:  BNC   2088
02022:  BNZ   202A
02024:  MOVF   xE1,W
02026:  SUBLW  CF
02028:  BNC   2088
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
0202A:  MOVF   xE4,W
0202C:  SUBLW  00
0202E:  BC    2040
02030:  XORLW  FF
02032:  BNZ   203A
02034:  MOVF   xE3,W
02036:  SUBLW  00
02038:  BC    2040
0203A:  MOVLW  03
0203C:  MOVWF  01
0203E:  BRA    230A
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
02040:  MOVLW  D0
02042:  SUBWF  xE1,W
02044:  MOVWF  xE7
02046:  MOVLW  07
02048:  SUBWFB xE2,W
0204A:  MOVWF  xE8
0204C:  MOVLW  02
0204E:  ADDWF  xE8,F
02050:  MOVFF  7E8,FAA
02054:  MOVFF  7E7,FA9
02058:  MOVFF  7E3,FA8
0205C:  BCF    FA6.6
0205E:  BCF    FA6.7
02060:  BSF    FA6.2
02062:  MOVF   FF2,W
02064:  MOVWF  00
02066:  BCF    FF2.6
02068:  BCF    FF2.7
0206A:  MOVLB  F
0206C:  MOVLW  55
0206E:  MOVWF  FA7
02070:  MOVLW  AA
02072:  MOVWF  FA7
02074:  BSF    FA6.1
02076:  BTFSC  FA6.1
02078:  BRA    2076
0207A:  BCF    FA6.2
0207C:  MOVF   00,W
0207E:  IORWF  FF2,F
.................... 		return 0; 
02080:  MOVLW  00
02082:  MOVWF  01
02084:  MOVLB  7
02086:  BRA    230A
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
02088:  MOVF   xE2,W
0208A:  SUBLW  03
0208C:  BC    211E
0208E:  XORLW  FF
02090:  BNZ   2098
02092:  MOVF   xE1,W
02094:  SUBLW  4B
02096:  BC    211E
02098:  MOVF   xE2,W
0209A:  SUBLW  04
0209C:  BNC   211E
0209E:  BNZ   20A6
020A0:  MOVF   xE1,W
020A2:  SUBLW  93
020A4:  BNC   211E
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
020A6:  MOVF   xE4,W
020A8:  SUBLW  00
020AA:  BC    20BC
020AC:  XORLW  FF
020AE:  BNZ   20B6
020B0:  MOVF   xE3,W
020B2:  SUBLW  00
020B4:  BC    20BC
020B6:  MOVLW  03
020B8:  MOVWF  01
020BA:  BRA    230A
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
020BC:  MOVLW  4C
020BE:  SUBWF  xE1,W
020C0:  MOVWF  xE5
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
020C2:  MOVFF  7E5,7ED
020C6:  MOVLW  06
020C8:  MOVWF  xEE
020CA:  MOVLB  0
020CC:  CALL   0A4E
020D0:  MOVFF  00,7E6
.................... 		n = n / 6; /* number of sentence */ 
020D4:  MOVFF  7E5,7ED
020D8:  MOVLW  06
020DA:  MOVLB  7
020DC:  MOVWF  xEE
020DE:  MOVLB  0
020E0:  CALL   0A4E
020E4:  MOVFF  01,7E5
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
020E8:  MOVLB  7
020EA:  MOVF   xE5,W
020EC:  MULLW  06
020EE:  MOVF   FF3,W
020F0:  CLRF   03
020F2:  ADDLW  18
020F4:  MOVWF  xE7
020F6:  MOVLW  00
020F8:  ADDWFC 03,W
020FA:  MOVWF  xE8
020FC:  CLRF   03
020FE:  MOVF   xE6,W
02100:  ADDWF  xE7,W
02102:  MOVWF  01
02104:  MOVF   xE8,W
02106:  ADDWFC 03,F
02108:  MOVF   01,W
0210A:  ADDLW  36
0210C:  MOVWF  FE9
0210E:  MOVLW  00
02110:  ADDWFC 03,W
02112:  MOVWF  FEA
02114:  MOVFF  7E3,FEF
.................... 		 
.................... 		return 0; 
02118:  MOVLW  00
0211A:  MOVWF  01
0211C:  BRA    230A
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
0211E:  MOVLB  1
02120:  MOVF   xD7,F
02122:  BZ    215A
.................... 		if ( 1000 == address ) { 
02124:  MOVLB  7
02126:  MOVF   xE1,W
02128:  SUBLW  E8
0212A:  BNZ   213E
0212C:  MOVF   xE2,W
0212E:  SUBLW  03
02130:  BNZ   213E
.................... 			config.serial_prefix=value; 
02132:  MOVFF  7E3,39
.................... 			return 0; 
02136:  MOVLW  00
02138:  MOVWF  01
0213A:  BRA    230A
.................... 		} else if ( 1001 == address ) { 
0213C:  BRA    2158
0213E:  MOVF   xE1,W
02140:  SUBLW  E9
02142:  BNZ   2158
02144:  MOVF   xE2,W
02146:  SUBLW  03
02148:  BNZ   2158
.................... 			config.serial_number=value; 
0214A:  MOVFF  7E4,3B
0214E:  MOVFF  7E3,3A
.................... 			return 0; 
02152:  MOVLW  00
02154:  MOVWF  01
02156:  BRA    230A
02158:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
0215A:  MOVLB  7
0215C:  MOVF   xE1,W
0215E:  MOVWF  00
02160:  MOVF   xE2,W
02162:  MOVWF  03
02164:  MOVLW  03
02166:  SUBWF  03,W
02168:  BNZ   2174
0216A:  MOVLW  EE
0216C:  SUBWF  00,W
0216E:  MOVLB  0
02170:  BZ    220E
02172:  MOVLB  7
02174:  MOVLW  03
02176:  SUBWF  03,W
02178:  BNZ   2184
0217A:  MOVLW  EF
0217C:  SUBWF  00,W
0217E:  MOVLB  0
02180:  BZ    2226
02182:  MOVLB  7
02184:  MOVLW  03
02186:  SUBWF  03,W
02188:  BNZ   2194
0218A:  MOVLW  F0
0218C:  SUBWF  00,W
0218E:  MOVLB  0
02190:  BZ    2236
02192:  MOVLB  7
02194:  MOVLW  03
02196:  SUBWF  03,W
02198:  BNZ   21A4
0219A:  MOVLW  F1
0219C:  SUBWF  00,W
0219E:  MOVLB  0
021A0:  BZ    224E
021A2:  MOVLB  7
021A4:  MOVLW  03
021A6:  SUBWF  03,W
021A8:  BNZ   21B4
021AA:  MOVLW  F2
021AC:  SUBWF  00,W
021AE:  MOVLB  0
021B0:  BZ    225A
021B2:  MOVLB  7
021B4:  MOVLW  03
021B6:  SUBWF  03,W
021B8:  BNZ   21C4
021BA:  MOVLW  F3
021BC:  SUBWF  00,W
021BE:  MOVLB  0
021C0:  BZ    2274
021C2:  MOVLB  7
021C4:  MOVLW  03
021C6:  SUBWF  03,W
021C8:  BNZ   21D6
021CA:  MOVLW  F4
021CC:  SUBWF  00,W
021CE:  MOVLB  0
021D0:  BTFSC  FD8.2
021D2:  BRA    228C
021D4:  MOVLB  7
021D6:  MOVLW  07
021D8:  SUBWF  03,W
021DA:  BNZ   21E8
021DC:  MOVLW  CE
021DE:  SUBWF  00,W
021E0:  MOVLB  0
021E2:  BTFSC  FD8.2
021E4:  BRA    22A4
021E6:  MOVLB  7
021E8:  MOVLW  07
021EA:  SUBWF  03,W
021EC:  BNZ   21FA
021EE:  MOVLW  CF
021F0:  SUBWF  00,W
021F2:  MOVLB  0
021F4:  BTFSC  FD8.2
021F6:  BRA    22BE
021F8:  MOVLB  7
021FA:  MOVLW  4E
021FC:  SUBWF  03,W
021FE:  BNZ   220C
02200:  MOVLW  1F
02202:  SUBWF  00,W
02204:  MOVLB  0
02206:  BTFSC  FD8.2
02208:  BRA    22D8
0220A:  MOVLB  7
0220C:  BRA    2300
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
0220E:  MOVLB  7
02210:  MOVF   xE4,F
02212:  BNZ   221A
02214:  MOVF   xE3,W
02216:  SUBLW  80
02218:  BC    2220
0221A:  MOVLW  03
0221C:  MOVWF  01
0221E:  BRA    230A
.................... 			config.modbus_address=value; 
02220:  MOVFF  7E3,36
.................... 			break; 
02224:  BRA    2306
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
02226:  MOVLB  1
02228:  BSF    xF9.1
.................... 			config.adc_sample_ticks=value; 
0222A:  MOVFF  7E4,3D
0222E:  MOVFF  7E3,3C
.................... 			break; 
02232:  MOVLB  7
02234:  BRA    2306
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02236:  MOVLB  7
02238:  MOVF   xE4,F
0223A:  BNZ   2242
0223C:  MOVF   xE3,W
0223E:  SUBLW  01
02240:  BC    2248
02242:  MOVLW  03
02244:  MOVWF  01
02246:  BRA    230A
.................... 			config.allow_bootload_request=value; 
02248:  MOVFF  7E3,3E
.................... 			break; 
0224C:  BRA    2306
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
0224E:  MOVFF  7E4,40
02252:  MOVFF  7E3,3F
.................... 			break; 
02256:  MOVLB  7
02258:  BRA    2306
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
0225A:  MOVLB  7
0225C:  MOVF   xE3,F
0225E:  BNZ   226A
02260:  MOVF   xE4,F
02262:  BNZ   226A
02264:  MOVLW  03
02266:  MOVWF  01
02268:  BRA    230A
.................... 			config.pi_offtime_seconds=value; 
0226A:  MOVFF  7E4,42
0226E:  MOVFF  7E3,41
.................... 			break; 
02272:  BRA    2306
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02274:  MOVLB  7
02276:  MOVF   xE4,F
02278:  BNZ   2280
0227A:  MOVF   xE3,W
0227C:  SUBLW  01
0227E:  BC    2286
02280:  MOVLW  03
02282:  MOVWF  01
02284:  BRA    230A
.................... 			config.power_startup=value; 
02286:  MOVFF  7E3,43
.................... 			break; 
0228A:  BRA    2306
....................  
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
0228C:  MOVLB  7
0228E:  MOVF   xE4,F
02290:  BNZ   2298
02292:  MOVF   xE3,W
02294:  SUBLW  02
02296:  BC    229E
02298:  MOVLW  03
0229A:  MOVWF  01
0229C:  BRA    230A
.................... 			config.rs485_port_mode=value; 
0229E:  MOVFF  7E3,38
.................... 			break; 
022A2:  BRA    2306
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
022A4:  MOVLB  7
022A6:  DECFSZ xE3,W
022A8:  BRA    22AE
022AA:  MOVF   xE4,F
022AC:  BZ    22B4
022AE:  MOVLW  03
022B0:  MOVWF  01
022B2:  BRA    230A
.................... 			write_default_param_file(); 
022B4:  MOVLB  0
022B6:  CALL   0C86
.................... 			break; 
022BA:  MOVLB  7
022BC:  BRA    2306
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
022BE:  MOVLB  7
022C0:  DECFSZ xE3,W
022C2:  BRA    22C8
022C4:  MOVF   xE4,F
022C6:  BZ    22CE
022C8:  MOVLW  03
022CA:  MOVWF  01
022CC:  BRA    230A
.................... 			write_param_file(); 
022CE:  MOVLB  0
022D0:  CALL   0C32
.................... 			break; 
022D4:  MOVLB  7
022D6:  BRA    2306
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
022D8:  MOVLB  7
022DA:  MOVF   xE3,W
022DC:  SUBLW  0A
022DE:  BNZ   22E6
022E0:  MOVF   xE4,W
022E2:  SUBLW  07
022E4:  BZ    22F2
.................... 				current.factory_unlocked=0; 
022E6:  MOVLB  1
022E8:  CLRF   xD7
.................... 				return ILLEGAL_DATA_VALUE; 
022EA:  MOVLW  03
022EC:  MOVWF  01
022EE:  MOVLB  7
022F0:  BRA    230A
.................... 			} 
.................... 			current.factory_unlocked=1; 
022F2:  MOVLW  01
022F4:  MOVLB  1
022F6:  MOVWF  xD7
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
022F8:  MOVLW  C8
022FA:  MOVWF  xF6
.................... 			break; 
022FC:  MOVLB  7
022FE:  BRA    2306
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02300:  MOVLW  02
02302:  MOVWF  01
02304:  BRA    230A
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02306:  MOVLW  00
02308:  MOVWF  01
.................... } 
0230A:  MOVLB  0
0230C:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
0239E:  GOTO   1148
023A2:  MOVF   01,F
023A4:  BTFSC  FD8.2
023A6:  BRA    268A
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
023A8:  DECFSZ 38,W
023AA:  BRA    245E
023AC:  MOVF   36,W
023AE:  MOVLB  6
023B0:  SUBWF  xC3,W
023B2:  BTFSS  FD8.2
023B4:  BRA    23BA
023B6:  MOVLB  0
023B8:  BRA    245E
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
023BA:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
023BC:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
023BE:  CLRWDT
023C0:  MOVLW  02
023C2:  MOVLB  7
023C4:  MOVWF  xDB
023C6:  MOVLW  B5
023C8:  MOVWF  xDC
023CA:  MOVLB  0
023CC:  CALL   116E
023D0:  MOVLB  7
023D2:  DECFSZ xDB,F
023D4:  BRA    23C6
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
023D6:  MOVLB  6
023D8:  MOVF   xC3,W
023DA:  MOVLB  0
023DC:  CALL   118E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
023E0:  CLRWDT
023E2:  MOVLW  67
023E4:  MOVWF  00
023E6:  DECFSZ 00,F
023E8:  BRA    23E6
023EA:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
023EC:  MOVLB  6
023EE:  MOVF   xC5,W
023F0:  MOVLB  0
023F2:  CALL   118E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
023F6:  CLRWDT
023F8:  MOVLW  67
023FA:  MOVWF  00
023FC:  DECFSZ 00,F
023FE:  BRA    23FC
02400:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02402:  MOVLB  7
02404:  CLRF   xDA
02406:  MOVLW  02
02408:  MOVLB  6
0240A:  ADDWF  xC4,W
0240C:  MOVLB  7
0240E:  SUBWF  xDA,W
02410:  BC    243E
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02412:  MOVLW  C7
02414:  ADDWF  xDA,W
02416:  MOVWF  FE9
02418:  MOVLW  06
0241A:  MOVWF  FEA
0241C:  BTFSC  FD8.0
0241E:  INCF   FEA,F
02420:  MOVFF  FEF,7DB
02424:  MOVF   xDB,W
02426:  MOVLB  0
02428:  CALL   118E
.................... 				delay_us(104); //one stop bit @ 9600 baud 
0242C:  CLRWDT
0242E:  MOVLW  67
02430:  MOVWF  00
02432:  DECFSZ 00,F
02434:  BRA    2432
02436:  NOP   
.................... 			} 
02438:  MOVLB  7
0243A:  INCF   xDA,F
0243C:  BRA    2406
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
0243E:  BTFSS  F72.1
02440:  BRA    243E
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02442:  CLRWDT
02444:  MOVLW  02
02446:  MOVWF  xDB
02448:  MOVLW  B5
0244A:  MOVWF  xDC
0244C:  MOVLB  0
0244E:  CALL   116E
02452:  MOVLB  7
02454:  DECFSZ xDB,F
02456:  BRA    2448
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02458:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
0245A:  BCF    F8C.0
0245C:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
0245E:  MOVF   36,W
02460:  SUBLW  80
02462:  BZ    2470
02464:  MOVF   36,W
02466:  MOVLB  6
02468:  SUBWF  xC3,W
0246A:  BTFSS  FD8.2
0246C:  BRA    2674
0246E:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02470:  MOVLB  1
02472:  INCFSZ xCB,W
02474:  BRA    247C
02476:  INCFSZ xCC,W
02478:  BRA    247C
0247A:  BRA    2482
.................... 				current.modbus_our_packets++; 
0247C:  INCF   xCB,F
0247E:  BTFSC  FD8.2
02480:  INCF   xCC,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02482:  MOVLW  14
02484:  MOVWF  xF6
....................  
.................... 			switch(modbus_rx.func) { 
02486:  MOVLB  6
02488:  MOVF   xC5,W
0248A:  XORLW  03
0248C:  MOVLB  0
0248E:  BZ    24A0
02490:  XORLW  07
02492:  BZ    24A0
02494:  XORLW  02
02496:  BZ    2518
02498:  XORLW  16
0249A:  BTFSC  FD8.2
0249C:  BRA    258A
0249E:  BRA    264C
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
024A0:  MOVFF  6C7,7D6
024A4:  MOVFF  6C8,7D5
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
024A8:  MOVFF  6C9,7D8
024AC:  MOVFF  6CA,7D7
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
024B0:  MOVLB  7
024B2:  MOVF   xD7,W
024B4:  ADDWF  xD5,W
024B6:  MOVWF  xDB
024B8:  MOVF   xD8,W
024BA:  ADDWFC xD6,W
024BC:  MOVWF  xDC
024BE:  MOVFF  7D6,7DE
024C2:  MOVFF  7D5,7DD
024C6:  MOVWF  xE0
024C8:  MOVFF  7DB,7DF
024CC:  MOVLB  0
024CE:  GOTO   1196
024D2:  MOVF   01,F
024D4:  BNZ   24FA
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
024D6:  MOVFF  6C3,7DB
024DA:  MOVLB  7
024DC:  CLRF   xDD
024DE:  MOVFF  6C5,7DC
024E2:  MOVLW  02
024E4:  MOVWF  xDE
024E6:  MOVLB  0
024E8:  CALL   131C
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
024EC:  MOVLB  1
024EE:  CLRF   xD0
024F0:  MOVLW  02
024F2:  MOVWF  xCF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
024F4:  CLRF   xF6
.................... 					} else { 
024F6:  BRA    2516
024F8:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
024FA:  MOVFF  6C5,7DB
024FE:  MOVFF  6C3,7DC
02502:  MOVFF  7D6,7DE
02506:  MOVFF  7D5,7DD
0250A:  MOVFF  7D8,7E0
0250E:  MOVFF  7D7,7DF
02512:  BRA    1F88
02514:  MOVLB  1
.................... 					} 
.................... 					break; 
02516:  BRA    266C
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02518:  MOVFF  6C7,7D6
0251C:  MOVFF  6C8,7D5
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02520:  MOVFF  6C9,7DC
02524:  MOVFF  6CA,7DB
02528:  MOVFF  7D6,7E2
0252C:  MOVFF  7D5,7E1
02530:  MOVFF  6C9,7E4
02534:  MOVFF  6CA,7E3
02538:  RCALL  200A
0253A:  MOVFF  01,7D9
....................  
.................... 					if ( result ) { 
0253E:  MOVLB  7
02540:  MOVF   xD9,F
02542:  BZ    2566
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02544:  MOVFF  6C3,7DB
02548:  CLRF   xDD
0254A:  MOVFF  6C5,7DC
0254E:  MOVFF  7D9,7DE
02552:  MOVLB  0
02554:  CALL   131C
.................... 						current.modbus_last_error=result; 
02558:  MOVLB  1
0255A:  CLRF   xD0
0255C:  MOVFF  7D9,1CF
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02560:  CLRF   xF6
.................... 					}  else { 
02562:  BRA    2588
02564:  MOVLB  7
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02566:  MOVFF  6C9,7DC
0256A:  MOVFF  6CA,7DB
0256E:  MOVFF  6C3,7DD
02572:  MOVFF  7D6,7DF
02576:  MOVFF  7D5,7DE
0257A:  MOVFF  6C9,7E1
0257E:  MOVFF  6CA,7E0
02582:  MOVLB  0
02584:  BRA    230E
02586:  MOVLB  1
.................... 					} 
.................... 					break; 
02588:  BRA    266C
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0258A:  MOVFF  6C7,7D6
0258E:  MOVFF  6C8,7D5
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02592:  MOVFF  6C9,7D8
02596:  MOVFF  6CA,7D7
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
0259A:  MOVLB  7
0259C:  CLRF   xDA
0259E:  MOVF   xD8,F
025A0:  BNZ   25A8
025A2:  MOVF   xD7,W
025A4:  SUBWF  xDA,W
025A6:  BC    262C
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
025A8:  MOVF   xDA,W
025AA:  ADDWF  xD5,W
025AC:  MOVWF  xDB
025AE:  MOVLW  00
025B0:  ADDWFC xD6,W
025B2:  MOVWF  xDC
025B4:  BCF    FD8.0
025B6:  RLCF   xDA,W
025B8:  ADDLW  05
025BA:  ADDLW  C7
025BC:  MOVWF  FE9
025BE:  MOVLW  06
025C0:  MOVWF  FEA
025C2:  BTFSC  FD8.0
025C4:  INCF   FEA,F
025C6:  MOVFF  FEF,7DD
025CA:  BCF    FD8.0
025CC:  RLCF   xDA,W
025CE:  ADDLW  06
025D0:  ADDLW  C7
025D2:  MOVWF  FE9
025D4:  MOVLW  06
025D6:  MOVWF  FEA
025D8:  BTFSC  FD8.0
025DA:  INCF   FEA,F
025DC:  MOVFF  FEF,7DE
025E0:  MOVFF  7DD,7E0
025E4:  MOVFF  7DE,7DF
025E8:  MOVFF  7DC,7E2
025EC:  MOVFF  7DB,7E1
025F0:  MOVFF  7DD,7E4
025F4:  MOVFF  7DE,7E3
025F8:  MOVLB  0
025FA:  RCALL  200A
025FC:  MOVFF  01,7D9
....................  
.................... 						if ( result ) { 
02600:  MOVLB  7
02602:  MOVF   xD9,F
02604:  BZ    2628
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02606:  MOVFF  6C3,7DB
0260A:  CLRF   xDD
0260C:  MOVFF  6C5,7DC
02610:  MOVFF  7D9,7DE
02614:  MOVLB  0
02616:  CALL   131C
.................... 							current.modbus_last_error=result; 
0261A:  MOVLB  1
0261C:  CLRF   xD0
0261E:  MOVFF  7D9,1CF
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02622:  CLRF   xF6
.................... 			 
.................... 							break; 
02624:  MOVLB  7
02626:  BRA    262C
.................... 						} 
.................... 					} 
02628:  INCF   xDA,F
0262A:  BRA    259E
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
0262C:  MOVF   xD9,F
0262E:  BNZ   2648
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02630:  MOVFF  6C3,7DB
02634:  MOVFF  7D6,7DD
02638:  MOVFF  7D5,7DC
0263C:  MOVFF  7D8,7DF
02640:  MOVFF  7D7,7DE
02644:  MOVLB  0
02646:  BRA    2356
.................... 					} 
....................  
.................... 					break;   
02648:  MOVLB  1
0264A:  BRA    266C
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
0264C:  MOVFF  6C3,7DB
02650:  MOVLB  7
02652:  CLRF   xDD
02654:  MOVFF  6C5,7DC
02658:  MOVLW  01
0265A:  MOVWF  xDE
0265C:  MOVLB  0
0265E:  CALL   131C
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02662:  MOVLB  1
02664:  CLRF   xD0
02666:  MOVLW  01
02668:  MOVWF  xCF
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
0266A:  CLRF   xF6
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
0266C:  CLRF   xD9
0266E:  CLRF   xD8
....................  
.................... 		} else { 
02670:  BRA    268A
02672:  MOVLB  6
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02674:  MOVLB  1
02676:  INCFSZ xCD,W
02678:  BRA    2680
0267A:  INCFSZ xCE,W
0267C:  BRA    2680
0267E:  BRA    2686
.................... 				current.modbus_other_packets++; 
02680:  INCF   xCD,F
02682:  BTFSC  FD8.2
02684:  INCF   xCE,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02686:  MOVLW  0A
02688:  MOVWF  xF6
0268A:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
0268C:  GOTO   2B1C (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00442:  MOVLB  8
00444:  BTFSS  xE7.0
00446:  BRA    0460
00448:  MOVLB  1
0044A:  INCFSZ xE5,W
0044C:  BRA    0458
0044E:  INCFSZ xE6,W
00450:  BRA    0458
00452:  MOVLB  8
00454:  BRA    0460
00456:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00458:  INCF   xE5,F
0045A:  BTFSC  FD8.2
0045C:  INCF   xE6,F
0045E:  MOVLB  8
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00460:  BTFSS  xE7.2
00462:  BRA    047C
00464:  MOVLB  1
00466:  INCFSZ xE7,W
00468:  BRA    0474
0046A:  INCFSZ xE8,W
0046C:  BRA    0474
0046E:  MOVLB  8
00470:  BRA    047C
00472:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00474:  INCF   xE7,F
00476:  BTFSC  FD8.2
00478:  INCF   xE8,F
0047A:  MOVLB  8
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0047C:  BTFSS  xE7.4
0047E:  BRA    0498
00480:  MOVLB  1
00482:  INCFSZ xE9,W
00484:  BRA    0490
00486:  INCFSZ xEA,W
00488:  BRA    0490
0048A:  MOVLB  8
0048C:  BRA    0498
0048E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00490:  INCF   xE9,F
00492:  BTFSC  FD8.2
00494:  INCF   xEA,F
00496:  MOVLB  8
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00498:  BCF    xE7.1
0049A:  BTFSC  F81.0
0049C:  BSF    xE7.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0049E:  BTFSC  xE7.1
004A0:  BRA    0524
004A2:  MOVLB  6
004A4:  BTFSC  xBF.1
004A6:  BRA    04AC
004A8:  MOVLB  8
004AA:  BRA    0524
.................... 		current.pulse_count[0]++; 
004AC:  MOVLB  0
004AE:  INCF   xA8,F
004B0:  BTFSC  FD8.2
004B2:  INCF   xA9,F
.................... 		current.pulse_sum[0]++; 
004B4:  MOVLW  01
004B6:  ADDWF  xAE,F
004B8:  BTFSC  FD8.0
004BA:  INCF   xAF,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xB0,F
004C0:  BTFSC  FD8.2
004C2:  INCF   xB1,F
.................... 		if ( 1 == ext0_state ) { 
004C4:  MOVLB  6
004C6:  BTFSS  xBF.2
004C8:  BRA    0512
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004CA:  MOVLB  8
004CC:  BCF    xE7.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004CE:  MOVFF  1E6,97
004D2:  MOVFF  1E5,96
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004D6:  MOVLB  0
004D8:  MOVF   x97,W
004DA:  SUBWF  x9D,W
004DC:  BNC   04EE
004DE:  BNZ   04E6
004E0:  MOVF   x9C,W
004E2:  SUBWF  x96,W
004E4:  BC    04EE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004E6:  MOVFF  97,9D
004EA:  MOVFF  96,9C
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004EE:  MOVF   xA3,W
004F0:  SUBWF  x97,W
004F2:  BNC   050E
004F4:  BNZ   04FC
004F6:  MOVF   x96,W
004F8:  SUBWF  xA2,W
004FA:  BC    050E
004FC:  INCFSZ x96,W
004FE:  BRA    0506
00500:  INCFSZ x97,W
00502:  BRA    0506
00504:  BRA    050E
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00506:  MOVFF  97,A3
0050A:  MOVFF  96,A2
.................... 			} 
.................... 			ext0_state=0; 
0050E:  MOVLB  6
00510:  BCF    xBF.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00512:  BTFSC  xBF.2
00514:  BRA    0524
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00516:  MOVLB  1
00518:  CLRF   xE6
0051A:  CLRF   xE5
.................... 			ext0_count=1; 
0051C:  MOVLB  8
0051E:  BSF    xE7.0
.................... 			ext0_state=1; 
00520:  MOVLB  6
00522:  BSF    xBF.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00524:  MOVLB  6
00526:  BCF    xBF.1
00528:  MOVLB  8
0052A:  BTFSS  xE7.1
0052C:  BRA    0534
0052E:  MOVLB  6
00530:  BSF    xBF.1
00532:  MOVLB  8
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00534:  BCF    xE7.3
00536:  BTFSC  F81.1
00538:  BSF    xE7.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0053A:  BTFSC  xE7.3
0053C:  BRA    05C0
0053E:  MOVLB  6
00540:  BTFSC  xBF.3
00542:  BRA    0548
00544:  MOVLB  8
00546:  BRA    05C0
.................... 		current.pulse_count[1]++; 
00548:  MOVLB  0
0054A:  INCF   xAA,F
0054C:  BTFSC  FD8.2
0054E:  INCF   xAB,F
.................... 		current.pulse_sum[1]++; 
00550:  MOVLW  01
00552:  ADDWF  xB2,F
00554:  BTFSC  FD8.0
00556:  INCF   xB3,F
00558:  BTFSC  FD8.2
0055A:  INCF   xB4,F
0055C:  BTFSC  FD8.2
0055E:  INCF   xB5,F
.................... 		if ( 1 == ext1_state ) { 
00560:  MOVLB  6
00562:  BTFSS  xBF.4
00564:  BRA    05AE
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00566:  MOVLB  8
00568:  BCF    xE7.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0056A:  MOVFF  1E8,99
0056E:  MOVFF  1E7,98
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00572:  MOVLB  0
00574:  MOVF   x99,W
00576:  SUBWF  x9F,W
00578:  BNC   058A
0057A:  BNZ   0582
0057C:  MOVF   x9E,W
0057E:  SUBWF  x98,W
00580:  BC    058A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00582:  MOVFF  99,9F
00586:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0058A:  MOVF   xA5,W
0058C:  SUBWF  x99,W
0058E:  BNC   05AA
00590:  BNZ   0598
00592:  MOVF   x98,W
00594:  SUBWF  xA4,W
00596:  BC    05AA
00598:  INCFSZ x98,W
0059A:  BRA    05A2
0059C:  INCFSZ x99,W
0059E:  BRA    05A2
005A0:  BRA    05AA
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005A2:  MOVFF  99,A5
005A6:  MOVFF  98,A4
.................... 			} 
.................... 			ext1_state=0; 
005AA:  MOVLB  6
005AC:  BCF    xBF.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005AE:  BTFSC  xBF.4
005B0:  BRA    05C0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005B2:  MOVLB  1
005B4:  CLRF   xE8
005B6:  CLRF   xE7
.................... 			ext1_count=1; 
005B8:  MOVLB  8
005BA:  BSF    xE7.2
.................... 			ext1_state=1; 
005BC:  MOVLB  6
005BE:  BSF    xBF.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005C0:  MOVLB  6
005C2:  BCF    xBF.3
005C4:  MOVLB  8
005C6:  BTFSS  xE7.3
005C8:  BRA    05D0
005CA:  MOVLB  6
005CC:  BSF    xBF.3
005CE:  MOVLB  8
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005D0:  BCF    xE7.5
005D2:  BTFSC  F81.2
005D4:  BSF    xE7.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005D6:  BTFSC  xE7.5
005D8:  BRA    065C
005DA:  MOVLB  6
005DC:  BTFSC  xBF.5
005DE:  BRA    05E4
005E0:  MOVLB  8
005E2:  BRA    065C
.................... 		current.pulse_count[2]++; 
005E4:  MOVLB  0
005E6:  INCF   xAC,F
005E8:  BTFSC  FD8.2
005EA:  INCF   xAD,F
.................... 		current.pulse_sum[2]++; 
005EC:  MOVLW  01
005EE:  ADDWF  xB6,F
005F0:  BTFSC  FD8.0
005F2:  INCF   xB7,F
005F4:  BTFSC  FD8.2
005F6:  INCF   xB8,F
005F8:  BTFSC  FD8.2
005FA:  INCF   xB9,F
.................... 		if ( 1 == ext2_state ) { 
005FC:  MOVLB  6
005FE:  BTFSS  xBF.6
00600:  BRA    064A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
00602:  MOVLB  8
00604:  BCF    xE7.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00606:  MOVFF  1EA,9B
0060A:  MOVFF  1E9,9A
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0060E:  MOVLB  0
00610:  MOVF   x9B,W
00612:  SUBWF  xA1,W
00614:  BNC   0626
00616:  BNZ   061E
00618:  MOVF   xA0,W
0061A:  SUBWF  x9A,W
0061C:  BC    0626
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0061E:  MOVFF  9B,A1
00622:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00626:  MOVF   xA7,W
00628:  SUBWF  x9B,W
0062A:  BNC   0646
0062C:  BNZ   0634
0062E:  MOVF   x9A,W
00630:  SUBWF  xA6,W
00632:  BC    0646
00634:  INCFSZ x9A,W
00636:  BRA    063E
00638:  INCFSZ x9B,W
0063A:  BRA    063E
0063C:  BRA    0646
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0063E:  MOVFF  9B,A7
00642:  MOVFF  9A,A6
.................... 			} 
.................... 			ext2_state=0; 
00646:  MOVLB  6
00648:  BCF    xBF.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0064A:  BTFSC  xBF.6
0064C:  BRA    065C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0064E:  MOVLB  1
00650:  CLRF   xEA
00652:  CLRF   xE9
.................... 			ext2_count=1; 
00654:  MOVLB  8
00656:  BSF    xE7.4
.................... 			ext2_state=1; 
00658:  MOVLB  6
0065A:  BSF    xBF.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0065C:  MOVLB  6
0065E:  BCF    xBF.5
00660:  MOVLB  8
00662:  BTFSS  xE7.5
00664:  BRA    066C
00666:  MOVLB  6
00668:  BSF    xBF.5
0066A:  MOVLB  8
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0066C:  MOVLB  7
0066E:  INCF   xCA,F
.................... 	if ( 10 == tick ) { 
00670:  MOVF   xCA,W
00672:  SUBLW  0A
00674:  BNZ   067E
.................... 		tick=0; 
00676:  CLRF   xCA
.................... 		timers.now_millisecond=1; 
00678:  MOVLB  1
0067A:  BSF    xF9.2
0067C:  MOVLB  7
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0067E:  BCF    F9E.1
00680:  MOVLB  0
00682:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0069E:  BRA    0686
006A0:  MOVFF  01,8E4
.................... 	current.rda2_bytes_received++; 
006A4:  MOVLB  1
006A6:  INCF   xE3,F
006A8:  BTFSC  FD8.2
006AA:  INCF   xE4,F
....................  
.................... 	if ( RS485_MODE_OFF != config.rs485_port_mode ) { 
006AC:  MOVF   38,F
006AE:  BZ    06D0
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006B0:  MOVLB  2
006B2:  CLRF   xFE
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006B4:  INCFSZ xFD,W
006B6:  BRA    06BA
006B8:  BRA    06CE
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006BA:  MOVLW  FD
006BC:  ADDWF  xFD,W
006BE:  MOVWF  FE9
006C0:  MOVLW  01
006C2:  MOVWF  FEA
006C4:  BTFSC  FD8.0
006C6:  INCF   FEA,F
006C8:  MOVFF  8E4,FEF
.................... 			timers.rda2_buff_pos++; 
006CC:  INCF   xFD,F
006CE:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 	if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006D0:  MOVF   38,W
006D2:  SUBLW  02
006D4:  BNZ   06EE
.................... 		if ( '\n' == c || '\r' == c ) { 
006D6:  MOVLB  8
006D8:  MOVF   xE4,W
006DA:  SUBLW  0A
006DC:  BZ    06E4
006DE:  MOVF   xE4,W
006E0:  SUBLW  0D
006E2:  BNZ   06EC
.................... 			timers.rda2_buff_gap=20; 
006E4:  MOVLW  14
006E6:  MOVLB  2
006E8:  MOVWF  xFE
006EA:  MOVLB  8
006EC:  MOVLB  1
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
006EE:  BCF    FA4.5
006F0:  MOVLB  0
006F2:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
00738:  RCALL  06F6
0073A:  MOVFF  01,8E4
....................  
.................... 	current.rda_bytes_received++; 
0073E:  MOVLB  1
00740:  INCF   xE1,F
00742:  BTFSC  FD8.2
00744:  INCF   xE2,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
00746:  MOVLB  6
00748:  BTFSC  xBF.0
0074A:  BRA    07A2
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
0074C:  MOVF   xC0,F
0074E:  BNZ   0760
.................... 			modbus_serial_crc.d = 0xFFFF; 
00750:  SETF   xC2
00752:  SETF   xC1
.................... 			modbus_rx.address = c; 
00754:  MOVFF  8E4,6C3
.................... 			modbus_serial_state++; 
00758:  INCF   xC0,F
.................... 			modbus_rx.len = 0; 
0075A:  CLRF   xC4
.................... 			modbus_rx.error=0; 
0075C:  CLRF   xC6
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
0075E:  BRA    078E
00760:  DECFSZ xC0,W
00762:  BRA    076C
.................... 			modbus_rx.func = c; 
00764:  MOVFF  8E4,6C5
.................... 			modbus_serial_state++; 
00768:  INCF   xC0,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
0076A:  BRA    078E
0076C:  MOVF   xC0,W
0076E:  SUBLW  02
00770:  BNZ   078E
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
00772:  INCFSZ xC4,W
00774:  BRA    077A
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00776:  MOVLW  FE
00778:  MOVWF  xC4
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
0077A:  MOVLW  C7
0077C:  ADDWF  xC4,W
0077E:  MOVWF  FE9
00780:  MOVLW  06
00782:  MOVWF  FEA
00784:  BTFSC  FD8.0
00786:  INCF   FEA,F
00788:  MOVFF  8E4,FEF
.................... 			modbus_rx.len++; 
0078C:  INCF   xC4,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
0078E:  MOVFF  8E4,8E5
00792:  MOVLB  0
00794:  RCALL  070C
.................... 		modbus_enable_timeout(TRUE); 
00796:  MOVLW  01
00798:  MOVLB  8
0079A:  MOVWF  xE5
0079C:  MOVLB  0
0079E:  RCALL  03FC
007A0:  MOVLB  6
.................... 	} 
.................... } 
....................  
....................  
....................  
007A2:  BCF    F9E.5
007A4:  MOVLB  0
007A6:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
008A4:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
008A6:  MOVLW  08
008A8:  MOVWF  F61
008AA:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
008AC:  MOVLW  00
008AE:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
008B0:  MOVLW  FF
008B2:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
008B4:  MOVLW  92
008B6:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
008B8:  MOVLW  80
008BA:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
008BC:  BCF    F96.0
008BE:  BCF    F96.1
008C0:  BCF    F96.2
008C2:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
008C4:  MOVLB  1
008C6:  CLRF   xF6
.................... 	timers.load_off_seconds=2; 
008C8:  CLRF   xF8
008CA:  MOVLW  02
008CC:  MOVWF  xF7
.................... 	timers.now_adc_sample=0; 
008CE:  BCF    xF9.0
.................... 	timers.now_adc_reset_count=0; 
008D0:  BCF    xF9.1
.................... 	timers.now_millisecond=0; 
008D2:  BCF    xF9.2
.................... 	timers.port_b=0b11111111; 
008D4:  SETF   xFA
.................... 	timers.port_c=0b11111111; 
008D6:  SETF   xFB
....................  
.................... 	timers.rda2_buff_pos=0; 
008D8:  MOVLB  2
008DA:  CLRF   xFD
.................... 	timers.rda2_buff_gap=255; 
008DC:  SETF   xFE
.................... 	timers.now_parse_rda2=0; 
008DE:  MOVLB  1
008E0:  BCF    xFC.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
008E2:  MOVLB  7
008E4:  CLRF   xD5
008E6:  MOVF   xD5,W
008E8:  SUBLW  02
008EA:  BNC   099A
.................... 		current.pulse_period[i]=0; 
008EC:  CLRF   03
008EE:  MOVFF  7D5,02
008F2:  BCF    FD8.0
008F4:  RLCF   02,F
008F6:  RLCF   03,F
008F8:  MOVF   02,W
008FA:  ADDLW  96
008FC:  MOVWF  FE9
008FE:  MOVLW  00
00900:  ADDWFC 03,W
00902:  MOVWF  FEA
00904:  CLRF   FEC
00906:  MOVF   FED,F
00908:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
0090A:  CLRF   03
0090C:  MOVFF  7D5,02
00910:  BCF    FD8.0
00912:  RLCF   02,F
00914:  RLCF   03,F
00916:  MOVF   02,W
00918:  ADDLW  9C
0091A:  MOVWF  FE9
0091C:  MOVLW  00
0091E:  ADDWFC 03,W
00920:  MOVWF  FEA
00922:  SETF   FEC
00924:  MOVF   FED,F
00926:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00928:  CLRF   03
0092A:  MOVFF  7D5,02
0092E:  BCF    FD8.0
00930:  RLCF   02,F
00932:  RLCF   03,F
00934:  MOVF   02,W
00936:  ADDLW  A2
00938:  MOVWF  FE9
0093A:  MOVLW  00
0093C:  ADDWFC 03,W
0093E:  MOVWF  FEA
00940:  CLRF   FEC
00942:  MOVF   FED,F
00944:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00946:  CLRF   03
00948:  MOVFF  7D5,02
0094C:  BCF    FD8.0
0094E:  RLCF   02,F
00950:  RLCF   03,F
00952:  MOVF   02,W
00954:  ADDLW  A8
00956:  MOVWF  FE9
00958:  MOVLW  00
0095A:  ADDWFC 03,W
0095C:  MOVWF  FEA
0095E:  CLRF   FEC
00960:  MOVF   FED,F
00962:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00964:  MOVLB  8
00966:  CLRF   xDA
00968:  MOVFF  7D5,8D9
0096C:  CLRF   xDC
0096E:  MOVLW  04
00970:  MOVWF  xDB
00972:  MOVLB  0
00974:  RCALL  0868
00976:  MOVF   01,W
00978:  ADDLW  AE
0097A:  MOVWF  FE9
0097C:  MOVLW  00
0097E:  ADDWFC 02,W
00980:  MOVWF  FEA
00982:  MOVF   FEE,F
00984:  MOVF   FEE,F
00986:  CLRF   FEC
00988:  MOVF   FED,F
0098A:  CLRF   FEF
0098C:  MOVF   FED,F
0098E:  CLRF   FEF
00990:  MOVF   FED,F
00992:  CLRF   FEF
.................... 	} 
00994:  MOVLB  7
00996:  INCF   xD5,F
00998:  BRA    08E6
....................  
.................... 	current.modbus_our_packets=0; 
0099A:  MOVLB  1
0099C:  CLRF   xCC
0099E:  CLRF   xCB
.................... 	current.modbus_other_packets=0; 
009A0:  CLRF   xCE
009A2:  CLRF   xCD
.................... 	current.modbus_last_error=0; 
009A4:  CLRF   xD0
009A6:  CLRF   xCF
.................... 	current.sequence_number=0; 
009A8:  CLRF   xD2
009AA:  CLRF   xD1
.................... 	current.uptime_minutes=0; 
009AC:  CLRF   xD4
009AE:  CLRF   xD3
.................... 	current.interval_milliseconds=0; 
009B0:  CLRF   xD6
009B2:  CLRF   xD5
.................... 	current.adc_buffer_index=0; 
009B4:  CLRF   xCA
.................... 	current.factory_unlocked=0; 
009B6:  CLRF   xD7
.................... 	current.watchdog_seconds=0; 
009B8:  CLRF   xD9
009BA:  CLRF   xD8
.................... 	current.rda_bytes_received=0; 
009BC:  CLRF   xE2
009BE:  CLRF   xE1
.................... 	current.rda2_bytes_received=0; 
009C0:  CLRF   xE4
009C2:  CLRF   xE3
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
009C4:  MOVLW  02
009C6:  MOVWF  FEA
009C8:  SETF   FE9
009CA:  CLRF   00
009CC:  MOVLW  03
009CE:  MOVWF  02
009D0:  MOVLW  C0
009D2:  MOVWF  01
009D4:  MOVLB  0
009D6:  RCALL  088A
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
009D8:  MOVFF  4B,1DC
009DC:  MOVFF  4A,1DB
.................... 	current.power_off_delay=config.power_off_below_delay; 
009E0:  MOVFF  47,1DE
009E4:  MOVFF  46,1DD
.................... 	current.power_override_timeout=0; 
009E8:  MOVLB  1
009EA:  CLRF   xE0
009EC:  CLRF   xDF
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
009EE:  MOVLW  00
009F0:  IORLW  05
009F2:  MOVWF  FBA
009F4:  MOVLW  4A
009F6:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
009F8:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
009FA:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
009FC:  MOVLB  0
009FE:  GOTO   2998 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00FCA:  MOVLB  1
00FCC:  BCF    xF9.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00FCE:  BCF    FD8.0
00FD0:  MOVLB  7
00FD2:  RLCF   xD0,W
00FD4:  MOVWF  xD5
00FD6:  RLCF   xD1,W
00FD8:  MOVWF  xD6
00FDA:  MOVLW  00
00FDC:  MOVLB  1
00FDE:  BTFSS  xFB.5
00FE0:  MOVLW  01
00FE2:  MOVLB  7
00FE4:  IORWF  xD5,F
00FE6:  MOVFF  7D5,7D0
00FEA:  MOVF   xD6,W
00FEC:  IORLW  E0
00FEE:  MOVWF  xD1
.................... 	if ( b2_state==0xf000) { 
00FF0:  MOVF   xD0,F
00FF2:  BNZ   0FFA
00FF4:  MOVF   xD1,W
00FF6:  SUBLW  F0
00FF8:  BNZ   0FFA
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00FFA:  MOVLB  1
00FFC:  INCFSZ xE5,W
00FFE:  BRA    100C
01000:  INCFSZ xE6,W
01002:  BRA    100C
.................... 				current.pulse_period[0]=0; 
01004:  MOVLB  0
01006:  CLRF   x97
01008:  CLRF   x96
0100A:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
0100C:  INCFSZ xE7,W
0100E:  BRA    101C
01010:  INCFSZ xE8,W
01012:  BRA    101C
.................... 				current.pulse_period[1]=0; 
01014:  MOVLB  0
01016:  CLRF   x99
01018:  CLRF   x98
0101A:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
0101C:  INCFSZ xE9,W
0101E:  BRA    102C
01020:  INCFSZ xEA,W
01022:  BRA    102C
.................... 				current.pulse_period[2]=0; 
01024:  MOVLB  0
01026:  CLRF   x9B
01028:  CLRF   x9A
0102A:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
0102C:  MOVFF  F81,1FA
.................... 	timers.port_c=port_c; 
01030:  MOVFF  F82,1FB
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
01034:  MOVF   xF6,F
01036:  BNZ   103C
.................... 		output_low(LED_GREEN); 
01038:  BCF    F89.3
.................... 	} else { 
0103A:  BRA    1040
.................... 		output_high(LED_GREEN); 
0103C:  BSF    F89.3
.................... 		timers.led_on_green--; 
0103E:  DECF   xF6,F
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
01040:  INCFSZ xD5,W
01042:  BRA    104A
01044:  INCFSZ xD6,W
01046:  BRA    104A
01048:  BRA    1050
.................... 		current.interval_milliseconds++; 
0104A:  INCF   xD5,F
0104C:  BTFSC  FD8.2
0104E:  INCF   xD6,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
01050:  MOVLB  7
01052:  INCF   xCE,F
01054:  BTFSC  FD8.2
01056:  INCF   xCF,F
.................... 	if ( 1000 == ticks ) { 
01058:  MOVF   xCE,W
0105A:  SUBLW  E8
0105C:  BNZ   10E2
0105E:  MOVF   xCF,W
01060:  SUBLW  03
01062:  BNZ   10E2
.................... 		ticks=0; 
01064:  CLRF   xCF
01066:  CLRF   xCE
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
01068:  MOVLB  1
0106A:  INCFSZ xD8,W
0106C:  BRA    1074
0106E:  INCFSZ xD9,W
01070:  BRA    1074
01072:  BRA    107A
.................... 			current.watchdog_seconds++; 
01074:  INCF   xD8,F
01076:  BTFSC  FD8.2
01078:  INCF   xD9,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
0107A:  MOVF   3F,F
0107C:  BNZ   1082
0107E:  MOVF   40,F
01080:  BZ    10A0
01082:  MOVF   40,W
01084:  SUBWF  xD9,W
01086:  BNC   10A0
01088:  BNZ   1090
0108A:  MOVF   xD8,W
0108C:  SUBWF  3F,W
0108E:  BC    10A0
01090:  MOVF   xF7,F
01092:  BNZ   10A0
01094:  MOVF   xF8,F
01096:  BNZ   10A0
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
01098:  MOVFF  42,1F8
0109C:  MOVFF  41,1F7
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
010A0:  MOVF   xF7,F
010A2:  BNZ   10AC
010A4:  MOVF   xF8,F
010A6:  BNZ   10AC
.................... 			output_high(PI_POWER_EN); 
010A8:  BSF    F8B.0
.................... 		} else { 
010AA:  BRA    10C2
.................... 			output_low(PI_POWER_EN); 
010AC:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
010AE:  MOVF   xF7,W
010B0:  BTFSC  FD8.2
010B2:  DECF   xF8,F
010B4:  DECF   xF7,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
010B6:  MOVF   xF7,F
010B8:  BNZ   10C2
010BA:  MOVF   xF8,F
010BC:  BNZ   10C2
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
010BE:  CLRF   xD9
010C0:  CLRF   xD8
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
010C2:  MOVLB  7
010C4:  INCF   xCB,F
.................... 		if ( 60 == uptimeTicks ) { 
010C6:  MOVF   xCB,W
010C8:  SUBLW  3C
010CA:  BNZ   10E2
.................... 			uptimeTicks=0; 
010CC:  CLRF   xCB
.................... 			if ( current.uptime_minutes < 65535 )  
010CE:  MOVLB  1
010D0:  INCFSZ xD3,W
010D2:  BRA    10DA
010D4:  INCFSZ xD4,W
010D6:  BRA    10DA
010D8:  BRA    10E0
.................... 				current.uptime_minutes++; 
010DA:  INCF   xD3,F
010DC:  BTFSC  FD8.2
010DE:  INCF   xD4,F
010E0:  MOVLB  7
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
010E2:  INCFSZ xD2,W
010E4:  BRA    10F8
010E6:  INCFSZ xD3,W
010E8:  BRA    10F8
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
010EA:  CLRF   xED
010EC:  MOVLB  0
010EE:  RCALL  0F42
010F0:  MOVFF  02,7D3
010F4:  MOVFF  01,7D2
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
010F8:  MOVLB  1
010FA:  BTFSS  xF9.1
010FC:  BRA    1106
.................... 		timers.now_adc_reset_count=0; 
010FE:  BCF    xF9.1
.................... 		adcTicks=0; 
01100:  MOVLB  7
01102:  CLRF   xCD
01104:  CLRF   xCC
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01106:  MOVLB  7
01108:  INCF   xCC,F
0110A:  BTFSC  FD8.2
0110C:  INCF   xCD,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
0110E:  MOVF   3C,W
01110:  SUBWF  xCC,W
01112:  BNZ   1128
01114:  MOVF   3D,W
01116:  SUBWF  xCD,W
01118:  BNZ   1128
.................... 		adcTicks=0; 
0111A:  CLRF   xCD
0111C:  CLRF   xCC
.................... 		timers.now_adc_sample=1; 
0111E:  MOVLB  1
01120:  BSF    xF9.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
01122:  MOVLB  7
01124:  SETF   xD3
01126:  SETF   xD2
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01128:  MOVLB  2
0112A:  INCFSZ xFE,W
0112C:  BRA    1130
0112E:  BRA    1132
.................... 		timers.rda2_buff_gap++; 
01130:  INCF   xFE,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
01132:  MOVF   xFE,W
01134:  SUBLW  09
01136:  BC    1142
01138:  MOVF   xFD,F
0113A:  BZ    1142
.................... 		timers.now_parse_rda2=1;	 
0113C:  MOVLB  1
0113E:  BSF    xFC.0
01140:  MOVLB  2
.................... 	} 
.................... } 
01142:  MOVLB  0
01144:  GOTO   2B0A (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 n) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < n && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
02690:  MOVLB  8
02692:  CLRF   xE0
02694:  MOVF   xDF,W
02696:  SUBWF  xE0,W
02698:  BC    2706
0269A:  CLRF   03
0269C:  MOVF   xE0,W
0269E:  ADDWF  xDD,W
026A0:  MOVWF  FE9
026A2:  MOVF   xDE,W
026A4:  ADDWFC 03,W
026A6:  MOVWF  FEA
026A8:  MOVF   FEF,F
026AA:  BZ    2706
026AC:  CLRF   03
026AE:  MOVF   xE0,W
026B0:  ADDWF  xDD,W
026B2:  MOVWF  FE9
026B4:  MOVF   xDE,W
026B6:  ADDWFC 03,W
026B8:  MOVWF  FEA
026BA:  MOVF   FEF,W
026BC:  SUBLW  0A
026BE:  BZ    2706
026C0:  CLRF   03
026C2:  MOVF   xE0,W
026C4:  ADDWF  xDD,W
026C6:  MOVWF  FE9
026C8:  MOVF   xDE,W
026CA:  ADDWFC 03,W
026CC:  MOVWF  FEA
026CE:  MOVF   FEF,W
026D0:  SUBLW  0D
026D2:  BZ    2706
.................... 		dest[i] = src[i]; 
026D4:  CLRF   03
026D6:  MOVF   xE0,W
026D8:  ADDWF  xDB,W
026DA:  MOVWF  01
026DC:  MOVF   xDC,W
026DE:  ADDWFC 03,F
026E0:  MOVFF  03,8E2
026E4:  CLRF   03
026E6:  MOVF   xE0,W
026E8:  ADDWF  xDD,W
026EA:  MOVWF  FE9
026EC:  MOVF   xDE,W
026EE:  ADDWFC 03,W
026F0:  MOVWF  FEA
026F2:  MOVFF  FEF,8E3
026F6:  MOVFF  8E2,FEA
026FA:  MOVFF  01,FE9
026FE:  MOVFF  8E3,FEF
.................... 	} 
02702:  INCF   xE0,F
02704:  BRA    2694
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < n ; i++) { 
02706:  MOVF   xDF,W
02708:  SUBWF  xE0,W
0270A:  BC    2720
.................... 		dest[i] = '\0'; 
0270C:  CLRF   03
0270E:  MOVF   xE0,W
02710:  ADDWF  xDB,W
02712:  MOVWF  FE9
02714:  MOVF   xDC,W
02716:  ADDWFC 03,W
02718:  MOVWF  FEA
0271A:  CLRF   FEF
.................... 	} 
0271C:  INCF   xE0,F
0271E:  BRA    2706
....................  
.................... 	/* always null terminate */ 
.................... 	dest[n-1]='\0'; 
02720:  MOVLW  01
02722:  SUBWF  xDF,W
02724:  CLRF   03
02726:  ADDWF  xDB,W
02728:  MOVWF  FE9
0272A:  MOVF   xDC,W
0272C:  ADDWFC 03,W
0272E:  MOVWF  FEA
02730:  CLRF   FEF
.................... } 
02732:  MOVLB  0
02734:  RETURN 0
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
027CE:  MOVFF  2FD,8D5
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
027D2:  MOVLB  2
027D4:  SETF   xFD
.................... 	memcpy(buff,timers.rda2_buff,length); 
027D6:  MOVLW  07
027D8:  MOVWF  FEA
027DA:  MOVLW  D5
027DC:  MOVWF  FE9
027DE:  MOVLW  01
027E0:  MOVWF  FE2
027E2:  MOVLW  FD
027E4:  MOVWF  FE1
027E6:  MOVLB  8
027E8:  MOVF   xD5,W
027EA:  MOVWF  01
027EC:  BZ    27F6
027EE:  MOVFF  FE6,FEE
027F2:  DECFSZ 01,F
027F4:  BRA    27EE
.................... 	timers.rda2_buff_gap=0; 
027F6:  MOVLB  2
027F8:  CLRF   xFE
.................... 	timers.rda2_buff_pos=0; 
027FA:  CLRF   xFD
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
027FC:  DECFSZ 38,W
027FE:  BRA    2836
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02800:  MOVLB  8
02802:  CLRF   xD7
02804:  CLRF   xD6
02806:  MOVF   xD7,F
02808:  BNZ   2832
0280A:  MOVF   xD5,W
0280C:  SUBWF  xD6,W
0280E:  BC    2832
.................... 			fputc(buff[l],STREAM_PI); 
02810:  MOVLW  D5
02812:  ADDWF  xD6,W
02814:  MOVWF  FE9
02816:  MOVLW  07
02818:  ADDWFC xD7,W
0281A:  MOVWF  FEA
0281C:  MOVFF  FEF,8D9
02820:  MOVF   xD9,W
02822:  MOVLB  0
02824:  CALL   1284
.................... 		} 
02828:  MOVLB  8
0282A:  INCF   xD6,F
0282C:  BTFSC  FD8.2
0282E:  INCF   xD7,F
02830:  BRA    2806
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
02832:  BRA    28EE
02834:  MOVLB  2
02836:  MOVF   38,W
02838:  SUBLW  02
0283A:  BNZ   28F0
.................... 		/* do something */ 
....................  
.................... 		/* put copy in 11th slot no mater what ... for debugging */ 
.................... 		strncpy_terminate_trim(nmea.sentence[11],buff,NMEA_SENTENCE_LENGTH-1); 
0283C:  MOVLW  06
0283E:  MOVLB  8
02840:  MOVWF  xDC
02842:  MOVLW  6F
02844:  MOVWF  xDB
02846:  MOVLW  07
02848:  MOVWF  xDE
0284A:  MOVLW  D5
0284C:  MOVWF  xDD
0284E:  MOVLW  4F
02850:  MOVWF  xDF
02852:  MOVLB  0
02854:  RCALL  2690
.................... //		strncpy(nmea.sentence[11],buff,NMEA_SENTENCE_LENGTH-1); 
.................... 		/* always null terminate final character */ 
.................... 		nmea.sentence[11][NMEA_SENTENCE_LENGTH-1]='\0'; 
02856:  MOVLB  6
02858:  CLRF   xBE
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
0285A:  MOVLB  8
0285C:  MOVF   xD5,W
0285E:  SUBLW  05
02860:  BNC   2864
.................... 			return; 
02862:  BRA    28EE
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
02864:  CLRF   xD8
02866:  MOVF   xD8,W
02868:  SUBLW  0B
0286A:  BNC   28EE
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
0286C:  MOVF   xD8,W
0286E:  MULLW  06
02870:  MOVF   FF3,W
02872:  CLRF   03
02874:  ADDLW  4E
02876:  MOVWF  01
02878:  MOVLW  00
0287A:  ADDWFC 03,F
0287C:  MOVFF  01,8D9
02880:  MOVFF  03,8DA
02884:  MOVLW  07
02886:  MOVWF  xDC
02888:  MOVLW  D5
0288A:  MOVWF  xDB
0288C:  MOVFF  03,8DE
02890:  MOVFF  01,8DD
02894:  CLRF   xE0
02896:  MOVLW  06
02898:  MOVWF  xDF
0289A:  MOVLB  0
0289C:  BRA    2736
0289E:  MOVF   01,F
028A0:  BZ    28A4
.................... 				/* no match */ 
.................... 				continue; 
028A2:  BRA    28E8
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,NMEA_SENTENCE_LENGTH-1); 
028A4:  MOVLB  8
028A6:  CLRF   xDA
028A8:  MOVFF  8D8,8D9
028AC:  CLRF   xDC
028AE:  MOVLW  50
028B0:  MOVWF  xDB
028B2:  MOVLB  0
028B4:  CALL   0868
028B8:  MOVFF  02,03
028BC:  MOVF   01,W
028BE:  ADDLW  FF
028C0:  MOVWF  01
028C2:  MOVLW  02
028C4:  ADDWFC 03,F
028C6:  MOVFF  01,8D9
028CA:  MOVLB  8
028CC:  MOVFF  03,8DA
028D0:  MOVFF  03,8DC
028D4:  MOVFF  01,8DB
028D8:  MOVLW  07
028DA:  MOVWF  xDE
028DC:  MOVLW  D5
028DE:  MOVWF  xDD
028E0:  MOVLW  4F
028E2:  MOVWF  xDF
028E4:  MOVLB  0
028E6:  RCALL  2690
.................... 		} 
028E8:  MOVLB  8
028EA:  INCF   xD8,F
028EC:  BRA    2866
028EE:  MOVLB  2
.................... 	} 
.................... } 
028F0:  MOVLB  0
028F2:  GOTO   2B28 (RETURN)
....................  
....................  
.................... void main(void) { 
028F6:  CLRF   FF8
028F8:  BCF    FF1.2
028FA:  BSF    F9F.1
028FC:  BCF    F9F.5
028FE:  BCF    FA5.5
02900:  BSF    FD0.7
02902:  BSF    07.7
02904:  CLRF   FEA
02906:  CLRF   FE9
02908:  CLRF   35
0290A:  BCF    FB8.3
0290C:  MOVLW  0C
0290E:  MOVWF  FAF
02910:  MOVLW  A6
02912:  MOVWF  FAC
02914:  MOVLW  90
02916:  MOVWF  FAB
02918:  BCF    F70.3
0291A:  MOVLW  4D
0291C:  MOVWF  F75
0291E:  MOVLW  A6
02920:  MOVWF  F72
02922:  MOVLW  90
02924:  MOVWF  F71
02926:  MOVLB  6
02928:  BCF    xBF.0
0292A:  CLRF   xC0
0292C:  MOVLB  7
0292E:  CLRF   xCA
02930:  MOVLB  6
02932:  BCF    xBF.1
02934:  BCF    xBF.2
02936:  BCF    xBF.3
02938:  BCF    xBF.4
0293A:  BCF    xBF.5
0293C:  BCF    xBF.6
0293E:  MOVLB  7
02940:  CLRF   xCB
02942:  CLRF   xCD
02944:  CLRF   xCC
02946:  CLRF   xCF
02948:  CLRF   xCE
0294A:  CLRF   xD1
0294C:  CLRF   xD0
0294E:  MOVF   FC1,W
02950:  ANDLW  F0
02952:  MOVWF  FC1
02954:  MOVLW  00
02956:  MOVLB  F
02958:  MOVWF  x38
0295A:  MOVWF  x3C
0295C:  MOVWF  x39
0295E:  MOVWF  x3A
02960:  MOVWF  x3B
02962:  MOVLB  1
02964:  CLRF   x88
02966:  CLRF   F77
02968:  CLRF   F78
0296A:  CLRF   F79
0296C:  CLRF   2F
0296E:  CLRF   30
02970:  MOVLB  7
02972:  CLRF   xC6
02974:  CLRF   xC7
02976:  CLRF   xC8
02978:  CLRF   xC9
0297A:  CLRF   xD2
0297C:  CLRF   xD3
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
0297E:  MOVF   FD0,W
02980:  ANDLW  0F
02982:  BTFSS  FD0.4
02984:  MOVLW  00
02986:  BSF    FD0.0
02988:  BSF    FD0.1
0298A:  BSF    FD0.4
0298C:  BSF    FD8.3
0298E:  BSF    FD8.4
02990:  MOVWF  xD4
....................  
.................... 	init(); 
02992:  MOVLB  0
02994:  GOTO   08A4
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
02998:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
0299A:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
0299C:  MOVLW  AA
0299E:  MOVWF  FF6
029A0:  MOVLW  07
029A2:  MOVWF  FF7
029A4:  MOVLW  07
029A6:  MOVLB  7
029A8:  MOVWF  xD5
029AA:  MOVLB  0
029AC:  CALL   0A02
029B0:  MOVLW  B6
029B2:  MOVWF  FF6
029B4:  MOVLW  07
029B6:  MOVWF  FF7
029B8:  CALL   0A2C
029BC:  MOVLW  0D
029BE:  BTFSS  FA4.4
029C0:  BRA    29BE
029C2:  MOVWF  F73
029C4:  MOVLW  0A
029C6:  BTFSS  FA4.4
029C8:  BRA    29C6
029CA:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
029CC:  MOVLW  C0
029CE:  MOVWF  FF6
029D0:  MOVLW  07
029D2:  MOVWF  FF7
029D4:  MOVLW  12
029D6:  MOVLB  7
029D8:  MOVWF  xD5
029DA:  MOVLB  0
029DC:  CALL   0A02
029E0:  MOVFF  7D4,7D5
029E4:  MOVLW  1B
029E6:  MOVLB  7
029E8:  MOVWF  xD6
029EA:  MOVLB  0
029EC:  GOTO   0A7A
029F0:  MOVLW  20
029F2:  BTFSS  FA4.4
029F4:  BRA    29F2
029F6:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
029F8:  MOVLB  7
029FA:  MOVF   xD4,W
029FC:  XORLW  07
029FE:  MOVLB  0
02A00:  BZ    2A1C
02A02:  XORLW  0C
02A04:  BZ    2A2A
02A06:  XORLW  04
02A08:  BZ    2A38
02A0A:  XORLW  03
02A0C:  BZ    2A46
02A0E:  XORLW  02
02A10:  BZ    2A54
02A12:  XORLW  0D
02A14:  BZ    2A62
02A16:  XORLW  03
02A18:  BZ    2A70
02A1A:  BRA    2A7E
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
02A1C:  MOVLW  D6
02A1E:  MOVWF  FF6
02A20:  MOVLW  07
02A22:  MOVWF  FF7
02A24:  CALL   0A2C
02A28:  BRA    2A8A
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
02A2A:  MOVLW  E2
02A2C:  MOVWF  FF6
02A2E:  MOVLW  07
02A30:  MOVWF  FF7
02A32:  CALL   0A2C
02A36:  BRA    2A8A
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
02A38:  MOVLW  F2
02A3A:  MOVWF  FF6
02A3C:  MOVLW  07
02A3E:  MOVWF  FF7
02A40:  CALL   0A2C
02A44:  BRA    2A8A
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
02A46:  MOVLW  00
02A48:  MOVWF  FF6
02A4A:  MOVLW  08
02A4C:  MOVWF  FF7
02A4E:  CALL   0A2C
02A52:  BRA    2A8A
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
02A54:  MOVLW  10
02A56:  MOVWF  FF6
02A58:  MOVLW  08
02A5A:  MOVWF  FF7
02A5C:  CALL   0A2C
02A60:  BRA    2A8A
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
02A62:  MOVLW  22
02A64:  MOVWF  FF6
02A66:  MOVLW  08
02A68:  MOVWF  FF7
02A6A:  CALL   0A2C
02A6E:  BRA    2A8A
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
02A70:  MOVLW  32
02A72:  MOVWF  FF6
02A74:  MOVLW  08
02A76:  MOVWF  FF7
02A78:  CALL   0A2C
02A7C:  BRA    2A8A
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
02A7E:  MOVLW  44
02A80:  MOVWF  FF6
02A82:  MOVLW  08
02A84:  MOVWF  FF7
02A86:  CALL   0A2C
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
02A8A:  MOVLW  4E
02A8C:  MOVWF  FF6
02A8E:  MOVLW  08
02A90:  MOVWF  FF7
02A92:  CALL   0A2C
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02A96:  GOTO   0D2E
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02A9A:  MOVF   36,W
02A9C:  SUBLW  80
02A9E:  BC    2AA4
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02AA0:  CALL   0C86
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02AA4:  BSF    FAB.7
02AA6:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02AA8:  GOTO   0D8C
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02AAC:  MOVLB  7
02AAE:  CLRF   xD4
02AB0:  MOVF   xD4,W
02AB2:  SUBLW  1D
02AB4:  BNC   2AC2
.................... 		adc_update(); 
02AB6:  MOVLB  0
02AB8:  CALL   0E4A
.................... 	} 
02ABC:  MOVLB  7
02ABE:  INCF   xD4,F
02AC0:  BRA    2AB0
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02AC2:  MOVFF  43,1DA
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
02AC6:  BTFSS  F72.1
02AC8:  BRA    2AC6
.................... 	output_low(RS485_DE); 
02ACA:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02ACC:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02ACE:  MOVLW  52
02AD0:  MOVWF  FF6
02AD2:  MOVLW  08
02AD4:  MOVWF  FF7
02AD6:  MOVLW  07
02AD8:  MOVWF  xD5
02ADA:  MOVLB  0
02ADC:  GOTO   0EF2
02AE0:  MOVLW  5E
02AE2:  MOVWF  FF6
02AE4:  MOVLW  08
02AE6:  MOVWF  FF7
02AE8:  GOTO   0F1E
02AEC:  MOVLW  0D
02AEE:  BTFSS  F9E.4
02AF0:  BRA    2AEE
02AF2:  MOVWF  FAD
02AF4:  MOVLW  0A
02AF6:  BTFSS  F9E.4
02AF8:  BRA    2AF6
02AFA:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02AFC:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
02AFE:  MOVLB  1
02B00:  BTFSS  xF9.2
02B02:  BRA    2B0C
.................... 			periodic_millisecond(); 
02B04:  MOVLB  0
02B06:  GOTO   0FCA
02B0A:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02B0C:  BTFSS  xF9.0
02B0E:  BRA    2B18
.................... 			timers.now_adc_sample=0; 
02B10:  BCF    xF9.0
.................... 			adc_update(); 
02B12:  MOVLB  0
02B14:  CALL   0E4A
.................... 		} 
....................  
.................... 		modbus_process(); 
02B18:  MOVLB  0
02B1A:  BRA    239E
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
02B1C:  MOVLB  1
02B1E:  BTFSS  xFC.0
02B20:  BRA    2B2A
.................... 			timers.now_parse_rda2=0; 
02B22:  BCF    xFC.0
.................... 			rs485_to_host(); 
02B24:  MOVLB  0
02B26:  BRA    27CE
02B28:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
02B2A:  MOVLB  0
02B2C:  BRA    2AFC
.................... } 
02B2E:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
