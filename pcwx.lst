CCS PCH C Compiler, Version 4.135, 4375               20-Mar-16 09:42

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 13016 bytes (20%)
                         Largest free fragment is 52516
               RAM used: 2302 (59%) at main() level
                         2580 (66%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   3070
*
00008:  GOTO   00E2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03BC
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0748
0007C:  BTFSS  F9D.4
0007E:  GOTO   0088
00082:  BTFSC  F9E.4
00084:  GOTO   06D2
00088:  BTFSS  FA3.5
0008A:  GOTO   0094
0008E:  BTFSC  FA4.5
00090:  GOTO   064A
00094:  MOVFF  0E,00
00098:  MOVFF  0F,01
0009C:  MOVFF  10,02
000A0:  MOVFF  11,03
000A4:  MOVFF  0C,FE9
000A8:  MOVFF  07,FEA
000AC:  BSF    07.7
000AE:  MOVFF  08,FE1
000B2:  MOVFF  09,FE2
000B6:  MOVFF  0A,FD9
000BA:  MOVFF  0B,FDA
000BE:  MOVFF  12,FF3
000C2:  MOVFF  13,FF4
000C6:  MOVFF  14,FFA
000CA:  MOVFF  15,FF5
000CE:  MOVFF  16,FF6
000D2:  MOVFF  17,FF7
000D6:  MOVF   04,W
000D8:  MOVFF  06,FE0
000DC:  MOVFF  05,FD8
000E0:  RETFIE 0
000E2:  MOVWF  1A
000E4:  MOVFF  FD8,1B
000E8:  MOVFF  FE0,1C
000EC:  MOVLB  0
000EE:  MOVFF  FE9,22
000F2:  MOVFF  FEA,1D
000F6:  MOVFF  FE1,1E
000FA:  MOVFF  FE2,1F
000FE:  MOVFF  FD9,20
00102:  MOVFF  FDA,21
00106:  MOVFF  FF3,28
0010A:  MOVFF  FF4,29
0010E:  MOVFF  FFA,2A
00112:  MOVFF  FF5,2B
00116:  MOVFF  FF6,2C
0011A:  MOVFF  FF7,2D
0011E:  MOVFF  00,24
00122:  MOVFF  01,25
00126:  MOVFF  02,26
0012A:  MOVFF  03,27
0012E:  BTFSS  F9D.1
00130:  GOTO   013A
00134:  BTFSC  F9E.1
00136:  GOTO   03EE
0013A:  MOVFF  24,00
0013E:  MOVFF  25,01
00142:  MOVFF  26,02
00146:  MOVFF  27,03
0014A:  MOVFF  22,FE9
0014E:  MOVFF  1D,FEA
00152:  BSF    1D.7
00154:  MOVFF  1E,FE1
00158:  MOVFF  1F,FE2
0015C:  MOVFF  20,FD9
00160:  MOVFF  21,FDA
00164:  MOVFF  28,FF3
00168:  MOVFF  29,FF4
0016C:  MOVFF  2A,FFA
00170:  MOVFF  2B,FF5
00174:  MOVFF  2C,FF6
00178:  MOVFF  2D,FF7
0017C:  MOVF   1A,W
0017E:  MOVFF  1C,FE0
00182:  MOVFF  1B,FD8
00186:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02DAE:  MOVLB  A
02DB0:  MOVF   x08,F
02DB2:  BNZ   2DB8
02DB4:  MOVF   x09,F
02DB6:  BZ    2E3C
....................       if (*s1 != *s2) 
02DB8:  MOVFF  A04,FE9
02DBC:  MOVFF  A05,FEA
02DC0:  MOVFF  FEF,A0A
02DC4:  MOVFF  A07,03
02DC8:  MOVFF  A06,FE9
02DCC:  MOVFF  A07,FEA
02DD0:  MOVF   FEF,W
02DD2:  SUBWF  x0A,W
02DD4:  BZ    2E04
....................          return((*s1 <*s2) ? -1: 1); 
02DD6:  MOVFF  A05,03
02DDA:  MOVFF  A04,FE9
02DDE:  MOVFF  A05,FEA
02DE2:  MOVFF  FEF,A0A
02DE6:  MOVFF  A07,03
02DEA:  MOVFF  A06,FE9
02DEE:  MOVFF  A07,FEA
02DF2:  MOVF   FEF,W
02DF4:  SUBWF  x0A,W
02DF6:  BC    2DFC
02DF8:  MOVLW  FF
02DFA:  BRA    2DFE
02DFC:  MOVLW  01
02DFE:  MOVWF  01
02E00:  BRA    2E40
....................       else if (*s1 == '\0') 
02E02:  BRA    2E1A
02E04:  MOVFF  A05,03
02E08:  MOVFF  A04,FE9
02E0C:  MOVFF  A05,FEA
02E10:  MOVF   FEF,F
02E12:  BNZ   2E1A
....................          return(0); 
02E14:  MOVLW  00
02E16:  MOVWF  01
02E18:  BRA    2E40
02E1A:  MOVFF  A05,03
02E1E:  MOVF   x04,W
02E20:  INCF   x04,F
02E22:  BTFSC  FD8.2
02E24:  INCF   x05,F
02E26:  MOVFF  A07,03
02E2A:  MOVF   x06,W
02E2C:  INCF   x06,F
02E2E:  BTFSC  FD8.2
02E30:  INCF   x07,F
02E32:  MOVF   x08,W
02E34:  BTFSC  FD8.2
02E36:  DECF   x09,F
02E38:  DECF   x08,F
02E3A:  BRA    2DB0
....................    return(0); 
02E3C:  MOVLW  00
02E3E:  MOVWF  01
.................... } 
02E40:  MOVLB  0
02E42:  GOTO   2FC0 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
011DC:  MOVLW  05
011DE:  MOVLB  9
011E0:  SUBWF  x07,F
011E2:  BNC   11F8
011E4:  MOVLW  09
011E6:  MOVWF  FEA
011E8:  MOVLW  07
011EA:  MOVWF  FE9
011EC:  MOVF   FEF,W
011EE:  BZ    11F8
011F0:  BRA    11F4
011F2:  CLRWDT
011F4:  DECFSZ FEF,F
011F6:  BRA    11F2
011F8:  MOVLB  0
011FA:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
006CA:  BTFSS  F9E.4
006CC:  BRA    06CA
006CE:  MOVWF  FAD
006D0:  RETURN 0
*
00706:  BTFSS  F9E.5
00708:  BRA    0706
0070A:  MOVFF  FAB,35
0070E:  MOVFF  FAE,01
00712:  BTFSS  35.1
00714:  BRA    071A
00716:  BCF    FAB.4
00718:  BSF    FAB.4
0071A:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00632:  BTFSS  FA4.5
00634:  BRA    0632
00636:  MOVFF  F71,35
0063A:  MOVFF  F74,01
0063E:  BTFSS  35.1
00640:  BRA    0646
00642:  BCF    F71.4
00644:  BSF    F71.4
00646:  GOTO   064C (RETURN)
*
011FC:  BTFSS  FA4.4
011FE:  BRA    11FC
01200:  MOVWF  F73
01202:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... 	int8 pic_to_pi_latch_mask; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
....................  
.................... 	/* push button / magnetic switch on board */ 
.................... 	int8 button_state; 
....................  
.................... 	/* push button / magnetic switch on board */ 
.................... 	int8 latch_sw_magnet; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
....................  
.................... 	/* transmit buffer for PIC to PI */ 
.................... 	int8 rda_tx_buff[256]; 
.................... 	int8 rda_tx_length; 
.................... 	int8 rda_tx_pos; 
.................... 	int1 now_rda_tx_ready; 
.................... 	int1 now_rda_tx_done; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][NMEA_SENTENCE_LENGTH]; 
.................... 	int16 sentence_age[N_NMEA0183_SENTENCES]; 
.................... 	int8 sentence_length[N_NMEA0183_SENTENCES]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00EC8:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00E28:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00E2A:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00E2C:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00E2E:  MOVLB  9
00E30:  MOVF   x01,F
00E32:  BNZ   0E3A
.................... 		c=0b00011; 
00E34:  MOVLW  03
00E36:  MOVWF  x05
.................... 	else if ( 1 == ch )  
00E38:  BRA    0E84
00E3A:  DECFSZ x01,W
00E3C:  BRA    0E44
.................... 		c=0b10011; 
00E3E:  MOVLW  13
00E40:  MOVWF  x05
.................... 	else if ( 2 == ch )  
00E42:  BRA    0E84
00E44:  MOVF   x01,W
00E46:  SUBLW  02
00E48:  BNZ   0E50
.................... 		c=0b01011; 
00E4A:  MOVLW  0B
00E4C:  MOVWF  x05
.................... 	else if ( 3 == ch )  
00E4E:  BRA    0E84
00E50:  MOVF   x01,W
00E52:  SUBLW  03
00E54:  BNZ   0E5C
.................... 		c=0b11011; 
00E56:  MOVLW  1B
00E58:  MOVWF  x05
.................... 	else if ( 4 == ch ) 
00E5A:  BRA    0E84
00E5C:  MOVF   x01,W
00E5E:  SUBLW  04
00E60:  BNZ   0E68
.................... 		c=0b00111; 
00E62:  MOVLW  07
00E64:  MOVWF  x05
.................... 	else if ( 5 == ch )  
00E66:  BRA    0E84
00E68:  MOVF   x01,W
00E6A:  SUBLW  05
00E6C:  BNZ   0E74
.................... 		c=0b10111; 
00E6E:  MOVLW  17
00E70:  MOVWF  x05
.................... 	else if ( 6 == ch ) 
00E72:  BRA    0E84
00E74:  MOVF   x01,W
00E76:  SUBLW  06
00E78:  BNZ   0E80
.................... 		c=0b01111; 
00E7A:  MOVLW  0F
00E7C:  MOVWF  x05
.................... 	else 
00E7E:  BRA    0E84
.................... 		c=0b11111; 
00E80:  MOVLW  1F
00E82:  MOVWF  x05
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00E84:  CLRF   x04
00E86:  MOVF   x04,W
00E88:  SUBLW  04
00E8A:  BNC   0EA2
.................... 		output_low(MCP3208_CLK); 
00E8C:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00E8E:  BTFSC  x05.0
00E90:  BRA    0E96
00E92:  BCF    F8B.5
00E94:  BRA    0E98
00E96:  BSF    F8B.5
.................... 		c=c>>1; 
00E98:  BCF    FD8.0
00E9A:  RRCF   x05,F
.................... 		output_high(MCP3208_CLK); 
00E9C:  BSF    F8B.3
.................... 	} 
00E9E:  INCF   x04,F
00EA0:  BRA    0E86
....................  
....................  
.................... 	value=0; 
00EA2:  CLRF   x03
00EA4:  CLRF   x02
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00EA6:  CLRF   x04
00EA8:  MOVF   x04,W
00EAA:  SUBLW  0D
00EAC:  BNC   0EC4
.................... 		output_low(MCP3208_CLK); 
00EAE:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00EB0:  BTFSC  F82.4
00EB2:  BRA    0EB8
00EB4:  BCF    FD8.0
00EB6:  BRA    0EBA
00EB8:  BSF    FD8.0
00EBA:  RLCF   x02,F
00EBC:  RLCF   x03,F
.................... 		output_high(MCP3208_CLK); 
00EBE:  BSF    F8B.3
.................... 	} 
00EC0:  INCF   x04,F
00EC2:  BRA    0EA8
....................  
.................... 	bit_clear(value,13); 
00EC4:  BCF    x03.5
.................... 	bit_clear(value,12); 
00EC6:  BCF    x03.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00ECA:  MOVFF  902,01
00ECE:  MOVFF  903,02
.................... } 
00ED2:  MOVLB  0
00ED4:  GOTO   0F4A (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
01410:  MOVLB  A
01412:  CLRF   x03
01414:  MOVFF  918,A02
01418:  CLRF   x05
0141A:  MOVLW  20
0141C:  MOVWF  x04
0141E:  MOVLB  0
01420:  CALL   0878
01424:  MOVFF  02,03
01428:  MOVF   01,W
0142A:  ADDLW  CC
0142C:  MOVWF  01
0142E:  MOVLW  00
01430:  ADDWFC 03,F
01432:  MOVFF  01,91C
01436:  MOVLB  9
01438:  MOVFF  03,91D
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
0143C:  CLRF   x1A
0143E:  CLRF   x19
.................... 	for( i = 0; i < 16 ; i++ ) { 
01440:  CLRF   x1B
01442:  MOVF   x1B,W
01444:  SUBLW  0F
01446:  BNC   146A
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
01448:  BCF    FD8.0
0144A:  RLCF   x1B,W
0144C:  CLRF   03
0144E:  ADDWF  x1C,W
01450:  MOVWF  FE9
01452:  MOVF   x1D,W
01454:  ADDWFC 03,W
01456:  MOVWF  FEA
01458:  MOVFF  FEC,03
0145C:  MOVF   FED,F
0145E:  MOVF   FEF,W
01460:  ADDWF  x19,F
01462:  MOVF   03,W
01464:  ADDWFC x1A,F
.................... 	} 
01466:  INCF   x1B,F
01468:  BRA    1442
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
0146A:  MOVLW  08
0146C:  ADDWF  x19,W
0146E:  MOVWF  x1E
01470:  MOVLW  00
01472:  ADDWFC x1A,W
01474:  MOVWF  x1F
01476:  RRCF   x1F,W
01478:  MOVWF  03
0147A:  RRCF   x1E,W
0147C:  MOVWF  02
0147E:  RRCF   03,F
01480:  RRCF   02,F
01482:  RRCF   03,F
01484:  RRCF   02,F
01486:  RRCF   03,F
01488:  RRCF   02,F
0148A:  MOVLW  0F
0148C:  ANDWF  03,F
0148E:  MOVFF  02,01
01492:  MOVFF  03,02
.................... } 
01496:  MOVLB  0
01498:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00ED8:  MOVLB  1
00EDA:  INCF   xCC,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00EDC:  MOVF   xCC,W
00EDE:  SUBLW  0F
00EE0:  BC    0EE4
.................... 		current.adc_buffer_index=0; 
00EE2:  CLRF   xCC
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00EE4:  MOVLB  8
00EE6:  CLRF   xFE
00EE8:  MOVF   xFE,W
00EEA:  SUBLW  07
00EEC:  BNC   0F80
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00EEE:  MOVLB  A
00EF0:  CLRF   x03
00EF2:  MOVFF  8FE,A02
00EF6:  CLRF   x05
00EF8:  MOVLW  20
00EFA:  MOVWF  x04
00EFC:  MOVLB  0
00EFE:  RCALL  0878
00F00:  MOVFF  02,03
00F04:  MOVF   01,W
00F06:  ADDLW  34
00F08:  MOVLB  8
00F0A:  MOVWF  xFF
00F0C:  MOVLW  00
00F0E:  ADDWFC 02,W
00F10:  MOVLB  9
00F12:  MOVWF  x00
00F14:  CLRF   03
00F16:  MOVLB  1
00F18:  MOVFF  1CC,02
00F1C:  BCF    FD8.0
00F1E:  RLCF   02,F
00F20:  RLCF   03,F
00F22:  MOVF   02,W
00F24:  MOVLB  8
00F26:  ADDWF  xFF,W
00F28:  MOVWF  01
00F2A:  MOVLB  9
00F2C:  MOVF   x00,W
00F2E:  ADDWFC 03,F
00F30:  MOVF   01,W
00F32:  ADDLW  98
00F34:  MOVWF  01
00F36:  MOVLW  00
00F38:  ADDWFC 03,F
00F3A:  MOVFF  01,8FF
00F3E:  MOVFF  03,900
00F42:  MOVFF  8FE,901
00F46:  MOVLB  0
00F48:  BRA    0E28
00F4A:  MOVFF  900,FEA
00F4E:  MOVFF  8FF,FE9
00F52:  MOVFF  02,FEC
00F56:  MOVF   FED,F
00F58:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00F5C:  CLRF   03
00F5E:  MOVLB  8
00F60:  MOVFF  8FE,02
00F64:  BCF    FD8.0
00F66:  RLCF   02,F
00F68:  RLCF   03,F
00F6A:  MOVF   02,W
00F6C:  ADDLW  BC
00F6E:  MOVWF  FE9
00F70:  MOVLW  00
00F72:  ADDWFC 03,W
00F74:  MOVWF  FEA
00F76:  CLRF   FEC
00F78:  MOVF   FED,F
00F7A:  CLRF   FEF
....................  
.................... 	} 
00F7C:  INCF   xFE,F
00F7E:  BRA    0EE8
.................... } 
00F80:  MOVLB  0
00F82:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00BCE:  MOVF   x1D,W
00BD0:  XORWF  x1E,W
00BD2:  MOVWF  01
*
00C20:  MOVF   x1D,W
00C22:  XORWF  x1E,W
00C24:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00B58:  MOVLB  9
00B5A:  CLRF   x07
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B5C:  MOVFF  906,03
00B60:  MOVF   x05,W
00B62:  BTFSC  FD8.2
00B64:  DECF   x06,F
00B66:  DECF   x05,F
00B68:  MOVWF  x08
00B6A:  MOVFF  03,909
00B6E:  MOVF   x08,F
00B70:  BNZ   0B76
00B72:  MOVF   x09,F
00B74:  BZ    0BE0
.................... 		*data = read_eeprom( address++ ); 
00B76:  MOVFF  904,03
00B7A:  MOVF   x03,W
00B7C:  MOVWF  FE9
00B7E:  MOVFF  03,FEA
00B82:  MOVF   x02,W
00B84:  MOVWF  03
00B86:  MOVF   x01,W
00B88:  INCF   x01,F
00B8A:  BTFSC  FD8.2
00B8C:  INCF   x02,F
00B8E:  MOVWF  x0A
00B90:  MOVFF  03,90B
00B94:  MOVFF  FF2,90C
00B98:  BCF    FF2.6
00B9A:  BCF    FF2.7
00B9C:  MOVFF  90B,FAA
00BA0:  MOVFF  90A,FA9
00BA4:  BCF    FA6.6
00BA6:  BCF    FA6.7
00BA8:  BSF    FA6.0
00BAA:  MOVF   FA8,W
00BAC:  BTFSC  x0C.6
00BAE:  BSF    FF2.6
00BB0:  BTFSC  x0C.7
00BB2:  BSF    FF2.7
00BB4:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00BB6:  MOVFF  904,03
00BBA:  MOVF   x03,W
00BBC:  MOVWF  FE9
00BBE:  MOVFF  03,FEA
00BC2:  MOVFF  FEF,908
00BC6:  MOVFF  907,91D
00BCA:  MOVFF  908,91E
*
00BD4:  MOVFF  01,907
.................... 		data++; 
00BD8:  INCF   x03,F
00BDA:  BTFSC  FD8.2
00BDC:  INCF   x04,F
.................... 	} 
00BDE:  BRA    0B5C
.................... 	return crc; 
00BE0:  MOVFF  907,01
.................... } 
00BE4:  MOVLB  0
00BE6:  GOTO   0D5A (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00BEA:  MOVLB  9
00BEC:  CLRF   x1B
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BEE:  MOVFF  91A,03
00BF2:  MOVF   x19,W
00BF4:  BTFSC  FD8.2
00BF6:  DECF   x1A,F
00BF8:  DECF   x19,F
00BFA:  MOVWF  x1C
00BFC:  MOVFF  03,91D
00C00:  MOVF   x1C,F
00C02:  BNZ   0C08
00C04:  MOVF   x1D,F
00C06:  BZ    0C86
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00C08:  MOVFF  918,03
00C0C:  MOVF   x17,W
00C0E:  MOVWF  FE9
00C10:  MOVFF  03,FEA
00C14:  MOVFF  FEF,91C
00C18:  MOVFF  91B,91D
00C1C:  MOVFF  91C,91E
*
00C26:  MOVFF  01,91B
.................... 		write_eeprom( address++, *data++ ); 
00C2A:  MOVF   x16,W
00C2C:  MOVWF  03
00C2E:  MOVF   x15,W
00C30:  INCF   x15,F
00C32:  BTFSC  FD8.2
00C34:  INCF   x16,F
00C36:  MOVWF  x1C
00C38:  MOVFF  03,91D
00C3C:  MOVF   x18,W
00C3E:  MOVWF  03
00C40:  MOVF   x17,W
00C42:  INCF   x17,F
00C44:  BTFSC  FD8.2
00C46:  INCF   x18,F
00C48:  MOVWF  FE9
00C4A:  MOVFF  03,FEA
00C4E:  MOVFF  FEF,91E
00C52:  MOVFF  91D,FAA
00C56:  MOVFF  91C,FA9
00C5A:  MOVFF  91E,FA8
00C5E:  BCF    FA6.6
00C60:  BCF    FA6.7
00C62:  BSF    FA6.2
00C64:  MOVF   FF2,W
00C66:  MOVWF  00
00C68:  BCF    FF2.6
00C6A:  BCF    FF2.7
00C6C:  MOVLB  F
00C6E:  MOVLW  55
00C70:  MOVWF  FA7
00C72:  MOVLW  AA
00C74:  MOVWF  FA7
00C76:  BSF    FA6.1
00C78:  BTFSC  FA6.1
00C7A:  BRA    0C78
00C7C:  BCF    FA6.2
00C7E:  MOVF   00,W
00C80:  IORWF  FF2,F
.................... 	} 
00C82:  MOVLB  9
00C84:  BRA    0BEE
....................  
.................... 	return crc; 
00C86:  MOVFF  91B,01
.................... } 
00C8A:  MOVLB  0
00C8C:  GOTO   0CB0 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00C90:  MOVLB  9
00C92:  CLRF   x14
00C94:  MOVLW  36
00C96:  MOVWF  x13
00C98:  CLRF   x16
00C9A:  MOVLW  02
00C9C:  MOVWF  x15
00C9E:  MOVFF  914,918
00CA2:  MOVFF  913,917
00CA6:  CLRF   x1A
00CA8:  MOVLW  62
00CAA:  MOVWF  x19
00CAC:  MOVLB  0
00CAE:  BRA    0BEA
00CB0:  MOVFF  01,912
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00CB4:  CLRF   FAA
00CB6:  CLRF   FA9
00CB8:  MOVFF  912,FA8
00CBC:  BCF    FA6.6
00CBE:  BCF    FA6.7
00CC0:  BSF    FA6.2
00CC2:  MOVF   FF2,W
00CC4:  MOVWF  00
00CC6:  BCF    FF2.6
00CC8:  BCF    FF2.7
00CCA:  MOVLB  F
00CCC:  MOVLW  55
00CCE:  MOVWF  FA7
00CD0:  MOVLW  AA
00CD2:  MOVWF  FA7
00CD4:  BSF    FA6.1
00CD6:  BTFSC  FA6.1
00CD8:  BRA    0CD6
00CDA:  BCF    FA6.2
00CDC:  MOVF   00,W
00CDE:  IORWF  FF2,F
.................... } 
00CE0:  MOVLB  0
00CE2:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00CE4:  MOVLW  96
00CE6:  MOVLB  1
00CE8:  MOVWF  xFA
....................  
.................... 	config.modbus_address=38; 
00CEA:  MOVLW  26
00CEC:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00CEE:  MOVLW  03
00CF0:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00CF2:  MOVLW  02
00CF4:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00CF6:  MOVLW  50
00CF8:  MOVWF  3A
.................... 	config.serial_number=9876; 
00CFA:  MOVLW  26
00CFC:  MOVWF  3C
00CFE:  MOVLW  94
00D00:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00D02:  CLRF   3E
00D04:  MOVLW  14
00D06:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00D08:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00D0A:  MOVLW  02
00D0C:  MOVWF  41
00D0E:  MOVLW  76
00D10:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00D12:  CLRF   43
00D14:  MOVLW  02
00D16:  MOVWF  42
.................... 	config.power_startup=0; 
00D18:  CLRF   44
.................... 	config.pic_to_pi_latch_mask=1;  
00D1A:  MOVLW  01
00D1C:  MOVWF  4F
....................  
.................... 	/* set NMEA0183 sentence character array to all '*' */ 
.................... 	memset(config.nmea0183_sentence,'*',sizeof(config.nmea0183_sentence)); 
00D1E:  CLRF   FEA
00D20:  MOVLW  50
00D22:  MOVWF  FE9
00D24:  MOVLW  2A
00D26:  MOVWF  00
00D28:  CLRF   02
00D2A:  MOVLW  48
00D2C:  MOVWF  01
00D2E:  MOVLB  0
00D30:  RCALL  089A
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00D32:  RCALL  0C90
....................  
.................... } 
00D34:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00D36:  MOVLB  9
00D38:  CLRF   x00
00D3A:  MOVLW  36
00D3C:  MOVLB  8
00D3E:  MOVWF  xFF
00D40:  MOVLB  9
00D42:  CLRF   x02
00D44:  MOVLW  02
00D46:  MOVWF  x01
00D48:  MOVFF  900,904
00D4C:  MOVFF  8FF,903
00D50:  CLRF   x06
00D52:  MOVLW  62
00D54:  MOVWF  x05
00D56:  MOVLB  0
00D58:  BRA    0B58
00D5A:  MOVFF  01,8FE
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00D5E:  MOVFF  FF2,8FF
00D62:  BCF    FF2.6
00D64:  BCF    FF2.7
00D66:  CLRF   FAA
00D68:  CLRF   FA9
00D6A:  BCF    FA6.6
00D6C:  BCF    FA6.7
00D6E:  BSF    FA6.0
00D70:  MOVF   FA8,W
00D72:  MOVLB  8
00D74:  BTFSC  xFF.6
00D76:  BSF    FF2.6
00D78:  BTFSC  xFF.7
00D7A:  BSF    FF2.7
00D7C:  SUBWF  xFE,W
00D7E:  BZ    0D86
.................... 		write_default_param_file(); 
00D80:  MOVLB  0
00D82:  RCALL  0CE4
00D84:  MOVLB  8
.................... 	} 
.................... } 
00D86:  MOVLB  0
00D88:  GOTO   3212 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
.................... } 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00E0E:  BTFSS  F9E.5
00E10:  BRA    0E16
.................... 		fgetc(STREAM_PI); 
00E12:  RCALL  0706
.................... 	} 
00E14:  BRA    0E0E
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00E16:  BSF    F9D.5
.................... } 
00E18:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00E1A:  RCALL  0E0E
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_8 | T0_8_BIT); /* 0.683 ms @ 12 MHz. Use fosc/4 not fosc */ 
00E1C:  MOVLW  C2
00E1E:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00E20:  MOVLW  C0
00E22:  IORWF  FF2,F
.................... } 
00E24:  GOTO   3228 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003A8:  BCF    FF2.5
.................... 	if (enable) { 
003AA:  MOVLB  A
003AC:  MOVF   x11,F
003AE:  BZ    03B8
.................... 		set_timer0(0); 
003B0:  CLRF   FD7
003B2:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003B4:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003B6:  BSF    FF2.5
.................... 	} 
.................... } 
003B8:  MOVLB  0
003BA:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003BC:  MOVLB  7
003BE:  MOVF   xEB,W
003C0:  SUBLW  02
003C2:  BNZ   03D8
003C4:  MOVF   xEC,F
003C6:  BNZ   03D8
003C8:  MOVF   xED,F
003CA:  BNZ   03D8
003CC:  BTFSC  xEA.0
003CE:  BRA    03D8
....................    { 
....................       modbus_rx.len-=2; 
003D0:  MOVLW  02
003D2:  SUBWF  xEF,F
....................       modbus_serial_new=TRUE; 
003D4:  BSF    xEA.0
....................    } 
....................    else 
003D6:  BRA    03DA
....................       modbus_serial_new=FALSE; 
003D8:  BCF    xEA.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003DA:  SETF   xED
003DC:  SETF   xEC
....................    modbus_serial_state=MODBUS_GETADDY; 
003DE:  CLRF   xEB
....................    modbus_enable_timeout(FALSE); 
003E0:  MOVLB  A
003E2:  CLRF   x11
003E4:  MOVLB  0
003E6:  RCALL  03A8
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003E8:  BCF    FF2.2
003EA:  GOTO   0094
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
0071C:  MOVLB  7
0071E:  MOVF   xED,W
00720:  MOVLB  A
00722:  XORWF  x11,W
00724:  MOVWF  x12
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00726:  CLRF   03
00728:  MOVF   x12,W
0072A:  MOVLB  0
0072C:  RCALL  0188
0072E:  MOVWF  01
00730:  MOVLB  7
00732:  MOVF   xEC,W
00734:  XORWF  01,W
00736:  MOVWF  xED
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00738:  CLRF   03
0073A:  MOVLB  A
0073C:  MOVF   x12,W
0073E:  MOVLB  0
00740:  RCALL  0298
00742:  MOVFF  FE8,7EC
.................... } 
00746:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	timers.rda_tx_buff[timers.rda_tx_length]=c; 
*
01316:  MOVLW  03
01318:  MOVLB  4
0131A:  ADDWF  x03,W
0131C:  MOVWF  FE9
0131E:  MOVLW  03
01320:  MOVWF  FEA
01322:  BTFSC  FD8.0
01324:  INCF   FEA,F
01326:  MOVFF  912,FEF
.................... 	timers.rda_tx_length++; 
0132A:  INCF   x03,F
0132C:  CLRF   19
0132E:  BTFSC  FF2.6
01330:  BSF    19.6
01332:  BCF    FF2.6
01334:  BTFSC  FF2.7
01336:  BSF    19.7
01338:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
0133A:  MOVFF  912,A11
0133E:  MOVLB  0
01340:  CALL   071C
01344:  BTFSC  19.6
01346:  BSF    FF2.6
01348:  BTFSC  19.7
0134A:  BSF    FF2.7
.................... } 
0134C:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) { 
.................... 	/* reset out transmit buffer */ 
.................... 	timers.rda_tx_length=0; 
0134E:  MOVLB  4
01350:  CLRF   x03
.................... 	timers.rda_tx_pos=0; 
01352:  CLRF   x04
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01354:  MOVLB  7
01356:  SETF   xED
01358:  SETF   xEC
.................... 	modbus_serial_new=FALSE; 
0135A:  BCF    xEA.0
....................  
.................... 	modbus_serial_putc(to); 
0135C:  MOVFF  910,912
01360:  MOVLB  0
01362:  RCALL  1316
.................... 	modbus_serial_putc(func); 
01364:  MOVFF  911,912
01368:  RCALL  1316
.................... } 
0136A:  RETURN 0
....................  
.................... void modbus_serial_send_stop() { 
.................... 	int8 crc_low, crc_high; 
....................  
.................... 	crc_high=modbus_serial_crc.b[1]; 
0136C:  MOVFF  7ED,911
.................... 	crc_low=modbus_serial_crc.b[0]; 
01370:  MOVFF  7EC,910
....................  
.................... 	modbus_serial_putc(crc_high); 
01374:  MOVFF  911,912
01378:  RCALL  1316
.................... 	modbus_serial_putc(crc_low); 
0137A:  MOVFF  910,912
0137E:  RCALL  1316
....................  
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01380:  MOVLB  7
01382:  SETF   xED
01384:  SETF   xEC
....................  
.................... 	/* ready to transmit from buffer flag set. Elsewhere we start sending */ 
.................... 	timers.now_rda_tx_ready=1; 
01386:  MOVLB  4
01388:  BSF    x05.0
.................... } 
0138A:  MOVLB  0
0138C:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
011B6:  MOVLB  7
011B8:  BTFSC  xEA.0
011BA:  BRA    11C4
....................       return FALSE; 
011BC:  MOVLW  00
011BE:  MOVWF  01
011C0:  BRA    11D6
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
011C2:  BRA    11D0
011C4:  BTFSS  xF0.7
011C6:  BRA    11D0
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
011C8:  MOVFF  7F2,7F1
....................       modbus_rx.len = 1; 
011CC:  MOVLW  01
011CE:  MOVWF  xEF
....................    } 
....................    modbus_serial_new=FALSE; 
011D0:  BCF    xEA.0
....................    return TRUE; 
011D2:  MOVLW  01
011D4:  MOVWF  01
.................... } 
011D6:  MOVLB  0
011D8:  GOTO   2AB0 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02A1C:  MOVFF  908,910
02A20:  MOVLW  06
02A22:  MOVLB  9
02A24:  MOVWF  x11
02A26:  MOVLB  0
02A28:  CALL   134E
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02A2C:  MOVFF  90A,90D
02A30:  MOVFF  90A,912
02A34:  CALL   1316
....................    modbus_serial_putc(make8(reg_address,0)); 
02A38:  MOVFF  909,90D
02A3C:  MOVFF  909,912
02A40:  CALL   1316
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02A44:  MOVFF  90C,90D
02A48:  MOVFF  90C,912
02A4C:  CALL   1316
....................    modbus_serial_putc(make8(reg_value,0)); 
02A50:  MOVFF  90B,90D
02A54:  MOVFF  90B,912
02A58:  CALL   1316
....................  
....................    modbus_serial_send_stop(); 
02A5C:  CALL   136C
.................... } 
02A60:  GOTO   2C9C (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02A64:  MOVFF  906,910
02A68:  MOVLW  10
02A6A:  MOVLB  9
02A6C:  MOVWF  x11
02A6E:  MOVLB  0
02A70:  CALL   134E
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02A74:  MOVFF  908,90B
02A78:  MOVFF  908,912
02A7C:  CALL   1316
....................    modbus_serial_putc(make8(start_address,0)); 
02A80:  MOVFF  907,90B
02A84:  MOVFF  907,912
02A88:  CALL   1316
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02A8C:  MOVFF  90A,90B
02A90:  MOVFF  90A,912
02A94:  CALL   1316
....................    modbus_serial_putc(make8(quantity,0)); 
02A98:  MOVFF  909,90B
02A9C:  MOVFF  909,912
02AA0:  CALL   1316
....................  
....................    modbus_serial_send_stop(); 
02AA4:  CALL   136C
.................... } 
02AA8:  GOTO   2D66 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0138E:  MOVLB  9
01390:  MOVF   x07,W
01392:  IORLW  80
01394:  MOVWF  x0A
01396:  MOVFF  908,90B
0139A:  MOVFF  906,910
0139E:  MOVWF  x11
013A0:  MOVLB  0
013A2:  RCALL  134E
....................    modbus_serial_putc(error); 
013A4:  MOVFF  909,912
013A8:  RCALL  1316
....................    modbus_serial_send_stop(); 
013AA:  RCALL  136C
.................... } 
013AC:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          54 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1014 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
.................... #define MIN_NMEA0183_META_REGISTER   6500 
.................... #define MAX_NMEA0183_META_REGISTER   MIN_NMEA0183_META_REGISTER + N_NMEA0183_SENTENCES*2 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
014FE:  MOVLB  1
01500:  CLRF   xCE
01502:  CLRF   xCD
.................... 	current.modbus_other_packets=0; 
01504:  CLRF   xD0
01506:  CLRF   xCF
.................... 	current.modbus_last_error=0; 
01508:  CLRF   xD2
0150A:  CLRF   xD1
.................... } 
0150C:  MOVLB  0
0150E:  GOTO   2256 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0149A:  BCF    FF2.6
0149C:  BCF    FF2.7
0149E:  BTFSC  FF2.7
014A0:  BRA    149C
....................  
.................... 	current.pulse_count[0]=0; 
014A2:  CLRF   xAB
014A4:  CLRF   xAA
.................... 	current.pulse_count[1]=0; 
014A6:  CLRF   xAD
014A8:  CLRF   xAC
.................... 	current.pulse_count[2]=0; 
014AA:  CLRF   xAF
014AC:  CLRF   xAE
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
014AE:  SETF   x9F
014B0:  SETF   x9E
.................... 	current.pulse_min_period[1]=65535; 
014B2:  SETF   xA1
014B4:  SETF   xA0
.................... 	current.pulse_min_period[2]=65535; 
014B6:  SETF   xA3
014B8:  SETF   xA2
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
014BA:  CLRF   xA5
014BC:  CLRF   xA4
.................... 	current.pulse_max_period[1]=0; 
014BE:  CLRF   xA7
014C0:  CLRF   xA6
.................... 	current.pulse_max_period[2]=0; 
014C2:  CLRF   xA9
014C4:  CLRF   xA8
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
014C6:  MOVLB  1
014C8:  CLRF   xD8
014CA:  CLRF   xD7
....................  
.................... 	enable_interrupts(GLOBAL); 
014CC:  MOVLW  C0
014CE:  IORWF  FF2,F
.................... } 
014D0:  MOVLB  0
014D2:  GOTO   2206 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
014D6:  BCF    FF2.6
014D8:  BCF    FF2.7
014DA:  BTFSC  FF2.7
014DC:  BRA    14D8
.................... 	current.pulse_sum[0]=0; 
014DE:  CLRF   xB3
014E0:  CLRF   xB2
014E2:  CLRF   xB1
014E4:  CLRF   xB0
.................... 	current.pulse_sum[1]=0; 
014E6:  CLRF   xB7
014E8:  CLRF   xB6
014EA:  CLRF   xB5
014EC:  CLRF   xB4
.................... 	current.pulse_sum[2]=0; 
014EE:  CLRF   xBB
014F0:  CLRF   xBA
014F2:  CLRF   xB9
014F4:  CLRF   xB8
.................... 	enable_interrupts(GLOBAL); 
014F6:  MOVLW  C0
014F8:  IORWF  FF2,F
.................... } 
014FA:  GOTO   2216 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
013AE:  BCF    FF2.6
013B0:  BCF    FF2.7
013B2:  BTFSC  FF2.7
013B4:  BRA    13B0
.................... 	l=current.pulse_sum[ch]; 
013B6:  MOVLB  A
013B8:  CLRF   x03
013BA:  MOVFF  918,A02
013BE:  CLRF   x05
013C0:  MOVLW  04
013C2:  MOVWF  x04
013C4:  MOVLB  0
013C6:  CALL   0878
013CA:  MOVFF  02,03
013CE:  MOVF   01,W
013D0:  ADDLW  B0
013D2:  MOVWF  FE9
013D4:  MOVLW  00
013D6:  ADDWFC 02,W
013D8:  MOVWF  FEA
013DA:  MOVFF  FEF,00
013DE:  MOVFF  FEC,01
013E2:  MOVFF  FEC,02
013E6:  MOVFF  FEC,03
013EA:  MOVFF  03,91C
013EE:  MOVFF  02,91B
013F2:  MOVFF  01,91A
013F6:  MOVFF  00,919
.................... 	enable_interrupts(GLOBAL); 
013FA:  MOVLW  C0
013FC:  IORWF  FF2,F
....................  
.................... 	return l; 
013FE:  MOVFF  919,00
01402:  MOVFF  91A,01
01406:  MOVFF  91B,02
0140A:  MOVFF  91C,03
.................... } 
0140E:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01512:  MOVLB  9
01514:  MOVF   x13,W
01516:  SUBLW  06
01518:  BC    156E
0151A:  XORLW  FF
0151C:  BNZ   1524
0151E:  MOVF   x12,W
01520:  SUBLW  CF
01522:  BC    156E
01524:  MOVF   x13,W
01526:  SUBLW  09
01528:  BNC   156E
0152A:  BNZ   1532
0152C:  MOVF   x12,W
0152E:  SUBLW  CF
01530:  BNC   156E
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01532:  MOVLW  D0
01534:  SUBWF  x12,W
01536:  MOVWF  x18
01538:  MOVLW  07
0153A:  SUBWFB x13,W
0153C:  MOVWF  x19
0153E:  MOVLW  02
01540:  ADDWF  x19,F
01542:  MOVFF  FF2,91A
01546:  BCF    FF2.6
01548:  BCF    FF2.7
0154A:  MOVFF  919,FAA
0154E:  MOVFF  918,FA9
01552:  BCF    FA6.6
01554:  BCF    FA6.7
01556:  BSF    FA6.0
01558:  MOVF   FA8,W
0155A:  BTFSC  x1A.6
0155C:  BSF    FF2.6
0155E:  BTFSC  x1A.7
01560:  BSF    FF2.7
01562:  CLRF   03
01564:  MOVWF  01
01566:  MOVF   03,W
01568:  MOVWF  02
0156A:  GOTO   2584
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
0156E:  MOVF   x13,W
01570:  SUBLW  03
01572:  BC    15F2
01574:  XORLW  FF
01576:  BNZ   157E
01578:  MOVF   x12,W
0157A:  SUBLW  4B
0157C:  BC    15F2
0157E:  MOVF   x13,W
01580:  SUBLW  04
01582:  BNC   15F2
01584:  BNZ   158C
01586:  MOVF   x12,W
01588:  SUBLW  93
0158A:  BNC   15F2
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0158C:  MOVLW  4C
0158E:  SUBWF  x12,W
01590:  MOVWF  x14
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01592:  MOVFF  914,918
01596:  MOVLW  06
01598:  MOVWF  x19
0159A:  MOVLB  0
0159C:  CALL   0AAA
015A0:  MOVFF  00,915
.................... 		n = n / 6; /* number of sentence */ 
015A4:  MOVFF  914,918
015A8:  MOVLW  06
015AA:  MOVLB  9
015AC:  MOVWF  x19
015AE:  MOVLB  0
015B0:  CALL   0AAA
015B4:  MOVFF  01,914
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
015B8:  MOVLB  9
015BA:  MOVF   x14,W
015BC:  MULLW  06
015BE:  MOVF   FF3,W
015C0:  CLRF   03
015C2:  ADDLW  1A
015C4:  MOVWF  x18
015C6:  MOVLW  00
015C8:  ADDWFC 03,W
015CA:  MOVWF  x19
015CC:  CLRF   03
015CE:  MOVF   x15,W
015D0:  ADDWF  x18,W
015D2:  MOVWF  01
015D4:  MOVF   x19,W
015D6:  ADDWFC 03,F
015D8:  MOVF   01,W
015DA:  ADDLW  36
015DC:  MOVWF  FE9
015DE:  MOVLW  00
015E0:  ADDWFC 03,W
015E2:  MOVWF  FEA
015E4:  MOVF   FEF,W
015E6:  CLRF   03
015E8:  MOVWF  01
015EA:  MOVFF  03,02
015EE:  GOTO   2584
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
015F2:  MOVF   x13,W
015F4:  SUBLW  12
015F6:  BC    163A
015F8:  XORLW  FF
015FA:  BNZ   1602
015FC:  MOVF   x12,W
015FE:  SUBLW  87
01600:  BC    163A
01602:  MOVF   x13,W
01604:  SUBLW  17
01606:  BNC   163A
01608:  BNZ   1610
0160A:  MOVF   x12,W
0160C:  SUBLW  47
0160E:  BNC   163A
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
01610:  MOVLW  88
01612:  SUBWF  x12,F
01614:  MOVLW  13
01616:  SUBWFB x13,F
....................  
....................  		p  = nmea.sentence[0]; 
01618:  MOVLW  04
0161A:  MOVWF  x17
0161C:  MOVLW  06
0161E:  MOVWF  x16
.................... 		return (int16) p[addr]; 
01620:  MOVF   x16,W
01622:  ADDWF  x12,W
01624:  MOVWF  FE9
01626:  MOVF   x17,W
01628:  ADDWFC x13,W
0162A:  MOVWF  FEA
0162C:  MOVF   FEF,W
0162E:  CLRF   03
01630:  MOVWF  01
01632:  MOVFF  03,02
01636:  GOTO   2584
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
0163A:  MOVF   x13,W
0163C:  SUBLW  16
0163E:  BC    16AA
01640:  XORLW  FF
01642:  BNZ   164A
01644:  MOVF   x12,W
01646:  SUBLW  6F
01648:  BC    16AA
0164A:  MOVF   x13,W
0164C:  SUBLW  19
0164E:  BNC   16AA
01650:  BNZ   1658
01652:  MOVF   x12,W
01654:  SUBLW  4F
01656:  BNC   16AA
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01658:  MOVLW  70
0165A:  SUBWF  x12,F
0165C:  MOVLW  17
0165E:  SUBWFB x13,F
.................... 		addr = addr * 2; 
01660:  BCF    FD8.0
01662:  RLCF   x12,F
01664:  RLCF   x13,F
....................  
....................  		p  = nmea.sentence[0]; 
01666:  MOVLW  04
01668:  MOVWF  x17
0166A:  MOVLW  06
0166C:  MOVWF  x16
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0166E:  MOVF   x16,W
01670:  ADDWF  x12,W
01672:  MOVWF  FE9
01674:  MOVF   x17,W
01676:  ADDWFC x13,W
01678:  MOVWF  FEA
0167A:  MOVFF  FEF,918
0167E:  MOVLW  01
01680:  ADDWF  x12,W
01682:  MOVWF  x19
01684:  MOVLW  00
01686:  ADDWFC x13,W
01688:  MOVWF  x1A
0168A:  MOVF   x16,W
0168C:  ADDWF  x19,W
0168E:  MOVWF  FE9
01690:  MOVF   x17,W
01692:  ADDWFC x1A,W
01694:  MOVWF  FEA
01696:  MOVFF  FEF,91B
0169A:  MOVFF  918,03
0169E:  MOVFF  91B,01
016A2:  MOVFF  918,02
016A6:  GOTO   2584
.................... 	} 
....................  
....................  
.................... 	switch ( addr ) { 
016AA:  MOVF   x12,W
016AC:  MOVWF  00
016AE:  MOVF   x13,W
016B0:  MOVWF  03
016B2:  MOVF   03,W
016B4:  BNZ   16C2
016B6:  MOVF   00,F
016B8:  MOVLB  0
016BA:  BTFSC  FD8.2
016BC:  GOTO   1D9E
016C0:  MOVLB  9
016C2:  MOVF   03,W
016C4:  BNZ   16D4
016C6:  MOVLW  01
016C8:  SUBWF  00,W
016CA:  MOVLB  0
016CC:  BTFSC  FD8.2
016CE:  GOTO   1DAE
016D2:  MOVLB  9
016D4:  MOVF   03,W
016D6:  BNZ   16E6
016D8:  MOVLW  02
016DA:  SUBWF  00,W
016DC:  MOVLB  0
016DE:  BTFSC  FD8.2
016E0:  GOTO   1DBE
016E4:  MOVLB  9
016E6:  MOVF   03,W
016E8:  BNZ   16F8
016EA:  MOVLW  03
016EC:  SUBWF  00,W
016EE:  MOVLB  0
016F0:  BTFSC  FD8.2
016F2:  GOTO   1DCE
016F6:  MOVLB  9
016F8:  MOVF   03,W
016FA:  BNZ   170A
016FC:  MOVLW  04
016FE:  SUBWF  00,W
01700:  MOVLB  0
01702:  BTFSC  FD8.2
01704:  GOTO   1DDE
01708:  MOVLB  9
0170A:  MOVF   03,W
0170C:  BNZ   171C
0170E:  MOVLW  05
01710:  SUBWF  00,W
01712:  MOVLB  0
01714:  BTFSC  FD8.2
01716:  GOTO   1E0A
0171A:  MOVLB  9
0171C:  MOVF   03,W
0171E:  BNZ   172E
01720:  MOVLW  06
01722:  SUBWF  00,W
01724:  MOVLB  0
01726:  BTFSC  FD8.2
01728:  GOTO   1E1C
0172C:  MOVLB  9
0172E:  MOVF   03,W
01730:  BNZ   1740
01732:  MOVLW  07
01734:  SUBWF  00,W
01736:  MOVLB  0
01738:  BTFSC  FD8.2
0173A:  GOTO   1E2C
0173E:  MOVLB  9
01740:  MOVF   03,W
01742:  BNZ   1752
01744:  MOVLW  08
01746:  SUBWF  00,W
01748:  MOVLB  0
0174A:  BTFSC  FD8.2
0174C:  GOTO   1E3C
01750:  MOVLB  9
01752:  MOVF   03,W
01754:  BNZ   1764
01756:  MOVLW  09
01758:  SUBWF  00,W
0175A:  MOVLB  0
0175C:  BTFSC  FD8.2
0175E:  GOTO   1E4C
01762:  MOVLB  9
01764:  MOVF   03,W
01766:  BNZ   1776
01768:  MOVLW  0A
0176A:  SUBWF  00,W
0176C:  MOVLB  0
0176E:  BTFSC  FD8.2
01770:  GOTO   1E5A
01774:  MOVLB  9
01776:  MOVF   03,W
01778:  BNZ   1788
0177A:  MOVLW  0B
0177C:  SUBWF  00,W
0177E:  MOVLB  0
01780:  BTFSC  FD8.2
01782:  GOTO   1E86
01786:  MOVLB  9
01788:  MOVF   03,W
0178A:  BNZ   179A
0178C:  MOVLW  0C
0178E:  SUBWF  00,W
01790:  MOVLB  0
01792:  BTFSC  FD8.2
01794:  GOTO   1E96
01798:  MOVLB  9
0179A:  MOVF   03,W
0179C:  BNZ   17AC
0179E:  MOVLW  0D
017A0:  SUBWF  00,W
017A2:  MOVLB  0
017A4:  BTFSC  FD8.2
017A6:  GOTO   1EA4
017AA:  MOVLB  9
017AC:  MOVF   03,W
017AE:  BNZ   17BE
017B0:  MOVLW  0E
017B2:  SUBWF  00,W
017B4:  MOVLB  0
017B6:  BTFSC  FD8.2
017B8:  GOTO   1EB2
017BC:  MOVLB  9
017BE:  MOVF   03,W
017C0:  BNZ   17D0
017C2:  MOVLW  0F
017C4:  SUBWF  00,W
017C6:  MOVLB  0
017C8:  BTFSC  FD8.2
017CA:  GOTO   1EC0
017CE:  MOVLB  9
017D0:  MOVF   03,W
017D2:  BNZ   17E2
017D4:  MOVLW  10
017D6:  SUBWF  00,W
017D8:  MOVLB  0
017DA:  BTFSC  FD8.2
017DC:  GOTO   1ECE
017E0:  MOVLB  9
017E2:  MOVF   03,W
017E4:  BNZ   17F4
017E6:  MOVLW  11
017E8:  SUBWF  00,W
017EA:  MOVLB  0
017EC:  BTFSC  FD8.2
017EE:  GOTO   1EFA
017F2:  MOVLB  9
017F4:  MOVF   03,W
017F6:  BNZ   1806
017F8:  MOVLW  12
017FA:  SUBWF  00,W
017FC:  MOVLB  0
017FE:  BTFSC  FD8.2
01800:  GOTO   1F0A
01804:  MOVLB  9
01806:  MOVF   03,W
01808:  BNZ   1818
0180A:  MOVLW  13
0180C:  SUBWF  00,W
0180E:  MOVLB  0
01810:  BTFSC  FD8.2
01812:  GOTO   1F38
01816:  MOVLB  9
01818:  MOVF   03,W
0181A:  BNZ   182A
0181C:  MOVLW  14
0181E:  SUBWF  00,W
01820:  MOVLB  0
01822:  BTFSC  FD8.2
01824:  GOTO   1F50
01828:  MOVLB  9
0182A:  MOVF   03,W
0182C:  BNZ   183C
0182E:  MOVLW  15
01830:  SUBWF  00,W
01832:  MOVLB  0
01834:  BTFSC  FD8.2
01836:  GOTO   1F5E
0183A:  MOVLB  9
0183C:  MOVF   03,W
0183E:  BNZ   184E
01840:  MOVLW  16
01842:  SUBWF  00,W
01844:  MOVLB  0
01846:  BTFSC  FD8.2
01848:  GOTO   1F8C
0184C:  MOVLB  9
0184E:  MOVF   03,W
01850:  BNZ   1860
01852:  MOVLW  17
01854:  SUBWF  00,W
01856:  MOVLB  0
01858:  BTFSC  FD8.2
0185A:  GOTO   1FA6
0185E:  MOVLB  9
01860:  MOVF   03,W
01862:  BNZ   1872
01864:  MOVLW  18
01866:  SUBWF  00,W
01868:  MOVLB  0
0186A:  BTFSC  FD8.2
0186C:  GOTO   1FB4
01870:  MOVLB  9
01872:  MOVF   03,W
01874:  BNZ   1884
01876:  MOVLW  19
01878:  SUBWF  00,W
0187A:  MOVLB  0
0187C:  BTFSC  FD8.2
0187E:  GOTO   1FE2
01882:  MOVLB  9
01884:  MOVF   03,W
01886:  BNZ   1896
01888:  MOVLW  1A
0188A:  SUBWF  00,W
0188C:  MOVLB  0
0188E:  BTFSC  FD8.2
01890:  GOTO   1FFC
01894:  MOVLB  9
01896:  MOVF   03,W
01898:  BNZ   18A8
0189A:  MOVLW  1B
0189C:  SUBWF  00,W
0189E:  MOVLB  0
018A0:  BTFSC  FD8.2
018A2:  GOTO   200A
018A6:  MOVLB  9
018A8:  MOVF   03,W
018AA:  BNZ   18BA
018AC:  MOVLW  1C
018AE:  SUBWF  00,W
018B0:  MOVLB  0
018B2:  BTFSC  FD8.2
018B4:  GOTO   2038
018B8:  MOVLB  9
018BA:  MOVF   03,W
018BC:  BNZ   18CC
018BE:  MOVLW  1D
018C0:  SUBWF  00,W
018C2:  MOVLB  0
018C4:  BTFSC  FD8.2
018C6:  GOTO   2052
018CA:  MOVLB  9
018CC:  MOVF   03,W
018CE:  BNZ   18DE
018D0:  MOVLW  1E
018D2:  SUBWF  00,W
018D4:  MOVLB  0
018D6:  BTFSC  FD8.2
018D8:  GOTO   2060
018DC:  MOVLB  9
018DE:  MOVF   03,W
018E0:  BNZ   18F0
018E2:  MOVLW  1F
018E4:  SUBWF  00,W
018E6:  MOVLB  0
018E8:  BTFSC  FD8.2
018EA:  GOTO   208E
018EE:  MOVLB  9
018F0:  MOVF   03,W
018F2:  BNZ   1902
018F4:  MOVLW  20
018F6:  SUBWF  00,W
018F8:  MOVLB  0
018FA:  BTFSC  FD8.2
018FC:  GOTO   20A8
01900:  MOVLB  9
01902:  MOVF   03,W
01904:  BNZ   1914
01906:  MOVLW  21
01908:  SUBWF  00,W
0190A:  MOVLB  0
0190C:  BTFSC  FD8.2
0190E:  GOTO   20B6
01912:  MOVLB  9
01914:  MOVF   03,W
01916:  BNZ   1926
01918:  MOVLW  22
0191A:  SUBWF  00,W
0191C:  MOVLB  0
0191E:  BTFSC  FD8.2
01920:  GOTO   20E4
01924:  MOVLB  9
01926:  MOVF   03,W
01928:  BNZ   1938
0192A:  MOVLW  23
0192C:  SUBWF  00,W
0192E:  MOVLB  0
01930:  BTFSC  FD8.2
01932:  GOTO   20FE
01936:  MOVLB  9
01938:  MOVF   03,W
0193A:  BNZ   194A
0193C:  MOVLW  24
0193E:  SUBWF  00,W
01940:  MOVLB  0
01942:  BTFSC  FD8.2
01944:  GOTO   210C
01948:  MOVLB  9
0194A:  MOVF   03,W
0194C:  BNZ   195C
0194E:  MOVLW  25
01950:  SUBWF  00,W
01952:  MOVLB  0
01954:  BTFSC  FD8.2
01956:  GOTO   213A
0195A:  MOVLB  9
0195C:  MOVF   03,W
0195E:  BNZ   196E
01960:  MOVLW  26
01962:  SUBWF  00,W
01964:  MOVLB  0
01966:  BTFSC  FD8.2
01968:  GOTO   2154
0196C:  MOVLB  9
0196E:  MOVF   03,W
01970:  BNZ   1980
01972:  MOVLW  27
01974:  SUBWF  00,W
01976:  MOVLB  0
01978:  BTFSC  FD8.2
0197A:  GOTO   2162
0197E:  MOVLB  9
01980:  MOVF   03,W
01982:  BNZ   1992
01984:  MOVLW  28
01986:  SUBWF  00,W
01988:  MOVLB  0
0198A:  BTFSC  FD8.2
0198C:  GOTO   2190
01990:  MOVLB  9
01992:  MOVF   03,W
01994:  BNZ   19A4
01996:  MOVLW  29
01998:  SUBWF  00,W
0199A:  MOVLB  0
0199C:  BTFSC  FD8.2
0199E:  GOTO   21AA
019A2:  MOVLB  9
019A4:  MOVF   03,W
019A6:  BNZ   19B6
019A8:  MOVLW  2A
019AA:  SUBWF  00,W
019AC:  MOVLB  0
019AE:  BTFSC  FD8.2
019B0:  GOTO   21B8
019B4:  MOVLB  9
019B6:  MOVF   03,W
019B8:  BNZ   19C8
019BA:  MOVLW  2B
019BC:  SUBWF  00,W
019BE:  MOVLB  0
019C0:  BTFSC  FD8.2
019C2:  GOTO   21D2
019C6:  MOVLB  9
019C8:  MOVF   03,W
019CA:  BNZ   19DA
019CC:  MOVLW  2C
019CE:  SUBWF  00,W
019D0:  MOVLB  0
019D2:  BTFSC  FD8.2
019D4:  GOTO   21E2
019D8:  MOVLB  9
019DA:  MOVF   03,W
019DC:  BNZ   19EC
019DE:  MOVLW  2D
019E0:  SUBWF  00,W
019E2:  MOVLB  0
019E4:  BTFSC  FD8.2
019E6:  GOTO   21F2
019EA:  MOVLB  9
019EC:  MOVF   03,W
019EE:  BNZ   19FE
019F0:  MOVLW  2E
019F2:  SUBWF  00,W
019F4:  MOVLB  0
019F6:  BTFSC  FD8.2
019F8:  GOTO   2202
019FC:  MOVLB  9
019FE:  MOVF   03,W
01A00:  BNZ   1A10
01A02:  MOVLW  2F
01A04:  SUBWF  00,W
01A06:  MOVLB  0
01A08:  BTFSC  FD8.2
01A0A:  GOTO   2212
01A0E:  MOVLB  9
01A10:  MOVF   03,W
01A12:  BNZ   1A22
01A14:  MOVLW  30
01A16:  SUBWF  00,W
01A18:  MOVLB  0
01A1A:  BTFSC  FD8.2
01A1C:  GOTO   2222
01A20:  MOVLB  9
01A22:  MOVF   03,W
01A24:  BNZ   1A34
01A26:  MOVLW  31
01A28:  SUBWF  00,W
01A2A:  MOVLB  0
01A2C:  BTFSC  FD8.2
01A2E:  GOTO   2232
01A32:  MOVLB  9
01A34:  MOVF   03,W
01A36:  BNZ   1A46
01A38:  MOVLW  32
01A3A:  SUBWF  00,W
01A3C:  MOVLB  0
01A3E:  BTFSC  FD8.2
01A40:  GOTO   2242
01A44:  MOVLB  9
01A46:  MOVF   03,W
01A48:  BNZ   1A58
01A4A:  MOVLW  33
01A4C:  SUBWF  00,W
01A4E:  MOVLB  0
01A50:  BTFSC  FD8.2
01A52:  GOTO   2252
01A56:  MOVLB  9
01A58:  MOVF   03,W
01A5A:  BNZ   1A6A
01A5C:  MOVLW  34
01A5E:  SUBWF  00,W
01A60:  MOVLB  0
01A62:  BTFSC  FD8.2
01A64:  GOTO   2262
01A68:  MOVLB  9
01A6A:  MOVF   03,W
01A6C:  BNZ   1A7C
01A6E:  MOVLW  35
01A70:  SUBWF  00,W
01A72:  MOVLB  0
01A74:  BTFSC  FD8.2
01A76:  GOTO   2272
01A7A:  MOVLB  9
01A7C:  MOVF   03,W
01A7E:  BNZ   1A8E
01A80:  MOVLW  36
01A82:  SUBWF  00,W
01A84:  MOVLB  0
01A86:  BTFSC  FD8.2
01A88:  GOTO   2282
01A8C:  MOVLB  9
01A8E:  MOVLW  03
01A90:  SUBWF  03,W
01A92:  BNZ   1AA2
01A94:  MOVLW  E8
01A96:  SUBWF  00,W
01A98:  MOVLB  0
01A9A:  BTFSC  FD8.2
01A9C:  GOTO   2294
01AA0:  MOVLB  9
01AA2:  MOVLW  03
01AA4:  SUBWF  03,W
01AA6:  BNZ   1AB6
01AA8:  MOVLW  E9
01AAA:  SUBWF  00,W
01AAC:  MOVLB  0
01AAE:  BTFSC  FD8.2
01AB0:  GOTO   22A4
01AB4:  MOVLB  9
01AB6:  MOVLW  03
01AB8:  SUBWF  03,W
01ABA:  BNZ   1ACA
01ABC:  MOVLW  EA
01ABE:  SUBWF  00,W
01AC0:  MOVLB  0
01AC2:  BTFSC  FD8.2
01AC4:  GOTO   22B2
01AC8:  MOVLB  9
01ACA:  MOVLW  03
01ACC:  SUBWF  03,W
01ACE:  BNZ   1ADE
01AD0:  MOVLW  EB
01AD2:  SUBWF  00,W
01AD4:  MOVLB  0
01AD6:  BTFSC  FD8.2
01AD8:  GOTO   22C0
01ADC:  MOVLB  9
01ADE:  MOVLW  03
01AE0:  SUBWF  03,W
01AE2:  BNZ   1AF2
01AE4:  MOVLW  EC
01AE6:  SUBWF  00,W
01AE8:  MOVLB  0
01AEA:  BTFSC  FD8.2
01AEC:  GOTO   22CE
01AF0:  MOVLB  9
01AF2:  MOVLW  03
01AF4:  SUBWF  03,W
01AF6:  BNZ   1B06
01AF8:  MOVLW  ED
01AFA:  SUBWF  00,W
01AFC:  MOVLB  0
01AFE:  BTFSC  FD8.2
01B00:  GOTO   22DC
01B04:  MOVLB  9
01B06:  MOVLW  03
01B08:  SUBWF  03,W
01B0A:  BNZ   1B1A
01B0C:  MOVLW  EE
01B0E:  SUBWF  00,W
01B10:  MOVLB  0
01B12:  BTFSC  FD8.2
01B14:  GOTO   22EA
01B18:  MOVLB  9
01B1A:  MOVLW  03
01B1C:  SUBWF  03,W
01B1E:  BNZ   1B2E
01B20:  MOVLW  EF
01B22:  SUBWF  00,W
01B24:  MOVLB  0
01B26:  BTFSC  FD8.2
01B28:  GOTO   22FA
01B2C:  MOVLB  9
01B2E:  MOVLW  03
01B30:  SUBWF  03,W
01B32:  BNZ   1B42
01B34:  MOVLW  F0
01B36:  SUBWF  00,W
01B38:  MOVLB  0
01B3A:  BTFSC  FD8.2
01B3C:  GOTO   2308
01B40:  MOVLB  9
01B42:  MOVLW  03
01B44:  SUBWF  03,W
01B46:  BNZ   1B56
01B48:  MOVLW  F1
01B4A:  SUBWF  00,W
01B4C:  MOVLB  0
01B4E:  BTFSC  FD8.2
01B50:  GOTO   2318
01B54:  MOVLB  9
01B56:  MOVLW  03
01B58:  SUBWF  03,W
01B5A:  BNZ   1B6A
01B5C:  MOVLW  F2
01B5E:  SUBWF  00,W
01B60:  MOVLB  0
01B62:  BTFSC  FD8.2
01B64:  GOTO   2326
01B68:  MOVLB  9
01B6A:  MOVLW  03
01B6C:  SUBWF  03,W
01B6E:  BNZ   1B7E
01B70:  MOVLW  F3
01B72:  SUBWF  00,W
01B74:  MOVLB  0
01B76:  BTFSC  FD8.2
01B78:  GOTO   2334
01B7C:  MOVLB  9
01B7E:  MOVLW  03
01B80:  SUBWF  03,W
01B82:  BNZ   1B92
01B84:  MOVLW  F4
01B86:  SUBWF  00,W
01B88:  MOVLB  0
01B8A:  BTFSC  FD8.2
01B8C:  GOTO   2344
01B90:  MOVLB  9
01B92:  MOVLW  03
01B94:  SUBWF  03,W
01B96:  BNZ   1BA6
01B98:  MOVLW  F5
01B9A:  SUBWF  00,W
01B9C:  MOVLB  0
01B9E:  BTFSC  FD8.2
01BA0:  GOTO   2354
01BA4:  MOVLB  9
01BA6:  MOVLW  03
01BA8:  SUBWF  03,W
01BAA:  BNZ   1BBA
01BAC:  MOVLW  F6
01BAE:  SUBWF  00,W
01BB0:  MOVLB  0
01BB2:  BTFSC  FD8.2
01BB4:  GOTO   23D6
01BB8:  MOVLB  9
01BBA:  MOVLW  19
01BBC:  SUBWF  03,W
01BBE:  BNZ   1BCE
01BC0:  MOVLW  64
01BC2:  SUBWF  00,W
01BC4:  MOVLB  0
01BC6:  BTFSC  FD8.2
01BC8:  GOTO   23E6
01BCC:  MOVLB  9
01BCE:  MOVLW  19
01BD0:  SUBWF  03,W
01BD2:  BNZ   1BE2
01BD4:  MOVLW  65
01BD6:  SUBWF  00,W
01BD8:  MOVLB  0
01BDA:  BTFSC  FD8.2
01BDC:  GOTO   23F6
01BE0:  MOVLB  9
01BE2:  MOVLW  19
01BE4:  SUBWF  03,W
01BE6:  BNZ   1BF6
01BE8:  MOVLW  66
01BEA:  SUBWF  00,W
01BEC:  MOVLB  0
01BEE:  BTFSC  FD8.2
01BF0:  GOTO   2408
01BF4:  MOVLB  9
01BF6:  MOVLW  19
01BF8:  SUBWF  03,W
01BFA:  BNZ   1C0A
01BFC:  MOVLW  67
01BFE:  SUBWF  00,W
01C00:  MOVLB  0
01C02:  BTFSC  FD8.2
01C04:  GOTO   2418
01C08:  MOVLB  9
01C0A:  MOVLW  19
01C0C:  SUBWF  03,W
01C0E:  BNZ   1C1E
01C10:  MOVLW  68
01C12:  SUBWF  00,W
01C14:  MOVLB  0
01C16:  BTFSC  FD8.2
01C18:  GOTO   242A
01C1C:  MOVLB  9
01C1E:  MOVLW  19
01C20:  SUBWF  03,W
01C22:  BNZ   1C32
01C24:  MOVLW  69
01C26:  SUBWF  00,W
01C28:  MOVLB  0
01C2A:  BTFSC  FD8.2
01C2C:  GOTO   243A
01C30:  MOVLB  9
01C32:  MOVLW  19
01C34:  SUBWF  03,W
01C36:  BNZ   1C46
01C38:  MOVLW  6A
01C3A:  SUBWF  00,W
01C3C:  MOVLB  0
01C3E:  BTFSC  FD8.2
01C40:  GOTO   244C
01C44:  MOVLB  9
01C46:  MOVLW  19
01C48:  SUBWF  03,W
01C4A:  BNZ   1C5A
01C4C:  MOVLW  6B
01C4E:  SUBWF  00,W
01C50:  MOVLB  0
01C52:  BTFSC  FD8.2
01C54:  GOTO   245C
01C58:  MOVLB  9
01C5A:  MOVLW  19
01C5C:  SUBWF  03,W
01C5E:  BNZ   1C6E
01C60:  MOVLW  6C
01C62:  SUBWF  00,W
01C64:  MOVLB  0
01C66:  BTFSC  FD8.2
01C68:  GOTO   246E
01C6C:  MOVLB  9
01C6E:  MOVLW  19
01C70:  SUBWF  03,W
01C72:  BNZ   1C82
01C74:  MOVLW  6D
01C76:  SUBWF  00,W
01C78:  MOVLB  0
01C7A:  BTFSC  FD8.2
01C7C:  GOTO   247E
01C80:  MOVLB  9
01C82:  MOVLW  19
01C84:  SUBWF  03,W
01C86:  BNZ   1C96
01C88:  MOVLW  6E
01C8A:  SUBWF  00,W
01C8C:  MOVLB  0
01C8E:  BTFSC  FD8.2
01C90:  GOTO   2490
01C94:  MOVLB  9
01C96:  MOVLW  19
01C98:  SUBWF  03,W
01C9A:  BNZ   1CAA
01C9C:  MOVLW  6F
01C9E:  SUBWF  00,W
01CA0:  MOVLB  0
01CA2:  BTFSC  FD8.2
01CA4:  GOTO   24A0
01CA8:  MOVLB  9
01CAA:  MOVLW  19
01CAC:  SUBWF  03,W
01CAE:  BNZ   1CBE
01CB0:  MOVLW  70
01CB2:  SUBWF  00,W
01CB4:  MOVLB  0
01CB6:  BTFSC  FD8.2
01CB8:  GOTO   24B2
01CBC:  MOVLB  9
01CBE:  MOVLW  19
01CC0:  SUBWF  03,W
01CC2:  BNZ   1CD2
01CC4:  MOVLW  71
01CC6:  SUBWF  00,W
01CC8:  MOVLB  0
01CCA:  BTFSC  FD8.2
01CCC:  GOTO   24C2
01CD0:  MOVLB  9
01CD2:  MOVLW  19
01CD4:  SUBWF  03,W
01CD6:  BNZ   1CE6
01CD8:  MOVLW  72
01CDA:  SUBWF  00,W
01CDC:  MOVLB  0
01CDE:  BTFSC  FD8.2
01CE0:  GOTO   24D4
01CE4:  MOVLB  9
01CE6:  MOVLW  19
01CE8:  SUBWF  03,W
01CEA:  BNZ   1CFA
01CEC:  MOVLW  73
01CEE:  SUBWF  00,W
01CF0:  MOVLB  0
01CF2:  BTFSC  FD8.2
01CF4:  GOTO   24E4
01CF8:  MOVLB  9
01CFA:  MOVLW  19
01CFC:  SUBWF  03,W
01CFE:  BNZ   1D0E
01D00:  MOVLW  74
01D02:  SUBWF  00,W
01D04:  MOVLB  0
01D06:  BTFSC  FD8.2
01D08:  GOTO   24F6
01D0C:  MOVLB  9
01D0E:  MOVLW  19
01D10:  SUBWF  03,W
01D12:  BNZ   1D22
01D14:  MOVLW  75
01D16:  SUBWF  00,W
01D18:  MOVLB  0
01D1A:  BTFSC  FD8.2
01D1C:  GOTO   2506
01D20:  MOVLB  9
01D22:  MOVLW  19
01D24:  SUBWF  03,W
01D26:  BNZ   1D36
01D28:  MOVLW  76
01D2A:  SUBWF  00,W
01D2C:  MOVLB  0
01D2E:  BTFSC  FD8.2
01D30:  GOTO   2518
01D34:  MOVLB  9
01D36:  MOVLW  19
01D38:  SUBWF  03,W
01D3A:  BNZ   1D4A
01D3C:  MOVLW  77
01D3E:  SUBWF  00,W
01D40:  MOVLB  0
01D42:  BTFSC  FD8.2
01D44:  GOTO   2528
01D48:  MOVLB  9
01D4A:  MOVLW  19
01D4C:  SUBWF  03,W
01D4E:  BNZ   1D5E
01D50:  MOVLW  78
01D52:  SUBWF  00,W
01D54:  MOVLB  0
01D56:  BTFSC  FD8.2
01D58:  GOTO   253A
01D5C:  MOVLB  9
01D5E:  MOVLW  19
01D60:  SUBWF  03,W
01D62:  BNZ   1D72
01D64:  MOVLW  79
01D66:  SUBWF  00,W
01D68:  MOVLB  0
01D6A:  BTFSC  FD8.2
01D6C:  GOTO   254A
01D70:  MOVLB  9
01D72:  MOVLW  19
01D74:  SUBWF  03,W
01D76:  BNZ   1D86
01D78:  MOVLW  7A
01D7A:  SUBWF  00,W
01D7C:  MOVLB  0
01D7E:  BTFSC  FD8.2
01D80:  GOTO   255C
01D84:  MOVLB  9
01D86:  MOVLW  19
01D88:  SUBWF  03,W
01D8A:  BNZ   1D9A
01D8C:  MOVLW  7B
01D8E:  SUBWF  00,W
01D90:  MOVLB  0
01D92:  BTFSC  FD8.2
01D94:  GOTO   256C
01D98:  MOVLB  9
01D9A:  GOTO   257C
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01D9E:  MOVFF  AA,01
01DA2:  MOVFF  AB,02
01DA6:  MOVLB  9
01DA8:  GOTO   2584
01DAC:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01DAE:  MOVF   x98,W
01DB0:  MOVWF  01
01DB2:  MOVF   x99,W
01DB4:  MOVWF  02
01DB6:  MOVLB  9
01DB8:  GOTO   2584
01DBC:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01DBE:  MOVF   x9E,W
01DC0:  MOVWF  01
01DC2:  MOVF   x9F,W
01DC4:  MOVWF  02
01DC6:  MOVLB  9
01DC8:  GOTO   2584
01DCC:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01DCE:  MOVF   xA4,W
01DD0:  MOVWF  01
01DD2:  MOVF   xA5,W
01DD4:  MOVWF  02
01DD6:  MOVLB  9
01DD8:  GOTO   2584
01DDC:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01DDE:  MOVLB  9
01DE0:  CLRF   x18
01DE2:  MOVLB  0
01DE4:  CALL   13AE
01DE8:  MOVFF  03,8F4
01DEC:  MOVFF  02,8F3
01DF0:  MOVFF  01,8F2
01DF4:  MOVFF  00,8F1
01DF8:  MOVLB  8
01DFA:  MOVF   xF1,W
01DFC:  MOVWF  01
01DFE:  MOVF   xF2,W
01E00:  MOVWF  02
01E02:  MOVLB  9
01E04:  GOTO   2584
01E08:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01E0A:  MOVLB  8
01E0C:  MOVF   xF3,W
01E0E:  MOVWF  01
01E10:  MOVF   xF4,W
01E12:  MOVWF  02
01E14:  MOVLB  9
01E16:  GOTO   2584
01E1A:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01E1C:  MOVF   xAC,W
01E1E:  MOVWF  01
01E20:  MOVF   xAD,W
01E22:  MOVWF  02
01E24:  MOVLB  9
01E26:  GOTO   2584
01E2A:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01E2C:  MOVF   x9A,W
01E2E:  MOVWF  01
01E30:  MOVF   x9B,W
01E32:  MOVWF  02
01E34:  MOVLB  9
01E36:  GOTO   2584
01E3A:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01E3C:  MOVF   xA0,W
01E3E:  MOVWF  01
01E40:  MOVF   xA1,W
01E42:  MOVWF  02
01E44:  MOVLB  9
01E46:  GOTO   2584
01E4A:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01E4C:  MOVF   xA6,W
01E4E:  MOVWF  01
01E50:  MOVF   xA7,W
01E52:  MOVWF  02
01E54:  MOVLB  9
01E56:  BRA    2584
01E58:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01E5A:  MOVLW  01
01E5C:  MOVLB  9
01E5E:  MOVWF  x18
01E60:  MOVLB  0
01E62:  CALL   13AE
01E66:  MOVFF  03,8F4
01E6A:  MOVFF  02,8F3
01E6E:  MOVFF  01,8F2
01E72:  MOVFF  00,8F1
01E76:  MOVLB  8
01E78:  MOVF   xF1,W
01E7A:  MOVWF  01
01E7C:  MOVF   xF2,W
01E7E:  MOVWF  02
01E80:  MOVLB  9
01E82:  BRA    2584
01E84:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01E86:  MOVLB  8
01E88:  MOVF   xF3,W
01E8A:  MOVWF  01
01E8C:  MOVF   xF4,W
01E8E:  MOVWF  02
01E90:  MOVLB  9
01E92:  BRA    2584
01E94:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01E96:  MOVF   xAE,W
01E98:  MOVWF  01
01E9A:  MOVF   xAF,W
01E9C:  MOVWF  02
01E9E:  MOVLB  9
01EA0:  BRA    2584
01EA2:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01EA4:  MOVF   x9C,W
01EA6:  MOVWF  01
01EA8:  MOVF   x9D,W
01EAA:  MOVWF  02
01EAC:  MOVLB  9
01EAE:  BRA    2584
01EB0:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01EB2:  MOVF   xA2,W
01EB4:  MOVWF  01
01EB6:  MOVF   xA3,W
01EB8:  MOVWF  02
01EBA:  MOVLB  9
01EBC:  BRA    2584
01EBE:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01EC0:  MOVF   xA8,W
01EC2:  MOVWF  01
01EC4:  MOVF   xA9,W
01EC6:  MOVWF  02
01EC8:  MOVLB  9
01ECA:  BRA    2584
01ECC:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01ECE:  MOVLW  02
01ED0:  MOVLB  9
01ED2:  MOVWF  x18
01ED4:  MOVLB  0
01ED6:  CALL   13AE
01EDA:  MOVFF  03,8F4
01EDE:  MOVFF  02,8F3
01EE2:  MOVFF  01,8F2
01EE6:  MOVFF  00,8F1
01EEA:  MOVLB  8
01EEC:  MOVF   xF1,W
01EEE:  MOVWF  01
01EF0:  MOVF   xF2,W
01EF2:  MOVWF  02
01EF4:  MOVLB  9
01EF6:  BRA    2584
01EF8:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01EFA:  MOVLB  8
01EFC:  MOVF   xF3,W
01EFE:  MOVWF  01
01F00:  MOVF   xF4,W
01F02:  MOVWF  02
01F04:  MOVLB  9
01F06:  BRA    2584
01F08:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01F0A:  CLRF   03
01F0C:  MOVLB  1
01F0E:  MOVF   xCC,W
01F10:  MOVWF  02
01F12:  BCF    FD8.0
01F14:  RLCF   02,F
01F16:  RLCF   03,F
01F18:  MOVF   02,W
01F1A:  ADDLW  CC
01F1C:  MOVWF  FE9
01F1E:  MOVLW  00
01F20:  ADDWFC 03,W
01F22:  MOVWF  FEA
01F24:  MOVFF  FEC,03
01F28:  MOVF   FED,F
01F2A:  MOVF   FEF,W
01F2C:  MOVWF  01
01F2E:  MOVF   03,W
01F30:  MOVWF  02
01F32:  MOVLB  9
01F34:  BRA    2584
01F36:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01F38:  MOVLB  9
01F3A:  CLRF   x18
01F3C:  MOVLB  0
01F3E:  CALL   1410
01F42:  MOVF   01,W
01F44:  MOVWF  01
01F46:  MOVF   02,W
01F48:  MOVWF  02
01F4A:  MOVLB  9
01F4C:  BRA    2584
01F4E:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01F50:  MOVF   xBC,W
01F52:  MOVWF  01
01F54:  MOVF   xBD,W
01F56:  MOVWF  02
01F58:  MOVLB  9
01F5A:  BRA    2584
01F5C:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01F5E:  CLRF   03
01F60:  MOVLB  1
01F62:  MOVF   xCC,W
01F64:  MOVWF  02
01F66:  BCF    FD8.0
01F68:  RLCF   02,F
01F6A:  RLCF   03,F
01F6C:  MOVF   02,W
01F6E:  ADDLW  EC
01F70:  MOVWF  FE9
01F72:  MOVLW  00
01F74:  ADDWFC 03,W
01F76:  MOVWF  FEA
01F78:  MOVFF  FEC,03
01F7C:  MOVF   FED,F
01F7E:  MOVF   FEF,W
01F80:  MOVWF  01
01F82:  MOVF   03,W
01F84:  MOVWF  02
01F86:  MOVLB  9
01F88:  BRA    2584
01F8A:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01F8C:  MOVLW  01
01F8E:  MOVLB  9
01F90:  MOVWF  x18
01F92:  MOVLB  0
01F94:  CALL   1410
01F98:  MOVF   01,W
01F9A:  MOVWF  01
01F9C:  MOVF   02,W
01F9E:  MOVWF  02
01FA0:  MOVLB  9
01FA2:  BRA    2584
01FA4:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01FA6:  MOVF   xBE,W
01FA8:  MOVWF  01
01FAA:  MOVF   xBF,W
01FAC:  MOVWF  02
01FAE:  MOVLB  9
01FB0:  BRA    2584
01FB2:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01FB4:  CLRF   03
01FB6:  MOVLB  1
01FB8:  MOVF   xCC,W
01FBA:  MOVWF  02
01FBC:  BCF    FD8.0
01FBE:  RLCF   02,F
01FC0:  RLCF   03,F
01FC2:  MOVF   02,W
01FC4:  ADDLW  0C
01FC6:  MOVWF  FE9
01FC8:  MOVLW  01
01FCA:  ADDWFC 03,W
01FCC:  MOVWF  FEA
01FCE:  MOVFF  FEC,03
01FD2:  MOVF   FED,F
01FD4:  MOVF   FEF,W
01FD6:  MOVWF  01
01FD8:  MOVF   03,W
01FDA:  MOVWF  02
01FDC:  MOVLB  9
01FDE:  BRA    2584
01FE0:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01FE2:  MOVLW  02
01FE4:  MOVLB  9
01FE6:  MOVWF  x18
01FE8:  MOVLB  0
01FEA:  CALL   1410
01FEE:  MOVF   01,W
01FF0:  MOVWF  01
01FF2:  MOVF   02,W
01FF4:  MOVWF  02
01FF6:  MOVLB  9
01FF8:  BRA    2584
01FFA:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01FFC:  MOVF   xC0,W
01FFE:  MOVWF  01
02000:  MOVF   xC1,W
02002:  MOVWF  02
02004:  MOVLB  9
02006:  BRA    2584
02008:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
0200A:  CLRF   03
0200C:  MOVLB  1
0200E:  MOVF   xCC,W
02010:  MOVWF  02
02012:  BCF    FD8.0
02014:  RLCF   02,F
02016:  RLCF   03,F
02018:  MOVF   02,W
0201A:  ADDLW  2C
0201C:  MOVWF  FE9
0201E:  MOVLW  01
02020:  ADDWFC 03,W
02022:  MOVWF  FEA
02024:  MOVFF  FEC,03
02028:  MOVF   FED,F
0202A:  MOVF   FEF,W
0202C:  MOVWF  01
0202E:  MOVF   03,W
02030:  MOVWF  02
02032:  MOVLB  9
02034:  BRA    2584
02036:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
02038:  MOVLW  03
0203A:  MOVLB  9
0203C:  MOVWF  x18
0203E:  MOVLB  0
02040:  CALL   1410
02044:  MOVF   01,W
02046:  MOVWF  01
02048:  MOVF   02,W
0204A:  MOVWF  02
0204C:  MOVLB  9
0204E:  BRA    2584
02050:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
02052:  MOVF   xC2,W
02054:  MOVWF  01
02056:  MOVF   xC3,W
02058:  MOVWF  02
0205A:  MOVLB  9
0205C:  BRA    2584
0205E:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
02060:  CLRF   03
02062:  MOVLB  1
02064:  MOVF   xCC,W
02066:  MOVWF  02
02068:  BCF    FD8.0
0206A:  RLCF   02,F
0206C:  RLCF   03,F
0206E:  MOVF   02,W
02070:  ADDLW  4C
02072:  MOVWF  FE9
02074:  MOVLW  01
02076:  ADDWFC 03,W
02078:  MOVWF  FEA
0207A:  MOVFF  FEC,03
0207E:  MOVF   FED,F
02080:  MOVF   FEF,W
02082:  MOVWF  01
02084:  MOVF   03,W
02086:  MOVWF  02
02088:  MOVLB  9
0208A:  BRA    2584
0208C:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
0208E:  MOVLW  04
02090:  MOVLB  9
02092:  MOVWF  x18
02094:  MOVLB  0
02096:  CALL   1410
0209A:  MOVF   01,W
0209C:  MOVWF  01
0209E:  MOVF   02,W
020A0:  MOVWF  02
020A2:  MOVLB  9
020A4:  BRA    2584
020A6:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
020A8:  MOVF   xC4,W
020AA:  MOVWF  01
020AC:  MOVF   xC5,W
020AE:  MOVWF  02
020B0:  MOVLB  9
020B2:  BRA    2584
020B4:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
020B6:  CLRF   03
020B8:  MOVLB  1
020BA:  MOVF   xCC,W
020BC:  MOVWF  02
020BE:  BCF    FD8.0
020C0:  RLCF   02,F
020C2:  RLCF   03,F
020C4:  MOVF   02,W
020C6:  ADDLW  6C
020C8:  MOVWF  FE9
020CA:  MOVLW  01
020CC:  ADDWFC 03,W
020CE:  MOVWF  FEA
020D0:  MOVFF  FEC,03
020D4:  MOVF   FED,F
020D6:  MOVF   FEF,W
020D8:  MOVWF  01
020DA:  MOVF   03,W
020DC:  MOVWF  02
020DE:  MOVLB  9
020E0:  BRA    2584
020E2:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
020E4:  MOVLW  05
020E6:  MOVLB  9
020E8:  MOVWF  x18
020EA:  MOVLB  0
020EC:  CALL   1410
020F0:  MOVF   01,W
020F2:  MOVWF  01
020F4:  MOVF   02,W
020F6:  MOVWF  02
020F8:  MOVLB  9
020FA:  BRA    2584
020FC:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
020FE:  MOVF   xC6,W
02100:  MOVWF  01
02102:  MOVF   xC7,W
02104:  MOVWF  02
02106:  MOVLB  9
02108:  BRA    2584
0210A:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
0210C:  CLRF   03
0210E:  MOVLB  1
02110:  MOVF   xCC,W
02112:  MOVWF  02
02114:  BCF    FD8.0
02116:  RLCF   02,F
02118:  RLCF   03,F
0211A:  MOVF   02,W
0211C:  ADDLW  8C
0211E:  MOVWF  FE9
02120:  MOVLW  01
02122:  ADDWFC 03,W
02124:  MOVWF  FEA
02126:  MOVFF  FEC,03
0212A:  MOVF   FED,F
0212C:  MOVF   FEF,W
0212E:  MOVWF  01
02130:  MOVF   03,W
02132:  MOVWF  02
02134:  MOVLB  9
02136:  BRA    2584
02138:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
0213A:  MOVLW  06
0213C:  MOVLB  9
0213E:  MOVWF  x18
02140:  MOVLB  0
02142:  CALL   1410
02146:  MOVF   01,W
02148:  MOVWF  01
0214A:  MOVF   02,W
0214C:  MOVWF  02
0214E:  MOVLB  9
02150:  BRA    2584
02152:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
02154:  MOVF   xC8,W
02156:  MOVWF  01
02158:  MOVF   xC9,W
0215A:  MOVWF  02
0215C:  MOVLB  9
0215E:  BRA    2584
02160:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
02162:  CLRF   03
02164:  MOVLB  1
02166:  MOVF   xCC,W
02168:  MOVWF  02
0216A:  BCF    FD8.0
0216C:  RLCF   02,F
0216E:  RLCF   03,F
02170:  MOVF   02,W
02172:  ADDLW  AC
02174:  MOVWF  FE9
02176:  MOVLW  01
02178:  ADDWFC 03,W
0217A:  MOVWF  FEA
0217C:  MOVFF  FEC,03
02180:  MOVF   FED,F
02182:  MOVF   FEF,W
02184:  MOVWF  01
02186:  MOVF   03,W
02188:  MOVWF  02
0218A:  MOVLB  9
0218C:  BRA    2584
0218E:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
02190:  MOVLW  07
02192:  MOVLB  9
02194:  MOVWF  x18
02196:  MOVLB  0
02198:  CALL   1410
0219C:  MOVF   01,W
0219E:  MOVWF  01
021A0:  MOVF   02,W
021A2:  MOVWF  02
021A4:  MOVLB  9
021A6:  BRA    2584
021A8:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
021AA:  MOVF   xCA,W
021AC:  MOVWF  01
021AE:  MOVF   xCB,W
021B0:  MOVWF  02
021B2:  MOVLB  9
021B4:  BRA    2584
021B6:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
021B8:  MOVLB  1
021BA:  MOVF   xD4,W
021BC:  MOVWF  03
021BE:  MOVF   xD3,W
021C0:  INCF   xD3,F
021C2:  BTFSC  FD8.2
021C4:  INCF   xD4,F
021C6:  MOVWF  01
021C8:  MOVF   03,W
021CA:  MOVWF  02
021CC:  MOVLB  9
021CE:  BRA    2584
021D0:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
021D2:  MOVLB  1
021D4:  MOVF   xD7,W
021D6:  MOVWF  01
021D8:  MOVF   xD8,W
021DA:  MOVWF  02
021DC:  MOVLB  9
021DE:  BRA    2584
021E0:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
021E2:  MOVLB  1
021E4:  MOVF   xD5,W
021E6:  MOVWF  01
021E8:  MOVF   xD6,W
021EA:  MOVWF  02
021EC:  MOVLB  9
021EE:  BRA    2584
021F0:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
021F2:  MOVLB  1
021F4:  MOVF   xDA,W
021F6:  MOVWF  01
021F8:  MOVF   xDB,W
021FA:  MOVWF  02
021FC:  MOVLB  9
021FE:  BRA    2584
02200:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
02202:  GOTO   149A
02206:  MOVLW  00
02208:  MOVWF  01
0220A:  MOVWF  02
0220C:  MOVLB  9
0220E:  BRA    2584
02210:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
02212:  GOTO   14D6
02216:  MOVLW  00
02218:  MOVWF  01
0221A:  MOVWF  02
0221C:  MOVLB  9
0221E:  BRA    2584
02220:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
02222:  MOVLB  1
02224:  MOVF   xCD,W
02226:  MOVWF  01
02228:  MOVF   xCE,W
0222A:  MOVWF  02
0222C:  MOVLB  9
0222E:  BRA    2584
02230:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
02232:  MOVLB  1
02234:  MOVF   xCF,W
02236:  MOVWF  01
02238:  MOVF   xD0,W
0223A:  MOVWF  02
0223C:  MOVLB  9
0223E:  BRA    2584
02240:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
02242:  MOVLB  1
02244:  MOVF   xD1,W
02246:  MOVWF  01
02248:  MOVF   xD2,W
0224A:  MOVWF  02
0224C:  MOVLB  9
0224E:  BRA    2584
02250:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
02252:  GOTO   14FE
02256:  MOVLW  00
02258:  MOVWF  01
0225A:  MOVWF  02
0225C:  MOVLB  9
0225E:  BRA    2584
02260:  MOVLB  0
.................... 		 
.................... 		/* meta */ 
.................... 		case 52: return (int16) current.rda_bytes_received; 
02262:  MOVLB  1
02264:  MOVF   xE3,W
02266:  MOVWF  01
02268:  MOVF   xE4,W
0226A:  MOVWF  02
0226C:  MOVLB  9
0226E:  BRA    2584
02270:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
02272:  MOVLB  1
02274:  MOVF   xE5,W
02276:  MOVWF  01
02278:  MOVF   xE6,W
0227A:  MOVWF  02
0227C:  MOVLB  9
0227E:  BRA    2584
02280:  MOVLB  0
.................... 		case 54: return (int16) current.button_state; 
02282:  CLRF   03
02284:  MOVLB  1
02286:  MOVF   xE7,W
02288:  MOVWF  01
0228A:  MOVF   03,W
0228C:  MOVWF  02
0228E:  MOVLB  9
02290:  BRA    2584
02292:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
02294:  CLRF   03
02296:  MOVF   3A,W
02298:  MOVWF  01
0229A:  MOVF   03,W
0229C:  MOVWF  02
0229E:  MOVLB  9
022A0:  BRA    2584
022A2:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
022A4:  MOVF   3B,W
022A6:  MOVWF  01
022A8:  MOVF   3C,W
022AA:  MOVWF  02
022AC:  MOVLB  9
022AE:  BRA    2584
022B0:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
022B2:  MOVLW  50
022B4:  MOVWF  01
022B6:  MOVLW  00
022B8:  MOVWF  02
022BA:  MOVLB  9
022BC:  BRA    2584
022BE:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
022C0:  MOVLW  57
022C2:  MOVWF  01
022C4:  MOVLW  00
022C6:  MOVWF  02
022C8:  MOVLB  9
022CA:  BRA    2584
022CC:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
022CE:  MOVLW  58
022D0:  MOVWF  01
022D2:  MOVLW  00
022D4:  MOVWF  02
022D6:  MOVLB  9
022D8:  BRA    2584
022DA:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
022DC:  MOVLW  01
022DE:  MOVWF  01
022E0:  MOVLW  00
022E2:  MOVWF  02
022E4:  MOVLB  9
022E6:  BRA    2584
022E8:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
022EA:  CLRF   03
022EC:  MOVF   36,W
022EE:  MOVWF  01
022F0:  MOVF   03,W
022F2:  MOVWF  02
022F4:  MOVLB  9
022F6:  BRA    2584
022F8:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
022FA:  MOVF   3D,W
022FC:  MOVWF  01
022FE:  MOVF   3E,W
02300:  MOVWF  02
02302:  MOVLB  9
02304:  BRA    2584
02306:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
02308:  CLRF   03
0230A:  MOVF   3F,W
0230C:  MOVWF  01
0230E:  MOVF   03,W
02310:  MOVWF  02
02312:  MOVLB  9
02314:  BRA    2584
02316:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
02318:  MOVF   40,W
0231A:  MOVWF  01
0231C:  MOVF   41,W
0231E:  MOVWF  02
02320:  MOVLB  9
02322:  BRA    2584
02324:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
02326:  MOVF   42,W
02328:  MOVWF  01
0232A:  MOVF   43,W
0232C:  MOVWF  02
0232E:  MOVLB  9
02330:  BRA    2584
02332:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
02334:  CLRF   03
02336:  MOVF   44,W
02338:  MOVWF  01
0233A:  MOVF   03,W
0233C:  MOVWF  02
0233E:  MOVLB  9
02340:  BRA    2584
02342:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
02344:  CLRF   03
02346:  MOVF   38,W
02348:  MOVWF  01
0234A:  MOVF   03,W
0234C:  MOVWF  02
0234E:  MOVLB  9
02350:  BRA    2584
02352:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
02354:  MOVF   39,F
02356:  BNZ   2366
02358:  MOVLW  B0
0235A:  MOVWF  01
0235C:  MOVLW  04
0235E:  MOVWF  02
02360:  MOVLB  9
02362:  BRA    2584
02364:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
02366:  DECFSZ 39,W
02368:  BRA    2378
0236A:  MOVLW  60
0236C:  MOVWF  01
0236E:  MOVLW  09
02370:  MOVWF  02
02372:  MOVLB  9
02374:  BRA    2584
02376:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
02378:  MOVF   39,W
0237A:  SUBLW  02
0237C:  BNZ   238C
0237E:  MOVLW  C0
02380:  MOVWF  01
02382:  MOVLW  12
02384:  MOVWF  02
02386:  MOVLB  9
02388:  BRA    2584
0238A:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
0238C:  MOVF   39,W
0238E:  SUBLW  04
02390:  BNZ   23A0
02392:  MOVLW  00
02394:  MOVWF  01
02396:  MOVLW  4B
02398:  MOVWF  02
0239A:  MOVLB  9
0239C:  BRA    2584
0239E:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
023A0:  MOVF   39,W
023A2:  SUBLW  05
023A4:  BNZ   23B4
023A6:  MOVLW  00
023A8:  MOVWF  01
023AA:  MOVLW  96
023AC:  MOVWF  02
023AE:  MOVLB  9
023B0:  BRA    2584
023B2:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
023B4:  MOVF   39,W
023B6:  SUBLW  06
023B8:  BNZ   23C8
023BA:  MOVLW  00
023BC:  MOVWF  01
023BE:  MOVLW  E1
023C0:  MOVWF  02
023C2:  MOVLB  9
023C4:  BRA    2584
023C6:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
023C8:  MOVLW  80
023CA:  MOVWF  01
023CC:  MOVLW  25
023CE:  MOVWF  02
023D0:  MOVLB  9
023D2:  BRA    2584
023D4:  MOVLB  0
.................... 		case 1014: return (int16) config.pic_to_pi_latch_mask; 
023D6:  CLRF   03
023D8:  MOVF   4F,W
023DA:  MOVWF  01
023DC:  MOVF   03,W
023DE:  MOVWF  02
023E0:  MOVLB  9
023E2:  BRA    2584
023E4:  MOVLB  0
....................  
.................... 		/* NMEA sentence age and length */ 
.................... 		case 6500: return (int16) nmea.sentence_age[0]; 
023E6:  MOVLB  7
023E8:  MOVF   xC6,W
023EA:  MOVWF  01
023EC:  MOVF   xC7,W
023EE:  MOVWF  02
023F0:  MOVLB  9
023F2:  BRA    2584
023F4:  MOVLB  0
.................... 		case 6501: return (int16) nmea.sentence_length[0]; 
023F6:  CLRF   03
023F8:  MOVLB  7
023FA:  MOVF   xDE,W
023FC:  MOVWF  01
023FE:  MOVF   03,W
02400:  MOVWF  02
02402:  MOVLB  9
02404:  BRA    2584
02406:  MOVLB  0
.................... 		case 6502: return (int16) nmea.sentence_age[1]; 
02408:  MOVLB  7
0240A:  MOVF   xC8,W
0240C:  MOVWF  01
0240E:  MOVF   xC9,W
02410:  MOVWF  02
02412:  MOVLB  9
02414:  BRA    2584
02416:  MOVLB  0
.................... 		case 6503: return (int16) nmea.sentence_length[1]; 
02418:  CLRF   03
0241A:  MOVLB  7
0241C:  MOVF   xDF,W
0241E:  MOVWF  01
02420:  MOVF   03,W
02422:  MOVWF  02
02424:  MOVLB  9
02426:  BRA    2584
02428:  MOVLB  0
.................... 		case 6504: return (int16) nmea.sentence_age[2]; 
0242A:  MOVLB  7
0242C:  MOVF   xCA,W
0242E:  MOVWF  01
02430:  MOVF   xCB,W
02432:  MOVWF  02
02434:  MOVLB  9
02436:  BRA    2584
02438:  MOVLB  0
.................... 		case 6505: return (int16) nmea.sentence_length[2]; 
0243A:  CLRF   03
0243C:  MOVLB  7
0243E:  MOVF   xE0,W
02440:  MOVWF  01
02442:  MOVF   03,W
02444:  MOVWF  02
02446:  MOVLB  9
02448:  BRA    2584
0244A:  MOVLB  0
.................... 		case 6506: return (int16) nmea.sentence_age[3]; 
0244C:  MOVLB  7
0244E:  MOVF   xCC,W
02450:  MOVWF  01
02452:  MOVF   xCD,W
02454:  MOVWF  02
02456:  MOVLB  9
02458:  BRA    2584
0245A:  MOVLB  0
.................... 		case 6507: return (int16) nmea.sentence_length[3]; 
0245C:  CLRF   03
0245E:  MOVLB  7
02460:  MOVF   xE1,W
02462:  MOVWF  01
02464:  MOVF   03,W
02466:  MOVWF  02
02468:  MOVLB  9
0246A:  BRA    2584
0246C:  MOVLB  0
.................... 		case 6508: return (int16) nmea.sentence_age[4]; 
0246E:  MOVLB  7
02470:  MOVF   xCE,W
02472:  MOVWF  01
02474:  MOVF   xCF,W
02476:  MOVWF  02
02478:  MOVLB  9
0247A:  BRA    2584
0247C:  MOVLB  0
.................... 		case 6509: return (int16) nmea.sentence_length[4]; 
0247E:  CLRF   03
02480:  MOVLB  7
02482:  MOVF   xE2,W
02484:  MOVWF  01
02486:  MOVF   03,W
02488:  MOVWF  02
0248A:  MOVLB  9
0248C:  BRA    2584
0248E:  MOVLB  0
.................... 		case 6510: return (int16) nmea.sentence_age[5]; 
02490:  MOVLB  7
02492:  MOVF   xD0,W
02494:  MOVWF  01
02496:  MOVF   xD1,W
02498:  MOVWF  02
0249A:  MOVLB  9
0249C:  BRA    2584
0249E:  MOVLB  0
.................... 		case 6511: return (int16) nmea.sentence_length[5]; 
024A0:  CLRF   03
024A2:  MOVLB  7
024A4:  MOVF   xE3,W
024A6:  MOVWF  01
024A8:  MOVF   03,W
024AA:  MOVWF  02
024AC:  MOVLB  9
024AE:  BRA    2584
024B0:  MOVLB  0
.................... 		case 6512: return (int16) nmea.sentence_age[6]; 
024B2:  MOVLB  7
024B4:  MOVF   xD2,W
024B6:  MOVWF  01
024B8:  MOVF   xD3,W
024BA:  MOVWF  02
024BC:  MOVLB  9
024BE:  BRA    2584
024C0:  MOVLB  0
.................... 		case 6513: return (int16) nmea.sentence_length[6]; 
024C2:  CLRF   03
024C4:  MOVLB  7
024C6:  MOVF   xE4,W
024C8:  MOVWF  01
024CA:  MOVF   03,W
024CC:  MOVWF  02
024CE:  MOVLB  9
024D0:  BRA    2584
024D2:  MOVLB  0
.................... 		case 6514: return (int16) nmea.sentence_age[7]; 
024D4:  MOVLB  7
024D6:  MOVF   xD4,W
024D8:  MOVWF  01
024DA:  MOVF   xD5,W
024DC:  MOVWF  02
024DE:  MOVLB  9
024E0:  BRA    2584
024E2:  MOVLB  0
.................... 		case 6515: return (int16) nmea.sentence_length[7]; 
024E4:  CLRF   03
024E6:  MOVLB  7
024E8:  MOVF   xE5,W
024EA:  MOVWF  01
024EC:  MOVF   03,W
024EE:  MOVWF  02
024F0:  MOVLB  9
024F2:  BRA    2584
024F4:  MOVLB  0
.................... 		case 6516: return (int16) nmea.sentence_age[8]; 
024F6:  MOVLB  7
024F8:  MOVF   xD6,W
024FA:  MOVWF  01
024FC:  MOVF   xD7,W
024FE:  MOVWF  02
02500:  MOVLB  9
02502:  BRA    2584
02504:  MOVLB  0
.................... 		case 6517: return (int16) nmea.sentence_length[8]; 
02506:  CLRF   03
02508:  MOVLB  7
0250A:  MOVF   xE6,W
0250C:  MOVWF  01
0250E:  MOVF   03,W
02510:  MOVWF  02
02512:  MOVLB  9
02514:  BRA    2584
02516:  MOVLB  0
.................... 		case 6518: return (int16) nmea.sentence_age[9]; 
02518:  MOVLB  7
0251A:  MOVF   xD8,W
0251C:  MOVWF  01
0251E:  MOVF   xD9,W
02520:  MOVWF  02
02522:  MOVLB  9
02524:  BRA    2584
02526:  MOVLB  0
.................... 		case 6519: return (int16) nmea.sentence_length[9]; 
02528:  CLRF   03
0252A:  MOVLB  7
0252C:  MOVF   xE7,W
0252E:  MOVWF  01
02530:  MOVF   03,W
02532:  MOVWF  02
02534:  MOVLB  9
02536:  BRA    2584
02538:  MOVLB  0
.................... 		case 6520: return (int16) nmea.sentence_age[10]; 
0253A:  MOVLB  7
0253C:  MOVF   xDA,W
0253E:  MOVWF  01
02540:  MOVF   xDB,W
02542:  MOVWF  02
02544:  MOVLB  9
02546:  BRA    2584
02548:  MOVLB  0
.................... 		case 6521: return (int16) nmea.sentence_length[10]; 
0254A:  CLRF   03
0254C:  MOVLB  7
0254E:  MOVF   xE8,W
02550:  MOVWF  01
02552:  MOVF   03,W
02554:  MOVWF  02
02556:  MOVLB  9
02558:  BRA    2584
0255A:  MOVLB  0
.................... 		case 6522: return (int16) nmea.sentence_age[11]; 
0255C:  MOVLB  7
0255E:  MOVF   xDC,W
02560:  MOVWF  01
02562:  MOVF   xDD,W
02564:  MOVWF  02
02566:  MOVLB  9
02568:  BRA    2584
0256A:  MOVLB  0
.................... 		case 6523: return (int16) nmea.sentence_length[11]; 
0256C:  CLRF   03
0256E:  MOVLB  7
02570:  MOVF   xE9,W
02572:  MOVWF  01
02574:  MOVF   03,W
02576:  MOVWF  02
02578:  MOVLB  9
0257A:  BRA    2584
....................  
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
0257C:  MOVLW  FF
0257E:  MOVWF  01
02580:  MOVWF  02
02582:  BRA    2584
.................... 	} 
....................  
.................... } 
02584:  MOVLB  0
02586:  GOTO   25D8 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01204:  MOVLB  9
01206:  MOVF   x08,W
01208:  SUBLW  1F
0120A:  BNZ   1224
0120C:  MOVF   x09,W
0120E:  SUBLW  4E
01210:  BNZ   1224
01212:  MOVF   x0A,W
01214:  SUBLW  20
01216:  BNZ   1224
01218:  MOVF   x0B,W
0121A:  SUBLW  4E
0121C:  BNZ   1224
.................... 		return 1; 
0121E:  MOVLW  01
01220:  MOVWF  01
01222:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_META_REGISTER && end <= MAX_NMEA0183_META_REGISTER )  
01224:  MOVF   x09,W
01226:  SUBLW  18
01228:  BC    1248
0122A:  XORLW  FF
0122C:  BNZ   1234
0122E:  MOVF   x08,W
01230:  SUBLW  63
01232:  BC    1248
01234:  MOVF   x0B,W
01236:  SUBLW  19
01238:  BNC   1248
0123A:  BNZ   1242
0123C:  MOVF   x0A,W
0123E:  SUBLW  7C
01240:  BNC   1248
.................... 		return 1; 
01242:  MOVLW  01
01244:  MOVWF  01
01246:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
01248:  MOVF   x09,W
0124A:  SUBLW  16
0124C:  BC    126C
0124E:  XORLW  FF
01250:  BNZ   1258
01252:  MOVF   x08,W
01254:  SUBLW  6F
01256:  BC    126C
01258:  MOVF   x0B,W
0125A:  SUBLW  19
0125C:  BNC   126C
0125E:  BNZ   1266
01260:  MOVF   x0A,W
01262:  SUBLW  50
01264:  BNC   126C
.................... 		return 1; 
01266:  MOVLW  01
01268:  MOVWF  01
0126A:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
0126C:  MOVF   x09,W
0126E:  SUBLW  12
01270:  BC    1290
01272:  XORLW  FF
01274:  BNZ   127C
01276:  MOVF   x08,W
01278:  SUBLW  87
0127A:  BC    1290
0127C:  MOVF   x0B,W
0127E:  SUBLW  17
01280:  BNC   1290
01282:  BNZ   128A
01284:  MOVF   x0A,W
01286:  SUBLW  48
01288:  BNC   1290
.................... 		return 1; 
0128A:  MOVLW  01
0128C:  MOVWF  01
0128E:  BRA    1310
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01290:  MOVF   x09,W
01292:  SUBLW  03
01294:  BC    12B4
01296:  XORLW  FF
01298:  BNZ   12A0
0129A:  MOVF   x08,W
0129C:  SUBLW  4B
0129E:  BC    12B4
012A0:  MOVF   x0B,W
012A2:  SUBLW  04
012A4:  BNC   12B4
012A6:  BNZ   12AE
012A8:  MOVF   x0A,W
012AA:  SUBLW  94
012AC:  BNC   12B4
.................... 		return 1; 
012AE:  MOVLW  01
012B0:  MOVWF  01
012B2:  BRA    1310
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
012B4:  MOVF   x09,W
012B6:  SUBLW  02
012B8:  BC    12D8
012BA:  XORLW  FF
012BC:  BNZ   12C4
012BE:  MOVF   x08,W
012C0:  SUBLW  E7
012C2:  BC    12D8
012C4:  MOVF   x0B,W
012C6:  SUBLW  03
012C8:  BNC   12D8
012CA:  BNZ   12D2
012CC:  MOVF   x0A,W
012CE:  SUBLW  F7
012D0:  BNC   12D8
.................... 		return 1; 
012D2:  MOVLW  01
012D4:  MOVWF  01
012D6:  BRA    1310
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
012D8:  MOVF   x09,W
012DA:  SUBLW  06
012DC:  BC    12FC
012DE:  XORLW  FF
012E0:  BNZ   12E8
012E2:  MOVF   x08,W
012E4:  SUBLW  CF
012E6:  BC    12FC
012E8:  MOVF   x0B,W
012EA:  SUBLW  09
012EC:  BNC   12FC
012EE:  BNZ   12F6
012F0:  MOVF   x0A,W
012F2:  SUBLW  D1
012F4:  BNC   12FC
.................... 		return 1; 
012F6:  MOVLW  01
012F8:  MOVWF  01
012FA:  BRA    1310
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
012FC:  MOVF   x0B,F
012FE:  BNZ   130C
01300:  MOVF   x0A,W
01302:  SUBLW  37
01304:  BNC   130C
.................... 		return 1; 
01306:  MOVLW  01
01308:  MOVWF  01
0130A:  BRA    1310
....................  
.................... 	return 0; 
0130C:  MOVLW  00
0130E:  MOVWF  01
.................... } 
01310:  MOVLB  0
01312:  GOTO   2BE8 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
0258A:  MOVFF  907,910
0258E:  MOVFF  906,911
02592:  CALL   134E
.................... 	modbus_serial_putc(register_count*2); 
02596:  BCF    FD8.0
02598:  MOVLB  9
0259A:  RLCF   x0A,W
0259C:  MOVWF  x10
0259E:  RLCF   x0B,W
025A0:  MOVWF  x11
025A2:  MOVFF  910,912
025A6:  MOVLB  0
025A8:  CALL   1316
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
025AC:  MOVLB  9
025AE:  CLRF   x0D
025B0:  CLRF   x0C
025B2:  MOVF   x0D,W
025B4:  SUBWF  x0B,W
025B6:  BNC   2602
025B8:  BNZ   25C0
025BA:  MOVF   x0A,W
025BC:  SUBWF  x0C,W
025BE:  BC    2602
.................... 		l=map_modbus(start_address+i); 
025C0:  MOVF   x0C,W
025C2:  ADDWF  x08,W
025C4:  MOVWF  x10
025C6:  MOVF   x0D,W
025C8:  ADDWFC x09,W
025CA:  MOVWF  x11
025CC:  MOVWF  x13
025CE:  MOVFF  910,912
025D2:  MOVLB  0
025D4:  GOTO   1512
025D8:  MOVFF  02,90F
025DC:  MOVFF  01,90E
.................... 		modbus_serial_putc(make8(l,1)); 
025E0:  MOVFF  90F,910
025E4:  MOVFF  90F,912
025E8:  CALL   1316
....................   		modbus_serial_putc(make8(l,0)); 
025EC:  MOVFF  90E,910
025F0:  MOVFF  90E,912
025F4:  CALL   1316
.................... 	} 
025F8:  MOVLB  9
025FA:  INCF   x0C,F
025FC:  BTFSC  FD8.2
025FE:  INCF   x0D,F
02600:  BRA    25B2
....................  
.................... 	modbus_serial_send_stop(); 
02602:  MOVLB  0
02604:  CALL   136C
.................... } 
02608:  GOTO   2C2A (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
0260C:  MOVLB  9
0260E:  MOVF   x0D,W
02610:  SUBLW  06
02612:  BC    268A
02614:  XORLW  FF
02616:  BNZ   261E
02618:  MOVF   x0C,W
0261A:  SUBLW  CF
0261C:  BC    268A
0261E:  MOVF   x0D,W
02620:  SUBLW  09
02622:  BNC   268A
02624:  BNZ   262C
02626:  MOVF   x0C,W
02628:  SUBLW  CF
0262A:  BNC   268A
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
0262C:  MOVF   x0F,W
0262E:  SUBLW  00
02630:  BC    2642
02632:  XORLW  FF
02634:  BNZ   263C
02636:  MOVF   x0E,W
02638:  SUBLW  00
0263A:  BC    2642
0263C:  MOVLW  03
0263E:  MOVWF  01
02640:  BRA    2A18
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
02642:  MOVLW  D0
02644:  SUBWF  x0C,W
02646:  MOVWF  x12
02648:  MOVLW  07
0264A:  SUBWFB x0D,W
0264C:  MOVWF  x13
0264E:  MOVLW  02
02650:  ADDWF  x13,F
02652:  MOVFF  913,FAA
02656:  MOVFF  912,FA9
0265A:  MOVFF  90E,FA8
0265E:  BCF    FA6.6
02660:  BCF    FA6.7
02662:  BSF    FA6.2
02664:  MOVF   FF2,W
02666:  MOVWF  00
02668:  BCF    FF2.6
0266A:  BCF    FF2.7
0266C:  MOVLB  F
0266E:  MOVLW  55
02670:  MOVWF  FA7
02672:  MOVLW  AA
02674:  MOVWF  FA7
02676:  BSF    FA6.1
02678:  BTFSC  FA6.1
0267A:  BRA    2678
0267C:  BCF    FA6.2
0267E:  MOVF   00,W
02680:  IORWF  FF2,F
.................... 		return 0; 
02682:  MOVLW  00
02684:  MOVWF  01
02686:  MOVLB  9
02688:  BRA    2A18
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
0268A:  MOVF   x0D,W
0268C:  SUBLW  03
0268E:  BC    2720
02690:  XORLW  FF
02692:  BNZ   269A
02694:  MOVF   x0C,W
02696:  SUBLW  4B
02698:  BC    2720
0269A:  MOVF   x0D,W
0269C:  SUBLW  04
0269E:  BNC   2720
026A0:  BNZ   26A8
026A2:  MOVF   x0C,W
026A4:  SUBLW  93
026A6:  BNC   2720
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
026A8:  MOVF   x0F,W
026AA:  SUBLW  00
026AC:  BC    26BE
026AE:  XORLW  FF
026B0:  BNZ   26B8
026B2:  MOVF   x0E,W
026B4:  SUBLW  00
026B6:  BC    26BE
026B8:  MOVLW  03
026BA:  MOVWF  01
026BC:  BRA    2A18
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
026BE:  MOVLW  4C
026C0:  SUBWF  x0C,W
026C2:  MOVWF  x10
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
026C4:  MOVFF  910,918
026C8:  MOVLW  06
026CA:  MOVWF  x19
026CC:  MOVLB  0
026CE:  CALL   0AAA
026D2:  MOVFF  00,911
.................... 		n = n / 6; /* number of sentence */ 
026D6:  MOVFF  910,918
026DA:  MOVLW  06
026DC:  MOVLB  9
026DE:  MOVWF  x19
026E0:  MOVLB  0
026E2:  CALL   0AAA
026E6:  MOVFF  01,910
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
026EA:  MOVLB  9
026EC:  MOVF   x10,W
026EE:  MULLW  06
026F0:  MOVF   FF3,W
026F2:  CLRF   03
026F4:  ADDLW  1A
026F6:  MOVWF  x12
026F8:  MOVLW  00
026FA:  ADDWFC 03,W
026FC:  MOVWF  x13
026FE:  CLRF   03
02700:  MOVF   x11,W
02702:  ADDWF  x12,W
02704:  MOVWF  01
02706:  MOVF   x13,W
02708:  ADDWFC 03,F
0270A:  MOVF   01,W
0270C:  ADDLW  36
0270E:  MOVWF  FE9
02710:  MOVLW  00
02712:  ADDWFC 03,W
02714:  MOVWF  FEA
02716:  MOVFF  90E,FEF
.................... 		 
.................... 		return 0; 
0271A:  MOVLW  00
0271C:  MOVWF  01
0271E:  BRA    2A18
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
02720:  MOVLB  1
02722:  MOVF   xD9,F
02724:  BZ    275C
.................... 		if ( 1000 == address ) { 
02726:  MOVLB  9
02728:  MOVF   x0C,W
0272A:  SUBLW  E8
0272C:  BNZ   2740
0272E:  MOVF   x0D,W
02730:  SUBLW  03
02732:  BNZ   2740
.................... 			config.serial_prefix=value; 
02734:  MOVFF  90E,3A
.................... 			return 0; 
02738:  MOVLW  00
0273A:  MOVWF  01
0273C:  BRA    2A18
.................... 		} else if ( 1001 == address ) { 
0273E:  BRA    275A
02740:  MOVF   x0C,W
02742:  SUBLW  E9
02744:  BNZ   275A
02746:  MOVF   x0D,W
02748:  SUBLW  03
0274A:  BNZ   275A
.................... 			config.serial_number=value; 
0274C:  MOVFF  90F,3C
02750:  MOVFF  90E,3B
.................... 			return 0; 
02754:  MOVLW  00
02756:  MOVWF  01
02758:  BRA    2A18
0275A:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
0275C:  MOVLB  9
0275E:  MOVF   x0C,W
02760:  MOVWF  00
02762:  MOVF   x0D,W
02764:  MOVWF  03
02766:  MOVLW  03
02768:  SUBWF  03,W
0276A:  BNZ   2778
0276C:  MOVLW  EE
0276E:  SUBWF  00,W
02770:  MOVLB  0
02772:  BTFSC  FD8.2
02774:  BRA    2852
02776:  MOVLB  9
02778:  MOVLW  03
0277A:  SUBWF  03,W
0277C:  BNZ   278A
0277E:  MOVLW  EF
02780:  SUBWF  00,W
02782:  MOVLB  0
02784:  BTFSC  FD8.2
02786:  BRA    286A
02788:  MOVLB  9
0278A:  MOVLW  03
0278C:  SUBWF  03,W
0278E:  BNZ   279C
02790:  MOVLW  F0
02792:  SUBWF  00,W
02794:  MOVLB  0
02796:  BTFSC  FD8.2
02798:  BRA    287A
0279A:  MOVLB  9
0279C:  MOVLW  03
0279E:  SUBWF  03,W
027A0:  BNZ   27AE
027A2:  MOVLW  F1
027A4:  SUBWF  00,W
027A6:  MOVLB  0
027A8:  BTFSC  FD8.2
027AA:  BRA    2892
027AC:  MOVLB  9
027AE:  MOVLW  03
027B0:  SUBWF  03,W
027B2:  BNZ   27C0
027B4:  MOVLW  F2
027B6:  SUBWF  00,W
027B8:  MOVLB  0
027BA:  BTFSC  FD8.2
027BC:  BRA    289E
027BE:  MOVLB  9
027C0:  MOVLW  03
027C2:  SUBWF  03,W
027C4:  BNZ   27D2
027C6:  MOVLW  F3
027C8:  SUBWF  00,W
027CA:  MOVLB  0
027CC:  BTFSC  FD8.2
027CE:  BRA    28B8
027D0:  MOVLB  9
027D2:  MOVLW  03
027D4:  SUBWF  03,W
027D6:  BNZ   27E4
027D8:  MOVLW  F4
027DA:  SUBWF  00,W
027DC:  MOVLB  0
027DE:  BTFSC  FD8.2
027E0:  BRA    28D0
027E2:  MOVLB  9
027E4:  MOVLW  03
027E6:  SUBWF  03,W
027E8:  BNZ   27F6
027EA:  MOVLW  F5
027EC:  SUBWF  00,W
027EE:  MOVLB  0
027F0:  BTFSC  FD8.2
027F2:  BRA    28E8
027F4:  MOVLB  9
027F6:  MOVLW  03
027F8:  SUBWF  03,W
027FA:  BNZ   2808
027FC:  MOVLW  F6
027FE:  SUBWF  00,W
02800:  MOVLB  0
02802:  BTFSC  FD8.2
02804:  BRA    2986
02806:  MOVLB  9
02808:  MOVLW  07
0280A:  SUBWF  03,W
0280C:  BNZ   281A
0280E:  MOVLW  CD
02810:  SUBWF  00,W
02812:  MOVLB  0
02814:  BTFSC  FD8.2
02816:  BRA    299E
02818:  MOVLB  9
0281A:  MOVLW  07
0281C:  SUBWF  03,W
0281E:  BNZ   282C
02820:  MOVLW  CE
02822:  SUBWF  00,W
02824:  MOVLB  0
02826:  BTFSC  FD8.2
02828:  BRA    29B2
0282A:  MOVLB  9
0282C:  MOVLW  07
0282E:  SUBWF  03,W
02830:  BNZ   283E
02832:  MOVLW  CF
02834:  SUBWF  00,W
02836:  MOVLB  0
02838:  BTFSC  FD8.2
0283A:  BRA    29CC
0283C:  MOVLB  9
0283E:  MOVLW  4E
02840:  SUBWF  03,W
02842:  BNZ   2850
02844:  MOVLW  1F
02846:  SUBWF  00,W
02848:  MOVLB  0
0284A:  BTFSC  FD8.2
0284C:  BRA    29E6
0284E:  MOVLB  9
02850:  BRA    2A0E
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
02852:  MOVLB  9
02854:  MOVF   x0F,F
02856:  BNZ   285E
02858:  MOVF   x0E,W
0285A:  SUBLW  80
0285C:  BC    2864
0285E:  MOVLW  03
02860:  MOVWF  01
02862:  BRA    2A18
.................... 			config.modbus_address=value; 
02864:  MOVFF  90E,36
.................... 			break; 
02868:  BRA    2A14
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
0286A:  MOVLB  1
0286C:  BSF    xFD.1
.................... 			config.adc_sample_ticks=value; 
0286E:  MOVFF  90F,3E
02872:  MOVFF  90E,3D
.................... 			break; 
02876:  MOVLB  9
02878:  BRA    2A14
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
0287A:  MOVLB  9
0287C:  MOVF   x0F,F
0287E:  BNZ   2886
02880:  MOVF   x0E,W
02882:  SUBLW  01
02884:  BC    288C
02886:  MOVLW  03
02888:  MOVWF  01
0288A:  BRA    2A18
.................... 			config.allow_bootload_request=value; 
0288C:  MOVFF  90E,3F
.................... 			break; 
02890:  BRA    2A14
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
02892:  MOVFF  90F,41
02896:  MOVFF  90E,40
.................... 			break; 
0289A:  MOVLB  9
0289C:  BRA    2A14
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
0289E:  MOVLB  9
028A0:  MOVF   x0E,F
028A2:  BNZ   28AE
028A4:  MOVF   x0F,F
028A6:  BNZ   28AE
028A8:  MOVLW  03
028AA:  MOVWF  01
028AC:  BRA    2A18
.................... 			config.pi_offtime_seconds=value; 
028AE:  MOVFF  90F,43
028B2:  MOVFF  90E,42
.................... 			break; 
028B6:  BRA    2A14
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
028B8:  MOVLB  9
028BA:  MOVF   x0F,F
028BC:  BNZ   28C4
028BE:  MOVF   x0E,W
028C0:  SUBLW  01
028C2:  BC    28CA
028C4:  MOVLW  03
028C6:  MOVWF  01
028C8:  BRA    2A18
.................... 			config.power_startup=value; 
028CA:  MOVFF  90E,44
.................... 			break; 
028CE:  BRA    2A14
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
028D0:  MOVLB  9
028D2:  MOVF   x0F,F
028D4:  BNZ   28DC
028D6:  MOVF   x0E,W
028D8:  SUBLW  02
028DA:  BC    28E2
028DC:  MOVLW  03
028DE:  MOVWF  01
028E0:  BRA    2A18
.................... 			config.rs485_port_mode=value; 
028E2:  MOVFF  90E,38
.................... 			break; 
028E6:  BRA    2A14
.................... 		 
.................... 		case 1013: 
....................  
.................... 			n=0; 
028E8:  MOVLB  9
028EA:  CLRF   x10
.................... 			if ( 1200 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_1200; } 
028EC:  MOVF   x0E,W
028EE:  SUBLW  B0
028F0:  BNZ   28FE
028F2:  MOVF   x0F,W
028F4:  SUBLW  04
028F6:  BNZ   28FE
028F8:  MOVLW  01
028FA:  MOVWF  x10
028FC:  CLRF   39
.................... 			if ( 2400 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_2400; } 
028FE:  MOVF   x0E,W
02900:  SUBLW  60
02902:  BNZ   2910
02904:  MOVF   x0F,W
02906:  SUBLW  09
02908:  BNZ   2910
0290A:  MOVLW  01
0290C:  MOVWF  x10
0290E:  MOVWF  39
.................... 			if ( 4800 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_4800; } 
02910:  MOVF   x0E,W
02912:  SUBLW  C0
02914:  BNZ   2924
02916:  MOVF   x0F,W
02918:  SUBLW  12
0291A:  BNZ   2924
0291C:  MOVLW  01
0291E:  MOVWF  x10
02920:  MOVLW  02
02922:  MOVWF  39
.................... 			if ( 9600 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_9600; } 
02924:  MOVF   x0E,W
02926:  SUBLW  80
02928:  BNZ   2938
0292A:  MOVF   x0F,W
0292C:  SUBLW  25
0292E:  BNZ   2938
02930:  MOVLW  01
02932:  MOVWF  x10
02934:  MOVLW  03
02936:  MOVWF  39
.................... 			if ( 19200 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_19200; } 
02938:  MOVF   x0E,F
0293A:  BNZ   294A
0293C:  MOVF   x0F,W
0293E:  SUBLW  4B
02940:  BNZ   294A
02942:  MOVLW  01
02944:  MOVWF  x10
02946:  MOVLW  04
02948:  MOVWF  39
.................... 			if ( 38400 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_38400; } 
0294A:  MOVF   x0E,F
0294C:  BNZ   295C
0294E:  MOVF   x0F,W
02950:  SUBLW  96
02952:  BNZ   295C
02954:  MOVLW  01
02956:  MOVWF  x10
02958:  MOVLW  05
0295A:  MOVWF  39
.................... 			if ( 57600 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_57600; } 
0295C:  MOVF   x0E,F
0295E:  BNZ   296E
02960:  MOVF   x0F,W
02962:  SUBLW  E1
02964:  BNZ   296E
02966:  MOVLW  01
02968:  MOVWF  x10
0296A:  MOVLW  06
0296C:  MOVWF  39
....................  
.................... 			if (  1==n ) { 
0296E:  DECFSZ x10,W
02970:  BRA    297C
.................... 				set_rs485_speed(); 
02972:  MOVLB  0
02974:  CALL   0D8C
.................... 			}  else { 
02978:  BRA    2982
0297A:  MOVLB  9
.................... 				return ILLEGAL_DATA_VALUE; 
0297C:  MOVLW  03
0297E:  MOVWF  01
02980:  BRA    2A18
.................... 			} 
.................... 			break; 
02982:  MOVLB  9
02984:  BRA    2A14
....................  
....................  
.................... 		case 1014: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02986:  MOVLB  9
02988:  MOVF   x0F,F
0298A:  BNZ   2992
0298C:  MOVF   x0E,W
0298E:  SUBLW  01
02990:  BC    2998
02992:  MOVLW  03
02994:  MOVWF  01
02996:  BRA    2A18
.................... 			config.pic_to_pi_latch_mask=value; 
02998:  MOVFF  90E,4F
.................... 			break; 
0299C:  BRA    2A14
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
0299E:  MOVLB  9
029A0:  DECFSZ x0E,W
029A2:  BRA    29A8
029A4:  MOVF   x0F,F
029A6:  BZ    29AE
029A8:  MOVLW  03
029AA:  MOVWF  01
029AC:  BRA    2A18
.................... 			reset_cpu(); 
029AE:  RESET
029B0:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
029B2:  MOVLB  9
029B4:  DECFSZ x0E,W
029B6:  BRA    29BC
029B8:  MOVF   x0F,F
029BA:  BZ    29C2
029BC:  MOVLW  03
029BE:  MOVWF  01
029C0:  BRA    2A18
.................... 			write_default_param_file(); 
029C2:  MOVLB  0
029C4:  CALL   0CE4
.................... 			break; 
029C8:  MOVLB  9
029CA:  BRA    2A14
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
029CC:  MOVLB  9
029CE:  DECFSZ x0E,W
029D0:  BRA    29D6
029D2:  MOVF   x0F,F
029D4:  BZ    29DC
029D6:  MOVLW  03
029D8:  MOVWF  01
029DA:  BRA    2A18
.................... 			write_param_file(); 
029DC:  MOVLB  0
029DE:  CALL   0C90
.................... 			break; 
029E2:  MOVLB  9
029E4:  BRA    2A14
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
029E6:  MOVLB  9
029E8:  MOVF   x0E,W
029EA:  SUBLW  0A
029EC:  BNZ   29F4
029EE:  MOVF   x0F,W
029F0:  SUBLW  07
029F2:  BZ    2A00
.................... 				current.factory_unlocked=0; 
029F4:  MOVLB  1
029F6:  CLRF   xD9
.................... 				return ILLEGAL_DATA_VALUE; 
029F8:  MOVLW  03
029FA:  MOVWF  01
029FC:  MOVLB  9
029FE:  BRA    2A18
.................... 			} 
.................... 			current.factory_unlocked=1; 
02A00:  MOVLW  01
02A02:  MOVLB  1
02A04:  MOVWF  xD9
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02A06:  MOVLW  C8
02A08:  MOVWF  xFA
.................... 			break; 
02A0A:  MOVLB  9
02A0C:  BRA    2A14
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02A0E:  MOVLW  02
02A10:  MOVWF  01
02A12:  BRA    2A18
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02A14:  MOVLW  00
02A16:  MOVWF  01
.................... } 
02A18:  MOVLB  0
02A1A:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02AAC:  GOTO   11B6
02AB0:  MOVF   01,F
02AB2:  BTFSC  FD8.2
02AB4:  BRA    2DA8
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02AB6:  DECFSZ 38,W
02AB8:  BRA    2B6C
02ABA:  MOVF   36,W
02ABC:  MOVLB  7
02ABE:  SUBWF  xEE,W
02AC0:  BTFSS  FD8.2
02AC2:  BRA    2AC8
02AC4:  MOVLB  0
02AC6:  BRA    2B6C
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02AC8:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02ACA:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02ACC:  CLRWDT
02ACE:  MOVLW  02
02AD0:  MOVLB  9
02AD2:  MOVWF  x04
02AD4:  MOVLW  B5
02AD6:  MOVWF  x07
02AD8:  MOVLB  0
02ADA:  CALL   11DC
02ADE:  MOVLB  9
02AE0:  DECFSZ x04,F
02AE2:  BRA    2AD4
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02AE4:  MOVLB  7
02AE6:  MOVF   xEE,W
02AE8:  MOVLB  0
02AEA:  CALL   11FC
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02AEE:  CLRWDT
02AF0:  MOVLW  67
02AF2:  MOVWF  00
02AF4:  DECFSZ 00,F
02AF6:  BRA    2AF4
02AF8:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02AFA:  MOVLB  7
02AFC:  MOVF   xF0,W
02AFE:  MOVLB  0
02B00:  CALL   11FC
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02B04:  CLRWDT
02B06:  MOVLW  67
02B08:  MOVWF  00
02B0A:  DECFSZ 00,F
02B0C:  BRA    2B0A
02B0E:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02B10:  MOVLB  9
02B12:  CLRF   x03
02B14:  MOVLW  02
02B16:  MOVLB  7
02B18:  ADDWF  xEF,W
02B1A:  MOVLB  9
02B1C:  SUBWF  x03,W
02B1E:  BC    2B4C
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02B20:  MOVLW  F2
02B22:  ADDWF  x03,W
02B24:  MOVWF  FE9
02B26:  MOVLW  07
02B28:  MOVWF  FEA
02B2A:  BTFSC  FD8.0
02B2C:  INCF   FEA,F
02B2E:  MOVFF  FEF,904
02B32:  MOVF   x04,W
02B34:  MOVLB  0
02B36:  CALL   11FC
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02B3A:  CLRWDT
02B3C:  MOVLW  67
02B3E:  MOVWF  00
02B40:  DECFSZ 00,F
02B42:  BRA    2B40
02B44:  NOP   
.................... 			} 
02B46:  MOVLB  9
02B48:  INCF   x03,F
02B4A:  BRA    2B14
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02B4C:  BTFSS  F72.1
02B4E:  BRA    2B4C
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02B50:  CLRWDT
02B52:  MOVLW  02
02B54:  MOVWF  x04
02B56:  MOVLW  B5
02B58:  MOVWF  x07
02B5A:  MOVLB  0
02B5C:  CALL   11DC
02B60:  MOVLB  9
02B62:  DECFSZ x04,F
02B64:  BRA    2B56
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02B66:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02B68:  BCF    F8C.0
02B6A:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02B6C:  MOVF   36,W
02B6E:  SUBLW  80
02B70:  BZ    2B7E
02B72:  MOVF   36,W
02B74:  MOVLB  7
02B76:  SUBWF  xEE,W
02B78:  BTFSS  FD8.2
02B7A:  BRA    2D92
02B7C:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02B7E:  MOVLB  1
02B80:  INCFSZ xCD,W
02B82:  BRA    2B8A
02B84:  INCFSZ xCE,W
02B86:  BRA    2B8A
02B88:  BRA    2B90
.................... 				current.modbus_our_packets++; 
02B8A:  INCF   xCD,F
02B8C:  BTFSC  FD8.2
02B8E:  INCF   xCE,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02B90:  MOVLW  14
02B92:  MOVWF  xFA
....................  
.................... 			switch(modbus_rx.func) { 
02B94:  MOVLB  7
02B96:  MOVF   xF0,W
02B98:  XORLW  03
02B9A:  MOVLB  0
02B9C:  BZ    2BAE
02B9E:  XORLW  07
02BA0:  BZ    2BAE
02BA2:  XORLW  02
02BA4:  BZ    2C2E
02BA6:  XORLW  16
02BA8:  BTFSC  FD8.2
02BAA:  BRA    2CA0
02BAC:  BRA    2D6A
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02BAE:  MOVFF  7F2,8FF
02BB2:  MOVFF  7F3,8FE
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02BB6:  MOVFF  7F4,901
02BBA:  MOVFF  7F5,900
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02BBE:  MOVLB  9
02BC0:  MOVF   x00,W
02BC2:  MOVLB  8
02BC4:  ADDWF  xFE,W
02BC6:  MOVLB  9
02BC8:  MOVWF  x04
02BCA:  MOVF   x01,W
02BCC:  MOVLB  8
02BCE:  ADDWFC xFF,W
02BD0:  MOVLB  9
02BD2:  MOVWF  x05
02BD4:  MOVFF  8FF,909
02BD8:  MOVFF  8FE,908
02BDC:  MOVWF  x0B
02BDE:  MOVFF  904,90A
02BE2:  MOVLB  0
02BE4:  GOTO   1204
02BE8:  MOVF   01,F
02BEA:  BNZ   2C10
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02BEC:  MOVFF  7EE,906
02BF0:  MOVLB  9
02BF2:  CLRF   x08
02BF4:  MOVFF  7F0,907
02BF8:  MOVLW  02
02BFA:  MOVWF  x09
02BFC:  MOVLB  0
02BFE:  CALL   138E
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02C02:  MOVLB  1
02C04:  CLRF   xD2
02C06:  MOVLW  02
02C08:  MOVWF  xD1
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02C0A:  CLRF   xFA
.................... 					} else { 
02C0C:  BRA    2C2C
02C0E:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02C10:  MOVFF  7F0,906
02C14:  MOVFF  7EE,907
02C18:  MOVFF  8FF,909
02C1C:  MOVFF  8FE,908
02C20:  MOVFF  901,90B
02C24:  MOVFF  900,90A
02C28:  BRA    258A
02C2A:  MOVLB  1
.................... 					} 
.................... 					break; 
02C2C:  BRA    2D8A
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02C2E:  MOVFF  7F2,8FF
02C32:  MOVFF  7F3,8FE
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02C36:  MOVFF  7F4,905
02C3A:  MOVFF  7F5,904
02C3E:  MOVFF  8FF,90D
02C42:  MOVFF  8FE,90C
02C46:  MOVFF  7F4,90F
02C4A:  MOVFF  7F5,90E
02C4E:  RCALL  260C
02C50:  MOVFF  01,902
....................  
.................... 					if ( result ) { 
02C54:  MOVLB  9
02C56:  MOVF   x02,F
02C58:  BZ    2C7C
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02C5A:  MOVFF  7EE,906
02C5E:  CLRF   x08
02C60:  MOVFF  7F0,907
02C64:  MOVFF  902,909
02C68:  MOVLB  0
02C6A:  CALL   138E
.................... 						current.modbus_last_error=result; 
02C6E:  MOVLB  1
02C70:  CLRF   xD2
02C72:  MOVFF  902,1D1
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02C76:  CLRF   xFA
.................... 					}  else { 
02C78:  BRA    2C9E
02C7A:  MOVLB  9
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02C7C:  MOVFF  7F4,905
02C80:  MOVFF  7F5,904
02C84:  MOVFF  7EE,908
02C88:  MOVFF  8FF,90A
02C8C:  MOVFF  8FE,909
02C90:  MOVFF  7F4,90C
02C94:  MOVFF  7F5,90B
02C98:  MOVLB  0
02C9A:  BRA    2A1C
02C9C:  MOVLB  1
.................... 					} 
.................... 					break; 
02C9E:  BRA    2D8A
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02CA0:  MOVFF  7F2,8FF
02CA4:  MOVFF  7F3,8FE
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02CA8:  MOVFF  7F4,901
02CAC:  MOVFF  7F5,900
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02CB0:  MOVLB  9
02CB2:  CLRF   x03
02CB4:  MOVF   x01,F
02CB6:  BNZ   2CBE
02CB8:  MOVF   x00,W
02CBA:  SUBWF  x03,W
02CBC:  BC    2D4A
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02CBE:  MOVF   x03,W
02CC0:  MOVLB  8
02CC2:  ADDWF  xFE,W
02CC4:  MOVLB  9
02CC6:  MOVWF  x04
02CC8:  MOVLW  00
02CCA:  MOVLB  8
02CCC:  ADDWFC xFF,W
02CCE:  MOVLB  9
02CD0:  MOVWF  x05
02CD2:  BCF    FD8.0
02CD4:  RLCF   x03,W
02CD6:  ADDLW  05
02CD8:  ADDLW  F2
02CDA:  MOVWF  FE9
02CDC:  MOVLW  07
02CDE:  MOVWF  FEA
02CE0:  BTFSC  FD8.0
02CE2:  INCF   FEA,F
02CE4:  MOVFF  FEF,906
02CE8:  BCF    FD8.0
02CEA:  RLCF   x03,W
02CEC:  ADDLW  06
02CEE:  ADDLW  F2
02CF0:  MOVWF  FE9
02CF2:  MOVLW  07
02CF4:  MOVWF  FEA
02CF6:  BTFSC  FD8.0
02CF8:  INCF   FEA,F
02CFA:  MOVFF  FEF,907
02CFE:  MOVFF  906,909
02D02:  MOVFF  907,908
02D06:  MOVFF  905,90D
02D0A:  MOVFF  904,90C
02D0E:  MOVFF  906,90F
02D12:  MOVFF  907,90E
02D16:  MOVLB  0
02D18:  RCALL  260C
02D1A:  MOVFF  01,902
....................  
.................... 						if ( result ) { 
02D1E:  MOVLB  9
02D20:  MOVF   x02,F
02D22:  BZ    2D46
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02D24:  MOVFF  7EE,906
02D28:  CLRF   x08
02D2A:  MOVFF  7F0,907
02D2E:  MOVFF  902,909
02D32:  MOVLB  0
02D34:  CALL   138E
.................... 							current.modbus_last_error=result; 
02D38:  MOVLB  1
02D3A:  CLRF   xD2
02D3C:  MOVFF  902,1D1
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02D40:  CLRF   xFA
.................... 			 
.................... 							break; 
02D42:  MOVLB  9
02D44:  BRA    2D4A
.................... 						} 
.................... 					} 
02D46:  INCF   x03,F
02D48:  BRA    2CB4
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02D4A:  MOVF   x02,F
02D4C:  BNZ   2D66
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02D4E:  MOVFF  7EE,906
02D52:  MOVFF  8FF,908
02D56:  MOVFF  8FE,907
02D5A:  MOVFF  901,90A
02D5E:  MOVFF  900,909
02D62:  MOVLB  0
02D64:  BRA    2A64
.................... 					} 
....................  
.................... 					break;   
02D66:  MOVLB  1
02D68:  BRA    2D8A
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02D6A:  MOVFF  7EE,906
02D6E:  MOVLB  9
02D70:  CLRF   x08
02D72:  MOVFF  7F0,907
02D76:  MOVLW  01
02D78:  MOVWF  x09
02D7A:  MOVLB  0
02D7C:  CALL   138E
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02D80:  MOVLB  1
02D82:  CLRF   xD2
02D84:  MOVLW  01
02D86:  MOVWF  xD1
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02D88:  CLRF   xFA
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02D8A:  CLRF   xDB
02D8C:  CLRF   xDA
....................  
.................... 		} else { 
02D8E:  BRA    2DA8
02D90:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02D92:  MOVLB  1
02D94:  INCFSZ xCF,W
02D96:  BRA    2D9E
02D98:  INCFSZ xD0,W
02D9A:  BRA    2D9E
02D9C:  BRA    2DA4
.................... 				current.modbus_other_packets++; 
02D9E:  INCF   xCF,F
02DA0:  BTFSC  FD8.2
02DA2:  INCF   xD0,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02DA4:  MOVLW  0A
02DA6:  MOVWF  xFA
02DA8:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02DAA:  GOTO   3298 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003EE:  MOVLB  A
003F0:  BTFSS  x13.0
003F2:  BRA    040C
003F4:  MOVLB  1
003F6:  INCFSZ xE9,W
003F8:  BRA    0404
003FA:  INCFSZ xEA,W
003FC:  BRA    0404
003FE:  MOVLB  A
00400:  BRA    040C
00402:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00404:  INCF   xE9,F
00406:  BTFSC  FD8.2
00408:  INCF   xEA,F
0040A:  MOVLB  A
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0040C:  BTFSS  x13.2
0040E:  BRA    0428
00410:  MOVLB  1
00412:  INCFSZ xEB,W
00414:  BRA    0420
00416:  INCFSZ xEC,W
00418:  BRA    0420
0041A:  MOVLB  A
0041C:  BRA    0428
0041E:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00420:  INCF   xEB,F
00422:  BTFSC  FD8.2
00424:  INCF   xEC,F
00426:  MOVLB  A
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
00428:  BTFSS  x13.4
0042A:  BRA    0444
0042C:  MOVLB  1
0042E:  INCFSZ xED,W
00430:  BRA    043C
00432:  INCFSZ xEE,W
00434:  BRA    043C
00436:  MOVLB  A
00438:  BRA    0444
0043A:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
0043C:  INCF   xED,F
0043E:  BTFSC  FD8.2
00440:  INCF   xEE,F
00442:  MOVLB  A
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00444:  BCF    x13.1
00446:  BTFSC  F81.0
00448:  BSF    x13.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0044A:  BTFSC  x13.1
0044C:  BRA    04D0
0044E:  MOVLB  7
00450:  BTFSC  xEA.1
00452:  BRA    0458
00454:  MOVLB  A
00456:  BRA    04D0
.................... 		current.pulse_count[0]++; 
00458:  MOVLB  0
0045A:  INCF   xAA,F
0045C:  BTFSC  FD8.2
0045E:  INCF   xAB,F
.................... 		current.pulse_sum[0]++; 
00460:  MOVLW  01
00462:  ADDWF  xB0,F
00464:  BTFSC  FD8.0
00466:  INCF   xB1,F
00468:  BTFSC  FD8.2
0046A:  INCF   xB2,F
0046C:  BTFSC  FD8.2
0046E:  INCF   xB3,F
.................... 		if ( 1 == ext0_state ) { 
00470:  MOVLB  7
00472:  BTFSS  xEA.2
00474:  BRA    04BE
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
00476:  MOVLB  A
00478:  BCF    x13.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0047A:  MOVFF  1EA,99
0047E:  MOVFF  1E9,98
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
00482:  MOVLB  0
00484:  MOVF   x99,W
00486:  SUBWF  x9F,W
00488:  BNC   049A
0048A:  BNZ   0492
0048C:  MOVF   x9E,W
0048E:  SUBWF  x98,W
00490:  BC    049A
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00492:  MOVFF  99,9F
00496:  MOVFF  98,9E
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0049A:  MOVF   xA5,W
0049C:  SUBWF  x99,W
0049E:  BNC   04BA
004A0:  BNZ   04A8
004A2:  MOVF   x98,W
004A4:  SUBWF  xA4,W
004A6:  BC    04BA
004A8:  INCFSZ x98,W
004AA:  BRA    04B2
004AC:  INCFSZ x99,W
004AE:  BRA    04B2
004B0:  BRA    04BA
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004B2:  MOVFF  99,A5
004B6:  MOVFF  98,A4
.................... 			} 
.................... 			ext0_state=0; 
004BA:  MOVLB  7
004BC:  BCF    xEA.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004BE:  BTFSC  xEA.2
004C0:  BRA    04D0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004C2:  MOVLB  1
004C4:  CLRF   xEA
004C6:  CLRF   xE9
.................... 			ext0_count=1; 
004C8:  MOVLB  A
004CA:  BSF    x13.0
.................... 			ext0_state=1; 
004CC:  MOVLB  7
004CE:  BSF    xEA.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004D0:  MOVLB  7
004D2:  BCF    xEA.1
004D4:  MOVLB  A
004D6:  BTFSS  x13.1
004D8:  BRA    04E0
004DA:  MOVLB  7
004DC:  BSF    xEA.1
004DE:  MOVLB  A
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004E0:  BCF    x13.3
004E2:  BTFSC  F81.1
004E4:  BSF    x13.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004E6:  BTFSC  x13.3
004E8:  BRA    056C
004EA:  MOVLB  7
004EC:  BTFSC  xEA.3
004EE:  BRA    04F4
004F0:  MOVLB  A
004F2:  BRA    056C
.................... 		current.pulse_count[1]++; 
004F4:  MOVLB  0
004F6:  INCF   xAC,F
004F8:  BTFSC  FD8.2
004FA:  INCF   xAD,F
.................... 		current.pulse_sum[1]++; 
004FC:  MOVLW  01
004FE:  ADDWF  xB4,F
00500:  BTFSC  FD8.0
00502:  INCF   xB5,F
00504:  BTFSC  FD8.2
00506:  INCF   xB6,F
00508:  BTFSC  FD8.2
0050A:  INCF   xB7,F
.................... 		if ( 1 == ext1_state ) { 
0050C:  MOVLB  7
0050E:  BTFSS  xEA.4
00510:  BRA    055A
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00512:  MOVLB  A
00514:  BCF    x13.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00516:  MOVFF  1EC,9B
0051A:  MOVFF  1EB,9A
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
0051E:  MOVLB  0
00520:  MOVF   x9B,W
00522:  SUBWF  xA1,W
00524:  BNC   0536
00526:  BNZ   052E
00528:  MOVF   xA0,W
0052A:  SUBWF  x9A,W
0052C:  BC    0536
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0052E:  MOVFF  9B,A1
00532:  MOVFF  9A,A0
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00536:  MOVF   xA7,W
00538:  SUBWF  x9B,W
0053A:  BNC   0556
0053C:  BNZ   0544
0053E:  MOVF   x9A,W
00540:  SUBWF  xA6,W
00542:  BC    0556
00544:  INCFSZ x9A,W
00546:  BRA    054E
00548:  INCFSZ x9B,W
0054A:  BRA    054E
0054C:  BRA    0556
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
0054E:  MOVFF  9B,A7
00552:  MOVFF  9A,A6
.................... 			} 
.................... 			ext1_state=0; 
00556:  MOVLB  7
00558:  BCF    xEA.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0055A:  BTFSC  xEA.4
0055C:  BRA    056C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
0055E:  MOVLB  1
00560:  CLRF   xEC
00562:  CLRF   xEB
.................... 			ext1_count=1; 
00564:  MOVLB  A
00566:  BSF    x13.2
.................... 			ext1_state=1; 
00568:  MOVLB  7
0056A:  BSF    xEA.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
0056C:  MOVLB  7
0056E:  BCF    xEA.3
00570:  MOVLB  A
00572:  BTFSS  x13.3
00574:  BRA    057C
00576:  MOVLB  7
00578:  BSF    xEA.3
0057A:  MOVLB  A
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0057C:  BCF    x13.5
0057E:  BTFSC  F81.2
00580:  BSF    x13.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00582:  BTFSC  x13.5
00584:  BRA    0608
00586:  MOVLB  7
00588:  BTFSC  xEA.5
0058A:  BRA    0590
0058C:  MOVLB  A
0058E:  BRA    0608
.................... 		current.pulse_count[2]++; 
00590:  MOVLB  0
00592:  INCF   xAE,F
00594:  BTFSC  FD8.2
00596:  INCF   xAF,F
.................... 		current.pulse_sum[2]++; 
00598:  MOVLW  01
0059A:  ADDWF  xB8,F
0059C:  BTFSC  FD8.0
0059E:  INCF   xB9,F
005A0:  BTFSC  FD8.2
005A2:  INCF   xBA,F
005A4:  BTFSC  FD8.2
005A6:  INCF   xBB,F
.................... 		if ( 1 == ext2_state ) { 
005A8:  MOVLB  7
005AA:  BTFSS  xEA.6
005AC:  BRA    05F6
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
005AE:  MOVLB  A
005B0:  BCF    x13.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005B2:  MOVFF  1EE,9D
005B6:  MOVFF  1ED,9C
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005BA:  MOVLB  0
005BC:  MOVF   x9D,W
005BE:  SUBWF  xA3,W
005C0:  BNC   05D2
005C2:  BNZ   05CA
005C4:  MOVF   xA2,W
005C6:  SUBWF  x9C,W
005C8:  BC    05D2
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005CA:  MOVFF  9D,A3
005CE:  MOVFF  9C,A2
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005D2:  MOVF   xA9,W
005D4:  SUBWF  x9D,W
005D6:  BNC   05F2
005D8:  BNZ   05E0
005DA:  MOVF   x9C,W
005DC:  SUBWF  xA8,W
005DE:  BC    05F2
005E0:  INCFSZ x9C,W
005E2:  BRA    05EA
005E4:  INCFSZ x9D,W
005E6:  BRA    05EA
005E8:  BRA    05F2
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005EA:  MOVFF  9D,A9
005EE:  MOVFF  9C,A8
.................... 			} 
.................... 			ext2_state=0; 
005F2:  MOVLB  7
005F4:  BCF    xEA.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005F6:  BTFSC  xEA.6
005F8:  BRA    0608
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005FA:  MOVLB  1
005FC:  CLRF   xEE
005FE:  CLRF   xED
.................... 			ext2_count=1; 
00600:  MOVLB  A
00602:  BSF    x13.4
.................... 			ext2_state=1; 
00604:  MOVLB  7
00606:  BSF    xEA.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
00608:  MOVLB  7
0060A:  BCF    xEA.5
0060C:  MOVLB  A
0060E:  BTFSS  x13.5
00610:  BRA    0618
00612:  MOVLB  7
00614:  BSF    xEA.5
00616:  MOVLB  A
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00618:  MOVLB  8
0061A:  INCF   xF5,F
.................... 	if ( 10 == tick ) { 
0061C:  MOVF   xF5,W
0061E:  SUBLW  0A
00620:  BNZ   062A
.................... 		tick=0; 
00622:  CLRF   xF5
.................... 		timers.now_millisecond=1; 
00624:  MOVLB  1
00626:  BSF    xFD.2
00628:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0062A:  BCF    F9E.1
0062C:  MOVLB  0
0062E:  GOTO   013A
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0064A:  BRA    0632
0064C:  MOVFF  01,A10
.................... 	current.rda2_bytes_received++; 
00650:  MOVLB  1
00652:  INCF   xE5,F
00654:  BTFSC  FD8.2
00656:  INCF   xE6,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
00658:  DECFSZ 38,W
0065A:  BRA    067E
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
0065C:  MOVLB  3
0065E:  CLRF   x02
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
00660:  INCFSZ x01,W
00662:  BRA    0666
00664:  BRA    067A
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
00666:  MOVLW  01
00668:  ADDWF  x01,W
0066A:  MOVWF  FE9
0066C:  MOVLW  02
0066E:  MOVWF  FEA
00670:  BTFSC  FD8.0
00672:  INCF   FEA,F
00674:  MOVFF  A10,FEF
.................... 			timers.rda2_buff_pos++; 
00678:  INCF   x01,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
0067A:  BRA    06C0
0067C:  MOVLB  1
0067E:  MOVF   38,W
00680:  SUBLW  02
00682:  BNZ   06C2
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
00684:  MOVLB  A
00686:  MOVF   x10,W
00688:  SUBLW  0A
0068A:  BZ    0692
0068C:  MOVF   x10,W
0068E:  SUBLW  0D
00690:  BNZ   06A2
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
00692:  MOVLB  3
00694:  MOVF   x01,F
00696:  BZ    069E
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
00698:  MOVLW  14
0069A:  MOVWF  x02
.................... 			}  else { 
0069C:  BRA    069E
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
0069E:  BRA    06C0
006A0:  MOVLB  A
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
006A2:  MOVLB  3
006A4:  CLRF   x02
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006A6:  INCFSZ x01,W
006A8:  BRA    06AC
006AA:  BRA    06C0
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
006AC:  MOVLW  01
006AE:  ADDWF  x01,W
006B0:  MOVWF  FE9
006B2:  MOVLW  02
006B4:  MOVWF  FEA
006B6:  BTFSC  FD8.0
006B8:  INCF   FEA,F
006BA:  MOVFF  A10,FEF
.................... 				timers.rda2_buff_pos++; 
006BE:  INCF   x01,F
006C0:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /* transmit buffer empty for Modbus to raspberry pi buffer */ 
006C2:  BCF    FA4.5
006C4:  MOVLB  0
006C6:  GOTO   0094
.................... #int_tbe 
.................... void isr_uart1_tbe() { 
.................... 	if ( timers.rda_tx_pos >= timers.rda_tx_length ) { 
*
006D2:  MOVLB  4
006D4:  MOVF   x03,W
006D6:  SUBWF  x04,W
006D8:  BNC   06E0
.................... 		/* done transmitting */ 
.................... 		timers.now_rda_tx_done=1; 
006DA:  BSF    x05.1
.................... 		disable_interrupts(INT_TBE); 
006DC:  BCF    F9D.4
.................... 	} else { 
006DE:  BRA    06FE
.................... 		/* put another character into TX buffer */ 
.................... 		fputc(timers.rda_tx_buff[timers.rda_tx_pos], STREAM_PI); 
006E0:  MOVLW  03
006E2:  ADDWF  x04,W
006E4:  MOVWF  FE9
006E6:  MOVLW  03
006E8:  MOVWF  FEA
006EA:  BTFSC  FD8.0
006EC:  INCF   FEA,F
006EE:  MOVFF  FEF,A10
006F2:  MOVLB  A
006F4:  MOVF   x10,W
006F6:  MOVLB  0
006F8:  RCALL  06CA
.................... 		timers.rda_tx_pos++; 
006FA:  MOVLB  4
006FC:  INCF   x04,F
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
006FE:  BCF    F9E.4
00700:  MOVLB  0
00702:  GOTO   0094
.................... #int_rda 
.................... void isr_uart1_rx() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
00748:  RCALL  0706
0074A:  MOVFF  01,A10
....................  
.................... 	current.rda_bytes_received++; 
0074E:  MOVLB  1
00750:  INCF   xE3,F
00752:  BTFSC  FD8.2
00754:  INCF   xE4,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
00756:  MOVLB  7
00758:  BTFSC  xEA.0
0075A:  BRA    07B2
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
0075C:  MOVF   xEB,F
0075E:  BNZ   0770
.................... 			modbus_serial_crc.d = 0xFFFF; 
00760:  SETF   xED
00762:  SETF   xEC
.................... 			modbus_rx.address = c; 
00764:  MOVFF  A10,7EE
.................... 			modbus_serial_state++; 
00768:  INCF   xEB,F
.................... 			modbus_rx.len = 0; 
0076A:  CLRF   xEF
.................... 			modbus_rx.error=0; 
0076C:  CLRF   xF1
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
0076E:  BRA    079E
00770:  DECFSZ xEB,W
00772:  BRA    077C
.................... 			modbus_rx.func = c; 
00774:  MOVFF  A10,7F0
.................... 			modbus_serial_state++; 
00778:  INCF   xEB,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
0077A:  BRA    079E
0077C:  MOVF   xEB,W
0077E:  SUBLW  02
00780:  BNZ   079E
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
00782:  INCFSZ xEF,W
00784:  BRA    078A
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00786:  MOVLW  FE
00788:  MOVWF  xEF
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
0078A:  MOVLW  F2
0078C:  ADDWF  xEF,W
0078E:  MOVWF  FE9
00790:  MOVLW  07
00792:  MOVWF  FEA
00794:  BTFSC  FD8.0
00796:  INCF   FEA,F
00798:  MOVFF  A10,FEF
.................... 			modbus_rx.len++; 
0079C:  INCF   xEF,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
0079E:  MOVFF  A10,A11
007A2:  MOVLB  0
007A4:  RCALL  071C
.................... 		modbus_enable_timeout(TRUE); 
007A6:  MOVLW  01
007A8:  MOVLB  A
007AA:  MOVWF  x11
007AC:  MOVLB  0
007AE:  RCALL  03A8
007B0:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
007B2:  BCF    F9E.5
007B4:  MOVLB  0
007B6:  GOTO   0094
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
00D8C:  MOVF   39,W
00D8E:  XORLW  00
00D90:  BZ    0DA8
00D92:  XORLW  01
00D94:  BZ    0DB8
00D96:  XORLW  03
00D98:  BZ    0DC8
00D9A:  XORLW  06
00D9C:  BZ    0DD8
00D9E:  XORLW  01
00DA0:  BZ    0DE4
00DA2:  XORLW  03
00DA4:  BZ    0DF4
00DA6:  BRA    0E00
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
00DA8:  BSF    F70.3
00DAA:  MOVLW  C3
00DAC:  MOVWF  F75
00DAE:  MOVLW  09
00DB0:  MOVWF  F76
00DB2:  MOVLW  A6
00DB4:  MOVWF  F72
00DB6:  BRA    0E0C
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
00DB8:  BSF    F70.3
00DBA:  MOVLW  E1
00DBC:  MOVWF  F75
00DBE:  MOVLW  04
00DC0:  MOVWF  F76
00DC2:  MOVLW  A6
00DC4:  MOVWF  F72
00DC6:  BRA    0E0C
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
00DC8:  BSF    F70.3
00DCA:  MOVLW  70
00DCC:  MOVWF  F75
00DCE:  MOVLW  02
00DD0:  MOVWF  F76
00DD2:  MOVLW  A6
00DD4:  MOVWF  F72
00DD6:  BRA    0E0C
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
00DD8:  BCF    F70.3
00DDA:  MOVLW  26
00DDC:  MOVWF  F75
00DDE:  MOVLW  A6
00DE0:  MOVWF  F72
00DE2:  BRA    0E0C
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
00DE4:  BSF    F70.3
00DE6:  MOVLW  4D
00DE8:  MOVWF  F75
00DEA:  MOVLW  00
00DEC:  MOVWF  F76
00DEE:  MOVLW  A6
00DF0:  MOVWF  F72
00DF2:  BRA    0E0C
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
00DF4:  BCF    F70.3
00DF6:  MOVLW  0C
00DF8:  MOVWF  F75
00DFA:  MOVLW  A6
00DFC:  MOVWF  F72
00DFE:  BRA    0E0C
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
00E00:  BCF    F70.3
00E02:  MOVLW  4D
00E04:  MOVWF  F75
00E06:  MOVLW  A6
00E08:  MOVWF  F72
00E0A:  BRA    0E0C
.................... 	} 
.................... } 
00E0C:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... 	setup_adc(ADC_OFF); 
*
008B4:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
008B6:  MOVLW  08
008B8:  MOVWF  F61
008BA:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
008BC:  MOVLW  00
008BE:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
008C0:  MOVLW  FF
008C2:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
008C4:  MOVLW  92
008C6:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
008C8:  MOVLW  80
008CA:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
008CC:  BCF    F96.0
008CE:  BCF    F96.1
008D0:  BCF    F96.2
008D2:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
008D4:  MOVLB  1
008D6:  CLRF   xFA
.................... 	timers.load_off_seconds=2; 
008D8:  CLRF   xFC
008DA:  MOVLW  02
008DC:  MOVWF  xFB
.................... 	timers.now_adc_sample=0; 
008DE:  BCF    xFD.0
.................... 	timers.now_adc_reset_count=0; 
008E0:  BCF    xFD.1
.................... 	timers.now_millisecond=0; 
008E2:  BCF    xFD.2
.................... 	timers.port_b=0b11111111; 
008E4:  SETF   xFE
.................... 	timers.port_c=0b11111111; 
008E6:  SETF   xFF
....................  
.................... 	timers.rda2_buff_pos=0; 
008E8:  MOVLB  3
008EA:  CLRF   x01
.................... 	timers.rda2_buff_gap=255; 
008EC:  SETF   x02
.................... 	timers.now_parse_rda2=0; 
008EE:  MOVLB  2
008F0:  BCF    x00.0
....................  
.................... 	timers.rda_tx_length=0; 
008F2:  MOVLB  4
008F4:  CLRF   x03
.................... 	timers.rda_tx_pos=0; 
008F6:  CLRF   x04
.................... 	timers.now_rda_tx_ready=0; 
008F8:  BCF    x05.0
.................... 	timers.now_rda_tx_done=0; 
008FA:  BCF    x05.1
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
008FC:  MOVLB  8
008FE:  CLRF   xFE
00900:  MOVF   xFE,W
00902:  SUBLW  02
00904:  BNC   09B4
.................... 		current.pulse_period[i]=0; 
00906:  CLRF   03
00908:  MOVFF  8FE,02
0090C:  BCF    FD8.0
0090E:  RLCF   02,F
00910:  RLCF   03,F
00912:  MOVF   02,W
00914:  ADDLW  98
00916:  MOVWF  FE9
00918:  MOVLW  00
0091A:  ADDWFC 03,W
0091C:  MOVWF  FEA
0091E:  CLRF   FEC
00920:  MOVF   FED,F
00922:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
00924:  CLRF   03
00926:  MOVFF  8FE,02
0092A:  BCF    FD8.0
0092C:  RLCF   02,F
0092E:  RLCF   03,F
00930:  MOVF   02,W
00932:  ADDLW  9E
00934:  MOVWF  FE9
00936:  MOVLW  00
00938:  ADDWFC 03,W
0093A:  MOVWF  FEA
0093C:  SETF   FEC
0093E:  MOVF   FED,F
00940:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00942:  CLRF   03
00944:  MOVFF  8FE,02
00948:  BCF    FD8.0
0094A:  RLCF   02,F
0094C:  RLCF   03,F
0094E:  MOVF   02,W
00950:  ADDLW  A4
00952:  MOVWF  FE9
00954:  MOVLW  00
00956:  ADDWFC 03,W
00958:  MOVWF  FEA
0095A:  CLRF   FEC
0095C:  MOVF   FED,F
0095E:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00960:  CLRF   03
00962:  MOVFF  8FE,02
00966:  BCF    FD8.0
00968:  RLCF   02,F
0096A:  RLCF   03,F
0096C:  MOVF   02,W
0096E:  ADDLW  AA
00970:  MOVWF  FE9
00972:  MOVLW  00
00974:  ADDWFC 03,W
00976:  MOVWF  FEA
00978:  CLRF   FEC
0097A:  MOVF   FED,F
0097C:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
0097E:  MOVLB  A
00980:  CLRF   x03
00982:  MOVFF  8FE,A02
00986:  CLRF   x05
00988:  MOVLW  04
0098A:  MOVWF  x04
0098C:  MOVLB  0
0098E:  RCALL  0878
00990:  MOVF   01,W
00992:  ADDLW  B0
00994:  MOVWF  FE9
00996:  MOVLW  00
00998:  ADDWFC 02,W
0099A:  MOVWF  FEA
0099C:  MOVF   FEE,F
0099E:  MOVF   FEE,F
009A0:  CLRF   FEC
009A2:  MOVF   FED,F
009A4:  CLRF   FEF
009A6:  MOVF   FED,F
009A8:  CLRF   FEF
009AA:  MOVF   FED,F
009AC:  CLRF   FEF
.................... 	} 
009AE:  MOVLB  8
009B0:  INCF   xFE,F
009B2:  BRA    0900
....................  
.................... 	current.modbus_our_packets=0; 
009B4:  MOVLB  1
009B6:  CLRF   xCE
009B8:  CLRF   xCD
.................... 	current.modbus_other_packets=0; 
009BA:  CLRF   xD0
009BC:  CLRF   xCF
.................... 	current.modbus_last_error=0; 
009BE:  CLRF   xD2
009C0:  CLRF   xD1
.................... 	current.sequence_number=0; 
009C2:  CLRF   xD4
009C4:  CLRF   xD3
.................... 	current.uptime_minutes=0; 
009C6:  CLRF   xD6
009C8:  CLRF   xD5
.................... 	current.interval_milliseconds=0; 
009CA:  CLRF   xD8
009CC:  CLRF   xD7
.................... 	current.adc_buffer_index=0; 
009CE:  CLRF   xCC
.................... 	current.factory_unlocked=0; 
009D0:  CLRF   xD9
.................... 	current.watchdog_seconds=0; 
009D2:  CLRF   xDB
009D4:  CLRF   xDA
.................... 	current.rda_bytes_received=0; 
009D6:  CLRF   xE4
009D8:  CLRF   xE3
.................... 	current.rda2_bytes_received=0; 
009DA:  CLRF   xE6
009DC:  CLRF   xE5
.................... 	current.button_state=0; 
009DE:  CLRF   xE7
.................... 	current.latch_sw_magnet=0; 
009E0:  CLRF   xE8
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
009E2:  MOVLW  04
009E4:  MOVWF  FEA
009E6:  MOVLW  06
009E8:  MOVWF  FE9
009EA:  CLRF   00
009EC:  MOVLW  03
009EE:  MOVWF  02
009F0:  MOVLW  E4
009F2:  MOVWF  01
009F4:  MOVLB  0
009F6:  RCALL  089A
.................... 	for ( i=0 ; i < N_NMEA0183_SENTENCES ; i++ ) { 
009F8:  MOVLB  8
009FA:  CLRF   xFE
009FC:  MOVF   xFE,W
009FE:  SUBLW  0B
00A00:  BNC   0A34
.................... 		nmea.sentence_age[i]=0xffff; 
00A02:  CLRF   03
00A04:  MOVFF  8FE,02
00A08:  BCF    FD8.0
00A0A:  RLCF   02,F
00A0C:  RLCF   03,F
00A0E:  MOVF   02,W
00A10:  ADDLW  C6
00A12:  MOVWF  FE9
00A14:  MOVLW  07
00A16:  ADDWFC 03,W
00A18:  MOVWF  FEA
00A1A:  SETF   FEC
00A1C:  MOVF   FED,F
00A1E:  SETF   FEF
.................... 		nmea.sentence_length[i]=0; 
00A20:  MOVLW  DE
00A22:  ADDWF  xFE,W
00A24:  MOVWF  FE9
00A26:  MOVLW  07
00A28:  MOVWF  FEA
00A2A:  BTFSC  FD8.0
00A2C:  INCF   FEA,F
00A2E:  CLRF   FEF
.................... 	} 
00A30:  INCF   xFE,F
00A32:  BRA    09FC
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00A34:  MOVFF  4C,1DE
00A38:  MOVFF  4B,1DD
.................... 	current.power_off_delay=config.power_off_below_delay; 
00A3C:  MOVFF  48,1E0
00A40:  MOVFF  47,1DF
.................... 	current.power_override_timeout=0; 
00A44:  MOVLB  1
00A46:  CLRF   xE2
00A48:  CLRF   xE1
....................  
.................... 	/* UART2 - RS-485 port speed will be set after parameters are read */ 
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00A4A:  MOVLW  00
00A4C:  IORLW  05
00A4E:  MOVWF  FBA
00A50:  MOVLW  4A
00A52:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00A54:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00A56:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00A58:  MOVLB  0
00A5A:  GOTO   3110 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... 	static int16 b0_state=0; /* push button */ 
.................... 	/* power control */ 
.................... 	int8 i; 
....................  
....................  
.................... 	timers.now_millisecond=0; 
*
00FD4:  MOVLB  1
00FD6:  BCF    xFD.2
....................  
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
00FD8:  BCF    FD8.0
00FDA:  MOVLB  8
00FDC:  RLCF   xFB,W
00FDE:  MOVWF  xFF
00FE0:  RLCF   xFC,W
00FE2:  MOVLB  9
00FE4:  MOVWF  x00
00FE6:  MOVLW  00
00FE8:  MOVLB  1
00FEA:  BTFSS  xFE.3
00FEC:  MOVLW  01
00FEE:  MOVLB  8
00FF0:  IORWF  xFF,F
00FF2:  MOVFF  8FF,8FB
00FF6:  MOVLB  9
00FF8:  MOVF   x00,W
00FFA:  IORLW  E0
00FFC:  MOVLB  8
00FFE:  MOVWF  xFC
.................... 	if ( b0_state==0xf000) { 
01000:  MOVF   xFB,F
01002:  BNZ   1016
01004:  MOVF   xFC,W
01006:  SUBLW  F0
01008:  BNZ   1016
.................... 		/* button pressed */ 
.................... 		current.button_state=1; 
0100A:  MOVLW  01
0100C:  MOVLB  1
0100E:  MOVWF  xE7
.................... 		current.latch_sw_magnet=1; 
01010:  MOVWF  xE8
.................... 	} else { 
01012:  BRA    101A
01014:  MOVLB  8
.................... 		current.button_State=0; 
01016:  MOVLB  1
01018:  CLRF   xE7
.................... 	} 
....................  
.................... 	/* set PIC to PI line based on latch state(s) */ 
.................... 	if ( bit_test(config.pic_to_pi_latch_mask,0) && current.latch_sw_magnet ) { 
0101A:  BTFSS  4F.0
0101C:  BRA    1026
0101E:  MOVF   xE8,F
01020:  BZ    1026
.................... 		output_high(PIC_TO_PI); 
01022:  BSF    F8C.3
.................... 	} else { 
01024:  BRA    1028
.................... 		output_low(PIC_TO_PI); 
01026:  BCF    F8C.3
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
01028:  INCFSZ xE9,W
0102A:  BRA    1038
0102C:  INCFSZ xEA,W
0102E:  BRA    1038
.................... 				current.pulse_period[0]=0; 
01030:  MOVLB  0
01032:  CLRF   x99
01034:  CLRF   x98
01036:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
01038:  INCFSZ xEB,W
0103A:  BRA    1048
0103C:  INCFSZ xEC,W
0103E:  BRA    1048
.................... 				current.pulse_period[1]=0; 
01040:  MOVLB  0
01042:  CLRF   x9B
01044:  CLRF   x9A
01046:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
01048:  INCFSZ xED,W
0104A:  BRA    1058
0104C:  INCFSZ xEE,W
0104E:  BRA    1058
.................... 				current.pulse_period[2]=0; 
01050:  MOVLB  0
01052:  CLRF   x9D
01054:  CLRF   x9C
01056:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
01058:  MOVFF  F81,1FE
.................... 	timers.port_c=port_c; 
0105C:  MOVFF  F82,1FF
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
01060:  MOVF   xFA,F
01062:  BNZ   1068
.................... 		output_low(LED_GREEN); 
01064:  BCF    F89.3
.................... 	} else { 
01066:  BRA    106C
.................... 		output_high(LED_GREEN); 
01068:  BSF    F89.3
.................... 		timers.led_on_green--; 
0106A:  DECF   xFA,F
.................... 	} 
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
0106C:  INCFSZ xD7,W
0106E:  BRA    1076
01070:  INCFSZ xD8,W
01072:  BRA    1076
01074:  BRA    107C
.................... 		current.interval_milliseconds++; 
01076:  INCF   xD7,F
01078:  BTFSC  FD8.2
0107A:  INCF   xD8,F
.................... 	} 
....................  
.................... 	if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
0107C:  MOVF   38,W
0107E:  SUBLW  02
01080:  BNZ   10DA
.................... 		/* NMEA sentence age */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
01082:  MOVLB  8
01084:  CLRF   xFE
01086:  MOVF   xFE,W
01088:  SUBLW  0B
0108A:  BNC   10DA
.................... 			if ( 0xffff != nmea.sentence_age[i] ) 
0108C:  CLRF   03
0108E:  MOVFF  8FE,02
01092:  BCF    FD8.0
01094:  RLCF   02,F
01096:  RLCF   03,F
01098:  MOVF   02,W
0109A:  ADDLW  C6
0109C:  MOVWF  FE9
0109E:  MOVLW  07
010A0:  ADDWFC 03,W
010A2:  MOVWF  FEA
010A4:  MOVFF  FEC,03
010A8:  MOVF   FED,F
010AA:  MOVF   FEF,W
010AC:  SUBLW  FF
010AE:  BNZ   10B6
010B0:  INCFSZ 03,W
010B2:  BRA    10B6
010B4:  BRA    10D6
.................... 				nmea.sentence_age[i]++; 
010B6:  CLRF   03
010B8:  MOVFF  8FE,02
010BC:  BCF    FD8.0
010BE:  RLCF   02,F
010C0:  RLCF   03,F
010C2:  MOVF   02,W
010C4:  ADDLW  C6
010C6:  MOVWF  FE9
010C8:  MOVLW  07
010CA:  ADDWFC 03,W
010CC:  MOVWF  FEA
010CE:  MOVLW  01
010D0:  ADDWF  FEE,F
010D2:  BNC   10D6
010D4:  INCF   FEF,F
.................... 		} 
010D6:  INCF   xFE,F
010D8:  BRA    1086
.................... 	} 
....................  
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
010DA:  MOVLB  8
010DC:  INCF   xF9,F
010DE:  BTFSC  FD8.2
010E0:  INCF   xFA,F
.................... 	if ( 1000 == ticks ) { 
010E2:  MOVF   xF9,W
010E4:  SUBLW  E8
010E6:  BNZ   116C
010E8:  MOVF   xFA,W
010EA:  SUBLW  03
010EC:  BNZ   116C
.................... 		ticks=0; 
010EE:  CLRF   xFA
010F0:  CLRF   xF9
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
010F2:  MOVLB  1
010F4:  INCFSZ xDA,W
010F6:  BRA    10FE
010F8:  INCFSZ xDB,W
010FA:  BRA    10FE
010FC:  BRA    1104
.................... 			current.watchdog_seconds++; 
010FE:  INCF   xDA,F
01100:  BTFSC  FD8.2
01102:  INCF   xDB,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
01104:  MOVF   40,F
01106:  BNZ   110C
01108:  MOVF   41,F
0110A:  BZ    112A
0110C:  MOVF   41,W
0110E:  SUBWF  xDB,W
01110:  BNC   112A
01112:  BNZ   111A
01114:  MOVF   xDA,W
01116:  SUBWF  40,W
01118:  BC    112A
0111A:  MOVF   xFB,F
0111C:  BNZ   112A
0111E:  MOVF   xFC,F
01120:  BNZ   112A
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
01122:  MOVFF  43,1FC
01126:  MOVFF  42,1FB
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
0112A:  MOVF   xFB,F
0112C:  BNZ   1136
0112E:  MOVF   xFC,F
01130:  BNZ   1136
.................... 			output_high(PI_POWER_EN); 
01132:  BSF    F8B.0
.................... 		} else { 
01134:  BRA    114C
.................... 			output_low(PI_POWER_EN); 
01136:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01138:  MOVF   xFB,W
0113A:  BTFSC  FD8.2
0113C:  DECF   xFC,F
0113E:  DECF   xFB,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
01140:  MOVF   xFB,F
01142:  BNZ   114C
01144:  MOVF   xFC,F
01146:  BNZ   114C
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01148:  CLRF   xDB
0114A:  CLRF   xDA
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
0114C:  MOVLB  8
0114E:  INCF   xF6,F
.................... 		if ( 60 == uptimeTicks ) { 
01150:  MOVF   xF6,W
01152:  SUBLW  3C
01154:  BNZ   116C
.................... 			uptimeTicks=0; 
01156:  CLRF   xF6
.................... 			if ( current.uptime_minutes < 65535 )  
01158:  MOVLB  1
0115A:  INCFSZ xD5,W
0115C:  BRA    1164
0115E:  INCFSZ xD6,W
01160:  BRA    1164
01162:  BRA    116A
.................... 				current.uptime_minutes++; 
01164:  INCF   xD5,F
01166:  BTFSC  FD8.2
01168:  INCF   xD6,F
0116A:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
0116C:  MOVLB  1
0116E:  BTFSS  xFD.1
01170:  BRA    117A
.................... 		timers.now_adc_reset_count=0; 
01172:  BCF    xFD.1
.................... 		adcTicks=0; 
01174:  MOVLB  8
01176:  CLRF   xF8
01178:  CLRF   xF7
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
0117A:  MOVLB  8
0117C:  INCF   xF7,F
0117E:  BTFSC  FD8.2
01180:  INCF   xF8,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
01182:  MOVF   3D,W
01184:  SUBWF  xF7,W
01186:  BNZ   1196
01188:  MOVF   3E,W
0118A:  SUBWF  xF8,W
0118C:  BNZ   1196
.................... 		adcTicks=0; 
0118E:  CLRF   xF8
01190:  CLRF   xF7
.................... 		timers.now_adc_sample=1; 
01192:  MOVLB  1
01194:  BSF    xFD.0
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01196:  MOVLB  3
01198:  INCFSZ x02,W
0119A:  BRA    119E
0119C:  BRA    11A0
.................... 		timers.rda2_buff_gap++; 
0119E:  INCF   x02,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
011A0:  MOVF   x02,W
011A2:  SUBLW  09
011A4:  BC    11B0
011A6:  MOVF   x01,F
011A8:  BZ    11B0
.................... 		timers.now_parse_rda2=1;	 
011AA:  MOVLB  2
011AC:  BSF    x00.0
011AE:  MOVLB  3
.................... 	} 
.................... } 
011B0:  MOVLB  0
011B2:  GOTO   3286 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && i < maxLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
02E46:  MOVLB  A
02E48:  CLRF   x0A
02E4A:  MOVF   x08,W
02E4C:  SUBWF  x0A,W
02E4E:  BC    2EC2
02E50:  MOVF   x09,W
02E52:  SUBWF  x0A,W
02E54:  BC    2EC2
02E56:  CLRF   03
02E58:  MOVF   x0A,W
02E5A:  ADDWF  x06,W
02E5C:  MOVWF  FE9
02E5E:  MOVF   x07,W
02E60:  ADDWFC 03,W
02E62:  MOVWF  FEA
02E64:  MOVF   FEF,F
02E66:  BZ    2EC2
02E68:  CLRF   03
02E6A:  MOVF   x0A,W
02E6C:  ADDWF  x06,W
02E6E:  MOVWF  FE9
02E70:  MOVF   x07,W
02E72:  ADDWFC 03,W
02E74:  MOVWF  FEA
02E76:  MOVF   FEF,W
02E78:  SUBLW  0A
02E7A:  BZ    2EC2
02E7C:  CLRF   03
02E7E:  MOVF   x0A,W
02E80:  ADDWF  x06,W
02E82:  MOVWF  FE9
02E84:  MOVF   x07,W
02E86:  ADDWFC 03,W
02E88:  MOVWF  FEA
02E8A:  MOVF   FEF,W
02E8C:  SUBLW  0D
02E8E:  BZ    2EC2
.................... 		dest[i] = src[i]; 
02E90:  CLRF   03
02E92:  MOVF   x0A,W
02E94:  ADDWF  x04,W
02E96:  MOVWF  01
02E98:  MOVF   x05,W
02E9A:  ADDWFC 03,F
02E9C:  MOVFF  03,A0C
02EA0:  CLRF   03
02EA2:  MOVF   x0A,W
02EA4:  ADDWF  x06,W
02EA6:  MOVWF  FE9
02EA8:  MOVF   x07,W
02EAA:  ADDWFC 03,W
02EAC:  MOVWF  FEA
02EAE:  MOVFF  FEF,A0D
02EB2:  MOVFF  A0C,FEA
02EB6:  MOVFF  01,FE9
02EBA:  MOVFF  A0D,FEF
.................... 	} 
02EBE:  INCF   x0A,F
02EC0:  BRA    2E4A
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
02EC2:  MOVF   x09,W
02EC4:  SUBWF  x0A,W
02EC6:  BC    2EDC
.................... 		dest[i] = '\0'; 
02EC8:  CLRF   03
02ECA:  MOVF   x0A,W
02ECC:  ADDWF  x04,W
02ECE:  MOVWF  FE9
02ED0:  MOVF   x05,W
02ED2:  ADDWFC 03,W
02ED4:  MOVWF  FEA
02ED6:  CLRF   FEF
.................... 	} 
02ED8:  INCF   x0A,F
02EDA:  BRA    2EC2
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
02EDC:  MOVLW  01
02EDE:  SUBWF  x09,W
02EE0:  CLRF   03
02EE2:  ADDWF  x04,W
02EE4:  MOVWF  FE9
02EE6:  MOVF   x05,W
02EE8:  ADDWFC 03,W
02EEA:  MOVWF  FEA
02EEC:  CLRF   FEF
.................... } 
02EEE:  MOVLB  0
02EF0:  GOTO   302E (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
02EF4:  MOVFF  301,9FE
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02EF8:  MOVLB  3
02EFA:  SETF   x01
.................... 	memcpy(buff,timers.rda2_buff,length); 
02EFC:  MOVLW  08
02EFE:  MOVWF  FEA
02F00:  MOVLW  FE
02F02:  MOVWF  FE9
02F04:  MOVLW  02
02F06:  MOVWF  FE2
02F08:  MOVLW  01
02F0A:  MOVWF  FE1
02F0C:  MOVLB  9
02F0E:  MOVF   xFE,W
02F10:  MOVWF  01
02F12:  BZ    2F1C
02F14:  MOVFF  FE6,FEE
02F18:  DECFSZ 01,F
02F1A:  BRA    2F14
.................... 	timers.rda2_buff_gap=0; 
02F1C:  MOVLB  3
02F1E:  CLRF   x02
.................... 	timers.rda2_buff_pos=0; 
02F20:  CLRF   x01
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02F22:  DECFSZ 38,W
02F24:  BRA    2F72
.................... 		/* transmit MODBUS received data back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02F26:  MOVLB  A
02F28:  CLRF   x00
02F2A:  MOVLB  9
02F2C:  CLRF   xFF
02F2E:  MOVLB  A
02F30:  MOVF   x00,F
02F32:  BNZ   2F6E
02F34:  MOVLB  9
02F36:  MOVF   xFE,W
02F38:  SUBWF  xFF,W
02F3A:  BTFSS  FD8.0
02F3C:  BRA    2F42
02F3E:  MOVLB  A
02F40:  BRA    2F6E
.................... 			fputc(buff[l],STREAM_PI); 
02F42:  MOVLW  FE
02F44:  ADDWF  xFF,W
02F46:  MOVWF  FE9
02F48:  MOVLW  08
02F4A:  MOVLB  A
02F4C:  ADDWFC x00,W
02F4E:  MOVWF  FEA
02F50:  MOVFF  FEF,A02
02F54:  MOVF   x02,W
02F56:  MOVLB  0
02F58:  CALL   06CA
.................... 		} 
02F5C:  MOVLB  9
02F5E:  INCF   xFF,F
02F60:  BTFSS  FD8.2
02F62:  BRA    2F6A
02F64:  MOVLB  A
02F66:  INCF   x00,F
02F68:  MOVLB  9
02F6A:  BRA    2F2E
02F6C:  MOVLB  A
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
02F6E:  BRA    3066
02F70:  MOVLB  3
02F72:  MOVF   38,W
02F74:  SUBLW  02
02F76:  BTFSS  FD8.2
02F78:  BRA    3068
.................... 		/* process NMEA0183 sentence */ 
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
02F7A:  MOVLB  9
02F7C:  MOVF   xFE,W
02F7E:  SUBLW  05
02F80:  BNC   2F84
.................... 			return; 
02F82:  BRA    306A
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
02F84:  MOVLB  A
02F86:  CLRF   x01
02F88:  MOVF   x01,W
02F8A:  SUBLW  0B
02F8C:  BNC   3066
.................... 			/* compare first six characters or look for wild card */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) && '*' != config.nmea0183_sentence[i][0] ) { 
02F8E:  MOVF   x01,W
02F90:  MULLW  06
02F92:  MOVF   FF3,W
02F94:  CLRF   03
02F96:  ADDLW  50
02F98:  MOVWF  01
02F9A:  MOVLW  00
02F9C:  ADDWFC 03,F
02F9E:  MOVFF  01,A02
02FA2:  MOVFF  03,A03
02FA6:  MOVLW  08
02FA8:  MOVWF  x05
02FAA:  MOVLW  FE
02FAC:  MOVWF  x04
02FAE:  MOVFF  03,A07
02FB2:  MOVFF  01,A06
02FB6:  CLRF   x09
02FB8:  MOVLW  06
02FBA:  MOVWF  x08
02FBC:  MOVLB  0
02FBE:  BRA    2DAE
02FC0:  MOVF   01,F
02FC2:  BZ    2FE6
02FC4:  MOVLB  A
02FC6:  MOVF   x01,W
02FC8:  MULLW  06
02FCA:  MOVF   FF3,W
02FCC:  CLRF   03
02FCE:  ADDLW  50
02FD0:  MOVWF  FE9
02FD2:  MOVLW  00
02FD4:  ADDWFC 03,W
02FD6:  MOVWF  FEA
02FD8:  MOVF   FEF,W
02FDA:  SUBLW  2A
02FDC:  BTFSS  FD8.2
02FDE:  BRA    2FE4
02FE0:  MOVLB  0
02FE2:  BRA    2FE6
.................... 				/* no match */ 
.................... 				continue; 
02FE4:  BRA    3062
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
02FE6:  MOVLB  A
02FE8:  CLRF   x03
02FEA:  MOVFF  A01,A02
02FEE:  CLRF   x05
02FF0:  MOVLW  50
02FF2:  MOVWF  x04
02FF4:  MOVLB  0
02FF6:  CALL   0878
02FFA:  MOVFF  02,03
02FFE:  MOVF   01,W
03000:  ADDLW  06
03002:  MOVWF  01
03004:  MOVLW  04
03006:  ADDWFC 03,F
03008:  MOVFF  01,A02
0300C:  MOVLB  A
0300E:  MOVFF  03,A03
03012:  MOVFF  03,A05
03016:  MOVFF  01,A04
0301A:  MOVLW  08
0301C:  MOVWF  x07
0301E:  MOVLW  FE
03020:  MOVWF  x06
03022:  MOVFF  9FE,A08
03026:  MOVLW  50
03028:  MOVWF  x09
0302A:  MOVLB  0
0302C:  BRA    2E46
.................... 			nmea.sentence_age[i]=0; 
0302E:  CLRF   03
03030:  MOVLB  A
03032:  MOVFF  A01,02
03036:  BCF    FD8.0
03038:  RLCF   02,F
0303A:  RLCF   03,F
0303C:  MOVF   02,W
0303E:  ADDLW  C6
03040:  MOVWF  FE9
03042:  MOVLW  07
03044:  ADDWFC 03,W
03046:  MOVWF  FEA
03048:  CLRF   FEC
0304A:  MOVF   FED,F
0304C:  CLRF   FEF
.................... 			nmea.sentence_length[i]=length; 
0304E:  MOVLW  DE
03050:  ADDWF  x01,W
03052:  MOVWF  FE9
03054:  MOVLW  07
03056:  MOVWF  FEA
03058:  BTFSC  FD8.0
0305A:  INCF   FEA,F
0305C:  MOVFF  9FE,FEF
....................  
.................... 			/* only fill in our first match */ 
.................... 			break; 
03060:  BRA    3066
.................... 		} 
03062:  INCF   x01,F
03064:  BRA    2F88
03066:  MOVLB  3
03068:  MOVLB  9
.................... 	} 
.................... } 
0306A:  MOVLB  0
0306C:  GOTO   32D4 (RETURN)
....................  
....................  
.................... void main(void) { 
03070:  CLRF   FF8
03072:  BCF    FF1.2
03074:  BSF    F9F.1
03076:  BCF    F9F.5
03078:  BCF    F9F.4
0307A:  BCF    FA5.5
0307C:  BSF    FD0.7
0307E:  BSF    07.7
03080:  CLRF   FEA
03082:  CLRF   FE9
03084:  CLRF   35
03086:  BCF    FB8.3
03088:  MOVLW  0C
0308A:  MOVWF  FAF
0308C:  MOVLW  A6
0308E:  MOVWF  FAC
03090:  MOVLW  90
03092:  MOVWF  FAB
03094:  BCF    F70.3
03096:  MOVLW  4D
03098:  MOVWF  F75
0309A:  MOVLW  A6
0309C:  MOVWF  F72
0309E:  MOVLW  90
030A0:  MOVWF  F71
030A2:  MOVLB  7
030A4:  BCF    xEA.0
030A6:  CLRF   xEB
030A8:  MOVLB  8
030AA:  CLRF   xF5
030AC:  MOVLB  7
030AE:  BCF    xEA.1
030B0:  BCF    xEA.2
030B2:  BCF    xEA.3
030B4:  BCF    xEA.4
030B6:  BCF    xEA.5
030B8:  BCF    xEA.6
030BA:  MOVLB  8
030BC:  CLRF   xF6
030BE:  CLRF   xF8
030C0:  CLRF   xF7
030C2:  CLRF   xFA
030C4:  CLRF   xF9
030C6:  CLRF   xFC
030C8:  CLRF   xFB
030CA:  MOVF   FC1,W
030CC:  ANDLW  F0
030CE:  MOVWF  FC1
030D0:  MOVLW  00
030D2:  MOVLB  F
030D4:  MOVWF  x38
030D6:  MOVWF  x3C
030D8:  MOVWF  x39
030DA:  MOVWF  x3A
030DC:  MOVWF  x3B
030DE:  MOVLB  1
030E0:  CLRF   x88
030E2:  CLRF   F77
030E4:  CLRF   F78
030E6:  CLRF   F79
030E8:  CLRF   2F
030EA:  CLRF   30
030EC:  MOVLB  8
030EE:  CLRF   xF1
030F0:  CLRF   xF2
030F2:  CLRF   xF3
030F4:  CLRF   xF4
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
030F6:  MOVF   FD0,W
030F8:  ANDLW  0F
030FA:  BTFSS  FD0.4
030FC:  MOVLW  00
030FE:  BSF    FD0.0
03100:  BSF    FD0.1
03102:  BSF    FD0.4
03104:  BSF    FD8.3
03106:  BSF    FD8.4
03108:  MOVWF  xFD
....................  
.................... 	init(); 
0310A:  MOVLB  0
0310C:  GOTO   08B4
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
03110:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
03112:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
03114:  MOVLW  BA
03116:  MOVWF  FF6
03118:  MOVLW  07
0311A:  MOVWF  FF7
0311C:  MOVLW  07
0311E:  MOVLB  8
03120:  MOVWF  xFE
03122:  MOVLB  0
03124:  CALL   0A5E
03128:  MOVLW  C6
0312A:  MOVWF  FF6
0312C:  MOVLW  07
0312E:  MOVWF  FF7
03130:  CALL   0A88
03134:  MOVLW  0D
03136:  BTFSS  FA4.4
03138:  BRA    3136
0313A:  MOVWF  F73
0313C:  MOVLW  0A
0313E:  BTFSS  FA4.4
03140:  BRA    313E
03142:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
03144:  MOVLW  D0
03146:  MOVWF  FF6
03148:  MOVLW  07
0314A:  MOVWF  FF7
0314C:  MOVLW  12
0314E:  MOVLB  8
03150:  MOVWF  xFE
03152:  MOVLB  0
03154:  CALL   0A5E
03158:  MOVFF  8FD,8FE
0315C:  MOVLW  1B
0315E:  MOVLB  8
03160:  MOVWF  xFF
03162:  MOVLB  0
03164:  GOTO   0AD6
03168:  MOVLW  20
0316A:  BTFSS  FA4.4
0316C:  BRA    316A
0316E:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
03170:  MOVLB  8
03172:  MOVF   xFD,W
03174:  XORLW  07
03176:  MOVLB  0
03178:  BZ    3194
0317A:  XORLW  0C
0317C:  BZ    31A2
0317E:  XORLW  04
03180:  BZ    31B0
03182:  XORLW  03
03184:  BZ    31BE
03186:  XORLW  02
03188:  BZ    31CC
0318A:  XORLW  0D
0318C:  BZ    31DA
0318E:  XORLW  03
03190:  BZ    31E8
03192:  BRA    31F6
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
03194:  MOVLW  E6
03196:  MOVWF  FF6
03198:  MOVLW  07
0319A:  MOVWF  FF7
0319C:  CALL   0A88
031A0:  BRA    3202
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
031A2:  MOVLW  F2
031A4:  MOVWF  FF6
031A6:  MOVLW  07
031A8:  MOVWF  FF7
031AA:  CALL   0A88
031AE:  BRA    3202
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
031B0:  MOVLW  02
031B2:  MOVWF  FF6
031B4:  MOVLW  08
031B6:  MOVWF  FF7
031B8:  CALL   0A88
031BC:  BRA    3202
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
031BE:  MOVLW  10
031C0:  MOVWF  FF6
031C2:  MOVLW  08
031C4:  MOVWF  FF7
031C6:  CALL   0A88
031CA:  BRA    3202
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
031CC:  MOVLW  20
031CE:  MOVWF  FF6
031D0:  MOVLW  08
031D2:  MOVWF  FF7
031D4:  CALL   0A88
031D8:  BRA    3202
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
031DA:  MOVLW  32
031DC:  MOVWF  FF6
031DE:  MOVLW  08
031E0:  MOVWF  FF7
031E2:  CALL   0A88
031E6:  BRA    3202
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
031E8:  MOVLW  42
031EA:  MOVWF  FF6
031EC:  MOVLW  08
031EE:  MOVWF  FF7
031F0:  CALL   0A88
031F4:  BRA    3202
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
031F6:  MOVLW  54
031F8:  MOVWF  FF6
031FA:  MOVLW  08
031FC:  MOVWF  FF7
031FE:  CALL   0A88
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
03202:  MOVLW  5E
03204:  MOVWF  FF6
03206:  MOVLW  08
03208:  MOVWF  FF7
0320A:  CALL   0A88
.................... #endif 
....................  
....................  
.................... 	read_param_file(); 
0320E:  GOTO   0D36
.................... 	set_rs485_speed(); 
03212:  CALL   0D8C
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
03216:  MOVF   36,W
03218:  SUBLW  80
0321A:  BC    3220
.................... 		write_default_param_file(); 
0321C:  CALL   0CE4
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
03220:  BSF    FAB.7
03222:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	modbus_init(); 
03224:  GOTO   0E1A
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
03228:  MOVLB  8
0322A:  CLRF   xFD
0322C:  MOVF   xFD,W
0322E:  SUBLW  1D
03230:  BNC   323E
.................... 		adc_update(); 
03232:  MOVLB  0
03234:  CALL   0ED8
.................... 	} 
03238:  MOVLB  8
0323A:  INCF   xFD,F
0323C:  BRA    322C
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
0323E:  MOVFF  44,1DC
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
03242:  BTFSS  F72.1
03244:  BRA    3242
.................... 	output_low(RS485_DE); 
03246:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
03248:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
0324A:  MOVLW  62
0324C:  MOVWF  FF6
0324E:  MOVLW  08
03250:  MOVWF  FF7
03252:  MOVLW  07
03254:  MOVWF  xFE
03256:  MOVLB  0
03258:  GOTO   0F84
0325C:  MOVLW  6E
0325E:  MOVWF  FF6
03260:  MOVLW  08
03262:  MOVWF  FF7
03264:  GOTO   0FB0
03268:  MOVLW  0D
0326A:  BTFSS  F9E.4
0326C:  BRA    326A
0326E:  MOVWF  FAD
03270:  MOVLW  0A
03272:  BTFSS  F9E.4
03274:  BRA    3272
03276:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
03278:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
0327A:  MOVLB  1
0327C:  BTFSS  xFD.2
0327E:  BRA    3288
.................... 			periodic_millisecond(); 
03280:  MOVLB  0
03282:  GOTO   0FD4
03286:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
03288:  BTFSS  xFD.0
0328A:  BRA    3294
.................... 			timers.now_adc_sample=0; 
0328C:  BCF    xFD.0
.................... 			adc_update(); 
0328E:  MOVLB  0
03290:  CALL   0ED8
.................... 		} 
....................  
.................... 		modbus_process(); 
03294:  MOVLB  0
03296:  BRA    2AAC
....................  
....................  
.................... 		/* buffered modbus transmit */ 
....................  
.................... 		/* start transmitting */ 
.................... 		if ( timers.now_rda_tx_ready ) { 
03298:  MOVLB  4
0329A:  BTFSS  x05.0
0329C:  BRA    32B0
.................... 			timers.now_rda_tx_ready=0; 
0329E:  BCF    x05.0
....................  
.................... //			output_high(_PIC_TO_PI); 
....................  
.................... 			RCV_OFF(); 
032A0:  BCF    F9D.5
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
032A2:  CLRWDT
032A4:  MOVLW  3C
032A6:  MOVWF  00
032A8:  DECFSZ 00,F
032AA:  BRA    32A8
032AC:  NOP   
....................  
.................... 			/* enable transmit buffer empty interrupt. It will feed itself */ 
.................... 			enable_interrupts(INT_TBE); 
032AE:  BSF    F9D.4
.................... 		} 
....................  
.................... 		/* done transmitting */ 
.................... 		if ( timers.now_rda_tx_done ) { 
032B0:  BTFSS  x05.1
032B2:  BRA    32C8
.................... 			timers.now_rda_tx_done=0; 
032B4:  BCF    x05.1
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
032B6:  CLRWDT
032B8:  MOVLW  3C
032BA:  MOVWF  00
032BC:  DECFSZ 00,F
032BE:  BRA    32BC
032C0:  NOP   
....................    			RCV_ON(); 
032C2:  MOVLB  0
032C4:  CALL   0E0E
....................  
.................... //			output_low(_PIC_TO_PI); 
.................... 		} 
....................  
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
032C8:  MOVLB  2
032CA:  BTFSS  x00.0
032CC:  BRA    32D6
.................... 			timers.now_parse_rda2=0; 
032CE:  BCF    x00.0
.................... 			rs485_to_host(); 
032D0:  MOVLB  0
032D2:  BRA    2EF4
032D4:  MOVLB  2
.................... 		} 
....................  
.................... 	} 
032D6:  MOVLB  0
032D8:  BRA    3278
.................... } 
032DA:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
