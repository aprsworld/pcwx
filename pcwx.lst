CCS PCH C Compiler, Version 4.135, 4375               13-Dec-15 13:40

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 13176 bytes (20%)
                         Largest free fragment is 52356
               RAM used: 2300 (59%) at main() level
                         2581 (66%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   3110
*
00008:  GOTO   00E2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   042E
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   07C2
0007C:  BTFSS  F9D.4
0007E:  GOTO   0088
00082:  BTFSC  F9E.4
00084:  GOTO   074C
00088:  BTFSS  FA3.5
0008A:  GOTO   0094
0008E:  BTFSC  FA4.5
00090:  GOTO   06BC
00094:  MOVFF  0E,00
00098:  MOVFF  0F,01
0009C:  MOVFF  10,02
000A0:  MOVFF  11,03
000A4:  MOVFF  0C,FE9
000A8:  MOVFF  07,FEA
000AC:  BSF    07.7
000AE:  MOVFF  08,FE1
000B2:  MOVFF  09,FE2
000B6:  MOVFF  0A,FD9
000BA:  MOVFF  0B,FDA
000BE:  MOVFF  12,FF3
000C2:  MOVFF  13,FF4
000C6:  MOVFF  14,FFA
000CA:  MOVFF  15,FF5
000CE:  MOVFF  16,FF6
000D2:  MOVFF  17,FF7
000D6:  MOVF   04,W
000D8:  MOVFF  06,FE0
000DC:  MOVFF  05,FD8
000E0:  RETFIE 0
000E2:  MOVWF  1A
000E4:  MOVFF  FD8,1B
000E8:  MOVFF  FE0,1C
000EC:  MOVLB  0
000EE:  MOVFF  FE9,22
000F2:  MOVFF  FEA,1D
000F6:  MOVFF  FE1,1E
000FA:  MOVFF  FE2,1F
000FE:  MOVFF  FD9,20
00102:  MOVFF  FDA,21
00106:  MOVFF  FF3,28
0010A:  MOVFF  FF4,29
0010E:  MOVFF  FFA,2A
00112:  MOVFF  FF5,2B
00116:  MOVFF  FF6,2C
0011A:  MOVFF  FF7,2D
0011E:  MOVFF  00,24
00122:  MOVFF  01,25
00126:  MOVFF  02,26
0012A:  MOVFF  03,27
0012E:  BTFSS  F9D.1
00130:  GOTO   013A
00134:  BTFSC  F9E.1
00136:  GOTO   0460
0013A:  MOVFF  24,00
0013E:  MOVFF  25,01
00142:  MOVFF  26,02
00146:  MOVFF  27,03
0014A:  MOVFF  22,FE9
0014E:  MOVFF  1D,FEA
00152:  BSF    1D.7
00154:  MOVFF  1E,FE1
00158:  MOVFF  1F,FE2
0015C:  MOVFF  20,FD9
00160:  MOVFF  21,FDA
00164:  MOVFF  28,FF3
00168:  MOVFF  29,FF4
0016C:  MOVFF  2A,FFA
00170:  MOVFF  2B,FF5
00174:  MOVFF  2C,FF6
00178:  MOVFF  2D,FF7
0017C:  MOVF   1A,W
0017E:  MOVFF  1C,FE0
00182:  MOVFF  1B,FD8
00186:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02E64:  MOVLB  A
02E66:  MOVF   x06,F
02E68:  BNZ   2E6E
02E6A:  MOVF   x07,F
02E6C:  BZ    2EF2
....................       if (*s1 != *s2) 
02E6E:  MOVFF  A02,FE9
02E72:  MOVFF  A03,FEA
02E76:  MOVFF  FEF,A08
02E7A:  MOVFF  A05,03
02E7E:  MOVFF  A04,FE9
02E82:  MOVFF  A05,FEA
02E86:  MOVF   FEF,W
02E88:  SUBWF  x08,W
02E8A:  BZ    2EBA
....................          return((*s1 <*s2) ? -1: 1); 
02E8C:  MOVFF  A03,03
02E90:  MOVFF  A02,FE9
02E94:  MOVFF  A03,FEA
02E98:  MOVFF  FEF,A08
02E9C:  MOVFF  A05,03
02EA0:  MOVFF  A04,FE9
02EA4:  MOVFF  A05,FEA
02EA8:  MOVF   FEF,W
02EAA:  SUBWF  x08,W
02EAC:  BC    2EB2
02EAE:  MOVLW  FF
02EB0:  BRA    2EB4
02EB2:  MOVLW  01
02EB4:  MOVWF  01
02EB6:  BRA    2EF6
....................       else if (*s1 == '\0') 
02EB8:  BRA    2ED0
02EBA:  MOVFF  A03,03
02EBE:  MOVFF  A02,FE9
02EC2:  MOVFF  A03,FEA
02EC6:  MOVF   FEF,F
02EC8:  BNZ   2ED0
....................          return(0); 
02ECA:  MOVLW  00
02ECC:  MOVWF  01
02ECE:  BRA    2EF6
02ED0:  MOVFF  A03,03
02ED4:  MOVF   x02,W
02ED6:  INCF   x02,F
02ED8:  BTFSC  FD8.2
02EDA:  INCF   x03,F
02EDC:  MOVFF  A05,03
02EE0:  MOVF   x04,W
02EE2:  INCF   x04,F
02EE4:  BTFSC  FD8.2
02EE6:  INCF   x05,F
02EE8:  MOVF   x06,W
02EEA:  BTFSC  FD8.2
02EEC:  DECF   x07,F
02EEE:  DECF   x06,F
02EF0:  BRA    2E66
....................    return(0); 
02EF2:  MOVLW  00
02EF4:  MOVWF  01
.................... } 
02EF6:  MOVLB  0
02EF8:  GOTO   3062 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
012DE:  MOVLW  05
012E0:  MOVLB  9
012E2:  SUBWF  x07,F
012E4:  BNC   12FA
012E6:  MOVLW  09
012E8:  MOVWF  FEA
012EA:  MOVLW  07
012EC:  MOVWF  FE9
012EE:  MOVF   FEF,W
012F0:  BZ    12FA
012F2:  BRA    12F6
012F4:  CLRWDT
012F6:  DECFSZ FEF,F
012F8:  BRA    12F4
012FA:  MOVLB  0
012FC:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00744:  BTFSS  F9E.4
00746:  BRA    0744
00748:  MOVWF  FAD
0074A:  RETURN 0
*
00780:  BTFSS  F9E.5
00782:  BRA    0780
00784:  MOVFF  FAB,35
00788:  MOVFF  FAE,01
0078C:  BTFSS  35.1
0078E:  BRA    0794
00790:  BCF    FAB.4
00792:  BSF    FAB.4
00794:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
006A4:  BTFSS  FA4.5
006A6:  BRA    06A4
006A8:  MOVFF  F71,35
006AC:  MOVFF  F74,01
006B0:  BTFSS  35.1
006B2:  BRA    06B8
006B4:  BCF    F71.4
006B6:  BSF    F71.4
006B8:  GOTO   06BE (RETURN)
*
012FE:  BTFSS  FA4.4
01300:  BRA    12FE
01302:  MOVWF  F73
01304:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define _PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
....................  
.................... 	/* push button on board */ 
.................... 	int8 button_state; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
....................  
.................... 	/* transmit buffer for PIC to PI */ 
.................... 	int8 rda_tx_buff[256]; 
.................... 	int8 rda_tx_length; 
.................... 	int8 rda_tx_pos; 
.................... 	int1 now_rda_tx_ready; 
.................... 	int1 now_rda_tx_done; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][NMEA_SENTENCE_LENGTH]; 
.................... 	int16 sentence_age[N_NMEA0183_SENTENCES]; 
.................... 	int8 sentence_length[N_NMEA0183_SENTENCES]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00FDC:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00F20:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00F22:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00F24:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00F26:  MOVLB  8
00F28:  MOVF   xFF,F
00F2A:  BNZ   0F36
.................... 		c=0b00011; 
00F2C:  MOVLW  03
00F2E:  MOVLB  9
00F30:  MOVWF  x03
.................... 	else if ( 1 == ch )  
00F32:  BRA    0F98
00F34:  MOVLB  8
00F36:  DECFSZ xFF,W
00F38:  BRA    0F44
.................... 		c=0b10011; 
00F3A:  MOVLW  13
00F3C:  MOVLB  9
00F3E:  MOVWF  x03
.................... 	else if ( 2 == ch )  
00F40:  BRA    0F98
00F42:  MOVLB  8
00F44:  MOVF   xFF,W
00F46:  SUBLW  02
00F48:  BNZ   0F54
.................... 		c=0b01011; 
00F4A:  MOVLW  0B
00F4C:  MOVLB  9
00F4E:  MOVWF  x03
.................... 	else if ( 3 == ch )  
00F50:  BRA    0F98
00F52:  MOVLB  8
00F54:  MOVF   xFF,W
00F56:  SUBLW  03
00F58:  BNZ   0F64
.................... 		c=0b11011; 
00F5A:  MOVLW  1B
00F5C:  MOVLB  9
00F5E:  MOVWF  x03
.................... 	else if ( 4 == ch ) 
00F60:  BRA    0F98
00F62:  MOVLB  8
00F64:  MOVF   xFF,W
00F66:  SUBLW  04
00F68:  BNZ   0F74
.................... 		c=0b00111; 
00F6A:  MOVLW  07
00F6C:  MOVLB  9
00F6E:  MOVWF  x03
.................... 	else if ( 5 == ch )  
00F70:  BRA    0F98
00F72:  MOVLB  8
00F74:  MOVF   xFF,W
00F76:  SUBLW  05
00F78:  BNZ   0F84
.................... 		c=0b10111; 
00F7A:  MOVLW  17
00F7C:  MOVLB  9
00F7E:  MOVWF  x03
.................... 	else if ( 6 == ch ) 
00F80:  BRA    0F98
00F82:  MOVLB  8
00F84:  MOVF   xFF,W
00F86:  SUBLW  06
00F88:  BNZ   0F92
.................... 		c=0b01111; 
00F8A:  MOVLW  0F
00F8C:  MOVLB  9
00F8E:  MOVWF  x03
.................... 	else 
00F90:  BRA    0F98
.................... 		c=0b11111; 
00F92:  MOVLW  1F
00F94:  MOVLB  9
00F96:  MOVWF  x03
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00F98:  CLRF   x02
00F9A:  MOVF   x02,W
00F9C:  SUBLW  04
00F9E:  BNC   0FB6
.................... 		output_low(MCP3208_CLK); 
00FA0:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00FA2:  BTFSC  x03.0
00FA4:  BRA    0FAA
00FA6:  BCF    F8B.5
00FA8:  BRA    0FAC
00FAA:  BSF    F8B.5
.................... 		c=c>>1; 
00FAC:  BCF    FD8.0
00FAE:  RRCF   x03,F
.................... 		output_high(MCP3208_CLK); 
00FB0:  BSF    F8B.3
.................... 	} 
00FB2:  INCF   x02,F
00FB4:  BRA    0F9A
....................  
....................  
.................... 	value=0; 
00FB6:  CLRF   x01
00FB8:  CLRF   x00
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00FBA:  CLRF   x02
00FBC:  MOVF   x02,W
00FBE:  SUBLW  0D
00FC0:  BNC   0FD8
.................... 		output_low(MCP3208_CLK); 
00FC2:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00FC4:  BTFSC  F82.4
00FC6:  BRA    0FCC
00FC8:  BCF    FD8.0
00FCA:  BRA    0FCE
00FCC:  BSF    FD8.0
00FCE:  RLCF   x00,F
00FD0:  RLCF   x01,F
.................... 		output_high(MCP3208_CLK); 
00FD2:  BSF    F8B.3
.................... 	} 
00FD4:  INCF   x02,F
00FD6:  BRA    0FBC
....................  
.................... 	bit_clear(value,13); 
00FD8:  BCF    x01.5
.................... 	bit_clear(value,12); 
00FDA:  BCF    x01.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00FDE:  MOVFF  900,01
00FE2:  MOVFF  901,02
.................... } 
00FE6:  MOVLB  0
00FE8:  GOTO   105A (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
01512:  MOVLB  A
01514:  CLRF   x01
01516:  MOVFF  918,A00
0151A:  CLRF   x03
0151C:  MOVLW  20
0151E:  MOVWF  x02
01520:  MOVLB  0
01522:  CALL   08F4
01526:  MOVFF  02,03
0152A:  MOVF   01,W
0152C:  ADDLW  CB
0152E:  MOVWF  01
01530:  MOVLW  00
01532:  ADDWFC 03,F
01534:  MOVFF  01,91C
01538:  MOVLB  9
0153A:  MOVFF  03,91D
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
0153E:  CLRF   x1A
01540:  CLRF   x19
.................... 	for( i = 0; i < 16 ; i++ ) { 
01542:  CLRF   x1B
01544:  MOVF   x1B,W
01546:  SUBLW  0F
01548:  BNC   156C
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
0154A:  BCF    FD8.0
0154C:  RLCF   x1B,W
0154E:  CLRF   03
01550:  ADDWF  x1C,W
01552:  MOVWF  FE9
01554:  MOVF   x1D,W
01556:  ADDWFC 03,W
01558:  MOVWF  FEA
0155A:  MOVFF  FEC,03
0155E:  MOVF   FED,F
01560:  MOVF   FEF,W
01562:  ADDWF  x19,F
01564:  MOVF   03,W
01566:  ADDWFC x1A,F
.................... 	} 
01568:  INCF   x1B,F
0156A:  BRA    1544
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
0156C:  MOVLW  08
0156E:  ADDWF  x19,W
01570:  MOVWF  x1E
01572:  MOVLW  00
01574:  ADDWFC x1A,W
01576:  MOVWF  x1F
01578:  RRCF   x1F,W
0157A:  MOVWF  03
0157C:  RRCF   x1E,W
0157E:  MOVWF  02
01580:  RRCF   03,F
01582:  RRCF   02,F
01584:  RRCF   03,F
01586:  RRCF   02,F
01588:  RRCF   03,F
0158A:  RRCF   02,F
0158C:  MOVLW  0F
0158E:  ANDWF  03,F
01590:  MOVFF  02,01
01594:  MOVFF  03,02
.................... } 
01598:  MOVLB  0
0159A:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00FEC:  MOVLB  1
00FEE:  INCF   xCB,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00FF0:  MOVF   xCB,W
00FF2:  SUBLW  0F
00FF4:  BC    0FF8
.................... 		current.adc_buffer_index=0; 
00FF6:  CLRF   xCB
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00FF8:  MOVLB  8
00FFA:  CLRF   xFC
00FFC:  MOVF   xFC,W
00FFE:  SUBLW  07
01000:  BNC   1090
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
01002:  MOVLB  A
01004:  CLRF   x01
01006:  MOVFF  8FC,A00
0100A:  CLRF   x03
0100C:  MOVLW  20
0100E:  MOVWF  x02
01010:  MOVLB  0
01012:  RCALL  08F4
01014:  MOVFF  02,03
01018:  MOVF   01,W
0101A:  ADDLW  34
0101C:  MOVLB  8
0101E:  MOVWF  xFD
01020:  MOVLW  00
01022:  ADDWFC 02,W
01024:  MOVWF  xFE
01026:  CLRF   03
01028:  MOVLB  1
0102A:  MOVFF  1CB,02
0102E:  BCF    FD8.0
01030:  RLCF   02,F
01032:  RLCF   03,F
01034:  MOVF   02,W
01036:  MOVLB  8
01038:  ADDWF  xFD,W
0103A:  MOVWF  01
0103C:  MOVF   xFE,W
0103E:  ADDWFC 03,F
01040:  MOVF   01,W
01042:  ADDLW  97
01044:  MOVWF  01
01046:  MOVLW  00
01048:  ADDWFC 03,F
0104A:  MOVFF  01,8FD
0104E:  MOVFF  03,8FE
01052:  MOVFF  8FC,8FF
01056:  MOVLB  0
01058:  BRA    0F20
0105A:  MOVFF  8FE,FEA
0105E:  MOVFF  8FD,FE9
01062:  MOVFF  02,FEC
01066:  MOVF   FED,F
01068:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
0106C:  CLRF   03
0106E:  MOVLB  8
01070:  MOVFF  8FC,02
01074:  BCF    FD8.0
01076:  RLCF   02,F
01078:  RLCF   03,F
0107A:  MOVF   02,W
0107C:  ADDLW  BB
0107E:  MOVWF  FE9
01080:  MOVLW  00
01082:  ADDWFC 03,W
01084:  MOVWF  FEA
01086:  CLRF   FEC
01088:  MOVF   FED,F
0108A:  CLRF   FEF
....................  
.................... 	} 
0108C:  INCF   xFC,F
0108E:  BRA    0FFC
.................... } 
01090:  MOVLB  0
01092:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00C52:  MOVF   x1D,W
00C54:  XORWF  x1E,W
00C56:  MOVWF  01
*
00CA4:  MOVF   x1D,W
00CA6:  XORWF  x1E,W
00CA8:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00BD2:  MOVLB  9
00BD4:  CLRF   x05
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BD6:  MOVFF  904,03
00BDA:  MOVF   x03,W
00BDC:  BTFSC  FD8.2
00BDE:  DECF   x04,F
00BE0:  DECF   x03,F
00BE2:  MOVWF  x06
00BE4:  MOVFF  03,907
00BE8:  MOVF   x06,F
00BEA:  BNZ   0BF0
00BEC:  MOVF   x07,F
00BEE:  BZ    0C64
.................... 		*data = read_eeprom( address++ ); 
00BF0:  MOVFF  902,03
00BF4:  MOVF   x01,W
00BF6:  MOVWF  FE9
00BF8:  MOVFF  03,FEA
00BFC:  MOVF   x00,W
00BFE:  MOVWF  03
00C00:  MOVLB  8
00C02:  MOVF   xFF,W
00C04:  INCF   xFF,F
00C06:  BTFSS  FD8.2
00C08:  BRA    0C10
00C0A:  MOVLB  9
00C0C:  INCF   x00,F
00C0E:  MOVLB  8
00C10:  MOVLB  9
00C12:  MOVWF  x08
00C14:  MOVFF  03,909
00C18:  MOVFF  FF2,90A
00C1C:  BCF    FF2.6
00C1E:  BCF    FF2.7
00C20:  MOVFF  909,FAA
00C24:  MOVFF  908,FA9
00C28:  BCF    FA6.6
00C2A:  BCF    FA6.7
00C2C:  BSF    FA6.0
00C2E:  MOVF   FA8,W
00C30:  BTFSC  x0A.6
00C32:  BSF    FF2.6
00C34:  BTFSC  x0A.7
00C36:  BSF    FF2.7
00C38:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00C3A:  MOVFF  902,03
00C3E:  MOVF   x01,W
00C40:  MOVWF  FE9
00C42:  MOVFF  03,FEA
00C46:  MOVFF  FEF,906
00C4A:  MOVFF  905,91D
00C4E:  MOVFF  906,91E
*
00C58:  MOVFF  01,905
.................... 		data++; 
00C5C:  INCF   x01,F
00C5E:  BTFSC  FD8.2
00C60:  INCF   x02,F
.................... 	} 
00C62:  BRA    0BD6
.................... 	return crc; 
00C64:  MOVFF  905,01
.................... } 
00C68:  MOVLB  0
00C6A:  GOTO   0E52 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00C6E:  MOVLB  9
00C70:  CLRF   x1B
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00C72:  MOVFF  91A,03
00C76:  MOVF   x19,W
00C78:  BTFSC  FD8.2
00C7A:  DECF   x1A,F
00C7C:  DECF   x19,F
00C7E:  MOVWF  x1C
00C80:  MOVFF  03,91D
00C84:  MOVF   x1C,F
00C86:  BNZ   0C8C
00C88:  MOVF   x1D,F
00C8A:  BZ    0D0A
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00C8C:  MOVFF  918,03
00C90:  MOVF   x17,W
00C92:  MOVWF  FE9
00C94:  MOVFF  03,FEA
00C98:  MOVFF  FEF,91C
00C9C:  MOVFF  91B,91D
00CA0:  MOVFF  91C,91E
*
00CAA:  MOVFF  01,91B
.................... 		write_eeprom( address++, *data++ ); 
00CAE:  MOVF   x16,W
00CB0:  MOVWF  03
00CB2:  MOVF   x15,W
00CB4:  INCF   x15,F
00CB6:  BTFSC  FD8.2
00CB8:  INCF   x16,F
00CBA:  MOVWF  x1C
00CBC:  MOVFF  03,91D
00CC0:  MOVF   x18,W
00CC2:  MOVWF  03
00CC4:  MOVF   x17,W
00CC6:  INCF   x17,F
00CC8:  BTFSC  FD8.2
00CCA:  INCF   x18,F
00CCC:  MOVWF  FE9
00CCE:  MOVFF  03,FEA
00CD2:  MOVFF  FEF,91E
00CD6:  MOVFF  91D,FAA
00CDA:  MOVFF  91C,FA9
00CDE:  MOVFF  91E,FA8
00CE2:  BCF    FA6.6
00CE4:  BCF    FA6.7
00CE6:  BSF    FA6.2
00CE8:  MOVF   FF2,W
00CEA:  MOVWF  00
00CEC:  BCF    FF2.6
00CEE:  BCF    FF2.7
00CF0:  MOVLB  F
00CF2:  MOVLW  55
00CF4:  MOVWF  FA7
00CF6:  MOVLW  AA
00CF8:  MOVWF  FA7
00CFA:  BSF    FA6.1
00CFC:  BTFSC  FA6.1
00CFE:  BRA    0CFC
00D00:  BCF    FA6.2
00D02:  MOVF   00,W
00D04:  IORWF  FF2,F
.................... 	} 
00D06:  MOVLB  9
00D08:  BRA    0C72
....................  
.................... 	return crc; 
00D0A:  MOVFF  91B,01
.................... } 
00D0E:  MOVLB  0
00D10:  GOTO   0D34 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00D14:  MOVLB  9
00D16:  CLRF   x14
00D18:  MOVLW  36
00D1A:  MOVWF  x13
00D1C:  CLRF   x16
00D1E:  MOVLW  02
00D20:  MOVWF  x15
00D22:  MOVFF  914,918
00D26:  MOVFF  913,917
00D2A:  CLRF   x1A
00D2C:  MOVLW  61
00D2E:  MOVWF  x19
00D30:  MOVLB  0
00D32:  BRA    0C6E
00D34:  MOVFF  01,912
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00D38:  CLRF   FAA
00D3A:  CLRF   FA9
00D3C:  MOVFF  912,FA8
00D40:  BCF    FA6.6
00D42:  BCF    FA6.7
00D44:  BSF    FA6.2
00D46:  MOVF   FF2,W
00D48:  MOVWF  00
00D4A:  BCF    FF2.6
00D4C:  BCF    FF2.7
00D4E:  MOVLB  F
00D50:  MOVLW  55
00D52:  MOVWF  FA7
00D54:  MOVLW  AA
00D56:  MOVWF  FA7
00D58:  BSF    FA6.1
00D5A:  BTFSC  FA6.1
00D5C:  BRA    0D5A
00D5E:  BCF    FA6.2
00D60:  MOVF   00,W
00D62:  IORWF  FF2,F
.................... } 
00D64:  MOVLB  0
00D66:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00D68:  MOVLW  96
00D6A:  MOVLB  1
00D6C:  MOVWF  xF8
....................  
.................... 	config.modbus_address=38; 
00D6E:  MOVLW  26
00D70:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00D72:  MOVLW  03
00D74:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00D76:  MOVLW  02
00D78:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00D7A:  MOVLW  50
00D7C:  MOVWF  3A
.................... 	config.serial_number=9876; 
00D7E:  MOVLW  26
00D80:  MOVWF  3C
00D82:  MOVLW  94
00D84:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00D86:  CLRF   3E
00D88:  MOVLW  14
00D8A:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00D8C:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00D8E:  MOVLW  02
00D90:  MOVWF  41
00D92:  MOVLW  76
00D94:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00D96:  CLRF   43
00D98:  MOVLW  02
00D9A:  MOVWF  42
.................... 	config.power_startup=0; 
00D9C:  CLRF   44
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00D9E:  CLRF   FEA
00DA0:  MOVLW  4F
00DA2:  MOVWF  FE9
00DA4:  CLRF   00
00DA6:  CLRF   02
00DA8:  MOVLW  48
00DAA:  MOVWF  01
00DAC:  MOVLB  0
00DAE:  RCALL  0916
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00DB0:  CLRF   FEA
00DB2:  MOVLW  4F
00DB4:  MOVWF  FE9
00DB6:  MOVLW  00
00DB8:  CALL   0188
00DBC:  TBLRD*-
00DBE:  TBLRD*+
00DC0:  MOVF   FF5,W
00DC2:  MOVWF  FEE
00DC4:  IORLW  00
00DC6:  BNZ   0DBE
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00DC8:  CLRF   FEA
00DCA:  MOVLW  55
00DCC:  MOVWF  FE9
00DCE:  MOVLW  00
00DD0:  CALL   01A0
00DD4:  TBLRD*-
00DD6:  TBLRD*+
00DD8:  MOVF   FF5,W
00DDA:  MOVWF  FEE
00DDC:  IORLW  00
00DDE:  BNZ   0DD6
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00DE0:  CLRF   FEA
00DE2:  MOVLW  5B
00DE4:  MOVWF  FE9
00DE6:  MOVLW  00
00DE8:  CALL   01B8
00DEC:  TBLRD*-
00DEE:  TBLRD*+
00DF0:  MOVF   FF5,W
00DF2:  MOVWF  FEE
00DF4:  IORLW  00
00DF6:  BNZ   0DEE
.................... 	strcpy(config.nmea0183_sentence[3],"$WIMDA"); 
00DF8:  CLRF   FEA
00DFA:  MOVLW  61
00DFC:  MOVWF  FE9
00DFE:  MOVLW  00
00E00:  CALL   01D0
00E04:  TBLRD*-
00E06:  TBLRD*+
00E08:  MOVF   FF5,W
00E0A:  MOVWF  FEE
00E0C:  IORLW  00
00E0E:  BNZ   0E06
....................  
.................... 	strcpy(config.nmea0183_sentence[6],"*"); /* put anything in */ 
00E10:  CLRF   FEA
00E12:  MOVLW  73
00E14:  MOVWF  FE9
00E16:  MOVLW  00
00E18:  CALL   01E8
00E1C:  TBLRD*-
00E1E:  TBLRD*+
00E20:  MOVF   FF5,W
00E22:  MOVWF  FEE
00E24:  IORLW  00
00E26:  BNZ   0E1E
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00E28:  RCALL  0D14
....................  
.................... } 
00E2A:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00E2C:  MOVLB  8
00E2E:  CLRF   xFE
00E30:  MOVLW  36
00E32:  MOVWF  xFD
00E34:  MOVLB  9
00E36:  CLRF   x00
00E38:  MOVLW  02
00E3A:  MOVLB  8
00E3C:  MOVWF  xFF
00E3E:  MOVFF  8FE,902
00E42:  MOVFF  8FD,901
00E46:  MOVLB  9
00E48:  CLRF   x04
00E4A:  MOVLW  61
00E4C:  MOVWF  x03
00E4E:  MOVLB  0
00E50:  BRA    0BD2
00E52:  MOVFF  01,8FC
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00E56:  MOVFF  FF2,8FD
00E5A:  BCF    FF2.6
00E5C:  BCF    FF2.7
00E5E:  CLRF   FAA
00E60:  CLRF   FA9
00E62:  BCF    FA6.6
00E64:  BCF    FA6.7
00E66:  BSF    FA6.0
00E68:  MOVF   FA8,W
00E6A:  MOVLB  8
00E6C:  BTFSC  xFD.6
00E6E:  BSF    FF2.6
00E70:  BTFSC  xFD.7
00E72:  BSF    FF2.7
00E74:  SUBWF  xFC,W
00E76:  BZ    0E7E
.................... 		write_default_param_file(); 
00E78:  MOVLB  0
00E7A:  RCALL  0D68
00E7C:  MOVLB  8
.................... 	} 
.................... } 
00E7E:  MOVLB  0
00E80:  GOTO   32B2 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
.................... } 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00F06:  BTFSS  F9E.5
00F08:  BRA    0F0E
.................... 		fgetc(STREAM_PI); 
00F0A:  RCALL  0780
.................... 	} 
00F0C:  BRA    0F06
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00F0E:  BSF    F9D.5
.................... } 
00F10:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00F12:  RCALL  0F06
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_8 | T0_8_BIT); /* 0.683 ms @ 12 MHz. Use fosc/4 not fosc */ 
00F14:  MOVLW  C2
00F16:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00F18:  MOVLW  C0
00F1A:  IORWF  FF2,F
.................... } 
00F1C:  GOTO   32C8 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0041A:  BCF    FF2.5
.................... 	if (enable) { 
0041C:  MOVLB  A
0041E:  MOVF   x12,F
00420:  BZ    042A
.................... 		set_timer0(0); 
00422:  CLRF   FD7
00424:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00426:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00428:  BSF    FF2.5
.................... 	} 
.................... } 
0042A:  MOVLB  0
0042C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0042E:  MOVLB  7
00430:  MOVF   xE9,W
00432:  SUBLW  02
00434:  BNZ   044A
00436:  MOVF   xEA,F
00438:  BNZ   044A
0043A:  MOVF   xEB,F
0043C:  BNZ   044A
0043E:  BTFSC  xE8.0
00440:  BRA    044A
....................    { 
....................       modbus_rx.len-=2; 
00442:  MOVLW  02
00444:  SUBWF  xED,F
....................       modbus_serial_new=TRUE; 
00446:  BSF    xE8.0
....................    } 
....................    else 
00448:  BRA    044C
....................       modbus_serial_new=FALSE; 
0044A:  BCF    xE8.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0044C:  SETF   xEB
0044E:  SETF   xEA
....................    modbus_serial_state=MODBUS_GETADDY; 
00450:  CLRF   xE9
....................    modbus_enable_timeout(FALSE); 
00452:  MOVLB  A
00454:  CLRF   x12
00456:  MOVLB  0
00458:  RCALL  041A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0045A:  BCF    FF2.2
0045C:  GOTO   0094
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00796:  MOVLB  7
00798:  MOVF   xEB,W
0079A:  MOVLB  A
0079C:  XORWF  x12,W
0079E:  MOVWF  x13
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
007A0:  CLRF   03
007A2:  MOVF   x13,W
007A4:  MOVLB  0
007A6:  RCALL  01FA
007A8:  MOVWF  01
007AA:  MOVLB  7
007AC:  MOVF   xEA,W
007AE:  XORWF  01,W
007B0:  MOVWF  xEB
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
007B2:  CLRF   03
007B4:  MOVLB  A
007B6:  MOVF   x13,W
007B8:  MOVLB  0
007BA:  RCALL  030A
007BC:  MOVFF  FE8,7EA
.................... } 
007C0:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	timers.rda_tx_buff[timers.rda_tx_length]=c; 
*
01418:  MOVLW  01
0141A:  MOVLB  4
0141C:  ADDWF  x01,W
0141E:  MOVWF  FE9
01420:  MOVLW  03
01422:  MOVWF  FEA
01424:  BTFSC  FD8.0
01426:  INCF   FEA,F
01428:  MOVFF  912,FEF
.................... 	timers.rda_tx_length++; 
0142C:  INCF   x01,F
0142E:  CLRF   19
01430:  BTFSC  FF2.6
01432:  BSF    19.6
01434:  BCF    FF2.6
01436:  BTFSC  FF2.7
01438:  BSF    19.7
0143A:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
0143C:  MOVFF  912,A12
01440:  MOVLB  0
01442:  CALL   0796
01446:  BTFSC  19.6
01448:  BSF    FF2.6
0144A:  BTFSC  19.7
0144C:  BSF    FF2.7
.................... } 
0144E:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) { 
.................... 	/* reset out transmit buffer */ 
.................... 	timers.rda_tx_length=0; 
01450:  MOVLB  4
01452:  CLRF   x01
.................... 	timers.rda_tx_pos=0; 
01454:  CLRF   x02
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01456:  MOVLB  7
01458:  SETF   xEB
0145A:  SETF   xEA
.................... 	modbus_serial_new=FALSE; 
0145C:  BCF    xE8.0
....................  
.................... 	modbus_serial_putc(to); 
0145E:  MOVFF  910,912
01462:  MOVLB  0
01464:  RCALL  1418
.................... 	modbus_serial_putc(func); 
01466:  MOVFF  911,912
0146A:  RCALL  1418
.................... } 
0146C:  RETURN 0
....................  
.................... void modbus_serial_send_stop() { 
.................... 	int8 crc_low, crc_high; 
....................  
.................... 	crc_high=modbus_serial_crc.b[1]; 
0146E:  MOVFF  7EB,911
.................... 	crc_low=modbus_serial_crc.b[0]; 
01472:  MOVFF  7EA,910
....................  
.................... 	modbus_serial_putc(crc_high); 
01476:  MOVFF  911,912
0147A:  RCALL  1418
.................... 	modbus_serial_putc(crc_low); 
0147C:  MOVFF  910,912
01480:  RCALL  1418
....................  
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01482:  MOVLB  7
01484:  SETF   xEB
01486:  SETF   xEA
....................  
.................... 	/* ready to transmit from buffer flag set. Elsewhere we start sending */ 
.................... 	timers.now_rda_tx_ready=1; 
01488:  MOVLB  4
0148A:  BSF    x03.0
.................... } 
0148C:  MOVLB  0
0148E:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
012B8:  MOVLB  7
012BA:  BTFSC  xE8.0
012BC:  BRA    12C6
....................       return FALSE; 
012BE:  MOVLW  00
012C0:  MOVWF  01
012C2:  BRA    12D8
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
012C4:  BRA    12D2
012C6:  BTFSS  xEE.7
012C8:  BRA    12D2
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
012CA:  MOVFF  7F0,7EF
....................       modbus_rx.len = 1; 
012CE:  MOVLW  01
012D0:  MOVWF  xED
....................    } 
....................    modbus_serial_new=FALSE; 
012D2:  BCF    xE8.0
....................    return TRUE; 
012D4:  MOVLW  01
012D6:  MOVWF  01
.................... } 
012D8:  MOVLB  0
012DA:  GOTO   2B5E (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02ACA:  MOVFF  908,910
02ACE:  MOVLW  06
02AD0:  MOVLB  9
02AD2:  MOVWF  x11
02AD4:  MOVLB  0
02AD6:  CALL   1450
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02ADA:  MOVFF  90A,90D
02ADE:  MOVFF  90A,912
02AE2:  CALL   1418
....................    modbus_serial_putc(make8(reg_address,0)); 
02AE6:  MOVFF  909,90D
02AEA:  MOVFF  909,912
02AEE:  CALL   1418
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02AF2:  MOVFF  90C,90D
02AF6:  MOVFF  90C,912
02AFA:  CALL   1418
....................    modbus_serial_putc(make8(reg_value,0)); 
02AFE:  MOVFF  90B,90D
02B02:  MOVFF  90B,912
02B06:  CALL   1418
....................  
....................    modbus_serial_send_stop(); 
02B0A:  CALL   146E
.................... } 
02B0E:  GOTO   2D4A (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02B12:  MOVFF  906,910
02B16:  MOVLW  10
02B18:  MOVLB  9
02B1A:  MOVWF  x11
02B1C:  MOVLB  0
02B1E:  CALL   1450
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02B22:  MOVFF  908,90B
02B26:  MOVFF  908,912
02B2A:  CALL   1418
....................    modbus_serial_putc(make8(start_address,0)); 
02B2E:  MOVFF  907,90B
02B32:  MOVFF  907,912
02B36:  CALL   1418
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02B3A:  MOVFF  90A,90B
02B3E:  MOVFF  90A,912
02B42:  CALL   1418
....................    modbus_serial_putc(make8(quantity,0)); 
02B46:  MOVFF  909,90B
02B4A:  MOVFF  909,912
02B4E:  CALL   1418
....................  
....................    modbus_serial_send_stop(); 
02B52:  CALL   146E
.................... } 
02B56:  GOTO   2E1C (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01490:  MOVLB  9
01492:  MOVF   x07,W
01494:  IORLW  80
01496:  MOVWF  x0A
01498:  MOVFF  908,90B
0149C:  MOVFF  906,910
014A0:  MOVWF  x11
014A2:  MOVLB  0
014A4:  RCALL  1450
....................    modbus_serial_putc(error); 
014A6:  MOVFF  909,912
014AA:  RCALL  1418
....................    modbus_serial_send_stop(); 
014AC:  RCALL  146E
.................... } 
014AE:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          54 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1013 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
.................... #define MIN_NMEA0183_META_REGISTER   6500 
.................... #define MAX_NMEA0183_META_REGISTER   MIN_NMEA0183_META_REGISTER + N_NMEA0183_SENTENCES*2 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
01600:  MOVLB  1
01602:  CLRF   xCD
01604:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
01606:  CLRF   xCF
01608:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
0160A:  CLRF   xD1
0160C:  CLRF   xD0
.................... } 
0160E:  MOVLB  0
01610:  GOTO   233E (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0159C:  BCF    FF2.6
0159E:  BCF    FF2.7
015A0:  BTFSC  FF2.7
015A2:  BRA    159E
....................  
.................... 	current.pulse_count[0]=0; 
015A4:  CLRF   xAA
015A6:  CLRF   xA9
.................... 	current.pulse_count[1]=0; 
015A8:  CLRF   xAC
015AA:  CLRF   xAB
.................... 	current.pulse_count[2]=0; 
015AC:  CLRF   xAE
015AE:  CLRF   xAD
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
015B0:  SETF   x9E
015B2:  SETF   x9D
.................... 	current.pulse_min_period[1]=65535; 
015B4:  SETF   xA0
015B6:  SETF   x9F
.................... 	current.pulse_min_period[2]=65535; 
015B8:  SETF   xA2
015BA:  SETF   xA1
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
015BC:  CLRF   xA4
015BE:  CLRF   xA3
.................... 	current.pulse_max_period[1]=0; 
015C0:  CLRF   xA6
015C2:  CLRF   xA5
.................... 	current.pulse_max_period[2]=0; 
015C4:  CLRF   xA8
015C6:  CLRF   xA7
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
015C8:  MOVLB  1
015CA:  CLRF   xD7
015CC:  CLRF   xD6
....................  
.................... 	enable_interrupts(GLOBAL); 
015CE:  MOVLW  C0
015D0:  IORWF  FF2,F
.................... } 
015D2:  MOVLB  0
015D4:  GOTO   22EE (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
015D8:  BCF    FF2.6
015DA:  BCF    FF2.7
015DC:  BTFSC  FF2.7
015DE:  BRA    15DA
.................... 	current.pulse_sum[0]=0; 
015E0:  CLRF   xB2
015E2:  CLRF   xB1
015E4:  CLRF   xB0
015E6:  CLRF   xAF
.................... 	current.pulse_sum[1]=0; 
015E8:  CLRF   xB6
015EA:  CLRF   xB5
015EC:  CLRF   xB4
015EE:  CLRF   xB3
.................... 	current.pulse_sum[2]=0; 
015F0:  CLRF   xBA
015F2:  CLRF   xB9
015F4:  CLRF   xB8
015F6:  CLRF   xB7
.................... 	enable_interrupts(GLOBAL); 
015F8:  MOVLW  C0
015FA:  IORWF  FF2,F
.................... } 
015FC:  GOTO   22FE (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
014B0:  BCF    FF2.6
014B2:  BCF    FF2.7
014B4:  BTFSC  FF2.7
014B6:  BRA    14B2
.................... 	l=current.pulse_sum[ch]; 
014B8:  MOVLB  A
014BA:  CLRF   x01
014BC:  MOVFF  918,A00
014C0:  CLRF   x03
014C2:  MOVLW  04
014C4:  MOVWF  x02
014C6:  MOVLB  0
014C8:  CALL   08F4
014CC:  MOVFF  02,03
014D0:  MOVF   01,W
014D2:  ADDLW  AF
014D4:  MOVWF  FE9
014D6:  MOVLW  00
014D8:  ADDWFC 02,W
014DA:  MOVWF  FEA
014DC:  MOVFF  FEF,00
014E0:  MOVFF  FEC,01
014E4:  MOVFF  FEC,02
014E8:  MOVFF  FEC,03
014EC:  MOVFF  03,91C
014F0:  MOVFF  02,91B
014F4:  MOVFF  01,91A
014F8:  MOVFF  00,919
.................... 	enable_interrupts(GLOBAL); 
014FC:  MOVLW  C0
014FE:  IORWF  FF2,F
....................  
.................... 	return l; 
01500:  MOVFF  919,00
01504:  MOVFF  91A,01
01508:  MOVFF  91B,02
0150C:  MOVFF  91C,03
.................... } 
01510:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01614:  MOVLB  9
01616:  MOVF   x13,W
01618:  SUBLW  06
0161A:  BC    1670
0161C:  XORLW  FF
0161E:  BNZ   1626
01620:  MOVF   x12,W
01622:  SUBLW  CF
01624:  BC    1670
01626:  MOVF   x13,W
01628:  SUBLW  09
0162A:  BNC   1670
0162C:  BNZ   1634
0162E:  MOVF   x12,W
01630:  SUBLW  CF
01632:  BNC   1670
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01634:  MOVLW  D0
01636:  SUBWF  x12,W
01638:  MOVWF  x18
0163A:  MOVLW  07
0163C:  SUBWFB x13,W
0163E:  MOVWF  x19
01640:  MOVLW  02
01642:  ADDWF  x19,F
01644:  MOVFF  FF2,91A
01648:  BCF    FF2.6
0164A:  BCF    FF2.7
0164C:  MOVFF  919,FAA
01650:  MOVFF  918,FA9
01654:  BCF    FA6.6
01656:  BCF    FA6.7
01658:  BSF    FA6.0
0165A:  MOVF   FA8,W
0165C:  BTFSC  x1A.6
0165E:  BSF    FF2.6
01660:  BTFSC  x1A.7
01662:  BSF    FF2.7
01664:  CLRF   03
01666:  MOVWF  01
01668:  MOVF   03,W
0166A:  MOVWF  02
0166C:  GOTO   265C
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
01670:  MOVF   x13,W
01672:  SUBLW  03
01674:  BC    16F4
01676:  XORLW  FF
01678:  BNZ   1680
0167A:  MOVF   x12,W
0167C:  SUBLW  4B
0167E:  BC    16F4
01680:  MOVF   x13,W
01682:  SUBLW  04
01684:  BNC   16F4
01686:  BNZ   168E
01688:  MOVF   x12,W
0168A:  SUBLW  93
0168C:  BNC   16F4
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0168E:  MOVLW  4C
01690:  SUBWF  x12,W
01692:  MOVWF  x14
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01694:  MOVFF  914,918
01698:  MOVLW  06
0169A:  MOVWF  x19
0169C:  MOVLB  0
0169E:  CALL   0B24
016A2:  MOVFF  00,915
.................... 		n = n / 6; /* number of sentence */ 
016A6:  MOVFF  914,918
016AA:  MOVLW  06
016AC:  MOVLB  9
016AE:  MOVWF  x19
016B0:  MOVLB  0
016B2:  CALL   0B24
016B6:  MOVFF  01,914
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
016BA:  MOVLB  9
016BC:  MOVF   x14,W
016BE:  MULLW  06
016C0:  MOVF   FF3,W
016C2:  CLRF   03
016C4:  ADDLW  19
016C6:  MOVWF  x18
016C8:  MOVLW  00
016CA:  ADDWFC 03,W
016CC:  MOVWF  x19
016CE:  CLRF   03
016D0:  MOVF   x15,W
016D2:  ADDWF  x18,W
016D4:  MOVWF  01
016D6:  MOVF   x19,W
016D8:  ADDWFC 03,F
016DA:  MOVF   01,W
016DC:  ADDLW  36
016DE:  MOVWF  FE9
016E0:  MOVLW  00
016E2:  ADDWFC 03,W
016E4:  MOVWF  FEA
016E6:  MOVF   FEF,W
016E8:  CLRF   03
016EA:  MOVWF  01
016EC:  MOVFF  03,02
016F0:  GOTO   265C
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
016F4:  MOVF   x13,W
016F6:  SUBLW  12
016F8:  BC    173A
016FA:  XORLW  FF
016FC:  BNZ   1704
016FE:  MOVF   x12,W
01700:  SUBLW  87
01702:  BC    173A
01704:  MOVF   x13,W
01706:  SUBLW  17
01708:  BNC   173A
0170A:  BNZ   1712
0170C:  MOVF   x12,W
0170E:  SUBLW  47
01710:  BNC   173A
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
01712:  MOVLW  88
01714:  SUBWF  x12,F
01716:  MOVLW  13
01718:  SUBWFB x13,F
....................  
....................  		p  = nmea.sentence[0]; 
0171A:  MOVLW  04
0171C:  MOVWF  x17
0171E:  MOVWF  x16
.................... 		return (int16) p[addr]; 
01720:  MOVF   x16,W
01722:  ADDWF  x12,W
01724:  MOVWF  FE9
01726:  MOVF   x17,W
01728:  ADDWFC x13,W
0172A:  MOVWF  FEA
0172C:  MOVF   FEF,W
0172E:  CLRF   03
01730:  MOVWF  01
01732:  MOVFF  03,02
01736:  GOTO   265C
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
0173A:  MOVF   x13,W
0173C:  SUBLW  16
0173E:  BC    17A8
01740:  XORLW  FF
01742:  BNZ   174A
01744:  MOVF   x12,W
01746:  SUBLW  6F
01748:  BC    17A8
0174A:  MOVF   x13,W
0174C:  SUBLW  19
0174E:  BNC   17A8
01750:  BNZ   1758
01752:  MOVF   x12,W
01754:  SUBLW  4F
01756:  BNC   17A8
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
01758:  MOVLW  70
0175A:  SUBWF  x12,F
0175C:  MOVLW  17
0175E:  SUBWFB x13,F
.................... 		addr = addr * 2; 
01760:  BCF    FD8.0
01762:  RLCF   x12,F
01764:  RLCF   x13,F
....................  
....................  		p  = nmea.sentence[0]; 
01766:  MOVLW  04
01768:  MOVWF  x17
0176A:  MOVWF  x16
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0176C:  MOVF   x16,W
0176E:  ADDWF  x12,W
01770:  MOVWF  FE9
01772:  MOVF   x17,W
01774:  ADDWFC x13,W
01776:  MOVWF  FEA
01778:  MOVFF  FEF,918
0177C:  MOVLW  01
0177E:  ADDWF  x12,W
01780:  MOVWF  x19
01782:  MOVLW  00
01784:  ADDWFC x13,W
01786:  MOVWF  x1A
01788:  MOVF   x16,W
0178A:  ADDWF  x19,W
0178C:  MOVWF  FE9
0178E:  MOVF   x17,W
01790:  ADDWFC x1A,W
01792:  MOVWF  FEA
01794:  MOVFF  FEF,91B
01798:  MOVFF  918,03
0179C:  MOVFF  91B,01
017A0:  MOVFF  918,02
017A4:  GOTO   265C
.................... 	} 
....................  
....................  
.................... 	switch ( addr ) { 
017A8:  MOVF   x12,W
017AA:  MOVWF  00
017AC:  MOVF   x13,W
017AE:  MOVWF  03
017B0:  MOVF   03,W
017B2:  BNZ   17C0
017B4:  MOVF   00,F
017B6:  MOVLB  0
017B8:  BTFSC  FD8.2
017BA:  GOTO   1E88
017BE:  MOVLB  9
017C0:  MOVF   03,W
017C2:  BNZ   17D2
017C4:  MOVLW  01
017C6:  SUBWF  00,W
017C8:  MOVLB  0
017CA:  BTFSC  FD8.2
017CC:  GOTO   1E98
017D0:  MOVLB  9
017D2:  MOVF   03,W
017D4:  BNZ   17E4
017D6:  MOVLW  02
017D8:  SUBWF  00,W
017DA:  MOVLB  0
017DC:  BTFSC  FD8.2
017DE:  GOTO   1EA8
017E2:  MOVLB  9
017E4:  MOVF   03,W
017E6:  BNZ   17F6
017E8:  MOVLW  03
017EA:  SUBWF  00,W
017EC:  MOVLB  0
017EE:  BTFSC  FD8.2
017F0:  GOTO   1EB8
017F4:  MOVLB  9
017F6:  MOVF   03,W
017F8:  BNZ   1808
017FA:  MOVLW  04
017FC:  SUBWF  00,W
017FE:  MOVLB  0
01800:  BTFSC  FD8.2
01802:  GOTO   1EC8
01806:  MOVLB  9
01808:  MOVF   03,W
0180A:  BNZ   181A
0180C:  MOVLW  05
0180E:  SUBWF  00,W
01810:  MOVLB  0
01812:  BTFSC  FD8.2
01814:  GOTO   1EF4
01818:  MOVLB  9
0181A:  MOVF   03,W
0181C:  BNZ   182C
0181E:  MOVLW  06
01820:  SUBWF  00,W
01822:  MOVLB  0
01824:  BTFSC  FD8.2
01826:  GOTO   1F06
0182A:  MOVLB  9
0182C:  MOVF   03,W
0182E:  BNZ   183E
01830:  MOVLW  07
01832:  SUBWF  00,W
01834:  MOVLB  0
01836:  BTFSC  FD8.2
01838:  GOTO   1F16
0183C:  MOVLB  9
0183E:  MOVF   03,W
01840:  BNZ   1850
01842:  MOVLW  08
01844:  SUBWF  00,W
01846:  MOVLB  0
01848:  BTFSC  FD8.2
0184A:  GOTO   1F26
0184E:  MOVLB  9
01850:  MOVF   03,W
01852:  BNZ   1862
01854:  MOVLW  09
01856:  SUBWF  00,W
01858:  MOVLB  0
0185A:  BTFSC  FD8.2
0185C:  GOTO   1F34
01860:  MOVLB  9
01862:  MOVF   03,W
01864:  BNZ   1874
01866:  MOVLW  0A
01868:  SUBWF  00,W
0186A:  MOVLB  0
0186C:  BTFSC  FD8.2
0186E:  GOTO   1F42
01872:  MOVLB  9
01874:  MOVF   03,W
01876:  BNZ   1886
01878:  MOVLW  0B
0187A:  SUBWF  00,W
0187C:  MOVLB  0
0187E:  BTFSC  FD8.2
01880:  GOTO   1F6E
01884:  MOVLB  9
01886:  MOVF   03,W
01888:  BNZ   1898
0188A:  MOVLW  0C
0188C:  SUBWF  00,W
0188E:  MOVLB  0
01890:  BTFSC  FD8.2
01892:  GOTO   1F7E
01896:  MOVLB  9
01898:  MOVF   03,W
0189A:  BNZ   18AA
0189C:  MOVLW  0D
0189E:  SUBWF  00,W
018A0:  MOVLB  0
018A2:  BTFSC  FD8.2
018A4:  GOTO   1F8C
018A8:  MOVLB  9
018AA:  MOVF   03,W
018AC:  BNZ   18BC
018AE:  MOVLW  0E
018B0:  SUBWF  00,W
018B2:  MOVLB  0
018B4:  BTFSC  FD8.2
018B6:  GOTO   1F9A
018BA:  MOVLB  9
018BC:  MOVF   03,W
018BE:  BNZ   18CE
018C0:  MOVLW  0F
018C2:  SUBWF  00,W
018C4:  MOVLB  0
018C6:  BTFSC  FD8.2
018C8:  GOTO   1FA8
018CC:  MOVLB  9
018CE:  MOVF   03,W
018D0:  BNZ   18E0
018D2:  MOVLW  10
018D4:  SUBWF  00,W
018D6:  MOVLB  0
018D8:  BTFSC  FD8.2
018DA:  GOTO   1FB6
018DE:  MOVLB  9
018E0:  MOVF   03,W
018E2:  BNZ   18F2
018E4:  MOVLW  11
018E6:  SUBWF  00,W
018E8:  MOVLB  0
018EA:  BTFSC  FD8.2
018EC:  GOTO   1FE2
018F0:  MOVLB  9
018F2:  MOVF   03,W
018F4:  BNZ   1904
018F6:  MOVLW  12
018F8:  SUBWF  00,W
018FA:  MOVLB  0
018FC:  BTFSC  FD8.2
018FE:  GOTO   1FF2
01902:  MOVLB  9
01904:  MOVF   03,W
01906:  BNZ   1916
01908:  MOVLW  13
0190A:  SUBWF  00,W
0190C:  MOVLB  0
0190E:  BTFSC  FD8.2
01910:  GOTO   2020
01914:  MOVLB  9
01916:  MOVF   03,W
01918:  BNZ   1928
0191A:  MOVLW  14
0191C:  SUBWF  00,W
0191E:  MOVLB  0
01920:  BTFSC  FD8.2
01922:  GOTO   2038
01926:  MOVLB  9
01928:  MOVF   03,W
0192A:  BNZ   193A
0192C:  MOVLW  15
0192E:  SUBWF  00,W
01930:  MOVLB  0
01932:  BTFSC  FD8.2
01934:  GOTO   2046
01938:  MOVLB  9
0193A:  MOVF   03,W
0193C:  BNZ   194C
0193E:  MOVLW  16
01940:  SUBWF  00,W
01942:  MOVLB  0
01944:  BTFSC  FD8.2
01946:  GOTO   2074
0194A:  MOVLB  9
0194C:  MOVF   03,W
0194E:  BNZ   195E
01950:  MOVLW  17
01952:  SUBWF  00,W
01954:  MOVLB  0
01956:  BTFSC  FD8.2
01958:  GOTO   208E
0195C:  MOVLB  9
0195E:  MOVF   03,W
01960:  BNZ   1970
01962:  MOVLW  18
01964:  SUBWF  00,W
01966:  MOVLB  0
01968:  BTFSC  FD8.2
0196A:  GOTO   209C
0196E:  MOVLB  9
01970:  MOVF   03,W
01972:  BNZ   1982
01974:  MOVLW  19
01976:  SUBWF  00,W
01978:  MOVLB  0
0197A:  BTFSC  FD8.2
0197C:  GOTO   20CA
01980:  MOVLB  9
01982:  MOVF   03,W
01984:  BNZ   1994
01986:  MOVLW  1A
01988:  SUBWF  00,W
0198A:  MOVLB  0
0198C:  BTFSC  FD8.2
0198E:  GOTO   20E4
01992:  MOVLB  9
01994:  MOVF   03,W
01996:  BNZ   19A6
01998:  MOVLW  1B
0199A:  SUBWF  00,W
0199C:  MOVLB  0
0199E:  BTFSC  FD8.2
019A0:  GOTO   20F2
019A4:  MOVLB  9
019A6:  MOVF   03,W
019A8:  BNZ   19B8
019AA:  MOVLW  1C
019AC:  SUBWF  00,W
019AE:  MOVLB  0
019B0:  BTFSC  FD8.2
019B2:  GOTO   2120
019B6:  MOVLB  9
019B8:  MOVF   03,W
019BA:  BNZ   19CA
019BC:  MOVLW  1D
019BE:  SUBWF  00,W
019C0:  MOVLB  0
019C2:  BTFSC  FD8.2
019C4:  GOTO   213A
019C8:  MOVLB  9
019CA:  MOVF   03,W
019CC:  BNZ   19DC
019CE:  MOVLW  1E
019D0:  SUBWF  00,W
019D2:  MOVLB  0
019D4:  BTFSC  FD8.2
019D6:  GOTO   2148
019DA:  MOVLB  9
019DC:  MOVF   03,W
019DE:  BNZ   19EE
019E0:  MOVLW  1F
019E2:  SUBWF  00,W
019E4:  MOVLB  0
019E6:  BTFSC  FD8.2
019E8:  GOTO   2176
019EC:  MOVLB  9
019EE:  MOVF   03,W
019F0:  BNZ   1A00
019F2:  MOVLW  20
019F4:  SUBWF  00,W
019F6:  MOVLB  0
019F8:  BTFSC  FD8.2
019FA:  GOTO   2190
019FE:  MOVLB  9
01A00:  MOVF   03,W
01A02:  BNZ   1A12
01A04:  MOVLW  21
01A06:  SUBWF  00,W
01A08:  MOVLB  0
01A0A:  BTFSC  FD8.2
01A0C:  GOTO   219E
01A10:  MOVLB  9
01A12:  MOVF   03,W
01A14:  BNZ   1A24
01A16:  MOVLW  22
01A18:  SUBWF  00,W
01A1A:  MOVLB  0
01A1C:  BTFSC  FD8.2
01A1E:  GOTO   21CC
01A22:  MOVLB  9
01A24:  MOVF   03,W
01A26:  BNZ   1A36
01A28:  MOVLW  23
01A2A:  SUBWF  00,W
01A2C:  MOVLB  0
01A2E:  BTFSC  FD8.2
01A30:  GOTO   21E6
01A34:  MOVLB  9
01A36:  MOVF   03,W
01A38:  BNZ   1A48
01A3A:  MOVLW  24
01A3C:  SUBWF  00,W
01A3E:  MOVLB  0
01A40:  BTFSC  FD8.2
01A42:  GOTO   21F4
01A46:  MOVLB  9
01A48:  MOVF   03,W
01A4A:  BNZ   1A5A
01A4C:  MOVLW  25
01A4E:  SUBWF  00,W
01A50:  MOVLB  0
01A52:  BTFSC  FD8.2
01A54:  GOTO   2222
01A58:  MOVLB  9
01A5A:  MOVF   03,W
01A5C:  BNZ   1A6C
01A5E:  MOVLW  26
01A60:  SUBWF  00,W
01A62:  MOVLB  0
01A64:  BTFSC  FD8.2
01A66:  GOTO   223C
01A6A:  MOVLB  9
01A6C:  MOVF   03,W
01A6E:  BNZ   1A7E
01A70:  MOVLW  27
01A72:  SUBWF  00,W
01A74:  MOVLB  0
01A76:  BTFSC  FD8.2
01A78:  GOTO   224A
01A7C:  MOVLB  9
01A7E:  MOVF   03,W
01A80:  BNZ   1A90
01A82:  MOVLW  28
01A84:  SUBWF  00,W
01A86:  MOVLB  0
01A88:  BTFSC  FD8.2
01A8A:  GOTO   2278
01A8E:  MOVLB  9
01A90:  MOVF   03,W
01A92:  BNZ   1AA2
01A94:  MOVLW  29
01A96:  SUBWF  00,W
01A98:  MOVLB  0
01A9A:  BTFSC  FD8.2
01A9C:  GOTO   2292
01AA0:  MOVLB  9
01AA2:  MOVF   03,W
01AA4:  BNZ   1AB4
01AA6:  MOVLW  2A
01AA8:  SUBWF  00,W
01AAA:  MOVLB  0
01AAC:  BTFSC  FD8.2
01AAE:  GOTO   22A0
01AB2:  MOVLB  9
01AB4:  MOVF   03,W
01AB6:  BNZ   1AC6
01AB8:  MOVLW  2B
01ABA:  SUBWF  00,W
01ABC:  MOVLB  0
01ABE:  BTFSC  FD8.2
01AC0:  GOTO   22BA
01AC4:  MOVLB  9
01AC6:  MOVF   03,W
01AC8:  BNZ   1AD8
01ACA:  MOVLW  2C
01ACC:  SUBWF  00,W
01ACE:  MOVLB  0
01AD0:  BTFSC  FD8.2
01AD2:  GOTO   22CA
01AD6:  MOVLB  9
01AD8:  MOVF   03,W
01ADA:  BNZ   1AEA
01ADC:  MOVLW  2D
01ADE:  SUBWF  00,W
01AE0:  MOVLB  0
01AE2:  BTFSC  FD8.2
01AE4:  GOTO   22DA
01AE8:  MOVLB  9
01AEA:  MOVF   03,W
01AEC:  BNZ   1AFC
01AEE:  MOVLW  2E
01AF0:  SUBWF  00,W
01AF2:  MOVLB  0
01AF4:  BTFSC  FD8.2
01AF6:  GOTO   22EA
01AFA:  MOVLB  9
01AFC:  MOVF   03,W
01AFE:  BNZ   1B0E
01B00:  MOVLW  2F
01B02:  SUBWF  00,W
01B04:  MOVLB  0
01B06:  BTFSC  FD8.2
01B08:  GOTO   22FA
01B0C:  MOVLB  9
01B0E:  MOVF   03,W
01B10:  BNZ   1B20
01B12:  MOVLW  30
01B14:  SUBWF  00,W
01B16:  MOVLB  0
01B18:  BTFSC  FD8.2
01B1A:  GOTO   230A
01B1E:  MOVLB  9
01B20:  MOVF   03,W
01B22:  BNZ   1B32
01B24:  MOVLW  31
01B26:  SUBWF  00,W
01B28:  MOVLB  0
01B2A:  BTFSC  FD8.2
01B2C:  GOTO   231A
01B30:  MOVLB  9
01B32:  MOVF   03,W
01B34:  BNZ   1B44
01B36:  MOVLW  32
01B38:  SUBWF  00,W
01B3A:  MOVLB  0
01B3C:  BTFSC  FD8.2
01B3E:  GOTO   232A
01B42:  MOVLB  9
01B44:  MOVF   03,W
01B46:  BNZ   1B56
01B48:  MOVLW  33
01B4A:  SUBWF  00,W
01B4C:  MOVLB  0
01B4E:  BTFSC  FD8.2
01B50:  GOTO   233A
01B54:  MOVLB  9
01B56:  MOVF   03,W
01B58:  BNZ   1B68
01B5A:  MOVLW  34
01B5C:  SUBWF  00,W
01B5E:  MOVLB  0
01B60:  BTFSC  FD8.2
01B62:  GOTO   234A
01B66:  MOVLB  9
01B68:  MOVF   03,W
01B6A:  BNZ   1B7A
01B6C:  MOVLW  35
01B6E:  SUBWF  00,W
01B70:  MOVLB  0
01B72:  BTFSC  FD8.2
01B74:  GOTO   235A
01B78:  MOVLB  9
01B7A:  MOVF   03,W
01B7C:  BNZ   1B8C
01B7E:  MOVLW  36
01B80:  SUBWF  00,W
01B82:  MOVLB  0
01B84:  BTFSC  FD8.2
01B86:  GOTO   236A
01B8A:  MOVLB  9
01B8C:  MOVLW  03
01B8E:  SUBWF  03,W
01B90:  BNZ   1BA0
01B92:  MOVLW  E8
01B94:  SUBWF  00,W
01B96:  MOVLB  0
01B98:  BTFSC  FD8.2
01B9A:  GOTO   237C
01B9E:  MOVLB  9
01BA0:  MOVLW  03
01BA2:  SUBWF  03,W
01BA4:  BNZ   1BB4
01BA6:  MOVLW  E9
01BA8:  SUBWF  00,W
01BAA:  MOVLB  0
01BAC:  BTFSC  FD8.2
01BAE:  GOTO   238C
01BB2:  MOVLB  9
01BB4:  MOVLW  03
01BB6:  SUBWF  03,W
01BB8:  BNZ   1BC8
01BBA:  MOVLW  EA
01BBC:  SUBWF  00,W
01BBE:  MOVLB  0
01BC0:  BTFSC  FD8.2
01BC2:  GOTO   239A
01BC6:  MOVLB  9
01BC8:  MOVLW  03
01BCA:  SUBWF  03,W
01BCC:  BNZ   1BDC
01BCE:  MOVLW  EB
01BD0:  SUBWF  00,W
01BD2:  MOVLB  0
01BD4:  BTFSC  FD8.2
01BD6:  GOTO   23A8
01BDA:  MOVLB  9
01BDC:  MOVLW  03
01BDE:  SUBWF  03,W
01BE0:  BNZ   1BF0
01BE2:  MOVLW  EC
01BE4:  SUBWF  00,W
01BE6:  MOVLB  0
01BE8:  BTFSC  FD8.2
01BEA:  GOTO   23B6
01BEE:  MOVLB  9
01BF0:  MOVLW  03
01BF2:  SUBWF  03,W
01BF4:  BNZ   1C04
01BF6:  MOVLW  ED
01BF8:  SUBWF  00,W
01BFA:  MOVLB  0
01BFC:  BTFSC  FD8.2
01BFE:  GOTO   23C4
01C02:  MOVLB  9
01C04:  MOVLW  03
01C06:  SUBWF  03,W
01C08:  BNZ   1C18
01C0A:  MOVLW  EE
01C0C:  SUBWF  00,W
01C0E:  MOVLB  0
01C10:  BTFSC  FD8.2
01C12:  GOTO   23D2
01C16:  MOVLB  9
01C18:  MOVLW  03
01C1A:  SUBWF  03,W
01C1C:  BNZ   1C2C
01C1E:  MOVLW  EF
01C20:  SUBWF  00,W
01C22:  MOVLB  0
01C24:  BTFSC  FD8.2
01C26:  GOTO   23E2
01C2A:  MOVLB  9
01C2C:  MOVLW  03
01C2E:  SUBWF  03,W
01C30:  BNZ   1C40
01C32:  MOVLW  F0
01C34:  SUBWF  00,W
01C36:  MOVLB  0
01C38:  BTFSC  FD8.2
01C3A:  GOTO   23F0
01C3E:  MOVLB  9
01C40:  MOVLW  03
01C42:  SUBWF  03,W
01C44:  BNZ   1C54
01C46:  MOVLW  F1
01C48:  SUBWF  00,W
01C4A:  MOVLB  0
01C4C:  BTFSC  FD8.2
01C4E:  GOTO   2400
01C52:  MOVLB  9
01C54:  MOVLW  03
01C56:  SUBWF  03,W
01C58:  BNZ   1C68
01C5A:  MOVLW  F2
01C5C:  SUBWF  00,W
01C5E:  MOVLB  0
01C60:  BTFSC  FD8.2
01C62:  GOTO   240E
01C66:  MOVLB  9
01C68:  MOVLW  03
01C6A:  SUBWF  03,W
01C6C:  BNZ   1C7C
01C6E:  MOVLW  F3
01C70:  SUBWF  00,W
01C72:  MOVLB  0
01C74:  BTFSC  FD8.2
01C76:  GOTO   241C
01C7A:  MOVLB  9
01C7C:  MOVLW  03
01C7E:  SUBWF  03,W
01C80:  BNZ   1C90
01C82:  MOVLW  F4
01C84:  SUBWF  00,W
01C86:  MOVLB  0
01C88:  BTFSC  FD8.2
01C8A:  GOTO   242C
01C8E:  MOVLB  9
01C90:  MOVLW  03
01C92:  SUBWF  03,W
01C94:  BNZ   1CA4
01C96:  MOVLW  F5
01C98:  SUBWF  00,W
01C9A:  MOVLB  0
01C9C:  BTFSC  FD8.2
01C9E:  GOTO   243C
01CA2:  MOVLB  9
01CA4:  MOVLW  19
01CA6:  SUBWF  03,W
01CA8:  BNZ   1CB8
01CAA:  MOVLW  64
01CAC:  SUBWF  00,W
01CAE:  MOVLB  0
01CB0:  BTFSC  FD8.2
01CB2:  GOTO   24BE
01CB6:  MOVLB  9
01CB8:  MOVLW  19
01CBA:  SUBWF  03,W
01CBC:  BNZ   1CCC
01CBE:  MOVLW  65
01CC0:  SUBWF  00,W
01CC2:  MOVLB  0
01CC4:  BTFSC  FD8.2
01CC6:  GOTO   24CE
01CCA:  MOVLB  9
01CCC:  MOVLW  19
01CCE:  SUBWF  03,W
01CD0:  BNZ   1CE0
01CD2:  MOVLW  66
01CD4:  SUBWF  00,W
01CD6:  MOVLB  0
01CD8:  BTFSC  FD8.2
01CDA:  GOTO   24E0
01CDE:  MOVLB  9
01CE0:  MOVLW  19
01CE2:  SUBWF  03,W
01CE4:  BNZ   1CF4
01CE6:  MOVLW  67
01CE8:  SUBWF  00,W
01CEA:  MOVLB  0
01CEC:  BTFSC  FD8.2
01CEE:  GOTO   24F0
01CF2:  MOVLB  9
01CF4:  MOVLW  19
01CF6:  SUBWF  03,W
01CF8:  BNZ   1D08
01CFA:  MOVLW  68
01CFC:  SUBWF  00,W
01CFE:  MOVLB  0
01D00:  BTFSC  FD8.2
01D02:  GOTO   2502
01D06:  MOVLB  9
01D08:  MOVLW  19
01D0A:  SUBWF  03,W
01D0C:  BNZ   1D1C
01D0E:  MOVLW  69
01D10:  SUBWF  00,W
01D12:  MOVLB  0
01D14:  BTFSC  FD8.2
01D16:  GOTO   2512
01D1A:  MOVLB  9
01D1C:  MOVLW  19
01D1E:  SUBWF  03,W
01D20:  BNZ   1D30
01D22:  MOVLW  6A
01D24:  SUBWF  00,W
01D26:  MOVLB  0
01D28:  BTFSC  FD8.2
01D2A:  GOTO   2524
01D2E:  MOVLB  9
01D30:  MOVLW  19
01D32:  SUBWF  03,W
01D34:  BNZ   1D44
01D36:  MOVLW  6B
01D38:  SUBWF  00,W
01D3A:  MOVLB  0
01D3C:  BTFSC  FD8.2
01D3E:  GOTO   2534
01D42:  MOVLB  9
01D44:  MOVLW  19
01D46:  SUBWF  03,W
01D48:  BNZ   1D58
01D4A:  MOVLW  6C
01D4C:  SUBWF  00,W
01D4E:  MOVLB  0
01D50:  BTFSC  FD8.2
01D52:  GOTO   2546
01D56:  MOVLB  9
01D58:  MOVLW  19
01D5A:  SUBWF  03,W
01D5C:  BNZ   1D6C
01D5E:  MOVLW  6D
01D60:  SUBWF  00,W
01D62:  MOVLB  0
01D64:  BTFSC  FD8.2
01D66:  GOTO   2556
01D6A:  MOVLB  9
01D6C:  MOVLW  19
01D6E:  SUBWF  03,W
01D70:  BNZ   1D80
01D72:  MOVLW  6E
01D74:  SUBWF  00,W
01D76:  MOVLB  0
01D78:  BTFSC  FD8.2
01D7A:  GOTO   2568
01D7E:  MOVLB  9
01D80:  MOVLW  19
01D82:  SUBWF  03,W
01D84:  BNZ   1D94
01D86:  MOVLW  6F
01D88:  SUBWF  00,W
01D8A:  MOVLB  0
01D8C:  BTFSC  FD8.2
01D8E:  GOTO   2578
01D92:  MOVLB  9
01D94:  MOVLW  19
01D96:  SUBWF  03,W
01D98:  BNZ   1DA8
01D9A:  MOVLW  70
01D9C:  SUBWF  00,W
01D9E:  MOVLB  0
01DA0:  BTFSC  FD8.2
01DA2:  GOTO   258A
01DA6:  MOVLB  9
01DA8:  MOVLW  19
01DAA:  SUBWF  03,W
01DAC:  BNZ   1DBC
01DAE:  MOVLW  71
01DB0:  SUBWF  00,W
01DB2:  MOVLB  0
01DB4:  BTFSC  FD8.2
01DB6:  GOTO   259A
01DBA:  MOVLB  9
01DBC:  MOVLW  19
01DBE:  SUBWF  03,W
01DC0:  BNZ   1DD0
01DC2:  MOVLW  72
01DC4:  SUBWF  00,W
01DC6:  MOVLB  0
01DC8:  BTFSC  FD8.2
01DCA:  GOTO   25AC
01DCE:  MOVLB  9
01DD0:  MOVLW  19
01DD2:  SUBWF  03,W
01DD4:  BNZ   1DE4
01DD6:  MOVLW  73
01DD8:  SUBWF  00,W
01DDA:  MOVLB  0
01DDC:  BTFSC  FD8.2
01DDE:  GOTO   25BC
01DE2:  MOVLB  9
01DE4:  MOVLW  19
01DE6:  SUBWF  03,W
01DE8:  BNZ   1DF8
01DEA:  MOVLW  74
01DEC:  SUBWF  00,W
01DEE:  MOVLB  0
01DF0:  BTFSC  FD8.2
01DF2:  GOTO   25CE
01DF6:  MOVLB  9
01DF8:  MOVLW  19
01DFA:  SUBWF  03,W
01DFC:  BNZ   1E0C
01DFE:  MOVLW  75
01E00:  SUBWF  00,W
01E02:  MOVLB  0
01E04:  BTFSC  FD8.2
01E06:  GOTO   25DE
01E0A:  MOVLB  9
01E0C:  MOVLW  19
01E0E:  SUBWF  03,W
01E10:  BNZ   1E20
01E12:  MOVLW  76
01E14:  SUBWF  00,W
01E16:  MOVLB  0
01E18:  BTFSC  FD8.2
01E1A:  GOTO   25F0
01E1E:  MOVLB  9
01E20:  MOVLW  19
01E22:  SUBWF  03,W
01E24:  BNZ   1E34
01E26:  MOVLW  77
01E28:  SUBWF  00,W
01E2A:  MOVLB  0
01E2C:  BTFSC  FD8.2
01E2E:  GOTO   2600
01E32:  MOVLB  9
01E34:  MOVLW  19
01E36:  SUBWF  03,W
01E38:  BNZ   1E48
01E3A:  MOVLW  78
01E3C:  SUBWF  00,W
01E3E:  MOVLB  0
01E40:  BTFSC  FD8.2
01E42:  GOTO   2612
01E46:  MOVLB  9
01E48:  MOVLW  19
01E4A:  SUBWF  03,W
01E4C:  BNZ   1E5C
01E4E:  MOVLW  79
01E50:  SUBWF  00,W
01E52:  MOVLB  0
01E54:  BTFSC  FD8.2
01E56:  GOTO   2622
01E5A:  MOVLB  9
01E5C:  MOVLW  19
01E5E:  SUBWF  03,W
01E60:  BNZ   1E70
01E62:  MOVLW  7A
01E64:  SUBWF  00,W
01E66:  MOVLB  0
01E68:  BTFSC  FD8.2
01E6A:  GOTO   2634
01E6E:  MOVLB  9
01E70:  MOVLW  19
01E72:  SUBWF  03,W
01E74:  BNZ   1E84
01E76:  MOVLW  7B
01E78:  SUBWF  00,W
01E7A:  MOVLB  0
01E7C:  BTFSC  FD8.2
01E7E:  GOTO   2644
01E82:  MOVLB  9
01E84:  GOTO   2654
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01E88:  MOVFF  A9,01
01E8C:  MOVFF  AA,02
01E90:  MOVLB  9
01E92:  GOTO   265C
01E96:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01E98:  MOVF   x97,W
01E9A:  MOVWF  01
01E9C:  MOVF   x98,W
01E9E:  MOVWF  02
01EA0:  MOVLB  9
01EA2:  GOTO   265C
01EA6:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01EA8:  MOVF   x9D,W
01EAA:  MOVWF  01
01EAC:  MOVF   x9E,W
01EAE:  MOVWF  02
01EB0:  MOVLB  9
01EB2:  GOTO   265C
01EB6:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01EB8:  MOVF   xA3,W
01EBA:  MOVWF  01
01EBC:  MOVF   xA4,W
01EBE:  MOVWF  02
01EC0:  MOVLB  9
01EC2:  GOTO   265C
01EC6:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01EC8:  MOVLB  9
01ECA:  CLRF   x18
01ECC:  MOVLB  0
01ECE:  CALL   14B0
01ED2:  MOVFF  03,8F2
01ED6:  MOVFF  02,8F1
01EDA:  MOVFF  01,8F0
01EDE:  MOVFF  00,8EF
01EE2:  MOVLB  8
01EE4:  MOVF   xEF,W
01EE6:  MOVWF  01
01EE8:  MOVF   xF0,W
01EEA:  MOVWF  02
01EEC:  MOVLB  9
01EEE:  GOTO   265C
01EF2:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01EF4:  MOVLB  8
01EF6:  MOVF   xF1,W
01EF8:  MOVWF  01
01EFA:  MOVF   xF2,W
01EFC:  MOVWF  02
01EFE:  MOVLB  9
01F00:  GOTO   265C
01F04:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01F06:  MOVF   xAB,W
01F08:  MOVWF  01
01F0A:  MOVF   xAC,W
01F0C:  MOVWF  02
01F0E:  MOVLB  9
01F10:  GOTO   265C
01F14:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01F16:  MOVF   x99,W
01F18:  MOVWF  01
01F1A:  MOVF   x9A,W
01F1C:  MOVWF  02
01F1E:  MOVLB  9
01F20:  GOTO   265C
01F24:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01F26:  MOVF   x9F,W
01F28:  MOVWF  01
01F2A:  MOVF   xA0,W
01F2C:  MOVWF  02
01F2E:  MOVLB  9
01F30:  BRA    265C
01F32:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01F34:  MOVF   xA5,W
01F36:  MOVWF  01
01F38:  MOVF   xA6,W
01F3A:  MOVWF  02
01F3C:  MOVLB  9
01F3E:  BRA    265C
01F40:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01F42:  MOVLW  01
01F44:  MOVLB  9
01F46:  MOVWF  x18
01F48:  MOVLB  0
01F4A:  CALL   14B0
01F4E:  MOVFF  03,8F2
01F52:  MOVFF  02,8F1
01F56:  MOVFF  01,8F0
01F5A:  MOVFF  00,8EF
01F5E:  MOVLB  8
01F60:  MOVF   xEF,W
01F62:  MOVWF  01
01F64:  MOVF   xF0,W
01F66:  MOVWF  02
01F68:  MOVLB  9
01F6A:  BRA    265C
01F6C:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01F6E:  MOVLB  8
01F70:  MOVF   xF1,W
01F72:  MOVWF  01
01F74:  MOVF   xF2,W
01F76:  MOVWF  02
01F78:  MOVLB  9
01F7A:  BRA    265C
01F7C:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01F7E:  MOVF   xAD,W
01F80:  MOVWF  01
01F82:  MOVF   xAE,W
01F84:  MOVWF  02
01F86:  MOVLB  9
01F88:  BRA    265C
01F8A:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01F8C:  MOVF   x9B,W
01F8E:  MOVWF  01
01F90:  MOVF   x9C,W
01F92:  MOVWF  02
01F94:  MOVLB  9
01F96:  BRA    265C
01F98:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01F9A:  MOVF   xA1,W
01F9C:  MOVWF  01
01F9E:  MOVF   xA2,W
01FA0:  MOVWF  02
01FA2:  MOVLB  9
01FA4:  BRA    265C
01FA6:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01FA8:  MOVF   xA7,W
01FAA:  MOVWF  01
01FAC:  MOVF   xA8,W
01FAE:  MOVWF  02
01FB0:  MOVLB  9
01FB2:  BRA    265C
01FB4:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01FB6:  MOVLW  02
01FB8:  MOVLB  9
01FBA:  MOVWF  x18
01FBC:  MOVLB  0
01FBE:  CALL   14B0
01FC2:  MOVFF  03,8F2
01FC6:  MOVFF  02,8F1
01FCA:  MOVFF  01,8F0
01FCE:  MOVFF  00,8EF
01FD2:  MOVLB  8
01FD4:  MOVF   xEF,W
01FD6:  MOVWF  01
01FD8:  MOVF   xF0,W
01FDA:  MOVWF  02
01FDC:  MOVLB  9
01FDE:  BRA    265C
01FE0:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01FE2:  MOVLB  8
01FE4:  MOVF   xF1,W
01FE6:  MOVWF  01
01FE8:  MOVF   xF2,W
01FEA:  MOVWF  02
01FEC:  MOVLB  9
01FEE:  BRA    265C
01FF0:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01FF2:  CLRF   03
01FF4:  MOVLB  1
01FF6:  MOVF   xCB,W
01FF8:  MOVWF  02
01FFA:  BCF    FD8.0
01FFC:  RLCF   02,F
01FFE:  RLCF   03,F
02000:  MOVF   02,W
02002:  ADDLW  CB
02004:  MOVWF  FE9
02006:  MOVLW  00
02008:  ADDWFC 03,W
0200A:  MOVWF  FEA
0200C:  MOVFF  FEC,03
02010:  MOVF   FED,F
02012:  MOVF   FEF,W
02014:  MOVWF  01
02016:  MOVF   03,W
02018:  MOVWF  02
0201A:  MOVLB  9
0201C:  BRA    265C
0201E:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
02020:  MOVLB  9
02022:  CLRF   x18
02024:  MOVLB  0
02026:  CALL   1512
0202A:  MOVF   01,W
0202C:  MOVWF  01
0202E:  MOVF   02,W
02030:  MOVWF  02
02032:  MOVLB  9
02034:  BRA    265C
02036:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
02038:  MOVF   xBB,W
0203A:  MOVWF  01
0203C:  MOVF   xBC,W
0203E:  MOVWF  02
02040:  MOVLB  9
02042:  BRA    265C
02044:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
02046:  CLRF   03
02048:  MOVLB  1
0204A:  MOVF   xCB,W
0204C:  MOVWF  02
0204E:  BCF    FD8.0
02050:  RLCF   02,F
02052:  RLCF   03,F
02054:  MOVF   02,W
02056:  ADDLW  EB
02058:  MOVWF  FE9
0205A:  MOVLW  00
0205C:  ADDWFC 03,W
0205E:  MOVWF  FEA
02060:  MOVFF  FEC,03
02064:  MOVF   FED,F
02066:  MOVF   FEF,W
02068:  MOVWF  01
0206A:  MOVF   03,W
0206C:  MOVWF  02
0206E:  MOVLB  9
02070:  BRA    265C
02072:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
02074:  MOVLW  01
02076:  MOVLB  9
02078:  MOVWF  x18
0207A:  MOVLB  0
0207C:  CALL   1512
02080:  MOVF   01,W
02082:  MOVWF  01
02084:  MOVF   02,W
02086:  MOVWF  02
02088:  MOVLB  9
0208A:  BRA    265C
0208C:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0208E:  MOVF   xBD,W
02090:  MOVWF  01
02092:  MOVF   xBE,W
02094:  MOVWF  02
02096:  MOVLB  9
02098:  BRA    265C
0209A:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0209C:  CLRF   03
0209E:  MOVLB  1
020A0:  MOVF   xCB,W
020A2:  MOVWF  02
020A4:  BCF    FD8.0
020A6:  RLCF   02,F
020A8:  RLCF   03,F
020AA:  MOVF   02,W
020AC:  ADDLW  0B
020AE:  MOVWF  FE9
020B0:  MOVLW  01
020B2:  ADDWFC 03,W
020B4:  MOVWF  FEA
020B6:  MOVFF  FEC,03
020BA:  MOVF   FED,F
020BC:  MOVF   FEF,W
020BE:  MOVWF  01
020C0:  MOVF   03,W
020C2:  MOVWF  02
020C4:  MOVLB  9
020C6:  BRA    265C
020C8:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
020CA:  MOVLW  02
020CC:  MOVLB  9
020CE:  MOVWF  x18
020D0:  MOVLB  0
020D2:  CALL   1512
020D6:  MOVF   01,W
020D8:  MOVWF  01
020DA:  MOVF   02,W
020DC:  MOVWF  02
020DE:  MOVLB  9
020E0:  BRA    265C
020E2:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
020E4:  MOVF   xBF,W
020E6:  MOVWF  01
020E8:  MOVF   xC0,W
020EA:  MOVWF  02
020EC:  MOVLB  9
020EE:  BRA    265C
020F0:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
020F2:  CLRF   03
020F4:  MOVLB  1
020F6:  MOVF   xCB,W
020F8:  MOVWF  02
020FA:  BCF    FD8.0
020FC:  RLCF   02,F
020FE:  RLCF   03,F
02100:  MOVF   02,W
02102:  ADDLW  2B
02104:  MOVWF  FE9
02106:  MOVLW  01
02108:  ADDWFC 03,W
0210A:  MOVWF  FEA
0210C:  MOVFF  FEC,03
02110:  MOVF   FED,F
02112:  MOVF   FEF,W
02114:  MOVWF  01
02116:  MOVF   03,W
02118:  MOVWF  02
0211A:  MOVLB  9
0211C:  BRA    265C
0211E:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
02120:  MOVLW  03
02122:  MOVLB  9
02124:  MOVWF  x18
02126:  MOVLB  0
02128:  CALL   1512
0212C:  MOVF   01,W
0212E:  MOVWF  01
02130:  MOVF   02,W
02132:  MOVWF  02
02134:  MOVLB  9
02136:  BRA    265C
02138:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
0213A:  MOVF   xC1,W
0213C:  MOVWF  01
0213E:  MOVF   xC2,W
02140:  MOVWF  02
02142:  MOVLB  9
02144:  BRA    265C
02146:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
02148:  CLRF   03
0214A:  MOVLB  1
0214C:  MOVF   xCB,W
0214E:  MOVWF  02
02150:  BCF    FD8.0
02152:  RLCF   02,F
02154:  RLCF   03,F
02156:  MOVF   02,W
02158:  ADDLW  4B
0215A:  MOVWF  FE9
0215C:  MOVLW  01
0215E:  ADDWFC 03,W
02160:  MOVWF  FEA
02162:  MOVFF  FEC,03
02166:  MOVF   FED,F
02168:  MOVF   FEF,W
0216A:  MOVWF  01
0216C:  MOVF   03,W
0216E:  MOVWF  02
02170:  MOVLB  9
02172:  BRA    265C
02174:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
02176:  MOVLW  04
02178:  MOVLB  9
0217A:  MOVWF  x18
0217C:  MOVLB  0
0217E:  CALL   1512
02182:  MOVF   01,W
02184:  MOVWF  01
02186:  MOVF   02,W
02188:  MOVWF  02
0218A:  MOVLB  9
0218C:  BRA    265C
0218E:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
02190:  MOVF   xC3,W
02192:  MOVWF  01
02194:  MOVF   xC4,W
02196:  MOVWF  02
02198:  MOVLB  9
0219A:  BRA    265C
0219C:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
0219E:  CLRF   03
021A0:  MOVLB  1
021A2:  MOVF   xCB,W
021A4:  MOVWF  02
021A6:  BCF    FD8.0
021A8:  RLCF   02,F
021AA:  RLCF   03,F
021AC:  MOVF   02,W
021AE:  ADDLW  6B
021B0:  MOVWF  FE9
021B2:  MOVLW  01
021B4:  ADDWFC 03,W
021B6:  MOVWF  FEA
021B8:  MOVFF  FEC,03
021BC:  MOVF   FED,F
021BE:  MOVF   FEF,W
021C0:  MOVWF  01
021C2:  MOVF   03,W
021C4:  MOVWF  02
021C6:  MOVLB  9
021C8:  BRA    265C
021CA:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
021CC:  MOVLW  05
021CE:  MOVLB  9
021D0:  MOVWF  x18
021D2:  MOVLB  0
021D4:  CALL   1512
021D8:  MOVF   01,W
021DA:  MOVWF  01
021DC:  MOVF   02,W
021DE:  MOVWF  02
021E0:  MOVLB  9
021E2:  BRA    265C
021E4:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
021E6:  MOVF   xC5,W
021E8:  MOVWF  01
021EA:  MOVF   xC6,W
021EC:  MOVWF  02
021EE:  MOVLB  9
021F0:  BRA    265C
021F2:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
021F4:  CLRF   03
021F6:  MOVLB  1
021F8:  MOVF   xCB,W
021FA:  MOVWF  02
021FC:  BCF    FD8.0
021FE:  RLCF   02,F
02200:  RLCF   03,F
02202:  MOVF   02,W
02204:  ADDLW  8B
02206:  MOVWF  FE9
02208:  MOVLW  01
0220A:  ADDWFC 03,W
0220C:  MOVWF  FEA
0220E:  MOVFF  FEC,03
02212:  MOVF   FED,F
02214:  MOVF   FEF,W
02216:  MOVWF  01
02218:  MOVF   03,W
0221A:  MOVWF  02
0221C:  MOVLB  9
0221E:  BRA    265C
02220:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
02222:  MOVLW  06
02224:  MOVLB  9
02226:  MOVWF  x18
02228:  MOVLB  0
0222A:  CALL   1512
0222E:  MOVF   01,W
02230:  MOVWF  01
02232:  MOVF   02,W
02234:  MOVWF  02
02236:  MOVLB  9
02238:  BRA    265C
0223A:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
0223C:  MOVF   xC7,W
0223E:  MOVWF  01
02240:  MOVF   xC8,W
02242:  MOVWF  02
02244:  MOVLB  9
02246:  BRA    265C
02248:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
0224A:  CLRF   03
0224C:  MOVLB  1
0224E:  MOVF   xCB,W
02250:  MOVWF  02
02252:  BCF    FD8.0
02254:  RLCF   02,F
02256:  RLCF   03,F
02258:  MOVF   02,W
0225A:  ADDLW  AB
0225C:  MOVWF  FE9
0225E:  MOVLW  01
02260:  ADDWFC 03,W
02262:  MOVWF  FEA
02264:  MOVFF  FEC,03
02268:  MOVF   FED,F
0226A:  MOVF   FEF,W
0226C:  MOVWF  01
0226E:  MOVF   03,W
02270:  MOVWF  02
02272:  MOVLB  9
02274:  BRA    265C
02276:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
02278:  MOVLW  07
0227A:  MOVLB  9
0227C:  MOVWF  x18
0227E:  MOVLB  0
02280:  CALL   1512
02284:  MOVF   01,W
02286:  MOVWF  01
02288:  MOVF   02,W
0228A:  MOVWF  02
0228C:  MOVLB  9
0228E:  BRA    265C
02290:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
02292:  MOVF   xC9,W
02294:  MOVWF  01
02296:  MOVF   xCA,W
02298:  MOVWF  02
0229A:  MOVLB  9
0229C:  BRA    265C
0229E:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
022A0:  MOVLB  1
022A2:  MOVF   xD3,W
022A4:  MOVWF  03
022A6:  MOVF   xD2,W
022A8:  INCF   xD2,F
022AA:  BTFSC  FD8.2
022AC:  INCF   xD3,F
022AE:  MOVWF  01
022B0:  MOVF   03,W
022B2:  MOVWF  02
022B4:  MOVLB  9
022B6:  BRA    265C
022B8:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
022BA:  MOVLB  1
022BC:  MOVF   xD6,W
022BE:  MOVWF  01
022C0:  MOVF   xD7,W
022C2:  MOVWF  02
022C4:  MOVLB  9
022C6:  BRA    265C
022C8:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
022CA:  MOVLB  1
022CC:  MOVF   xD4,W
022CE:  MOVWF  01
022D0:  MOVF   xD5,W
022D2:  MOVWF  02
022D4:  MOVLB  9
022D6:  BRA    265C
022D8:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
022DA:  MOVLB  1
022DC:  MOVF   xD9,W
022DE:  MOVWF  01
022E0:  MOVF   xDA,W
022E2:  MOVWF  02
022E4:  MOVLB  9
022E6:  BRA    265C
022E8:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
022EA:  GOTO   159C
022EE:  MOVLW  00
022F0:  MOVWF  01
022F2:  MOVWF  02
022F4:  MOVLB  9
022F6:  BRA    265C
022F8:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
022FA:  GOTO   15D8
022FE:  MOVLW  00
02300:  MOVWF  01
02302:  MOVWF  02
02304:  MOVLB  9
02306:  BRA    265C
02308:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
0230A:  MOVLB  1
0230C:  MOVF   xCC,W
0230E:  MOVWF  01
02310:  MOVF   xCD,W
02312:  MOVWF  02
02314:  MOVLB  9
02316:  BRA    265C
02318:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
0231A:  MOVLB  1
0231C:  MOVF   xCE,W
0231E:  MOVWF  01
02320:  MOVF   xCF,W
02322:  MOVWF  02
02324:  MOVLB  9
02326:  BRA    265C
02328:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
0232A:  MOVLB  1
0232C:  MOVF   xD0,W
0232E:  MOVWF  01
02330:  MOVF   xD1,W
02332:  MOVWF  02
02334:  MOVLB  9
02336:  BRA    265C
02338:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
0233A:  GOTO   1600
0233E:  MOVLW  00
02340:  MOVWF  01
02342:  MOVWF  02
02344:  MOVLB  9
02346:  BRA    265C
02348:  MOVLB  0
.................... 		 
.................... 		/* meta */ 
.................... 		case 52: return (int16) current.rda_bytes_received; 
0234A:  MOVLB  1
0234C:  MOVF   xE2,W
0234E:  MOVWF  01
02350:  MOVF   xE3,W
02352:  MOVWF  02
02354:  MOVLB  9
02356:  BRA    265C
02358:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
0235A:  MOVLB  1
0235C:  MOVF   xE4,W
0235E:  MOVWF  01
02360:  MOVF   xE5,W
02362:  MOVWF  02
02364:  MOVLB  9
02366:  BRA    265C
02368:  MOVLB  0
.................... 		case 54: return (int16) current.button_state; 
0236A:  CLRF   03
0236C:  MOVLB  1
0236E:  MOVF   xE6,W
02370:  MOVWF  01
02372:  MOVF   03,W
02374:  MOVWF  02
02376:  MOVLB  9
02378:  BRA    265C
0237A:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
0237C:  CLRF   03
0237E:  MOVF   3A,W
02380:  MOVWF  01
02382:  MOVF   03,W
02384:  MOVWF  02
02386:  MOVLB  9
02388:  BRA    265C
0238A:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
0238C:  MOVF   3B,W
0238E:  MOVWF  01
02390:  MOVF   3C,W
02392:  MOVWF  02
02394:  MOVLB  9
02396:  BRA    265C
02398:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
0239A:  MOVLW  50
0239C:  MOVWF  01
0239E:  MOVLW  00
023A0:  MOVWF  02
023A2:  MOVLB  9
023A4:  BRA    265C
023A6:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
023A8:  MOVLW  57
023AA:  MOVWF  01
023AC:  MOVLW  00
023AE:  MOVWF  02
023B0:  MOVLB  9
023B2:  BRA    265C
023B4:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
023B6:  MOVLW  58
023B8:  MOVWF  01
023BA:  MOVLW  00
023BC:  MOVWF  02
023BE:  MOVLB  9
023C0:  BRA    265C
023C2:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
023C4:  MOVLW  01
023C6:  MOVWF  01
023C8:  MOVLW  00
023CA:  MOVWF  02
023CC:  MOVLB  9
023CE:  BRA    265C
023D0:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
023D2:  CLRF   03
023D4:  MOVF   36,W
023D6:  MOVWF  01
023D8:  MOVF   03,W
023DA:  MOVWF  02
023DC:  MOVLB  9
023DE:  BRA    265C
023E0:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
023E2:  MOVF   3D,W
023E4:  MOVWF  01
023E6:  MOVF   3E,W
023E8:  MOVWF  02
023EA:  MOVLB  9
023EC:  BRA    265C
023EE:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
023F0:  CLRF   03
023F2:  MOVF   3F,W
023F4:  MOVWF  01
023F6:  MOVF   03,W
023F8:  MOVWF  02
023FA:  MOVLB  9
023FC:  BRA    265C
023FE:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
02400:  MOVF   40,W
02402:  MOVWF  01
02404:  MOVF   41,W
02406:  MOVWF  02
02408:  MOVLB  9
0240A:  BRA    265C
0240C:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
0240E:  MOVF   42,W
02410:  MOVWF  01
02412:  MOVF   43,W
02414:  MOVWF  02
02416:  MOVLB  9
02418:  BRA    265C
0241A:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
0241C:  CLRF   03
0241E:  MOVF   44,W
02420:  MOVWF  01
02422:  MOVF   03,W
02424:  MOVWF  02
02426:  MOVLB  9
02428:  BRA    265C
0242A:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
0242C:  CLRF   03
0242E:  MOVF   38,W
02430:  MOVWF  01
02432:  MOVF   03,W
02434:  MOVWF  02
02436:  MOVLB  9
02438:  BRA    265C
0243A:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
0243C:  MOVF   39,F
0243E:  BNZ   244E
02440:  MOVLW  B0
02442:  MOVWF  01
02444:  MOVLW  04
02446:  MOVWF  02
02448:  MOVLB  9
0244A:  BRA    265C
0244C:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
0244E:  DECFSZ 39,W
02450:  BRA    2460
02452:  MOVLW  60
02454:  MOVWF  01
02456:  MOVLW  09
02458:  MOVWF  02
0245A:  MOVLB  9
0245C:  BRA    265C
0245E:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
02460:  MOVF   39,W
02462:  SUBLW  02
02464:  BNZ   2474
02466:  MOVLW  C0
02468:  MOVWF  01
0246A:  MOVLW  12
0246C:  MOVWF  02
0246E:  MOVLB  9
02470:  BRA    265C
02472:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
02474:  MOVF   39,W
02476:  SUBLW  04
02478:  BNZ   2488
0247A:  MOVLW  00
0247C:  MOVWF  01
0247E:  MOVLW  4B
02480:  MOVWF  02
02482:  MOVLB  9
02484:  BRA    265C
02486:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
02488:  MOVF   39,W
0248A:  SUBLW  05
0248C:  BNZ   249C
0248E:  MOVLW  00
02490:  MOVWF  01
02492:  MOVLW  96
02494:  MOVWF  02
02496:  MOVLB  9
02498:  BRA    265C
0249A:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
0249C:  MOVF   39,W
0249E:  SUBLW  06
024A0:  BNZ   24B0
024A2:  MOVLW  00
024A4:  MOVWF  01
024A6:  MOVLW  E1
024A8:  MOVWF  02
024AA:  MOVLB  9
024AC:  BRA    265C
024AE:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
024B0:  MOVLW  80
024B2:  MOVWF  01
024B4:  MOVLW  25
024B6:  MOVWF  02
024B8:  MOVLB  9
024BA:  BRA    265C
024BC:  MOVLB  0
....................  
.................... 		/* NMEA sentence age and length */ 
.................... 		case 6500: return (int16) nmea.sentence_age[0]; 
024BE:  MOVLB  7
024C0:  MOVF   xC4,W
024C2:  MOVWF  01
024C4:  MOVF   xC5,W
024C6:  MOVWF  02
024C8:  MOVLB  9
024CA:  BRA    265C
024CC:  MOVLB  0
.................... 		case 6501: return (int16) nmea.sentence_length[0]; 
024CE:  CLRF   03
024D0:  MOVLB  7
024D2:  MOVF   xDC,W
024D4:  MOVWF  01
024D6:  MOVF   03,W
024D8:  MOVWF  02
024DA:  MOVLB  9
024DC:  BRA    265C
024DE:  MOVLB  0
.................... 		case 6502: return (int16) nmea.sentence_age[1]; 
024E0:  MOVLB  7
024E2:  MOVF   xC6,W
024E4:  MOVWF  01
024E6:  MOVF   xC7,W
024E8:  MOVWF  02
024EA:  MOVLB  9
024EC:  BRA    265C
024EE:  MOVLB  0
.................... 		case 6503: return (int16) nmea.sentence_length[1]; 
024F0:  CLRF   03
024F2:  MOVLB  7
024F4:  MOVF   xDD,W
024F6:  MOVWF  01
024F8:  MOVF   03,W
024FA:  MOVWF  02
024FC:  MOVLB  9
024FE:  BRA    265C
02500:  MOVLB  0
.................... 		case 6504: return (int16) nmea.sentence_age[2]; 
02502:  MOVLB  7
02504:  MOVF   xC8,W
02506:  MOVWF  01
02508:  MOVF   xC9,W
0250A:  MOVWF  02
0250C:  MOVLB  9
0250E:  BRA    265C
02510:  MOVLB  0
.................... 		case 6505: return (int16) nmea.sentence_length[2]; 
02512:  CLRF   03
02514:  MOVLB  7
02516:  MOVF   xDE,W
02518:  MOVWF  01
0251A:  MOVF   03,W
0251C:  MOVWF  02
0251E:  MOVLB  9
02520:  BRA    265C
02522:  MOVLB  0
.................... 		case 6506: return (int16) nmea.sentence_age[3]; 
02524:  MOVLB  7
02526:  MOVF   xCA,W
02528:  MOVWF  01
0252A:  MOVF   xCB,W
0252C:  MOVWF  02
0252E:  MOVLB  9
02530:  BRA    265C
02532:  MOVLB  0
.................... 		case 6507: return (int16) nmea.sentence_length[3]; 
02534:  CLRF   03
02536:  MOVLB  7
02538:  MOVF   xDF,W
0253A:  MOVWF  01
0253C:  MOVF   03,W
0253E:  MOVWF  02
02540:  MOVLB  9
02542:  BRA    265C
02544:  MOVLB  0
.................... 		case 6508: return (int16) nmea.sentence_age[4]; 
02546:  MOVLB  7
02548:  MOVF   xCC,W
0254A:  MOVWF  01
0254C:  MOVF   xCD,W
0254E:  MOVWF  02
02550:  MOVLB  9
02552:  BRA    265C
02554:  MOVLB  0
.................... 		case 6509: return (int16) nmea.sentence_length[4]; 
02556:  CLRF   03
02558:  MOVLB  7
0255A:  MOVF   xE0,W
0255C:  MOVWF  01
0255E:  MOVF   03,W
02560:  MOVWF  02
02562:  MOVLB  9
02564:  BRA    265C
02566:  MOVLB  0
.................... 		case 6510: return (int16) nmea.sentence_age[5]; 
02568:  MOVLB  7
0256A:  MOVF   xCE,W
0256C:  MOVWF  01
0256E:  MOVF   xCF,W
02570:  MOVWF  02
02572:  MOVLB  9
02574:  BRA    265C
02576:  MOVLB  0
.................... 		case 6511: return (int16) nmea.sentence_length[5]; 
02578:  CLRF   03
0257A:  MOVLB  7
0257C:  MOVF   xE1,W
0257E:  MOVWF  01
02580:  MOVF   03,W
02582:  MOVWF  02
02584:  MOVLB  9
02586:  BRA    265C
02588:  MOVLB  0
.................... 		case 6512: return (int16) nmea.sentence_age[6]; 
0258A:  MOVLB  7
0258C:  MOVF   xD0,W
0258E:  MOVWF  01
02590:  MOVF   xD1,W
02592:  MOVWF  02
02594:  MOVLB  9
02596:  BRA    265C
02598:  MOVLB  0
.................... 		case 6513: return (int16) nmea.sentence_length[6]; 
0259A:  CLRF   03
0259C:  MOVLB  7
0259E:  MOVF   xE2,W
025A0:  MOVWF  01
025A2:  MOVF   03,W
025A4:  MOVWF  02
025A6:  MOVLB  9
025A8:  BRA    265C
025AA:  MOVLB  0
.................... 		case 6514: return (int16) nmea.sentence_age[7]; 
025AC:  MOVLB  7
025AE:  MOVF   xD2,W
025B0:  MOVWF  01
025B2:  MOVF   xD3,W
025B4:  MOVWF  02
025B6:  MOVLB  9
025B8:  BRA    265C
025BA:  MOVLB  0
.................... 		case 6515: return (int16) nmea.sentence_length[7]; 
025BC:  CLRF   03
025BE:  MOVLB  7
025C0:  MOVF   xE3,W
025C2:  MOVWF  01
025C4:  MOVF   03,W
025C6:  MOVWF  02
025C8:  MOVLB  9
025CA:  BRA    265C
025CC:  MOVLB  0
.................... 		case 6516: return (int16) nmea.sentence_age[8]; 
025CE:  MOVLB  7
025D0:  MOVF   xD4,W
025D2:  MOVWF  01
025D4:  MOVF   xD5,W
025D6:  MOVWF  02
025D8:  MOVLB  9
025DA:  BRA    265C
025DC:  MOVLB  0
.................... 		case 6517: return (int16) nmea.sentence_length[8]; 
025DE:  CLRF   03
025E0:  MOVLB  7
025E2:  MOVF   xE4,W
025E4:  MOVWF  01
025E6:  MOVF   03,W
025E8:  MOVWF  02
025EA:  MOVLB  9
025EC:  BRA    265C
025EE:  MOVLB  0
.................... 		case 6518: return (int16) nmea.sentence_age[9]; 
025F0:  MOVLB  7
025F2:  MOVF   xD6,W
025F4:  MOVWF  01
025F6:  MOVF   xD7,W
025F8:  MOVWF  02
025FA:  MOVLB  9
025FC:  BRA    265C
025FE:  MOVLB  0
.................... 		case 6519: return (int16) nmea.sentence_length[9]; 
02600:  CLRF   03
02602:  MOVLB  7
02604:  MOVF   xE5,W
02606:  MOVWF  01
02608:  MOVF   03,W
0260A:  MOVWF  02
0260C:  MOVLB  9
0260E:  BRA    265C
02610:  MOVLB  0
.................... 		case 6520: return (int16) nmea.sentence_age[10]; 
02612:  MOVLB  7
02614:  MOVF   xD8,W
02616:  MOVWF  01
02618:  MOVF   xD9,W
0261A:  MOVWF  02
0261C:  MOVLB  9
0261E:  BRA    265C
02620:  MOVLB  0
.................... 		case 6521: return (int16) nmea.sentence_length[10]; 
02622:  CLRF   03
02624:  MOVLB  7
02626:  MOVF   xE6,W
02628:  MOVWF  01
0262A:  MOVF   03,W
0262C:  MOVWF  02
0262E:  MOVLB  9
02630:  BRA    265C
02632:  MOVLB  0
.................... 		case 6522: return (int16) nmea.sentence_age[11]; 
02634:  MOVLB  7
02636:  MOVF   xDA,W
02638:  MOVWF  01
0263A:  MOVF   xDB,W
0263C:  MOVWF  02
0263E:  MOVLB  9
02640:  BRA    265C
02642:  MOVLB  0
.................... 		case 6523: return (int16) nmea.sentence_length[11]; 
02644:  CLRF   03
02646:  MOVLB  7
02648:  MOVF   xE7,W
0264A:  MOVWF  01
0264C:  MOVF   03,W
0264E:  MOVWF  02
02650:  MOVLB  9
02652:  BRA    265C
....................  
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
02654:  MOVLW  FF
02656:  MOVWF  01
02658:  MOVWF  02
0265A:  BRA    265C
.................... 	} 
....................  
.................... } 
0265C:  MOVLB  0
0265E:  GOTO   26B0 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01306:  MOVLB  9
01308:  MOVF   x08,W
0130A:  SUBLW  1F
0130C:  BNZ   1326
0130E:  MOVF   x09,W
01310:  SUBLW  4E
01312:  BNZ   1326
01314:  MOVF   x0A,W
01316:  SUBLW  20
01318:  BNZ   1326
0131A:  MOVF   x0B,W
0131C:  SUBLW  4E
0131E:  BNZ   1326
.................... 		return 1; 
01320:  MOVLW  01
01322:  MOVWF  01
01324:  BRA    1412
....................  
.................... 	if ( start >= MIN_NMEA0183_META_REGISTER && end <= MAX_NMEA0183_META_REGISTER )  
01326:  MOVF   x09,W
01328:  SUBLW  18
0132A:  BC    134A
0132C:  XORLW  FF
0132E:  BNZ   1336
01330:  MOVF   x08,W
01332:  SUBLW  63
01334:  BC    134A
01336:  MOVF   x0B,W
01338:  SUBLW  19
0133A:  BNC   134A
0133C:  BNZ   1344
0133E:  MOVF   x0A,W
01340:  SUBLW  7C
01342:  BNC   134A
.................... 		return 1; 
01344:  MOVLW  01
01346:  MOVWF  01
01348:  BRA    1412
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
0134A:  MOVF   x09,W
0134C:  SUBLW  16
0134E:  BC    136E
01350:  XORLW  FF
01352:  BNZ   135A
01354:  MOVF   x08,W
01356:  SUBLW  6F
01358:  BC    136E
0135A:  MOVF   x0B,W
0135C:  SUBLW  19
0135E:  BNC   136E
01360:  BNZ   1368
01362:  MOVF   x0A,W
01364:  SUBLW  50
01366:  BNC   136E
.................... 		return 1; 
01368:  MOVLW  01
0136A:  MOVWF  01
0136C:  BRA    1412
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
0136E:  MOVF   x09,W
01370:  SUBLW  12
01372:  BC    1392
01374:  XORLW  FF
01376:  BNZ   137E
01378:  MOVF   x08,W
0137A:  SUBLW  87
0137C:  BC    1392
0137E:  MOVF   x0B,W
01380:  SUBLW  17
01382:  BNC   1392
01384:  BNZ   138C
01386:  MOVF   x0A,W
01388:  SUBLW  48
0138A:  BNC   1392
.................... 		return 1; 
0138C:  MOVLW  01
0138E:  MOVWF  01
01390:  BRA    1412
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01392:  MOVF   x09,W
01394:  SUBLW  03
01396:  BC    13B6
01398:  XORLW  FF
0139A:  BNZ   13A2
0139C:  MOVF   x08,W
0139E:  SUBLW  4B
013A0:  BC    13B6
013A2:  MOVF   x0B,W
013A4:  SUBLW  04
013A6:  BNC   13B6
013A8:  BNZ   13B0
013AA:  MOVF   x0A,W
013AC:  SUBLW  94
013AE:  BNC   13B6
.................... 		return 1; 
013B0:  MOVLW  01
013B2:  MOVWF  01
013B4:  BRA    1412
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
013B6:  MOVF   x09,W
013B8:  SUBLW  02
013BA:  BC    13DA
013BC:  XORLW  FF
013BE:  BNZ   13C6
013C0:  MOVF   x08,W
013C2:  SUBLW  E7
013C4:  BC    13DA
013C6:  MOVF   x0B,W
013C8:  SUBLW  03
013CA:  BNC   13DA
013CC:  BNZ   13D4
013CE:  MOVF   x0A,W
013D0:  SUBLW  F6
013D2:  BNC   13DA
.................... 		return 1; 
013D4:  MOVLW  01
013D6:  MOVWF  01
013D8:  BRA    1412
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
013DA:  MOVF   x09,W
013DC:  SUBLW  06
013DE:  BC    13FE
013E0:  XORLW  FF
013E2:  BNZ   13EA
013E4:  MOVF   x08,W
013E6:  SUBLW  CF
013E8:  BC    13FE
013EA:  MOVF   x0B,W
013EC:  SUBLW  09
013EE:  BNC   13FE
013F0:  BNZ   13F8
013F2:  MOVF   x0A,W
013F4:  SUBLW  D1
013F6:  BNC   13FE
.................... 		return 1; 
013F8:  MOVLW  01
013FA:  MOVWF  01
013FC:  BRA    1412
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
013FE:  MOVF   x0B,F
01400:  BNZ   140E
01402:  MOVF   x0A,W
01404:  SUBLW  37
01406:  BNC   140E
.................... 		return 1; 
01408:  MOVLW  01
0140A:  MOVWF  01
0140C:  BRA    1412
....................  
.................... 	return 0; 
0140E:  MOVLW  00
01410:  MOVWF  01
.................... } 
01412:  MOVLB  0
01414:  GOTO   2C96 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
02662:  MOVFF  907,910
02666:  MOVFF  906,911
0266A:  CALL   1450
.................... 	modbus_serial_putc(register_count*2); 
0266E:  BCF    FD8.0
02670:  MOVLB  9
02672:  RLCF   x0A,W
02674:  MOVWF  x10
02676:  RLCF   x0B,W
02678:  MOVWF  x11
0267A:  MOVFF  910,912
0267E:  MOVLB  0
02680:  CALL   1418
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
02684:  MOVLB  9
02686:  CLRF   x0D
02688:  CLRF   x0C
0268A:  MOVF   x0D,W
0268C:  SUBWF  x0B,W
0268E:  BNC   26DA
02690:  BNZ   2698
02692:  MOVF   x0A,W
02694:  SUBWF  x0C,W
02696:  BC    26DA
.................... 		l=map_modbus(start_address+i); 
02698:  MOVF   x0C,W
0269A:  ADDWF  x08,W
0269C:  MOVWF  x10
0269E:  MOVF   x0D,W
026A0:  ADDWFC x09,W
026A2:  MOVWF  x11
026A4:  MOVWF  x13
026A6:  MOVFF  910,912
026AA:  MOVLB  0
026AC:  GOTO   1614
026B0:  MOVFF  02,90F
026B4:  MOVFF  01,90E
.................... 		modbus_serial_putc(make8(l,1)); 
026B8:  MOVFF  90F,910
026BC:  MOVFF  90F,912
026C0:  CALL   1418
....................   		modbus_serial_putc(make8(l,0)); 
026C4:  MOVFF  90E,910
026C8:  MOVFF  90E,912
026CC:  CALL   1418
.................... 	} 
026D0:  MOVLB  9
026D2:  INCF   x0C,F
026D4:  BTFSC  FD8.2
026D6:  INCF   x0D,F
026D8:  BRA    268A
....................  
.................... 	modbus_serial_send_stop(); 
026DA:  MOVLB  0
026DC:  CALL   146E
.................... } 
026E0:  GOTO   2CD8 (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
026E4:  MOVLB  9
026E6:  MOVF   x0D,W
026E8:  SUBLW  06
026EA:  BC    2762
026EC:  XORLW  FF
026EE:  BNZ   26F6
026F0:  MOVF   x0C,W
026F2:  SUBLW  CF
026F4:  BC    2762
026F6:  MOVF   x0D,W
026F8:  SUBLW  09
026FA:  BNC   2762
026FC:  BNZ   2704
026FE:  MOVF   x0C,W
02700:  SUBLW  CF
02702:  BNC   2762
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02704:  MOVF   x0F,W
02706:  SUBLW  00
02708:  BC    271A
0270A:  XORLW  FF
0270C:  BNZ   2714
0270E:  MOVF   x0E,W
02710:  SUBLW  00
02712:  BC    271A
02714:  MOVLW  03
02716:  MOVWF  01
02718:  BRA    2AC6
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
0271A:  MOVLW  D0
0271C:  SUBWF  x0C,W
0271E:  MOVWF  x12
02720:  MOVLW  07
02722:  SUBWFB x0D,W
02724:  MOVWF  x13
02726:  MOVLW  02
02728:  ADDWF  x13,F
0272A:  MOVFF  913,FAA
0272E:  MOVFF  912,FA9
02732:  MOVFF  90E,FA8
02736:  BCF    FA6.6
02738:  BCF    FA6.7
0273A:  BSF    FA6.2
0273C:  MOVF   FF2,W
0273E:  MOVWF  00
02740:  BCF    FF2.6
02742:  BCF    FF2.7
02744:  MOVLB  F
02746:  MOVLW  55
02748:  MOVWF  FA7
0274A:  MOVLW  AA
0274C:  MOVWF  FA7
0274E:  BSF    FA6.1
02750:  BTFSC  FA6.1
02752:  BRA    2750
02754:  BCF    FA6.2
02756:  MOVF   00,W
02758:  IORWF  FF2,F
.................... 		return 0; 
0275A:  MOVLW  00
0275C:  MOVWF  01
0275E:  MOVLB  9
02760:  BRA    2AC6
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
02762:  MOVF   x0D,W
02764:  SUBLW  03
02766:  BC    27F8
02768:  XORLW  FF
0276A:  BNZ   2772
0276C:  MOVF   x0C,W
0276E:  SUBLW  4B
02770:  BC    27F8
02772:  MOVF   x0D,W
02774:  SUBLW  04
02776:  BNC   27F8
02778:  BNZ   2780
0277A:  MOVF   x0C,W
0277C:  SUBLW  93
0277E:  BNC   27F8
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02780:  MOVF   x0F,W
02782:  SUBLW  00
02784:  BC    2796
02786:  XORLW  FF
02788:  BNZ   2790
0278A:  MOVF   x0E,W
0278C:  SUBLW  00
0278E:  BC    2796
02790:  MOVLW  03
02792:  MOVWF  01
02794:  BRA    2AC6
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
02796:  MOVLW  4C
02798:  SUBWF  x0C,W
0279A:  MOVWF  x10
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
0279C:  MOVFF  910,918
027A0:  MOVLW  06
027A2:  MOVWF  x19
027A4:  MOVLB  0
027A6:  CALL   0B24
027AA:  MOVFF  00,911
.................... 		n = n / 6; /* number of sentence */ 
027AE:  MOVFF  910,918
027B2:  MOVLW  06
027B4:  MOVLB  9
027B6:  MOVWF  x19
027B8:  MOVLB  0
027BA:  CALL   0B24
027BE:  MOVFF  01,910
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
027C2:  MOVLB  9
027C4:  MOVF   x10,W
027C6:  MULLW  06
027C8:  MOVF   FF3,W
027CA:  CLRF   03
027CC:  ADDLW  19
027CE:  MOVWF  x12
027D0:  MOVLW  00
027D2:  ADDWFC 03,W
027D4:  MOVWF  x13
027D6:  CLRF   03
027D8:  MOVF   x11,W
027DA:  ADDWF  x12,W
027DC:  MOVWF  01
027DE:  MOVF   x13,W
027E0:  ADDWFC 03,F
027E2:  MOVF   01,W
027E4:  ADDLW  36
027E6:  MOVWF  FE9
027E8:  MOVLW  00
027EA:  ADDWFC 03,W
027EC:  MOVWF  FEA
027EE:  MOVFF  90E,FEF
.................... 		 
.................... 		return 0; 
027F2:  MOVLW  00
027F4:  MOVWF  01
027F6:  BRA    2AC6
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
027F8:  MOVLB  1
027FA:  MOVF   xD8,F
027FC:  BZ    2834
.................... 		if ( 1000 == address ) { 
027FE:  MOVLB  9
02800:  MOVF   x0C,W
02802:  SUBLW  E8
02804:  BNZ   2818
02806:  MOVF   x0D,W
02808:  SUBLW  03
0280A:  BNZ   2818
.................... 			config.serial_prefix=value; 
0280C:  MOVFF  90E,3A
.................... 			return 0; 
02810:  MOVLW  00
02812:  MOVWF  01
02814:  BRA    2AC6
.................... 		} else if ( 1001 == address ) { 
02816:  BRA    2832
02818:  MOVF   x0C,W
0281A:  SUBLW  E9
0281C:  BNZ   2832
0281E:  MOVF   x0D,W
02820:  SUBLW  03
02822:  BNZ   2832
.................... 			config.serial_number=value; 
02824:  MOVFF  90F,3C
02828:  MOVFF  90E,3B
.................... 			return 0; 
0282C:  MOVLW  00
0282E:  MOVWF  01
02830:  BRA    2AC6
02832:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
02834:  MOVLB  9
02836:  MOVF   x0C,W
02838:  MOVWF  00
0283A:  MOVF   x0D,W
0283C:  MOVWF  03
0283E:  MOVLW  03
02840:  SUBWF  03,W
02842:  BNZ   2850
02844:  MOVLW  EE
02846:  SUBWF  00,W
02848:  MOVLB  0
0284A:  BTFSC  FD8.2
0284C:  BRA    2918
0284E:  MOVLB  9
02850:  MOVLW  03
02852:  SUBWF  03,W
02854:  BNZ   2862
02856:  MOVLW  EF
02858:  SUBWF  00,W
0285A:  MOVLB  0
0285C:  BTFSC  FD8.2
0285E:  BRA    2930
02860:  MOVLB  9
02862:  MOVLW  03
02864:  SUBWF  03,W
02866:  BNZ   2874
02868:  MOVLW  F0
0286A:  SUBWF  00,W
0286C:  MOVLB  0
0286E:  BTFSC  FD8.2
02870:  BRA    2940
02872:  MOVLB  9
02874:  MOVLW  03
02876:  SUBWF  03,W
02878:  BNZ   2886
0287A:  MOVLW  F1
0287C:  SUBWF  00,W
0287E:  MOVLB  0
02880:  BTFSC  FD8.2
02882:  BRA    2958
02884:  MOVLB  9
02886:  MOVLW  03
02888:  SUBWF  03,W
0288A:  BNZ   2898
0288C:  MOVLW  F2
0288E:  SUBWF  00,W
02890:  MOVLB  0
02892:  BTFSC  FD8.2
02894:  BRA    2964
02896:  MOVLB  9
02898:  MOVLW  03
0289A:  SUBWF  03,W
0289C:  BNZ   28AA
0289E:  MOVLW  F3
028A0:  SUBWF  00,W
028A2:  MOVLB  0
028A4:  BTFSC  FD8.2
028A6:  BRA    297E
028A8:  MOVLB  9
028AA:  MOVLW  03
028AC:  SUBWF  03,W
028AE:  BNZ   28BC
028B0:  MOVLW  F4
028B2:  SUBWF  00,W
028B4:  MOVLB  0
028B6:  BTFSC  FD8.2
028B8:  BRA    2996
028BA:  MOVLB  9
028BC:  MOVLW  03
028BE:  SUBWF  03,W
028C0:  BNZ   28CE
028C2:  MOVLW  F5
028C4:  SUBWF  00,W
028C6:  MOVLB  0
028C8:  BTFSC  FD8.2
028CA:  BRA    29AE
028CC:  MOVLB  9
028CE:  MOVLW  07
028D0:  SUBWF  03,W
028D2:  BNZ   28E0
028D4:  MOVLW  CD
028D6:  SUBWF  00,W
028D8:  MOVLB  0
028DA:  BTFSC  FD8.2
028DC:  BRA    2A4C
028DE:  MOVLB  9
028E0:  MOVLW  07
028E2:  SUBWF  03,W
028E4:  BNZ   28F2
028E6:  MOVLW  CE
028E8:  SUBWF  00,W
028EA:  MOVLB  0
028EC:  BTFSC  FD8.2
028EE:  BRA    2A60
028F0:  MOVLB  9
028F2:  MOVLW  07
028F4:  SUBWF  03,W
028F6:  BNZ   2904
028F8:  MOVLW  CF
028FA:  SUBWF  00,W
028FC:  MOVLB  0
028FE:  BTFSC  FD8.2
02900:  BRA    2A7A
02902:  MOVLB  9
02904:  MOVLW  4E
02906:  SUBWF  03,W
02908:  BNZ   2916
0290A:  MOVLW  1F
0290C:  SUBWF  00,W
0290E:  MOVLB  0
02910:  BTFSC  FD8.2
02912:  BRA    2A94
02914:  MOVLB  9
02916:  BRA    2ABC
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
02918:  MOVLB  9
0291A:  MOVF   x0F,F
0291C:  BNZ   2924
0291E:  MOVF   x0E,W
02920:  SUBLW  80
02922:  BC    292A
02924:  MOVLW  03
02926:  MOVWF  01
02928:  BRA    2AC6
.................... 			config.modbus_address=value; 
0292A:  MOVFF  90E,36
.................... 			break; 
0292E:  BRA    2AC2
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
02930:  MOVLB  1
02932:  BSF    xFB.1
.................... 			config.adc_sample_ticks=value; 
02934:  MOVFF  90F,3E
02938:  MOVFF  90E,3D
.................... 			break; 
0293C:  MOVLB  9
0293E:  BRA    2AC2
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02940:  MOVLB  9
02942:  MOVF   x0F,F
02944:  BNZ   294C
02946:  MOVF   x0E,W
02948:  SUBLW  01
0294A:  BC    2952
0294C:  MOVLW  03
0294E:  MOVWF  01
02950:  BRA    2AC6
.................... 			config.allow_bootload_request=value; 
02952:  MOVFF  90E,3F
.................... 			break; 
02956:  BRA    2AC2
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
02958:  MOVFF  90F,41
0295C:  MOVFF  90E,40
.................... 			break; 
02960:  MOVLB  9
02962:  BRA    2AC2
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
02964:  MOVLB  9
02966:  MOVF   x0E,F
02968:  BNZ   2974
0296A:  MOVF   x0F,F
0296C:  BNZ   2974
0296E:  MOVLW  03
02970:  MOVWF  01
02972:  BRA    2AC6
.................... 			config.pi_offtime_seconds=value; 
02974:  MOVFF  90F,43
02978:  MOVFF  90E,42
.................... 			break; 
0297C:  BRA    2AC2
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
0297E:  MOVLB  9
02980:  MOVF   x0F,F
02982:  BNZ   298A
02984:  MOVF   x0E,W
02986:  SUBLW  01
02988:  BC    2990
0298A:  MOVLW  03
0298C:  MOVWF  01
0298E:  BRA    2AC6
.................... 			config.power_startup=value; 
02990:  MOVFF  90E,44
.................... 			break; 
02994:  BRA    2AC2
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
02996:  MOVLB  9
02998:  MOVF   x0F,F
0299A:  BNZ   29A2
0299C:  MOVF   x0E,W
0299E:  SUBLW  02
029A0:  BC    29A8
029A2:  MOVLW  03
029A4:  MOVWF  01
029A6:  BRA    2AC6
.................... 			config.rs485_port_mode=value; 
029A8:  MOVFF  90E,38
.................... 			break; 
029AC:  BRA    2AC2
.................... 		 
.................... 		case 1013: 
....................  
.................... 			n=0; 
029AE:  MOVLB  9
029B0:  CLRF   x10
.................... 			if ( 1200 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_1200; } 
029B2:  MOVF   x0E,W
029B4:  SUBLW  B0
029B6:  BNZ   29C4
029B8:  MOVF   x0F,W
029BA:  SUBLW  04
029BC:  BNZ   29C4
029BE:  MOVLW  01
029C0:  MOVWF  x10
029C2:  CLRF   39
.................... 			if ( 2400 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_2400; } 
029C4:  MOVF   x0E,W
029C6:  SUBLW  60
029C8:  BNZ   29D6
029CA:  MOVF   x0F,W
029CC:  SUBLW  09
029CE:  BNZ   29D6
029D0:  MOVLW  01
029D2:  MOVWF  x10
029D4:  MOVWF  39
.................... 			if ( 4800 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_4800; } 
029D6:  MOVF   x0E,W
029D8:  SUBLW  C0
029DA:  BNZ   29EA
029DC:  MOVF   x0F,W
029DE:  SUBLW  12
029E0:  BNZ   29EA
029E2:  MOVLW  01
029E4:  MOVWF  x10
029E6:  MOVLW  02
029E8:  MOVWF  39
.................... 			if ( 9600 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_9600; } 
029EA:  MOVF   x0E,W
029EC:  SUBLW  80
029EE:  BNZ   29FE
029F0:  MOVF   x0F,W
029F2:  SUBLW  25
029F4:  BNZ   29FE
029F6:  MOVLW  01
029F8:  MOVWF  x10
029FA:  MOVLW  03
029FC:  MOVWF  39
.................... 			if ( 19200 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_19200; } 
029FE:  MOVF   x0E,F
02A00:  BNZ   2A10
02A02:  MOVF   x0F,W
02A04:  SUBLW  4B
02A06:  BNZ   2A10
02A08:  MOVLW  01
02A0A:  MOVWF  x10
02A0C:  MOVLW  04
02A0E:  MOVWF  39
.................... 			if ( 38400 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_38400; } 
02A10:  MOVF   x0E,F
02A12:  BNZ   2A22
02A14:  MOVF   x0F,W
02A16:  SUBLW  96
02A18:  BNZ   2A22
02A1A:  MOVLW  01
02A1C:  MOVWF  x10
02A1E:  MOVLW  05
02A20:  MOVWF  39
.................... 			if ( 57600 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_57600; } 
02A22:  MOVF   x0E,F
02A24:  BNZ   2A34
02A26:  MOVF   x0F,W
02A28:  SUBLW  E1
02A2A:  BNZ   2A34
02A2C:  MOVLW  01
02A2E:  MOVWF  x10
02A30:  MOVLW  06
02A32:  MOVWF  39
....................  
.................... 			if (  1==n ) { 
02A34:  DECFSZ x10,W
02A36:  BRA    2A42
.................... 				set_rs485_speed(); 
02A38:  MOVLB  0
02A3A:  CALL   0E84
.................... 			}  else { 
02A3E:  BRA    2A48
02A40:  MOVLB  9
.................... 				return ILLEGAL_DATA_VALUE; 
02A42:  MOVLW  03
02A44:  MOVWF  01
02A46:  BRA    2AC6
.................... 			} 
.................... 			break; 
02A48:  MOVLB  9
02A4A:  BRA    2AC2
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A4C:  MOVLB  9
02A4E:  DECFSZ x0E,W
02A50:  BRA    2A56
02A52:  MOVF   x0F,F
02A54:  BZ    2A5C
02A56:  MOVLW  03
02A58:  MOVWF  01
02A5A:  BRA    2AC6
.................... 			reset_cpu(); 
02A5C:  RESET
02A5E:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A60:  MOVLB  9
02A62:  DECFSZ x0E,W
02A64:  BRA    2A6A
02A66:  MOVF   x0F,F
02A68:  BZ    2A70
02A6A:  MOVLW  03
02A6C:  MOVWF  01
02A6E:  BRA    2AC6
.................... 			write_default_param_file(); 
02A70:  MOVLB  0
02A72:  CALL   0D68
.................... 			break; 
02A76:  MOVLB  9
02A78:  BRA    2AC2
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A7A:  MOVLB  9
02A7C:  DECFSZ x0E,W
02A7E:  BRA    2A84
02A80:  MOVF   x0F,F
02A82:  BZ    2A8A
02A84:  MOVLW  03
02A86:  MOVWF  01
02A88:  BRA    2AC6
.................... 			write_param_file(); 
02A8A:  MOVLB  0
02A8C:  CALL   0D14
.................... 			break; 
02A90:  MOVLB  9
02A92:  BRA    2AC2
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
02A94:  MOVLB  9
02A96:  MOVF   x0E,W
02A98:  SUBLW  0A
02A9A:  BNZ   2AA2
02A9C:  MOVF   x0F,W
02A9E:  SUBLW  07
02AA0:  BZ    2AAE
.................... 				current.factory_unlocked=0; 
02AA2:  MOVLB  1
02AA4:  CLRF   xD8
.................... 				return ILLEGAL_DATA_VALUE; 
02AA6:  MOVLW  03
02AA8:  MOVWF  01
02AAA:  MOVLB  9
02AAC:  BRA    2AC6
.................... 			} 
.................... 			current.factory_unlocked=1; 
02AAE:  MOVLW  01
02AB0:  MOVLB  1
02AB2:  MOVWF  xD8
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02AB4:  MOVLW  C8
02AB6:  MOVWF  xF8
.................... 			break; 
02AB8:  MOVLB  9
02ABA:  BRA    2AC2
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02ABC:  MOVLW  02
02ABE:  MOVWF  01
02AC0:  BRA    2AC6
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02AC2:  MOVLW  00
02AC4:  MOVWF  01
.................... } 
02AC6:  MOVLB  0
02AC8:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02B5A:  GOTO   12B8
02B5E:  MOVF   01,F
02B60:  BTFSC  FD8.2
02B62:  BRA    2E5E
.................... output_low(_PIC_TO_PI); 
02B64:  BCF    F8C.3
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02B66:  DECFSZ 38,W
02B68:  BRA    2C1C
02B6A:  MOVF   36,W
02B6C:  MOVLB  7
02B6E:  SUBWF  xEC,W
02B70:  BTFSS  FD8.2
02B72:  BRA    2B78
02B74:  MOVLB  0
02B76:  BRA    2C1C
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02B78:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02B7A:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02B7C:  CLRWDT
02B7E:  MOVLW  02
02B80:  MOVLB  9
02B82:  MOVWF  x02
02B84:  MOVLW  B5
02B86:  MOVWF  x07
02B88:  MOVLB  0
02B8A:  CALL   12DE
02B8E:  MOVLB  9
02B90:  DECFSZ x02,F
02B92:  BRA    2B84
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02B94:  MOVLB  7
02B96:  MOVF   xEC,W
02B98:  MOVLB  0
02B9A:  CALL   12FE
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02B9E:  CLRWDT
02BA0:  MOVLW  67
02BA2:  MOVWF  00
02BA4:  DECFSZ 00,F
02BA6:  BRA    2BA4
02BA8:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02BAA:  MOVLB  7
02BAC:  MOVF   xEE,W
02BAE:  MOVLB  0
02BB0:  CALL   12FE
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02BB4:  CLRWDT
02BB6:  MOVLW  67
02BB8:  MOVWF  00
02BBA:  DECFSZ 00,F
02BBC:  BRA    2BBA
02BBE:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02BC0:  MOVLB  9
02BC2:  CLRF   x01
02BC4:  MOVLW  02
02BC6:  MOVLB  7
02BC8:  ADDWF  xED,W
02BCA:  MOVLB  9
02BCC:  SUBWF  x01,W
02BCE:  BC    2BFC
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02BD0:  MOVLW  F0
02BD2:  ADDWF  x01,W
02BD4:  MOVWF  FE9
02BD6:  MOVLW  07
02BD8:  MOVWF  FEA
02BDA:  BTFSC  FD8.0
02BDC:  INCF   FEA,F
02BDE:  MOVFF  FEF,902
02BE2:  MOVF   x02,W
02BE4:  MOVLB  0
02BE6:  CALL   12FE
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02BEA:  CLRWDT
02BEC:  MOVLW  67
02BEE:  MOVWF  00
02BF0:  DECFSZ 00,F
02BF2:  BRA    2BF0
02BF4:  NOP   
.................... 			} 
02BF6:  MOVLB  9
02BF8:  INCF   x01,F
02BFA:  BRA    2BC4
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02BFC:  BTFSS  F72.1
02BFE:  BRA    2BFC
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02C00:  CLRWDT
02C02:  MOVLW  02
02C04:  MOVWF  x02
02C06:  MOVLW  B5
02C08:  MOVWF  x07
02C0A:  MOVLB  0
02C0C:  CALL   12DE
02C10:  MOVLB  9
02C12:  DECFSZ x02,F
02C14:  BRA    2C06
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02C16:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02C18:  BCF    F8C.0
02C1A:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02C1C:  MOVF   36,W
02C1E:  SUBLW  80
02C20:  BZ    2C2E
02C22:  MOVF   36,W
02C24:  MOVLB  7
02C26:  SUBWF  xEC,W
02C28:  BTFSS  FD8.2
02C2A:  BRA    2E48
02C2C:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02C2E:  MOVLB  1
02C30:  INCFSZ xCC,W
02C32:  BRA    2C3A
02C34:  INCFSZ xCD,W
02C36:  BRA    2C3A
02C38:  BRA    2C40
.................... 				current.modbus_our_packets++; 
02C3A:  INCF   xCC,F
02C3C:  BTFSC  FD8.2
02C3E:  INCF   xCD,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02C40:  MOVLW  14
02C42:  MOVWF  xF8
....................  
.................... 			switch(modbus_rx.func) { 
02C44:  MOVLB  7
02C46:  MOVF   xEE,W
02C48:  XORLW  03
02C4A:  MOVLB  0
02C4C:  BZ    2C5E
02C4E:  XORLW  07
02C50:  BZ    2C5E
02C52:  XORLW  02
02C54:  BZ    2CDC
02C56:  XORLW  16
02C58:  BTFSC  FD8.2
02C5A:  BRA    2D4E
02C5C:  BRA    2E20
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02C5E:  MOVFF  7F0,8FD
02C62:  MOVFF  7F1,8FC
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02C66:  MOVFF  7F2,8FF
02C6A:  MOVFF  7F3,8FE
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02C6E:  MOVLB  8
02C70:  MOVF   xFE,W
02C72:  ADDWF  xFC,W
02C74:  MOVLB  9
02C76:  MOVWF  x02
02C78:  MOVLB  8
02C7A:  MOVF   xFF,W
02C7C:  ADDWFC xFD,W
02C7E:  MOVLB  9
02C80:  MOVWF  x03
02C82:  MOVFF  8FD,909
02C86:  MOVFF  8FC,908
02C8A:  MOVWF  x0B
02C8C:  MOVFF  902,90A
02C90:  MOVLB  0
02C92:  GOTO   1306
02C96:  MOVF   01,F
02C98:  BNZ   2CBE
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02C9A:  MOVFF  7EC,906
02C9E:  MOVLB  9
02CA0:  CLRF   x08
02CA2:  MOVFF  7EE,907
02CA6:  MOVLW  02
02CA8:  MOVWF  x09
02CAA:  MOVLB  0
02CAC:  CALL   1490
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02CB0:  MOVLB  1
02CB2:  CLRF   xD1
02CB4:  MOVLW  02
02CB6:  MOVWF  xD0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02CB8:  CLRF   xF8
.................... 					} else { 
02CBA:  BRA    2CDA
02CBC:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02CBE:  MOVFF  7EE,906
02CC2:  MOVFF  7EC,907
02CC6:  MOVFF  8FD,909
02CCA:  MOVFF  8FC,908
02CCE:  MOVFF  8FF,90B
02CD2:  MOVFF  8FE,90A
02CD6:  BRA    2662
02CD8:  MOVLB  1
.................... 					} 
.................... 					break; 
02CDA:  BRA    2E40
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02CDC:  MOVFF  7F0,8FD
02CE0:  MOVFF  7F1,8FC
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02CE4:  MOVFF  7F2,903
02CE8:  MOVFF  7F3,902
02CEC:  MOVFF  8FD,90D
02CF0:  MOVFF  8FC,90C
02CF4:  MOVFF  7F2,90F
02CF8:  MOVFF  7F3,90E
02CFC:  RCALL  26E4
02CFE:  MOVFF  01,900
....................  
.................... 					if ( result ) { 
02D02:  MOVLB  9
02D04:  MOVF   x00,F
02D06:  BZ    2D2A
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02D08:  MOVFF  7EC,906
02D0C:  CLRF   x08
02D0E:  MOVFF  7EE,907
02D12:  MOVFF  900,909
02D16:  MOVLB  0
02D18:  CALL   1490
.................... 						current.modbus_last_error=result; 
02D1C:  MOVLB  1
02D1E:  CLRF   xD1
02D20:  MOVFF  900,1D0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02D24:  CLRF   xF8
.................... 					}  else { 
02D26:  BRA    2D4C
02D28:  MOVLB  9
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02D2A:  MOVFF  7F2,903
02D2E:  MOVFF  7F3,902
02D32:  MOVFF  7EC,908
02D36:  MOVFF  8FD,90A
02D3A:  MOVFF  8FC,909
02D3E:  MOVFF  7F2,90C
02D42:  MOVFF  7F3,90B
02D46:  MOVLB  0
02D48:  BRA    2ACA
02D4A:  MOVLB  1
.................... 					} 
.................... 					break; 
02D4C:  BRA    2E40
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02D4E:  MOVFF  7F0,8FD
02D52:  MOVFF  7F1,8FC
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02D56:  MOVFF  7F2,8FF
02D5A:  MOVFF  7F3,8FE
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02D5E:  MOVLB  9
02D60:  CLRF   x01
02D62:  MOVLB  8
02D64:  MOVF   xFF,F
02D66:  BNZ   2D72
02D68:  MOVF   xFE,W
02D6A:  MOVLB  9
02D6C:  SUBWF  x01,W
02D6E:  BC    2E00
02D70:  MOVLB  8
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02D72:  MOVLB  9
02D74:  MOVF   x01,W
02D76:  MOVLB  8
02D78:  ADDWF  xFC,W
02D7A:  MOVLB  9
02D7C:  MOVWF  x02
02D7E:  MOVLW  00
02D80:  MOVLB  8
02D82:  ADDWFC xFD,W
02D84:  MOVLB  9
02D86:  MOVWF  x03
02D88:  BCF    FD8.0
02D8A:  RLCF   x01,W
02D8C:  ADDLW  05
02D8E:  ADDLW  F0
02D90:  MOVWF  FE9
02D92:  MOVLW  07
02D94:  MOVWF  FEA
02D96:  BTFSC  FD8.0
02D98:  INCF   FEA,F
02D9A:  MOVFF  FEF,904
02D9E:  BCF    FD8.0
02DA0:  RLCF   x01,W
02DA2:  ADDLW  06
02DA4:  ADDLW  F0
02DA6:  MOVWF  FE9
02DA8:  MOVLW  07
02DAA:  MOVWF  FEA
02DAC:  BTFSC  FD8.0
02DAE:  INCF   FEA,F
02DB0:  MOVFF  FEF,905
02DB4:  MOVFF  904,907
02DB8:  MOVFF  905,906
02DBC:  MOVFF  903,90D
02DC0:  MOVFF  902,90C
02DC4:  MOVFF  904,90F
02DC8:  MOVFF  905,90E
02DCC:  MOVLB  0
02DCE:  RCALL  26E4
02DD0:  MOVFF  01,900
....................  
.................... 						if ( result ) { 
02DD4:  MOVLB  9
02DD6:  MOVF   x00,F
02DD8:  BZ    2DFC
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02DDA:  MOVFF  7EC,906
02DDE:  CLRF   x08
02DE0:  MOVFF  7EE,907
02DE4:  MOVFF  900,909
02DE8:  MOVLB  0
02DEA:  CALL   1490
.................... 							current.modbus_last_error=result; 
02DEE:  MOVLB  1
02DF0:  CLRF   xD1
02DF2:  MOVFF  900,1D0
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02DF6:  CLRF   xF8
.................... 			 
.................... 							break; 
02DF8:  MOVLB  9
02DFA:  BRA    2E00
.................... 						} 
.................... 					} 
02DFC:  INCF   x01,F
02DFE:  BRA    2D62
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02E00:  MOVF   x00,F
02E02:  BNZ   2E1C
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02E04:  MOVFF  7EC,906
02E08:  MOVFF  8FD,908
02E0C:  MOVFF  8FC,907
02E10:  MOVFF  8FF,90A
02E14:  MOVFF  8FE,909
02E18:  MOVLB  0
02E1A:  BRA    2B12
.................... 					} 
....................  
.................... 					break;   
02E1C:  MOVLB  1
02E1E:  BRA    2E40
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02E20:  MOVFF  7EC,906
02E24:  MOVLB  9
02E26:  CLRF   x08
02E28:  MOVFF  7EE,907
02E2C:  MOVLW  01
02E2E:  MOVWF  x09
02E30:  MOVLB  0
02E32:  CALL   1490
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02E36:  MOVLB  1
02E38:  CLRF   xD1
02E3A:  MOVLW  01
02E3C:  MOVWF  xD0
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02E3E:  CLRF   xF8
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02E40:  CLRF   xDA
02E42:  CLRF   xD9
....................  
.................... 		} else { 
02E44:  BRA    2E5E
02E46:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02E48:  MOVLB  1
02E4A:  INCFSZ xCE,W
02E4C:  BRA    2E54
02E4E:  INCFSZ xCF,W
02E50:  BRA    2E54
02E52:  BRA    2E5A
.................... 				current.modbus_other_packets++; 
02E54:  INCF   xCE,F
02E56:  BTFSC  FD8.2
02E58:  INCF   xCF,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02E5A:  MOVLW  0A
02E5C:  MOVWF  xF8
02E5E:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02E60:  GOTO   3338 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00460:  MOVLB  A
00462:  BTFSS  x14.0
00464:  BRA    047E
00466:  MOVLB  1
00468:  INCFSZ xE7,W
0046A:  BRA    0476
0046C:  INCFSZ xE8,W
0046E:  BRA    0476
00470:  MOVLB  A
00472:  BRA    047E
00474:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00476:  INCF   xE7,F
00478:  BTFSC  FD8.2
0047A:  INCF   xE8,F
0047C:  MOVLB  A
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0047E:  BTFSS  x14.2
00480:  BRA    049A
00482:  MOVLB  1
00484:  INCFSZ xE9,W
00486:  BRA    0492
00488:  INCFSZ xEA,W
0048A:  BRA    0492
0048C:  MOVLB  A
0048E:  BRA    049A
00490:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00492:  INCF   xE9,F
00494:  BTFSC  FD8.2
00496:  INCF   xEA,F
00498:  MOVLB  A
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0049A:  BTFSS  x14.4
0049C:  BRA    04B6
0049E:  MOVLB  1
004A0:  INCFSZ xEB,W
004A2:  BRA    04AE
004A4:  INCFSZ xEC,W
004A6:  BRA    04AE
004A8:  MOVLB  A
004AA:  BRA    04B6
004AC:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
004AE:  INCF   xEB,F
004B0:  BTFSC  FD8.2
004B2:  INCF   xEC,F
004B4:  MOVLB  A
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
004B6:  BCF    x14.1
004B8:  BTFSC  F81.0
004BA:  BSF    x14.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
004BC:  BTFSC  x14.1
004BE:  BRA    0542
004C0:  MOVLB  7
004C2:  BTFSC  xE8.1
004C4:  BRA    04CA
004C6:  MOVLB  A
004C8:  BRA    0542
.................... 		current.pulse_count[0]++; 
004CA:  MOVLB  0
004CC:  INCF   xA9,F
004CE:  BTFSC  FD8.2
004D0:  INCF   xAA,F
.................... 		current.pulse_sum[0]++; 
004D2:  MOVLW  01
004D4:  ADDWF  xAF,F
004D6:  BTFSC  FD8.0
004D8:  INCF   xB0,F
004DA:  BTFSC  FD8.2
004DC:  INCF   xB1,F
004DE:  BTFSC  FD8.2
004E0:  INCF   xB2,F
.................... 		if ( 1 == ext0_state ) { 
004E2:  MOVLB  7
004E4:  BTFSS  xE8.2
004E6:  BRA    0530
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004E8:  MOVLB  A
004EA:  BCF    x14.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004EC:  MOVFF  1E8,98
004F0:  MOVFF  1E7,97
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004F4:  MOVLB  0
004F6:  MOVF   x98,W
004F8:  SUBWF  x9E,W
004FA:  BNC   050C
004FC:  BNZ   0504
004FE:  MOVF   x9D,W
00500:  SUBWF  x97,W
00502:  BC    050C
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00504:  MOVFF  98,9E
00508:  MOVFF  97,9D
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0050C:  MOVF   xA4,W
0050E:  SUBWF  x98,W
00510:  BNC   052C
00512:  BNZ   051A
00514:  MOVF   x97,W
00516:  SUBWF  xA3,W
00518:  BC    052C
0051A:  INCFSZ x97,W
0051C:  BRA    0524
0051E:  INCFSZ x98,W
00520:  BRA    0524
00522:  BRA    052C
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00524:  MOVFF  98,A4
00528:  MOVFF  97,A3
.................... 			} 
.................... 			ext0_state=0; 
0052C:  MOVLB  7
0052E:  BCF    xE8.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00530:  BTFSC  xE8.2
00532:  BRA    0542
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00534:  MOVLB  1
00536:  CLRF   xE8
00538:  CLRF   xE7
.................... 			ext0_count=1; 
0053A:  MOVLB  A
0053C:  BSF    x14.0
.................... 			ext0_state=1; 
0053E:  MOVLB  7
00540:  BSF    xE8.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00542:  MOVLB  7
00544:  BCF    xE8.1
00546:  MOVLB  A
00548:  BTFSS  x14.1
0054A:  BRA    0552
0054C:  MOVLB  7
0054E:  BSF    xE8.1
00550:  MOVLB  A
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00552:  BCF    x14.3
00554:  BTFSC  F81.1
00556:  BSF    x14.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
00558:  BTFSC  x14.3
0055A:  BRA    05DE
0055C:  MOVLB  7
0055E:  BTFSC  xE8.3
00560:  BRA    0566
00562:  MOVLB  A
00564:  BRA    05DE
.................... 		current.pulse_count[1]++; 
00566:  MOVLB  0
00568:  INCF   xAB,F
0056A:  BTFSC  FD8.2
0056C:  INCF   xAC,F
.................... 		current.pulse_sum[1]++; 
0056E:  MOVLW  01
00570:  ADDWF  xB3,F
00572:  BTFSC  FD8.0
00574:  INCF   xB4,F
00576:  BTFSC  FD8.2
00578:  INCF   xB5,F
0057A:  BTFSC  FD8.2
0057C:  INCF   xB6,F
.................... 		if ( 1 == ext1_state ) { 
0057E:  MOVLB  7
00580:  BTFSS  xE8.4
00582:  BRA    05CC
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00584:  MOVLB  A
00586:  BCF    x14.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00588:  MOVFF  1EA,9A
0058C:  MOVFF  1E9,99
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00590:  MOVLB  0
00592:  MOVF   x9A,W
00594:  SUBWF  xA0,W
00596:  BNC   05A8
00598:  BNZ   05A0
0059A:  MOVF   x9F,W
0059C:  SUBWF  x99,W
0059E:  BC    05A8
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
005A0:  MOVFF  9A,A0
005A4:  MOVFF  99,9F
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
005A8:  MOVF   xA6,W
005AA:  SUBWF  x9A,W
005AC:  BNC   05C8
005AE:  BNZ   05B6
005B0:  MOVF   x99,W
005B2:  SUBWF  xA5,W
005B4:  BC    05C8
005B6:  INCFSZ x99,W
005B8:  BRA    05C0
005BA:  INCFSZ x9A,W
005BC:  BRA    05C0
005BE:  BRA    05C8
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005C0:  MOVFF  9A,A6
005C4:  MOVFF  99,A5
.................... 			} 
.................... 			ext1_state=0; 
005C8:  MOVLB  7
005CA:  BCF    xE8.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005CC:  BTFSC  xE8.4
005CE:  BRA    05DE
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005D0:  MOVLB  1
005D2:  CLRF   xEA
005D4:  CLRF   xE9
.................... 			ext1_count=1; 
005D6:  MOVLB  A
005D8:  BSF    x14.2
.................... 			ext1_state=1; 
005DA:  MOVLB  7
005DC:  BSF    xE8.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005DE:  MOVLB  7
005E0:  BCF    xE8.3
005E2:  MOVLB  A
005E4:  BTFSS  x14.3
005E6:  BRA    05EE
005E8:  MOVLB  7
005EA:  BSF    xE8.3
005EC:  MOVLB  A
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005EE:  BCF    x14.5
005F0:  BTFSC  F81.2
005F2:  BSF    x14.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005F4:  BTFSC  x14.5
005F6:  BRA    067A
005F8:  MOVLB  7
005FA:  BTFSC  xE8.5
005FC:  BRA    0602
005FE:  MOVLB  A
00600:  BRA    067A
.................... 		current.pulse_count[2]++; 
00602:  MOVLB  0
00604:  INCF   xAD,F
00606:  BTFSC  FD8.2
00608:  INCF   xAE,F
.................... 		current.pulse_sum[2]++; 
0060A:  MOVLW  01
0060C:  ADDWF  xB7,F
0060E:  BTFSC  FD8.0
00610:  INCF   xB8,F
00612:  BTFSC  FD8.2
00614:  INCF   xB9,F
00616:  BTFSC  FD8.2
00618:  INCF   xBA,F
.................... 		if ( 1 == ext2_state ) { 
0061A:  MOVLB  7
0061C:  BTFSS  xE8.6
0061E:  BRA    0668
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
00620:  MOVLB  A
00622:  BCF    x14.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00624:  MOVFF  1EC,9C
00628:  MOVFF  1EB,9B
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0062C:  MOVLB  0
0062E:  MOVF   x9C,W
00630:  SUBWF  xA2,W
00632:  BNC   0644
00634:  BNZ   063C
00636:  MOVF   xA1,W
00638:  SUBWF  x9B,W
0063A:  BC    0644
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0063C:  MOVFF  9C,A2
00640:  MOVFF  9B,A1
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00644:  MOVF   xA8,W
00646:  SUBWF  x9C,W
00648:  BNC   0664
0064A:  BNZ   0652
0064C:  MOVF   x9B,W
0064E:  SUBWF  xA7,W
00650:  BC    0664
00652:  INCFSZ x9B,W
00654:  BRA    065C
00656:  INCFSZ x9C,W
00658:  BRA    065C
0065A:  BRA    0664
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0065C:  MOVFF  9C,A8
00660:  MOVFF  9B,A7
.................... 			} 
.................... 			ext2_state=0; 
00664:  MOVLB  7
00666:  BCF    xE8.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
00668:  BTFSC  xE8.6
0066A:  BRA    067A
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0066C:  MOVLB  1
0066E:  CLRF   xEC
00670:  CLRF   xEB
.................... 			ext2_count=1; 
00672:  MOVLB  A
00674:  BSF    x14.4
.................... 			ext2_state=1; 
00676:  MOVLB  7
00678:  BSF    xE8.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0067A:  MOVLB  7
0067C:  BCF    xE8.5
0067E:  MOVLB  A
00680:  BTFSS  x14.5
00682:  BRA    068A
00684:  MOVLB  7
00686:  BSF    xE8.5
00688:  MOVLB  A
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0068A:  MOVLB  8
0068C:  INCF   xF3,F
.................... 	if ( 10 == tick ) { 
0068E:  MOVF   xF3,W
00690:  SUBLW  0A
00692:  BNZ   069C
.................... 		tick=0; 
00694:  CLRF   xF3
.................... 		timers.now_millisecond=1; 
00696:  MOVLB  1
00698:  BSF    xFB.2
0069A:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0069C:  BCF    F9E.1
0069E:  MOVLB  0
006A0:  GOTO   013A
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
006BC:  BRA    06A4
006BE:  MOVFF  01,A11
.................... 	current.rda2_bytes_received++; 
006C2:  MOVLB  1
006C4:  INCF   xE4,F
006C6:  BTFSC  FD8.2
006C8:  INCF   xE5,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
006CA:  DECFSZ 38,W
006CC:  BRA    06F2
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006CE:  MOVLB  3
006D0:  CLRF   x00
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006D2:  MOVLB  2
006D4:  INCFSZ xFF,W
006D6:  BRA    06DA
006D8:  BRA    06EE
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006DA:  MOVLW  FF
006DC:  ADDWF  xFF,W
006DE:  MOVWF  FE9
006E0:  MOVLW  01
006E2:  MOVWF  FEA
006E4:  BTFSC  FD8.0
006E6:  INCF   FEA,F
006E8:  MOVFF  A11,FEF
.................... 			timers.rda2_buff_pos++; 
006EC:  INCF   xFF,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006EE:  BRA    073A
006F0:  MOVLB  1
006F2:  MOVF   38,W
006F4:  SUBLW  02
006F6:  BNZ   073C
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
006F8:  MOVLB  A
006FA:  MOVF   x11,W
006FC:  SUBLW  0A
006FE:  BZ    0706
00700:  MOVF   x11,W
00702:  SUBLW  0D
00704:  BNZ   071A
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
00706:  MOVLB  2
00708:  MOVF   xFF,F
0070A:  BZ    0716
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
0070C:  MOVLW  14
0070E:  MOVLB  3
00710:  MOVWF  x00
.................... 			}  else { 
00712:  BRA    0714
00714:  MOVLB  2
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
00716:  BRA    073A
00718:  MOVLB  A
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
0071A:  MOVLB  3
0071C:  CLRF   x00
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
0071E:  MOVLB  2
00720:  INCFSZ xFF,W
00722:  BRA    0726
00724:  BRA    073A
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
00726:  MOVLW  FF
00728:  ADDWF  xFF,W
0072A:  MOVWF  FE9
0072C:  MOVLW  01
0072E:  MOVWF  FEA
00730:  BTFSC  FD8.0
00732:  INCF   FEA,F
00734:  MOVFF  A11,FEF
.................... 				timers.rda2_buff_pos++; 
00738:  INCF   xFF,F
0073A:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /* transmit buffer empty for Modbus to raspberry pi buffer */ 
0073C:  BCF    FA4.5
0073E:  MOVLB  0
00740:  GOTO   0094
.................... #int_tbe 
.................... void isr_uart1_tbe() { 
.................... 	if ( timers.rda_tx_pos >= timers.rda_tx_length ) { 
*
0074C:  MOVLB  4
0074E:  MOVF   x01,W
00750:  SUBWF  x02,W
00752:  BNC   075A
.................... 		/* done transmitting */ 
.................... 		timers.now_rda_tx_done=1; 
00754:  BSF    x03.1
.................... 		disable_interrupts(INT_TBE); 
00756:  BCF    F9D.4
.................... 	} else { 
00758:  BRA    0778
.................... 		/* put another character into TX buffer */ 
.................... 		fputc(timers.rda_tx_buff[timers.rda_tx_pos], STREAM_PI); 
0075A:  MOVLW  01
0075C:  ADDWF  x02,W
0075E:  MOVWF  FE9
00760:  MOVLW  03
00762:  MOVWF  FEA
00764:  BTFSC  FD8.0
00766:  INCF   FEA,F
00768:  MOVFF  FEF,A11
0076C:  MOVLB  A
0076E:  MOVF   x11,W
00770:  MOVLB  0
00772:  RCALL  0744
.................... 		timers.rda_tx_pos++; 
00774:  MOVLB  4
00776:  INCF   x02,F
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00778:  BCF    F9E.4
0077A:  MOVLB  0
0077C:  GOTO   0094
.................... #int_rda 
.................... void isr_uart1_rx() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
007C2:  RCALL  0780
007C4:  MOVFF  01,A11
....................  
.................... 	current.rda_bytes_received++; 
007C8:  MOVLB  1
007CA:  INCF   xE2,F
007CC:  BTFSC  FD8.2
007CE:  INCF   xE3,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
007D0:  MOVLB  7
007D2:  BTFSC  xE8.0
007D4:  BRA    082E
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
007D6:  MOVF   xE9,F
007D8:  BNZ   07EC
.................... output_high(_PIC_TO_PI); 
007DA:  BSF    F8C.3
.................... 			modbus_serial_crc.d = 0xFFFF; 
007DC:  SETF   xEB
007DE:  SETF   xEA
.................... 			modbus_rx.address = c; 
007E0:  MOVFF  A11,7EC
.................... 			modbus_serial_state++; 
007E4:  INCF   xE9,F
.................... 			modbus_rx.len = 0; 
007E6:  CLRF   xED
.................... 			modbus_rx.error=0; 
007E8:  CLRF   xEF
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
007EA:  BRA    081A
007EC:  DECFSZ xE9,W
007EE:  BRA    07F8
.................... 			modbus_rx.func = c; 
007F0:  MOVFF  A11,7EE
.................... 			modbus_serial_state++; 
007F4:  INCF   xE9,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
007F6:  BRA    081A
007F8:  MOVF   xE9,W
007FA:  SUBLW  02
007FC:  BNZ   081A
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
007FE:  INCFSZ xED,W
00800:  BRA    0806
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00802:  MOVLW  FE
00804:  MOVWF  xED
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
00806:  MOVLW  F0
00808:  ADDWF  xED,W
0080A:  MOVWF  FE9
0080C:  MOVLW  07
0080E:  MOVWF  FEA
00810:  BTFSC  FD8.0
00812:  INCF   FEA,F
00814:  MOVFF  A11,FEF
.................... 			modbus_rx.len++; 
00818:  INCF   xED,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
0081A:  MOVFF  A11,A12
0081E:  MOVLB  0
00820:  RCALL  0796
.................... 		modbus_enable_timeout(TRUE); 
00822:  MOVLW  01
00824:  MOVLB  A
00826:  MOVWF  x12
00828:  MOVLB  0
0082A:  RCALL  041A
0082C:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
0082E:  BCF    F9E.5
00830:  MOVLB  0
00832:  GOTO   0094
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
00E84:  MOVF   39,W
00E86:  XORLW  00
00E88:  BZ    0EA0
00E8A:  XORLW  01
00E8C:  BZ    0EB0
00E8E:  XORLW  03
00E90:  BZ    0EC0
00E92:  XORLW  06
00E94:  BZ    0ED0
00E96:  XORLW  01
00E98:  BZ    0EDC
00E9A:  XORLW  03
00E9C:  BZ    0EEC
00E9E:  BRA    0EF8
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
00EA0:  BSF    F70.3
00EA2:  MOVLW  C3
00EA4:  MOVWF  F75
00EA6:  MOVLW  09
00EA8:  MOVWF  F76
00EAA:  MOVLW  A6
00EAC:  MOVWF  F72
00EAE:  BRA    0F04
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
00EB0:  BSF    F70.3
00EB2:  MOVLW  E1
00EB4:  MOVWF  F75
00EB6:  MOVLW  04
00EB8:  MOVWF  F76
00EBA:  MOVLW  A6
00EBC:  MOVWF  F72
00EBE:  BRA    0F04
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
00EC0:  BSF    F70.3
00EC2:  MOVLW  70
00EC4:  MOVWF  F75
00EC6:  MOVLW  02
00EC8:  MOVWF  F76
00ECA:  MOVLW  A6
00ECC:  MOVWF  F72
00ECE:  BRA    0F04
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
00ED0:  BCF    F70.3
00ED2:  MOVLW  26
00ED4:  MOVWF  F75
00ED6:  MOVLW  A6
00ED8:  MOVWF  F72
00EDA:  BRA    0F04
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
00EDC:  BSF    F70.3
00EDE:  MOVLW  4D
00EE0:  MOVWF  F75
00EE2:  MOVLW  00
00EE4:  MOVWF  F76
00EE6:  MOVLW  A6
00EE8:  MOVWF  F72
00EEA:  BRA    0F04
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
00EEC:  BCF    F70.3
00EEE:  MOVLW  0C
00EF0:  MOVWF  F75
00EF2:  MOVLW  A6
00EF4:  MOVWF  F72
00EF6:  BRA    0F04
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
00EF8:  BCF    F70.3
00EFA:  MOVLW  4D
00EFC:  MOVWF  F75
00EFE:  MOVLW  A6
00F00:  MOVWF  F72
00F02:  BRA    0F04
.................... 	} 
.................... } 
00F04:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00930:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00932:  MOVLW  08
00934:  MOVWF  F61
00936:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
00938:  MOVLW  00
0093A:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
0093C:  MOVLW  FF
0093E:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00940:  MOVLW  92
00942:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00944:  MOVLW  80
00946:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00948:  BCF    F96.0
0094A:  BCF    F96.1
0094C:  BCF    F96.2
0094E:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00950:  MOVLB  1
00952:  CLRF   xF8
.................... 	timers.load_off_seconds=2; 
00954:  CLRF   xFA
00956:  MOVLW  02
00958:  MOVWF  xF9
.................... 	timers.now_adc_sample=0; 
0095A:  BCF    xFB.0
.................... 	timers.now_adc_reset_count=0; 
0095C:  BCF    xFB.1
.................... 	timers.now_millisecond=0; 
0095E:  BCF    xFB.2
.................... 	timers.port_b=0b11111111; 
00960:  SETF   xFC
.................... 	timers.port_c=0b11111111; 
00962:  SETF   xFD
....................  
.................... 	timers.rda2_buff_pos=0; 
00964:  MOVLB  2
00966:  CLRF   xFF
.................... 	timers.rda2_buff_gap=255; 
00968:  MOVLB  3
0096A:  SETF   x00
.................... 	timers.now_parse_rda2=0; 
0096C:  MOVLB  1
0096E:  BCF    xFE.0
....................  
.................... 	timers.rda_tx_length=0; 
00970:  MOVLB  4
00972:  CLRF   x01
.................... 	timers.rda_tx_pos=0; 
00974:  CLRF   x02
.................... 	timers.now_rda_tx_ready=0; 
00976:  BCF    x03.0
.................... 	timers.now_rda_tx_done=0; 
00978:  BCF    x03.1
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
0097A:  MOVLB  8
0097C:  CLRF   xFC
0097E:  MOVF   xFC,W
00980:  SUBLW  02
00982:  BNC   0A32
.................... 		current.pulse_period[i]=0; 
00984:  CLRF   03
00986:  MOVFF  8FC,02
0098A:  BCF    FD8.0
0098C:  RLCF   02,F
0098E:  RLCF   03,F
00990:  MOVF   02,W
00992:  ADDLW  97
00994:  MOVWF  FE9
00996:  MOVLW  00
00998:  ADDWFC 03,W
0099A:  MOVWF  FEA
0099C:  CLRF   FEC
0099E:  MOVF   FED,F
009A0:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
009A2:  CLRF   03
009A4:  MOVFF  8FC,02
009A8:  BCF    FD8.0
009AA:  RLCF   02,F
009AC:  RLCF   03,F
009AE:  MOVF   02,W
009B0:  ADDLW  9D
009B2:  MOVWF  FE9
009B4:  MOVLW  00
009B6:  ADDWFC 03,W
009B8:  MOVWF  FEA
009BA:  SETF   FEC
009BC:  MOVF   FED,F
009BE:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
009C0:  CLRF   03
009C2:  MOVFF  8FC,02
009C6:  BCF    FD8.0
009C8:  RLCF   02,F
009CA:  RLCF   03,F
009CC:  MOVF   02,W
009CE:  ADDLW  A3
009D0:  MOVWF  FE9
009D2:  MOVLW  00
009D4:  ADDWFC 03,W
009D6:  MOVWF  FEA
009D8:  CLRF   FEC
009DA:  MOVF   FED,F
009DC:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
009DE:  CLRF   03
009E0:  MOVFF  8FC,02
009E4:  BCF    FD8.0
009E6:  RLCF   02,F
009E8:  RLCF   03,F
009EA:  MOVF   02,W
009EC:  ADDLW  A9
009EE:  MOVWF  FE9
009F0:  MOVLW  00
009F2:  ADDWFC 03,W
009F4:  MOVWF  FEA
009F6:  CLRF   FEC
009F8:  MOVF   FED,F
009FA:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
009FC:  MOVLB  A
009FE:  CLRF   x01
00A00:  MOVFF  8FC,A00
00A04:  CLRF   x03
00A06:  MOVLW  04
00A08:  MOVWF  x02
00A0A:  MOVLB  0
00A0C:  RCALL  08F4
00A0E:  MOVF   01,W
00A10:  ADDLW  AF
00A12:  MOVWF  FE9
00A14:  MOVLW  00
00A16:  ADDWFC 02,W
00A18:  MOVWF  FEA
00A1A:  MOVF   FEE,F
00A1C:  MOVF   FEE,F
00A1E:  CLRF   FEC
00A20:  MOVF   FED,F
00A22:  CLRF   FEF
00A24:  MOVF   FED,F
00A26:  CLRF   FEF
00A28:  MOVF   FED,F
00A2A:  CLRF   FEF
.................... 	} 
00A2C:  MOVLB  8
00A2E:  INCF   xFC,F
00A30:  BRA    097E
....................  
.................... 	current.modbus_our_packets=0; 
00A32:  MOVLB  1
00A34:  CLRF   xCD
00A36:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
00A38:  CLRF   xCF
00A3A:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
00A3C:  CLRF   xD1
00A3E:  CLRF   xD0
.................... 	current.sequence_number=0; 
00A40:  CLRF   xD3
00A42:  CLRF   xD2
.................... 	current.uptime_minutes=0; 
00A44:  CLRF   xD5
00A46:  CLRF   xD4
.................... 	current.interval_milliseconds=0; 
00A48:  CLRF   xD7
00A4A:  CLRF   xD6
.................... 	current.adc_buffer_index=0; 
00A4C:  CLRF   xCB
.................... 	current.factory_unlocked=0; 
00A4E:  CLRF   xD8
.................... 	current.watchdog_seconds=0; 
00A50:  CLRF   xDA
00A52:  CLRF   xD9
.................... 	current.rda_bytes_received=0; 
00A54:  CLRF   xE3
00A56:  CLRF   xE2
.................... 	current.rda2_bytes_received=0; 
00A58:  CLRF   xE5
00A5A:  CLRF   xE4
.................... 	current.button_state=0; 
00A5C:  CLRF   xE6
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
00A5E:  MOVLW  04
00A60:  MOVWF  FEA
00A62:  MOVWF  FE9
00A64:  CLRF   00
00A66:  MOVLW  03
00A68:  MOVWF  02
00A6A:  MOVLW  E4
00A6C:  MOVWF  01
00A6E:  MOVLB  0
00A70:  RCALL  0916
.................... 	for ( i=0 ; i < N_NMEA0183_SENTENCES ; i++ ) { 
00A72:  MOVLB  8
00A74:  CLRF   xFC
00A76:  MOVF   xFC,W
00A78:  SUBLW  0B
00A7A:  BNC   0AAE
.................... 		nmea.sentence_age[i]=0xffff; 
00A7C:  CLRF   03
00A7E:  MOVFF  8FC,02
00A82:  BCF    FD8.0
00A84:  RLCF   02,F
00A86:  RLCF   03,F
00A88:  MOVF   02,W
00A8A:  ADDLW  C4
00A8C:  MOVWF  FE9
00A8E:  MOVLW  07
00A90:  ADDWFC 03,W
00A92:  MOVWF  FEA
00A94:  SETF   FEC
00A96:  MOVF   FED,F
00A98:  SETF   FEF
.................... 		nmea.sentence_length[i]=0; 
00A9A:  MOVLW  DC
00A9C:  ADDWF  xFC,W
00A9E:  MOVWF  FE9
00AA0:  MOVLW  07
00AA2:  MOVWF  FEA
00AA4:  BTFSC  FD8.0
00AA6:  INCF   FEA,F
00AA8:  CLRF   FEF
.................... 	} 
00AAA:  INCF   xFC,F
00AAC:  BRA    0A76
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00AAE:  MOVFF  4C,1DD
00AB2:  MOVFF  4B,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
00AB6:  MOVFF  48,1DF
00ABA:  MOVFF  47,1DE
.................... 	current.power_override_timeout=0; 
00ABE:  MOVLB  1
00AC0:  CLRF   xE1
00AC2:  CLRF   xE0
....................  
.................... 	/* UART2 - RS-485 port speed will be set after parameters are read */ 
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00AC4:  MOVLW  00
00AC6:  IORLW  05
00AC8:  MOVWF  FBA
00ACA:  MOVLW  4A
00ACC:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00ACE:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00AD0:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00AD2:  MOVLB  0
00AD4:  GOTO   31B0 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... 	static int16 b0_state=0; /* push button */ 
.................... 	/* power control */ 
.................... 	int8 i; 
....................  
....................  
.................... 	timers.now_millisecond=0; 
*
010E4:  MOVLB  1
010E6:  BCF    xFB.2
....................  
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
010E8:  BCF    FD8.0
010EA:  MOVLB  8
010EC:  RLCF   xF9,W
010EE:  MOVWF  xFD
010F0:  RLCF   xFA,W
010F2:  MOVWF  xFE
010F4:  MOVLW  00
010F6:  MOVLB  1
010F8:  BTFSS  xFC.3
010FA:  MOVLW  01
010FC:  MOVLB  8
010FE:  IORWF  xFD,F
01100:  MOVFF  8FD,8F9
01104:  MOVF   xFE,W
01106:  IORLW  E0
01108:  MOVWF  xFA
.................... 	if ( b0_state==0xf000) { 
0110A:  MOVF   xF9,F
0110C:  BNZ   111E
0110E:  MOVF   xFA,W
01110:  SUBLW  F0
01112:  BNZ   111E
.................... 		/* button pressed */ 
.................... 		current.button_state=1; 
01114:  MOVLW  01
01116:  MOVLB  1
01118:  MOVWF  xE6
.................... 	} else { 
0111A:  BRA    1122
0111C:  MOVLB  8
.................... 		current.button_State=0; 
0111E:  MOVLB  1
01120:  CLRF   xE6
.................... 	} 
....................  
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
01122:  INCFSZ xE7,W
01124:  BRA    1132
01126:  INCFSZ xE8,W
01128:  BRA    1132
.................... 				current.pulse_period[0]=0; 
0112A:  MOVLB  0
0112C:  CLRF   x98
0112E:  CLRF   x97
01130:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
01132:  INCFSZ xE9,W
01134:  BRA    1142
01136:  INCFSZ xEA,W
01138:  BRA    1142
.................... 				current.pulse_period[1]=0; 
0113A:  MOVLB  0
0113C:  CLRF   x9A
0113E:  CLRF   x99
01140:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
01142:  INCFSZ xEB,W
01144:  BRA    1152
01146:  INCFSZ xEC,W
01148:  BRA    1152
.................... 				current.pulse_period[2]=0; 
0114A:  MOVLB  0
0114C:  CLRF   x9C
0114E:  CLRF   x9B
01150:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
01152:  MOVFF  F81,1FC
.................... 	timers.port_c=port_c; 
01156:  MOVFF  F82,1FD
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
0115A:  MOVF   xF8,F
0115C:  BNZ   1162
.................... 		output_low(LED_GREEN); 
0115E:  BCF    F89.3
.................... 	} else { 
01160:  BRA    1166
.................... 		output_high(LED_GREEN); 
01162:  BSF    F89.3
.................... 		timers.led_on_green--; 
01164:  DECF   xF8,F
.................... 	} 
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
01166:  INCFSZ xD6,W
01168:  BRA    1170
0116A:  INCFSZ xD7,W
0116C:  BRA    1170
0116E:  BRA    1176
.................... 		current.interval_milliseconds++; 
01170:  INCF   xD6,F
01172:  BTFSC  FD8.2
01174:  INCF   xD7,F
.................... 	} 
....................  
.................... 	if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
01176:  MOVF   38,W
01178:  SUBLW  02
0117A:  BNZ   11D4
.................... 		/* NMEA sentence age */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
0117C:  MOVLB  8
0117E:  CLRF   xFC
01180:  MOVF   xFC,W
01182:  SUBLW  0B
01184:  BNC   11D4
.................... 			if ( 0xffff != nmea.sentence_age[i] ) 
01186:  CLRF   03
01188:  MOVFF  8FC,02
0118C:  BCF    FD8.0
0118E:  RLCF   02,F
01190:  RLCF   03,F
01192:  MOVF   02,W
01194:  ADDLW  C4
01196:  MOVWF  FE9
01198:  MOVLW  07
0119A:  ADDWFC 03,W
0119C:  MOVWF  FEA
0119E:  MOVFF  FEC,03
011A2:  MOVF   FED,F
011A4:  MOVF   FEF,W
011A6:  SUBLW  FF
011A8:  BNZ   11B0
011AA:  INCFSZ 03,W
011AC:  BRA    11B0
011AE:  BRA    11D0
.................... 				nmea.sentence_age[i]++; 
011B0:  CLRF   03
011B2:  MOVFF  8FC,02
011B6:  BCF    FD8.0
011B8:  RLCF   02,F
011BA:  RLCF   03,F
011BC:  MOVF   02,W
011BE:  ADDLW  C4
011C0:  MOVWF  FE9
011C2:  MOVLW  07
011C4:  ADDWFC 03,W
011C6:  MOVWF  FEA
011C8:  MOVLW  01
011CA:  ADDWF  FEE,F
011CC:  BNC   11D0
011CE:  INCF   FEF,F
.................... 		} 
011D0:  INCF   xFC,F
011D2:  BRA    1180
.................... 	} 
....................  
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
011D4:  MOVLB  8
011D6:  INCF   xF7,F
011D8:  BTFSC  FD8.2
011DA:  INCF   xF8,F
.................... 	if ( 1000 == ticks ) { 
011DC:  MOVF   xF7,W
011DE:  SUBLW  E8
011E0:  BNZ   1266
011E2:  MOVF   xF8,W
011E4:  SUBLW  03
011E6:  BNZ   1266
.................... 		ticks=0; 
011E8:  CLRF   xF8
011EA:  CLRF   xF7
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
011EC:  MOVLB  1
011EE:  INCFSZ xD9,W
011F0:  BRA    11F8
011F2:  INCFSZ xDA,W
011F4:  BRA    11F8
011F6:  BRA    11FE
.................... 			current.watchdog_seconds++; 
011F8:  INCF   xD9,F
011FA:  BTFSC  FD8.2
011FC:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
011FE:  MOVF   40,F
01200:  BNZ   1206
01202:  MOVF   41,F
01204:  BZ    1224
01206:  MOVF   41,W
01208:  SUBWF  xDA,W
0120A:  BNC   1224
0120C:  BNZ   1214
0120E:  MOVF   xD9,W
01210:  SUBWF  40,W
01212:  BC    1224
01214:  MOVF   xF9,F
01216:  BNZ   1224
01218:  MOVF   xFA,F
0121A:  BNZ   1224
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
0121C:  MOVFF  43,1FA
01220:  MOVFF  42,1F9
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
01224:  MOVF   xF9,F
01226:  BNZ   1230
01228:  MOVF   xFA,F
0122A:  BNZ   1230
.................... 			output_high(PI_POWER_EN); 
0122C:  BSF    F8B.0
.................... 		} else { 
0122E:  BRA    1246
.................... 			output_low(PI_POWER_EN); 
01230:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01232:  MOVF   xF9,W
01234:  BTFSC  FD8.2
01236:  DECF   xFA,F
01238:  DECF   xF9,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
0123A:  MOVF   xF9,F
0123C:  BNZ   1246
0123E:  MOVF   xFA,F
01240:  BNZ   1246
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01242:  CLRF   xDA
01244:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
01246:  MOVLB  8
01248:  INCF   xF4,F
.................... 		if ( 60 == uptimeTicks ) { 
0124A:  MOVF   xF4,W
0124C:  SUBLW  3C
0124E:  BNZ   1266
.................... 			uptimeTicks=0; 
01250:  CLRF   xF4
.................... 			if ( current.uptime_minutes < 65535 )  
01252:  MOVLB  1
01254:  INCFSZ xD4,W
01256:  BRA    125E
01258:  INCFSZ xD5,W
0125A:  BRA    125E
0125C:  BRA    1264
.................... 				current.uptime_minutes++; 
0125E:  INCF   xD4,F
01260:  BTFSC  FD8.2
01262:  INCF   xD5,F
01264:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
01266:  MOVLB  1
01268:  BTFSS  xFB.1
0126A:  BRA    1274
.................... 		timers.now_adc_reset_count=0; 
0126C:  BCF    xFB.1
.................... 		adcTicks=0; 
0126E:  MOVLB  8
01270:  CLRF   xF6
01272:  CLRF   xF5
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01274:  MOVLB  8
01276:  INCF   xF5,F
01278:  BTFSC  FD8.2
0127A:  INCF   xF6,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
0127C:  MOVF   3D,W
0127E:  SUBWF  xF5,W
01280:  BNZ   1290
01282:  MOVF   3E,W
01284:  SUBWF  xF6,W
01286:  BNZ   1290
.................... 		adcTicks=0; 
01288:  CLRF   xF6
0128A:  CLRF   xF5
.................... 		timers.now_adc_sample=1; 
0128C:  MOVLB  1
0128E:  BSF    xFB.0
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01290:  MOVLB  3
01292:  INCFSZ x00,W
01294:  BRA    1298
01296:  BRA    129A
.................... 		timers.rda2_buff_gap++; 
01298:  INCF   x00,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
0129A:  MOVF   x00,W
0129C:  SUBLW  09
0129E:  BC    12B2
012A0:  MOVLB  2
012A2:  MOVF   xFF,F
012A4:  BTFSS  FD8.2
012A6:  BRA    12AC
012A8:  MOVLB  3
012AA:  BRA    12B2
.................... 		timers.now_parse_rda2=1;	 
012AC:  MOVLB  1
012AE:  BSF    xFE.0
012B0:  MOVLB  3
.................... 	} 
.................... } 
012B2:  MOVLB  0
012B4:  GOTO   3326 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && i < maxLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
02EFC:  MOVLB  A
02EFE:  CLRF   x08
02F00:  MOVF   x06,W
02F02:  SUBWF  x08,W
02F04:  BC    2F78
02F06:  MOVF   x07,W
02F08:  SUBWF  x08,W
02F0A:  BC    2F78
02F0C:  CLRF   03
02F0E:  MOVF   x08,W
02F10:  ADDWF  x04,W
02F12:  MOVWF  FE9
02F14:  MOVF   x05,W
02F16:  ADDWFC 03,W
02F18:  MOVWF  FEA
02F1A:  MOVF   FEF,F
02F1C:  BZ    2F78
02F1E:  CLRF   03
02F20:  MOVF   x08,W
02F22:  ADDWF  x04,W
02F24:  MOVWF  FE9
02F26:  MOVF   x05,W
02F28:  ADDWFC 03,W
02F2A:  MOVWF  FEA
02F2C:  MOVF   FEF,W
02F2E:  SUBLW  0A
02F30:  BZ    2F78
02F32:  CLRF   03
02F34:  MOVF   x08,W
02F36:  ADDWF  x04,W
02F38:  MOVWF  FE9
02F3A:  MOVF   x05,W
02F3C:  ADDWFC 03,W
02F3E:  MOVWF  FEA
02F40:  MOVF   FEF,W
02F42:  SUBLW  0D
02F44:  BZ    2F78
.................... 		dest[i] = src[i]; 
02F46:  CLRF   03
02F48:  MOVF   x08,W
02F4A:  ADDWF  x02,W
02F4C:  MOVWF  01
02F4E:  MOVF   x03,W
02F50:  ADDWFC 03,F
02F52:  MOVFF  03,A0A
02F56:  CLRF   03
02F58:  MOVF   x08,W
02F5A:  ADDWF  x04,W
02F5C:  MOVWF  FE9
02F5E:  MOVF   x05,W
02F60:  ADDWFC 03,W
02F62:  MOVWF  FEA
02F64:  MOVFF  FEF,A0B
02F68:  MOVFF  A0A,FEA
02F6C:  MOVFF  01,FE9
02F70:  MOVFF  A0B,FEF
.................... 	} 
02F74:  INCF   x08,F
02F76:  BRA    2F00
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
02F78:  MOVF   x07,W
02F7A:  SUBWF  x08,W
02F7C:  BC    2F92
.................... 		dest[i] = '\0'; 
02F7E:  CLRF   03
02F80:  MOVF   x08,W
02F82:  ADDWF  x02,W
02F84:  MOVWF  FE9
02F86:  MOVF   x03,W
02F88:  ADDWFC 03,W
02F8A:  MOVWF  FEA
02F8C:  CLRF   FEF
.................... 	} 
02F8E:  INCF   x08,F
02F90:  BRA    2F78
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
02F92:  MOVLW  01
02F94:  SUBWF  x07,W
02F96:  CLRF   03
02F98:  ADDWF  x02,W
02F9A:  MOVWF  FE9
02F9C:  MOVF   x03,W
02F9E:  ADDWFC 03,W
02FA0:  MOVWF  FEA
02FA2:  CLRF   FEF
.................... } 
02FA4:  MOVLB  0
02FA6:  GOTO   30D0 (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
02FAA:  MOVFF  2FF,9FC
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02FAE:  MOVLB  2
02FB0:  SETF   xFF
.................... 	memcpy(buff,timers.rda2_buff,length); 
02FB2:  MOVLW  08
02FB4:  MOVWF  FEA
02FB6:  MOVLW  FC
02FB8:  MOVWF  FE9
02FBA:  MOVLW  01
02FBC:  MOVWF  FE2
02FBE:  SETF   FE1
02FC0:  MOVLB  9
02FC2:  MOVF   xFC,W
02FC4:  MOVWF  01
02FC6:  BZ    2FD0
02FC8:  MOVFF  FE6,FEE
02FCC:  DECFSZ 01,F
02FCE:  BRA    2FC8
.................... 	timers.rda2_buff_gap=0; 
02FD0:  MOVLB  3
02FD2:  CLRF   x00
.................... 	timers.rda2_buff_pos=0; 
02FD4:  MOVLB  2
02FD6:  CLRF   xFF
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02FD8:  DECFSZ 38,W
02FDA:  BRA    3014
.................... 		/* transmit MODBUS received data back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02FDC:  MOVLB  9
02FDE:  CLRF   xFE
02FE0:  CLRF   xFD
02FE2:  MOVF   xFE,F
02FE4:  BNZ   3010
02FE6:  MOVF   xFC,W
02FE8:  SUBWF  xFD,W
02FEA:  BC    3010
.................... 			fputc(buff[l],STREAM_PI); 
02FEC:  MOVLW  FC
02FEE:  ADDWF  xFD,W
02FF0:  MOVWF  FE9
02FF2:  MOVLW  08
02FF4:  ADDWFC xFE,W
02FF6:  MOVWF  FEA
02FF8:  MOVFF  FEF,A00
02FFC:  MOVLB  A
02FFE:  MOVF   x00,W
03000:  MOVLB  0
03002:  CALL   0744
.................... 		} 
03006:  MOVLB  9
03008:  INCF   xFD,F
0300A:  BTFSC  FD8.2
0300C:  INCF   xFE,F
0300E:  BRA    2FE2
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
03010:  BRA    3108
03012:  MOVLB  2
03014:  MOVF   38,W
03016:  SUBLW  02
03018:  BTFSS  FD8.2
0301A:  BRA    310A
.................... 		/* process NMEA0183 sentence */ 
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
0301C:  MOVLB  9
0301E:  MOVF   xFC,W
03020:  SUBLW  05
03022:  BNC   3026
.................... 			return; 
03024:  BRA    3108
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
03026:  CLRF   xFF
03028:  MOVF   xFF,W
0302A:  SUBLW  0B
0302C:  BNC   3108
.................... 			/* compare first six characters or look for wild card */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) && '*' != config.nmea0183_sentence[i][0] ) { 
0302E:  MOVF   xFF,W
03030:  MULLW  06
03032:  MOVF   FF3,W
03034:  CLRF   03
03036:  ADDLW  4F
03038:  MOVWF  01
0303A:  MOVLW  00
0303C:  ADDWFC 03,F
0303E:  MOVFF  01,A00
03042:  MOVLB  A
03044:  MOVFF  03,A01
03048:  MOVLW  08
0304A:  MOVWF  x03
0304C:  MOVLW  FC
0304E:  MOVWF  x02
03050:  MOVFF  03,A05
03054:  MOVFF  01,A04
03058:  CLRF   x07
0305A:  MOVLW  06
0305C:  MOVWF  x06
0305E:  MOVLB  0
03060:  BRA    2E64
03062:  MOVF   01,F
03064:  BZ    3088
03066:  MOVLB  9
03068:  MOVF   xFF,W
0306A:  MULLW  06
0306C:  MOVF   FF3,W
0306E:  CLRF   03
03070:  ADDLW  4F
03072:  MOVWF  FE9
03074:  MOVLW  00
03076:  ADDWFC 03,W
03078:  MOVWF  FEA
0307A:  MOVF   FEF,W
0307C:  SUBLW  2A
0307E:  BTFSS  FD8.2
03080:  BRA    3086
03082:  MOVLB  0
03084:  BRA    3088
.................... 				/* no match */ 
.................... 				continue; 
03086:  BRA    3104
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
03088:  MOVLB  A
0308A:  CLRF   x01
0308C:  MOVFF  9FF,A00
03090:  CLRF   x03
03092:  MOVLW  50
03094:  MOVWF  x02
03096:  MOVLB  0
03098:  CALL   08F4
0309C:  MOVFF  02,03
030A0:  MOVF   01,W
030A2:  ADDLW  04
030A4:  MOVWF  01
030A6:  MOVLW  04
030A8:  ADDWFC 03,F
030AA:  MOVFF  01,A00
030AE:  MOVLB  A
030B0:  MOVFF  03,A01
030B4:  MOVFF  03,A03
030B8:  MOVFF  01,A02
030BC:  MOVLW  08
030BE:  MOVWF  x05
030C0:  MOVLW  FC
030C2:  MOVWF  x04
030C4:  MOVFF  9FC,A06
030C8:  MOVLW  50
030CA:  MOVWF  x07
030CC:  MOVLB  0
030CE:  BRA    2EFC
.................... 			nmea.sentence_age[i]=0; 
030D0:  CLRF   03
030D2:  MOVLB  9
030D4:  MOVFF  9FF,02
030D8:  BCF    FD8.0
030DA:  RLCF   02,F
030DC:  RLCF   03,F
030DE:  MOVF   02,W
030E0:  ADDLW  C4
030E2:  MOVWF  FE9
030E4:  MOVLW  07
030E6:  ADDWFC 03,W
030E8:  MOVWF  FEA
030EA:  CLRF   FEC
030EC:  MOVF   FED,F
030EE:  CLRF   FEF
.................... 			nmea.sentence_length[i]=length; 
030F0:  MOVLW  DC
030F2:  ADDWF  xFF,W
030F4:  MOVWF  FE9
030F6:  MOVLW  07
030F8:  MOVWF  FEA
030FA:  BTFSC  FD8.0
030FC:  INCF   FEA,F
030FE:  MOVFF  9FC,FEF
....................  
.................... 			/* only fill in our first match */ 
.................... 			break; 
03102:  BRA    3108
.................... 		} 
03104:  INCF   xFF,F
03106:  BRA    3028
03108:  MOVLB  2
.................... 	} 
.................... } 
0310A:  MOVLB  0
0310C:  GOTO   3374 (RETURN)
....................  
....................  
.................... void main(void) { 
03110:  CLRF   FF8
03112:  BCF    FF1.2
03114:  BSF    F9F.1
03116:  BCF    F9F.5
03118:  BCF    F9F.4
0311A:  BCF    FA5.5
0311C:  BSF    FD0.7
0311E:  BSF    07.7
03120:  CLRF   FEA
03122:  CLRF   FE9
03124:  CLRF   35
03126:  BCF    FB8.3
03128:  MOVLW  0C
0312A:  MOVWF  FAF
0312C:  MOVLW  A6
0312E:  MOVWF  FAC
03130:  MOVLW  90
03132:  MOVWF  FAB
03134:  BCF    F70.3
03136:  MOVLW  4D
03138:  MOVWF  F75
0313A:  MOVLW  A6
0313C:  MOVWF  F72
0313E:  MOVLW  90
03140:  MOVWF  F71
03142:  MOVLB  7
03144:  BCF    xE8.0
03146:  CLRF   xE9
03148:  MOVLB  8
0314A:  CLRF   xF3
0314C:  MOVLB  7
0314E:  BCF    xE8.1
03150:  BCF    xE8.2
03152:  BCF    xE8.3
03154:  BCF    xE8.4
03156:  BCF    xE8.5
03158:  BCF    xE8.6
0315A:  MOVLB  8
0315C:  CLRF   xF4
0315E:  CLRF   xF6
03160:  CLRF   xF5
03162:  CLRF   xF8
03164:  CLRF   xF7
03166:  CLRF   xFA
03168:  CLRF   xF9
0316A:  MOVF   FC1,W
0316C:  ANDLW  F0
0316E:  MOVWF  FC1
03170:  MOVLW  00
03172:  MOVLB  F
03174:  MOVWF  x38
03176:  MOVWF  x3C
03178:  MOVWF  x39
0317A:  MOVWF  x3A
0317C:  MOVWF  x3B
0317E:  MOVLB  1
03180:  CLRF   x88
03182:  CLRF   F77
03184:  CLRF   F78
03186:  CLRF   F79
03188:  CLRF   2F
0318A:  CLRF   30
0318C:  MOVLB  8
0318E:  CLRF   xEF
03190:  CLRF   xF0
03192:  CLRF   xF1
03194:  CLRF   xF2
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
03196:  MOVF   FD0,W
03198:  ANDLW  0F
0319A:  BTFSS  FD0.4
0319C:  MOVLW  00
0319E:  BSF    FD0.0
031A0:  BSF    FD0.1
031A2:  BSF    FD0.4
031A4:  BSF    FD8.3
031A6:  BSF    FD8.4
031A8:  MOVWF  xFB
....................  
.................... 	init(); 
031AA:  MOVLB  0
031AC:  GOTO   0930
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
031B0:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
031B2:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
031B4:  MOVLW  36
031B6:  MOVWF  FF6
031B8:  MOVLW  08
031BA:  MOVWF  FF7
031BC:  MOVLW  07
031BE:  MOVLB  8
031C0:  MOVWF  xFC
031C2:  MOVLB  0
031C4:  CALL   0AD8
031C8:  MOVLW  42
031CA:  MOVWF  FF6
031CC:  MOVLW  08
031CE:  MOVWF  FF7
031D0:  CALL   0B02
031D4:  MOVLW  0D
031D6:  BTFSS  FA4.4
031D8:  BRA    31D6
031DA:  MOVWF  F73
031DC:  MOVLW  0A
031DE:  BTFSS  FA4.4
031E0:  BRA    31DE
031E2:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
031E4:  MOVLW  4C
031E6:  MOVWF  FF6
031E8:  MOVLW  08
031EA:  MOVWF  FF7
031EC:  MOVLW  12
031EE:  MOVLB  8
031F0:  MOVWF  xFC
031F2:  MOVLB  0
031F4:  CALL   0AD8
031F8:  MOVFF  8FB,8FC
031FC:  MOVLW  1B
031FE:  MOVLB  8
03200:  MOVWF  xFD
03202:  MOVLB  0
03204:  GOTO   0B50
03208:  MOVLW  20
0320A:  BTFSS  FA4.4
0320C:  BRA    320A
0320E:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
03210:  MOVLB  8
03212:  MOVF   xFB,W
03214:  XORLW  07
03216:  MOVLB  0
03218:  BZ    3234
0321A:  XORLW  0C
0321C:  BZ    3242
0321E:  XORLW  04
03220:  BZ    3250
03222:  XORLW  03
03224:  BZ    325E
03226:  XORLW  02
03228:  BZ    326C
0322A:  XORLW  0D
0322C:  BZ    327A
0322E:  XORLW  03
03230:  BZ    3288
03232:  BRA    3296
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
03234:  MOVLW  62
03236:  MOVWF  FF6
03238:  MOVLW  08
0323A:  MOVWF  FF7
0323C:  CALL   0B02
03240:  BRA    32A2
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
03242:  MOVLW  6E
03244:  MOVWF  FF6
03246:  MOVLW  08
03248:  MOVWF  FF7
0324A:  CALL   0B02
0324E:  BRA    32A2
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
03250:  MOVLW  7E
03252:  MOVWF  FF6
03254:  MOVLW  08
03256:  MOVWF  FF7
03258:  CALL   0B02
0325C:  BRA    32A2
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
0325E:  MOVLW  8C
03260:  MOVWF  FF6
03262:  MOVLW  08
03264:  MOVWF  FF7
03266:  CALL   0B02
0326A:  BRA    32A2
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
0326C:  MOVLW  9C
0326E:  MOVWF  FF6
03270:  MOVLW  08
03272:  MOVWF  FF7
03274:  CALL   0B02
03278:  BRA    32A2
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
0327A:  MOVLW  AE
0327C:  MOVWF  FF6
0327E:  MOVLW  08
03280:  MOVWF  FF7
03282:  CALL   0B02
03286:  BRA    32A2
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
03288:  MOVLW  BE
0328A:  MOVWF  FF6
0328C:  MOVLW  08
0328E:  MOVWF  FF7
03290:  CALL   0B02
03294:  BRA    32A2
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
03296:  MOVLW  D0
03298:  MOVWF  FF6
0329A:  MOVLW  08
0329C:  MOVWF  FF7
0329E:  CALL   0B02
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
032A2:  MOVLW  DA
032A4:  MOVWF  FF6
032A6:  MOVLW  08
032A8:  MOVWF  FF7
032AA:  CALL   0B02
.................... #endif 
....................  
....................  
.................... 	read_param_file(); 
032AE:  GOTO   0E2C
.................... 	set_rs485_speed(); 
032B2:  CALL   0E84
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
032B6:  MOVF   36,W
032B8:  SUBLW  80
032BA:  BC    32C0
.................... 		write_default_param_file(); 
032BC:  CALL   0D68
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
032C0:  BSF    FAB.7
032C2:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	modbus_init(); 
032C4:  GOTO   0F12
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
032C8:  MOVLB  8
032CA:  CLRF   xFB
032CC:  MOVF   xFB,W
032CE:  SUBLW  1D
032D0:  BNC   32DE
.................... 		adc_update(); 
032D2:  MOVLB  0
032D4:  CALL   0FEC
.................... 	} 
032D8:  MOVLB  8
032DA:  INCF   xFB,F
032DC:  BRA    32CC
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
032DE:  MOVFF  44,1DB
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
032E2:  BTFSS  F72.1
032E4:  BRA    32E2
.................... 	output_low(RS485_DE); 
032E6:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
032E8:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
032EA:  MOVLW  DE
032EC:  MOVWF  FF6
032EE:  MOVLW  08
032F0:  MOVWF  FF7
032F2:  MOVLW  07
032F4:  MOVWF  xFC
032F6:  MOVLB  0
032F8:  GOTO   1094
032FC:  MOVLW  EA
032FE:  MOVWF  FF6
03300:  MOVLW  08
03302:  MOVWF  FF7
03304:  GOTO   10C0
03308:  MOVLW  0D
0330A:  BTFSS  F9E.4
0330C:  BRA    330A
0330E:  MOVWF  FAD
03310:  MOVLW  0A
03312:  BTFSS  F9E.4
03314:  BRA    3312
03316:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
03318:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
0331A:  MOVLB  1
0331C:  BTFSS  xFB.2
0331E:  BRA    3328
.................... 			periodic_millisecond(); 
03320:  MOVLB  0
03322:  GOTO   10E4
03326:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
03328:  BTFSS  xFB.0
0332A:  BRA    3334
.................... 			timers.now_adc_sample=0; 
0332C:  BCF    xFB.0
.................... 			adc_update(); 
0332E:  MOVLB  0
03330:  CALL   0FEC
.................... 		} 
....................  
.................... 		modbus_process(); 
03334:  MOVLB  0
03336:  BRA    2B5A
....................  
....................  
.................... 		/* buffered modbus transmit */ 
....................  
.................... 		/* start transmitting */ 
.................... 		if ( timers.now_rda_tx_ready ) { 
03338:  MOVLB  4
0333A:  BTFSS  x03.0
0333C:  BRA    3350
.................... 			timers.now_rda_tx_ready=0; 
0333E:  BCF    x03.0
....................  
.................... //			output_high(_PIC_TO_PI); 
....................  
.................... 			RCV_OFF(); 
03340:  BCF    F9D.5
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
03342:  CLRWDT
03344:  MOVLW  3C
03346:  MOVWF  00
03348:  DECFSZ 00,F
0334A:  BRA    3348
0334C:  NOP   
....................  
.................... 			/* enable transmit buffer empty interrupt. It will feed itself */ 
.................... 			enable_interrupts(INT_TBE); 
0334E:  BSF    F9D.4
.................... 		} 
....................  
.................... 		/* done transmitting */ 
.................... 		if ( timers.now_rda_tx_done ) { 
03350:  BTFSS  x03.1
03352:  BRA    3368
.................... 			timers.now_rda_tx_done=0; 
03354:  BCF    x03.1
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
03356:  CLRWDT
03358:  MOVLW  3C
0335A:  MOVWF  00
0335C:  DECFSZ 00,F
0335E:  BRA    335C
03360:  NOP   
....................    			RCV_ON(); 
03362:  MOVLB  0
03364:  CALL   0F06
....................  
.................... //			output_low(_PIC_TO_PI); 
.................... 		} 
....................  
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
03368:  MOVLB  1
0336A:  BTFSS  xFE.0
0336C:  BRA    3376
.................... 			timers.now_parse_rda2=0; 
0336E:  BCF    xFE.0
.................... 			rs485_to_host(); 
03370:  MOVLB  0
03372:  BRA    2FAA
03374:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
03376:  MOVLB  0
03378:  BRA    3318
.................... } 
0337A:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
