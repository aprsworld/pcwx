CCS PCH C Compiler, Version 4.135, 4375               23-Nov-15 16:26

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 11594 bytes (18%)
                         Largest free fragment is 53938
               RAM used: 2264 (58%) at main() level
                         2540 (65%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   2B14
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   0410
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0760
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   069E
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   0442
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02950:  MOVLB  9
02952:  MOVF   xE2,F
02954:  BNZ   295A
02956:  MOVF   xE3,F
02958:  BZ    29DE
....................       if (*s1 != *s2) 
0295A:  MOVFF  9DE,FE9
0295E:  MOVFF  9DF,FEA
02962:  MOVFF  FEF,9E4
02966:  MOVFF  9E1,03
0296A:  MOVFF  9E0,FE9
0296E:  MOVFF  9E1,FEA
02972:  MOVF   FEF,W
02974:  SUBWF  xE4,W
02976:  BZ    29A6
....................          return((*s1 <*s2) ? -1: 1); 
02978:  MOVFF  9DF,03
0297C:  MOVFF  9DE,FE9
02980:  MOVFF  9DF,FEA
02984:  MOVFF  FEF,9E4
02988:  MOVFF  9E1,03
0298C:  MOVFF  9E0,FE9
02990:  MOVFF  9E1,FEA
02994:  MOVF   FEF,W
02996:  SUBWF  xE4,W
02998:  BC    299E
0299A:  MOVLW  FF
0299C:  BRA    29A0
0299E:  MOVLW  01
029A0:  MOVWF  01
029A2:  BRA    29E2
....................       else if (*s1 == '\0') 
029A4:  BRA    29BC
029A6:  MOVFF  9DF,03
029AA:  MOVFF  9DE,FE9
029AE:  MOVFF  9DF,FEA
029B2:  MOVF   FEF,F
029B4:  BNZ   29BC
....................          return(0); 
029B6:  MOVLW  00
029B8:  MOVWF  01
029BA:  BRA    29E2
029BC:  MOVFF  9DF,03
029C0:  MOVF   xDE,W
029C2:  INCF   xDE,F
029C4:  BTFSC  FD8.2
029C6:  INCF   xDF,F
029C8:  MOVFF  9E1,03
029CC:  MOVF   xE0,W
029CE:  INCF   xE0,F
029D0:  BTFSC  FD8.2
029D2:  INCF   xE1,F
029D4:  MOVF   xE2,W
029D6:  BTFSC  FD8.2
029D8:  DECF   xE3,F
029DA:  DECF   xE2,F
029DC:  BRA    2952
....................    return(0); 
029DE:  MOVLW  00
029E0:  MOVWF  01
.................... } 
029E2:  MOVLB  0
029E4:  GOTO   2AB8 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
01188:  MOVLW  05
0118A:  MOVLB  8
0118C:  SUBWF  xDF,F
0118E:  BNC   11A4
01190:  MOVLW  08
01192:  MOVWF  FEA
01194:  MOVLW  DF
01196:  MOVWF  FE9
01198:  MOVF   FEF,W
0119A:  BZ    11A4
0119C:  BRA    11A0
0119E:  CLRWDT
011A0:  DECFSZ FEF,F
011A2:  BRA    119E
011A4:  MOVLB  0
011A6:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
0071E:  BTFSS  F9E.5
00720:  BRA    071E
00722:  MOVFF  FAB,35
00726:  MOVFF  FAE,01
0072A:  BTFSS  35.1
0072C:  BRA    0732
0072E:  BCF    FAB.4
00730:  BSF    FAB.4
00732:  RETURN 0
*
0129E:  BTFSS  F9E.4
012A0:  BRA    129E
012A2:  MOVWF  FAD
012A4:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00686:  BTFSS  FA4.5
00688:  BRA    0686
0068A:  MOVFF  F71,35
0068E:  MOVFF  F74,01
00692:  BTFSS  35.1
00694:  BRA    069A
00696:  BCF    F71.4
00698:  BSF    F71.4
0069A:  GOTO   06A0 (RETURN)
*
011A8:  BTFSS  FA4.4
011AA:  BRA    11A8
011AC:  MOVWF  F73
011AE:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define _PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
....................  
.................... 	/* transmit buffer for PIC to PI */ 
.................... 	int8 rda_tx_buff[256]; 
.................... 	int8 rda_tx_length; 
.................... 	int8 rda_tx_pos; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][80]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00EF2:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00E52:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00E54:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00E56:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00E58:  MOVLB  8
00E5A:  MOVF   xDB,F
00E5C:  BNZ   0E64
.................... 		c=0b00011; 
00E5E:  MOVLW  03
00E60:  MOVWF  xDF
.................... 	else if ( 1 == ch )  
00E62:  BRA    0EAE
00E64:  DECFSZ xDB,W
00E66:  BRA    0E6E
.................... 		c=0b10011; 
00E68:  MOVLW  13
00E6A:  MOVWF  xDF
.................... 	else if ( 2 == ch )  
00E6C:  BRA    0EAE
00E6E:  MOVF   xDB,W
00E70:  SUBLW  02
00E72:  BNZ   0E7A
.................... 		c=0b01011; 
00E74:  MOVLW  0B
00E76:  MOVWF  xDF
.................... 	else if ( 3 == ch )  
00E78:  BRA    0EAE
00E7A:  MOVF   xDB,W
00E7C:  SUBLW  03
00E7E:  BNZ   0E86
.................... 		c=0b11011; 
00E80:  MOVLW  1B
00E82:  MOVWF  xDF
.................... 	else if ( 4 == ch ) 
00E84:  BRA    0EAE
00E86:  MOVF   xDB,W
00E88:  SUBLW  04
00E8A:  BNZ   0E92
.................... 		c=0b00111; 
00E8C:  MOVLW  07
00E8E:  MOVWF  xDF
.................... 	else if ( 5 == ch )  
00E90:  BRA    0EAE
00E92:  MOVF   xDB,W
00E94:  SUBLW  05
00E96:  BNZ   0E9E
.................... 		c=0b10111; 
00E98:  MOVLW  17
00E9A:  MOVWF  xDF
.................... 	else if ( 6 == ch ) 
00E9C:  BRA    0EAE
00E9E:  MOVF   xDB,W
00EA0:  SUBLW  06
00EA2:  BNZ   0EAA
.................... 		c=0b01111; 
00EA4:  MOVLW  0F
00EA6:  MOVWF  xDF
.................... 	else 
00EA8:  BRA    0EAE
.................... 		c=0b11111; 
00EAA:  MOVLW  1F
00EAC:  MOVWF  xDF
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00EAE:  CLRF   xDE
00EB0:  MOVF   xDE,W
00EB2:  SUBLW  04
00EB4:  BNC   0ECC
.................... 		output_low(MCP3208_CLK); 
00EB6:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00EB8:  BTFSC  xDF.0
00EBA:  BRA    0EC0
00EBC:  BCF    F8B.5
00EBE:  BRA    0EC2
00EC0:  BSF    F8B.5
.................... 		c=c>>1; 
00EC2:  BCF    FD8.0
00EC4:  RRCF   xDF,F
.................... 		output_high(MCP3208_CLK); 
00EC6:  BSF    F8B.3
.................... 	} 
00EC8:  INCF   xDE,F
00ECA:  BRA    0EB0
....................  
....................  
.................... 	value=0; 
00ECC:  CLRF   xDD
00ECE:  CLRF   xDC
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00ED0:  CLRF   xDE
00ED2:  MOVF   xDE,W
00ED4:  SUBLW  0D
00ED6:  BNC   0EEE
.................... 		output_low(MCP3208_CLK); 
00ED8:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00EDA:  BTFSC  F82.4
00EDC:  BRA    0EE2
00EDE:  BCF    FD8.0
00EE0:  BRA    0EE4
00EE2:  BSF    FD8.0
00EE4:  RLCF   xDC,F
00EE6:  RLCF   xDD,F
.................... 		output_high(MCP3208_CLK); 
00EE8:  BSF    F8B.3
.................... 	} 
00EEA:  INCF   xDE,F
00EEC:  BRA    0ED2
....................  
.................... 	bit_clear(value,13); 
00EEE:  BCF    xDD.5
.................... 	bit_clear(value,12); 
00EF0:  BCF    xDD.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00EF4:  MOVFF  8DC,01
00EF8:  MOVFF  8DD,02
.................... } 
00EFC:  MOVLB  0
00EFE:  GOTO   0F70 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
013B0:  MOVLB  9
013B2:  CLRF   xDD
013B4:  MOVFF  8F0,9DC
013B8:  CLRF   xDF
013BA:  MOVLW  20
013BC:  MOVWF  xDE
013BE:  MOVLB  0
013C0:  CALL   0890
013C4:  MOVFF  02,03
013C8:  MOVF   01,W
013CA:  ADDLW  CB
013CC:  MOVWF  01
013CE:  MOVLW  00
013D0:  ADDWFC 03,F
013D2:  MOVFF  01,8F4
013D6:  MOVLB  8
013D8:  MOVFF  03,8F5
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
013DC:  CLRF   xF2
013DE:  CLRF   xF1
.................... 	for( i = 0; i < 16 ; i++ ) { 
013E0:  CLRF   xF3
013E2:  MOVF   xF3,W
013E4:  SUBLW  0F
013E6:  BNC   140A
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
013E8:  BCF    FD8.0
013EA:  RLCF   xF3,W
013EC:  CLRF   03
013EE:  ADDWF  xF4,W
013F0:  MOVWF  FE9
013F2:  MOVF   xF5,W
013F4:  ADDWFC 03,W
013F6:  MOVWF  FEA
013F8:  MOVFF  FEC,03
013FC:  MOVF   FED,F
013FE:  MOVF   FEF,W
01400:  ADDWF  xF1,F
01402:  MOVF   03,W
01404:  ADDWFC xF2,F
.................... 	} 
01406:  INCF   xF3,F
01408:  BRA    13E2
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
0140A:  MOVLW  08
0140C:  ADDWF  xF1,W
0140E:  MOVWF  xF6
01410:  MOVLW  00
01412:  ADDWFC xF2,W
01414:  MOVWF  xF7
01416:  RRCF   xF7,W
01418:  MOVWF  03
0141A:  RRCF   xF6,W
0141C:  MOVWF  02
0141E:  RRCF   03,F
01420:  RRCF   02,F
01422:  RRCF   03,F
01424:  RRCF   02,F
01426:  RRCF   03,F
01428:  RRCF   02,F
0142A:  MOVLW  0F
0142C:  ANDWF  03,F
0142E:  MOVFF  02,01
01432:  MOVFF  03,02
.................... } 
01436:  MOVLB  0
01438:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00F02:  MOVLB  1
00F04:  INCF   xCB,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00F06:  MOVF   xCB,W
00F08:  SUBLW  0F
00F0A:  BC    0F0E
.................... 		current.adc_buffer_index=0; 
00F0C:  CLRF   xCB
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00F0E:  MOVLB  8
00F10:  CLRF   xD8
00F12:  MOVF   xD8,W
00F14:  SUBLW  07
00F16:  BNC   0FA6
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00F18:  MOVLB  9
00F1A:  CLRF   xDD
00F1C:  MOVFF  8D8,9DC
00F20:  CLRF   xDF
00F22:  MOVLW  20
00F24:  MOVWF  xDE
00F26:  MOVLB  0
00F28:  RCALL  0890
00F2A:  MOVFF  02,03
00F2E:  MOVF   01,W
00F30:  ADDLW  34
00F32:  MOVLB  8
00F34:  MOVWF  xD9
00F36:  MOVLW  00
00F38:  ADDWFC 02,W
00F3A:  MOVWF  xDA
00F3C:  CLRF   03
00F3E:  MOVLB  1
00F40:  MOVFF  1CB,02
00F44:  BCF    FD8.0
00F46:  RLCF   02,F
00F48:  RLCF   03,F
00F4A:  MOVF   02,W
00F4C:  MOVLB  8
00F4E:  ADDWF  xD9,W
00F50:  MOVWF  01
00F52:  MOVF   xDA,W
00F54:  ADDWFC 03,F
00F56:  MOVF   01,W
00F58:  ADDLW  97
00F5A:  MOVWF  01
00F5C:  MOVLW  00
00F5E:  ADDWFC 03,F
00F60:  MOVFF  01,8D9
00F64:  MOVFF  03,8DA
00F68:  MOVFF  8D8,8DB
00F6C:  MOVLB  0
00F6E:  BRA    0E52
00F70:  MOVFF  8DA,FEA
00F74:  MOVFF  8D9,FE9
00F78:  MOVFF  02,FEC
00F7C:  MOVF   FED,F
00F7E:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00F82:  CLRF   03
00F84:  MOVLB  8
00F86:  MOVFF  8D8,02
00F8A:  BCF    FD8.0
00F8C:  RLCF   02,F
00F8E:  RLCF   03,F
00F90:  MOVF   02,W
00F92:  ADDLW  BB
00F94:  MOVWF  FE9
00F96:  MOVLW  00
00F98:  ADDWFC 03,W
00F9A:  MOVWF  FEA
00F9C:  CLRF   FEC
00F9E:  MOVF   FED,F
00FA0:  CLRF   FEF
....................  
.................... 	} 
00FA2:  INCF   xD8,F
00FA4:  BRA    0F12
.................... } 
00FA6:  MOVLB  0
00FA8:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00C24:  MOVF   xF5,W
00C26:  XORWF  xF6,W
00C28:  MOVWF  01
*
00C76:  MOVF   xF5,W
00C78:  XORWF  xF6,W
00C7A:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00BAE:  MOVLB  8
00BB0:  CLRF   xE1
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BB2:  MOVFF  8E0,03
00BB6:  MOVF   xDF,W
00BB8:  BTFSC  FD8.2
00BBA:  DECF   xE0,F
00BBC:  DECF   xDF,F
00BBE:  MOVWF  xE2
00BC0:  MOVFF  03,8E3
00BC4:  MOVF   xE2,F
00BC6:  BNZ   0BCC
00BC8:  MOVF   xE3,F
00BCA:  BZ    0C36
.................... 		*data = read_eeprom( address++ ); 
00BCC:  MOVFF  8DE,03
00BD0:  MOVF   xDD,W
00BD2:  MOVWF  FE9
00BD4:  MOVFF  03,FEA
00BD8:  MOVF   xDC,W
00BDA:  MOVWF  03
00BDC:  MOVF   xDB,W
00BDE:  INCF   xDB,F
00BE0:  BTFSC  FD8.2
00BE2:  INCF   xDC,F
00BE4:  MOVWF  xE4
00BE6:  MOVFF  03,8E5
00BEA:  MOVFF  FF2,8E6
00BEE:  BCF    FF2.6
00BF0:  BCF    FF2.7
00BF2:  MOVFF  8E5,FAA
00BF6:  MOVFF  8E4,FA9
00BFA:  BCF    FA6.6
00BFC:  BCF    FA6.7
00BFE:  BSF    FA6.0
00C00:  MOVF   FA8,W
00C02:  BTFSC  xE6.6
00C04:  BSF    FF2.6
00C06:  BTFSC  xE6.7
00C08:  BSF    FF2.7
00C0A:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00C0C:  MOVFF  8DE,03
00C10:  MOVF   xDD,W
00C12:  MOVWF  FE9
00C14:  MOVFF  03,FEA
00C18:  MOVFF  FEF,8E2
00C1C:  MOVFF  8E1,8F5
00C20:  MOVFF  8E2,8F6
*
00C2A:  MOVFF  01,8E1
.................... 		data++; 
00C2E:  INCF   xDD,F
00C30:  BTFSC  FD8.2
00C32:  INCF   xDE,F
.................... 	} 
00C34:  BRA    0BB2
.................... 	return crc; 
00C36:  MOVFF  8E1,01
.................... } 
00C3A:  MOVLB  0
00C3C:  GOTO   0E06 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00C40:  MOVLB  8
00C42:  CLRF   xF3
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00C44:  MOVFF  8F2,03
00C48:  MOVF   xF1,W
00C4A:  BTFSC  FD8.2
00C4C:  DECF   xF2,F
00C4E:  DECF   xF1,F
00C50:  MOVWF  xF4
00C52:  MOVFF  03,8F5
00C56:  MOVF   xF4,F
00C58:  BNZ   0C5E
00C5A:  MOVF   xF5,F
00C5C:  BZ    0CDC
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00C5E:  MOVFF  8F0,03
00C62:  MOVF   xEF,W
00C64:  MOVWF  FE9
00C66:  MOVFF  03,FEA
00C6A:  MOVFF  FEF,8F4
00C6E:  MOVFF  8F3,8F5
00C72:  MOVFF  8F4,8F6
*
00C7C:  MOVFF  01,8F3
.................... 		write_eeprom( address++, *data++ ); 
00C80:  MOVF   xEE,W
00C82:  MOVWF  03
00C84:  MOVF   xED,W
00C86:  INCF   xED,F
00C88:  BTFSC  FD8.2
00C8A:  INCF   xEE,F
00C8C:  MOVWF  xF4
00C8E:  MOVFF  03,8F5
00C92:  MOVF   xF0,W
00C94:  MOVWF  03
00C96:  MOVF   xEF,W
00C98:  INCF   xEF,F
00C9A:  BTFSC  FD8.2
00C9C:  INCF   xF0,F
00C9E:  MOVWF  FE9
00CA0:  MOVFF  03,FEA
00CA4:  MOVFF  FEF,8F6
00CA8:  MOVFF  8F5,FAA
00CAC:  MOVFF  8F4,FA9
00CB0:  MOVFF  8F6,FA8
00CB4:  BCF    FA6.6
00CB6:  BCF    FA6.7
00CB8:  BSF    FA6.2
00CBA:  MOVF   FF2,W
00CBC:  MOVWF  00
00CBE:  BCF    FF2.6
00CC0:  BCF    FF2.7
00CC2:  MOVLB  F
00CC4:  MOVLW  55
00CC6:  MOVWF  FA7
00CC8:  MOVLW  AA
00CCA:  MOVWF  FA7
00CCC:  BSF    FA6.1
00CCE:  BTFSC  FA6.1
00CD0:  BRA    0CCE
00CD2:  BCF    FA6.2
00CD4:  MOVF   00,W
00CD6:  IORWF  FF2,F
.................... 	} 
00CD8:  MOVLB  8
00CDA:  BRA    0C44
....................  
.................... 	return crc; 
00CDC:  MOVFF  8F3,01
.................... } 
00CE0:  MOVLB  0
00CE2:  GOTO   0D06 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00CE6:  MOVLB  8
00CE8:  CLRF   xEC
00CEA:  MOVLW  36
00CEC:  MOVWF  xEB
00CEE:  CLRF   xEE
00CF0:  MOVLW  02
00CF2:  MOVWF  xED
00CF4:  MOVFF  8EC,8F0
00CF8:  MOVFF  8EB,8EF
00CFC:  CLRF   xF2
00CFE:  MOVLW  61
00D00:  MOVWF  xF1
00D02:  MOVLB  0
00D04:  BRA    0C40
00D06:  MOVFF  01,8EA
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00D0A:  CLRF   FAA
00D0C:  CLRF   FA9
00D0E:  MOVFF  8EA,FA8
00D12:  BCF    FA6.6
00D14:  BCF    FA6.7
00D16:  BSF    FA6.2
00D18:  MOVF   FF2,W
00D1A:  MOVWF  00
00D1C:  BCF    FF2.6
00D1E:  BCF    FF2.7
00D20:  MOVLB  F
00D22:  MOVLW  55
00D24:  MOVWF  FA7
00D26:  MOVLW  AA
00D28:  MOVWF  FA7
00D2A:  BSF    FA6.1
00D2C:  BTFSC  FA6.1
00D2E:  BRA    0D2C
00D30:  BCF    FA6.2
00D32:  MOVF   00,W
00D34:  IORWF  FF2,F
.................... } 
00D36:  MOVLB  0
00D38:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00D3A:  MOVLW  96
00D3C:  MOVLB  1
00D3E:  MOVWF  xF7
....................  
.................... 	config.modbus_address=38; 
00D40:  MOVLW  26
00D42:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00D44:  MOVLW  03
00D46:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00D48:  MOVLW  02
00D4A:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00D4C:  MOVLW  50
00D4E:  MOVWF  3A
.................... 	config.serial_number=9876; 
00D50:  MOVLW  26
00D52:  MOVWF  3C
00D54:  MOVLW  94
00D56:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00D58:  CLRF   3E
00D5A:  MOVLW  14
00D5C:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00D5E:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00D60:  MOVLW  02
00D62:  MOVWF  41
00D64:  MOVLW  76
00D66:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00D68:  CLRF   43
00D6A:  MOVLW  02
00D6C:  MOVWF  42
.................... 	config.power_startup=0; 
00D6E:  CLRF   44
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00D70:  CLRF   FEA
00D72:  MOVLW  4F
00D74:  MOVWF  FE9
00D76:  CLRF   00
00D78:  CLRF   02
00D7A:  MOVLW  48
00D7C:  MOVWF  01
00D7E:  MOVLB  0
00D80:  RCALL  08B2
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00D82:  CLRF   FEA
00D84:  MOVLW  4F
00D86:  MOVWF  FE9
00D88:  MOVLW  00
00D8A:  CALL   017C
00D8E:  TBLRD*-
00D90:  TBLRD*+
00D92:  MOVF   FF5,W
00D94:  MOVWF  FEE
00D96:  IORLW  00
00D98:  BNZ   0D90
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00D9A:  CLRF   FEA
00D9C:  MOVLW  55
00D9E:  MOVWF  FE9
00DA0:  MOVLW  00
00DA2:  CALL   0194
00DA6:  TBLRD*-
00DA8:  TBLRD*+
00DAA:  MOVF   FF5,W
00DAC:  MOVWF  FEE
00DAE:  IORLW  00
00DB0:  BNZ   0DA8
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00DB2:  CLRF   FEA
00DB4:  MOVLW  5B
00DB6:  MOVWF  FE9
00DB8:  MOVLW  00
00DBA:  CALL   01AC
00DBE:  TBLRD*-
00DC0:  TBLRD*+
00DC2:  MOVF   FF5,W
00DC4:  MOVWF  FEE
00DC6:  IORLW  00
00DC8:  BNZ   0DC0
....................  
.................... 	strcpy(config.nmea0183_sentence[10],"$WIMDA"); 
00DCA:  CLRF   FEA
00DCC:  MOVLW  8B
00DCE:  MOVWF  FE9
00DD0:  MOVLW  00
00DD2:  CALL   01C4
00DD6:  TBLRD*-
00DD8:  TBLRD*+
00DDA:  MOVF   FF5,W
00DDC:  MOVWF  FEE
00DDE:  IORLW  00
00DE0:  BNZ   0DD8
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00DE2:  RCALL  0CE6
....................  
.................... } 
00DE4:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00DE6:  MOVLB  8
00DE8:  CLRF   xDA
00DEA:  MOVLW  36
00DEC:  MOVWF  xD9
00DEE:  CLRF   xDC
00DF0:  MOVLW  02
00DF2:  MOVWF  xDB
00DF4:  MOVFF  8DA,8DE
00DF8:  MOVFF  8D9,8DD
00DFC:  CLRF   xE0
00DFE:  MOVLW  61
00E00:  MOVWF  xDF
00E02:  MOVLB  0
00E04:  BRA    0BAE
00E06:  MOVFF  01,8D8
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00E0A:  MOVFF  FF2,8D9
00E0E:  BCF    FF2.6
00E10:  BCF    FF2.7
00E12:  CLRF   FAA
00E14:  CLRF   FA9
00E16:  BCF    FA6.6
00E18:  BCF    FA6.7
00E1A:  BSF    FA6.0
00E1C:  MOVF   FA8,W
00E1E:  MOVLB  8
00E20:  BTFSC  xD9.6
00E22:  BSF    FF2.6
00E24:  BTFSC  xD9.7
00E26:  BSF    FF2.7
00E28:  SUBWF  xD8,W
00E2A:  BZ    0E32
.................... 		write_default_param_file(); 
00E2C:  MOVLB  0
00E2E:  RCALL  0D3A
00E30:  MOVLB  8
.................... 	} 
.................... } 
00E32:  MOVLB  0
00E34:  GOTO   2CB8 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
012F6:  BTFSS  FAC.1
012F8:  BRA    12F6
.................... } 
012FA:  GOTO   1314 (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00E38:  BTFSS  F9E.5
00E3A:  BRA    0E40
.................... 		fgetc(STREAM_PI); 
00E3C:  RCALL  071E
.................... 	} 
00E3E:  BRA    0E38
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00E40:  BSF    F9D.5
.................... } 
00E42:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00E44:  RCALL  0E38
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00E46:  MOVLW  C6
00E48:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00E4A:  MOVLW  C0
00E4C:  IORWF  FF2,F
.................... } 
00E4E:  GOTO   2CCA (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
003FC:  BCF    FF2.5
.................... 	if (enable) { 
003FE:  MOVLB  9
00400:  MOVF   xE9,F
00402:  BZ    040C
.................... 		set_timer0(0); 
00404:  CLRF   FD7
00406:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00408:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
0040A:  BSF    FF2.5
.................... 	} 
.................... } 
0040C:  MOVLB  0
0040E:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
00410:  MOVLB  7
00412:  MOVF   xC3,W
00414:  SUBLW  02
00416:  BNZ   042C
00418:  MOVF   xC4,F
0041A:  BNZ   042C
0041C:  MOVF   xC5,F
0041E:  BNZ   042C
00420:  BTFSC  xC2.0
00422:  BRA    042C
....................    { 
....................       modbus_rx.len-=2; 
00424:  MOVLW  02
00426:  SUBWF  xC7,F
....................       modbus_serial_new=TRUE; 
00428:  BSF    xC2.0
....................    } 
....................    else 
0042A:  BRA    042E
....................       modbus_serial_new=FALSE; 
0042C:  BCF    xC2.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0042E:  SETF   xC5
00430:  SETF   xC4
....................    modbus_serial_state=MODBUS_GETADDY; 
00432:  CLRF   xC3
....................    modbus_enable_timeout(FALSE); 
00434:  MOVLB  9
00436:  CLRF   xE9
00438:  MOVLB  0
0043A:  RCALL  03FC
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0043C:  BCF    FF2.2
0043E:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00734:  MOVLB  7
00736:  MOVF   xC5,W
00738:  MOVLB  9
0073A:  XORWF  xE9,W
0073C:  MOVWF  xEA
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0073E:  CLRF   03
00740:  MOVF   xEA,W
00742:  MOVLB  0
00744:  RCALL  01DC
00746:  MOVWF  01
00748:  MOVLB  7
0074A:  MOVF   xC4,W
0074C:  XORWF  01,W
0074E:  MOVWF  xC5
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00750:  CLRF   03
00752:  MOVLB  9
00754:  MOVF   xEA,W
00756:  MOVLB  0
00758:  RCALL  02EC
0075A:  MOVFF  FE8,7C4
.................... } 
0075E:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
012A6:  MOVLB  8
012A8:  MOVF   xEA,W
012AA:  MOVLB  0
012AC:  RCALL  129E
012AE:  CLRF   19
012B0:  BTFSC  FF2.6
012B2:  BSF    19.6
012B4:  BCF    FF2.6
012B6:  BTFSC  FF2.7
012B8:  BSF    19.7
012BA:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
012BC:  MOVFF  8EA,9E9
012C0:  CALL   0734
012C4:  BTFSC  19.6
012C6:  BSF    FF2.6
012C8:  BTFSC  19.7
012CA:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... //	delay_us(9); 
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
012CC:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
.................... 	output_high(_PIC_TO_PI); 
012CE:  BSF    F8C.3
....................    modbus_serial_crc.d=0xFFFF; 
012D0:  MOVLB  7
012D2:  SETF   xC5
012D4:  SETF   xC4
....................    modbus_serial_new=FALSE; 
012D6:  BCF    xC2.0
....................  
....................    RCV_OFF(); 
012D8:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
012DA:  CLRWDT
012DC:  MOVLW  3C
012DE:  MOVWF  00
012E0:  DECFSZ 00,F
012E2:  BRA    12E0
012E4:  NOP   
....................  
....................    modbus_serial_putc(to); 
012E6:  MOVFF  8E8,8EA
012EA:  MOVLB  0
012EC:  RCALL  12A6
....................    modbus_serial_putc(func); 
012EE:  MOVFF  8E9,8EA
012F2:  RCALL  12A6
.................... } 
012F4:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
012FE:  MOVFF  7C5,8E9
....................    crc_low=modbus_serial_crc.b[0]; 
01302:  MOVFF  7C4,8E8
....................  
....................    modbus_serial_putc(crc_high); 
01306:  MOVFF  8E9,8EA
0130A:  RCALL  12A6
....................    modbus_serial_putc(crc_low); 
0130C:  MOVFF  8E8,8EA
01310:  RCALL  12A6
....................  
....................    WAIT_FOR_HW_BUFFER(); 
01312:  BRA    12F6
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
01314:  CLRWDT
01316:  MOVLW  3C
01318:  MOVWF  00
0131A:  DECFSZ 00,F
0131C:  BRA    131A
0131E:  NOP   
....................  
....................  
....................    RCV_ON(); 
01320:  RCALL  0E38
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
01322:  MOVLB  7
01324:  SETF   xC5
01326:  SETF   xC4
.................... 	output_low(_PIC_TO_PI); 
01328:  BCF    F8C.3
.................... } 
0132A:  MOVLB  0
0132C:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
01162:  MOVLB  7
01164:  BTFSC  xC2.0
01166:  BRA    1170
....................       return FALSE; 
01168:  MOVLW  00
0116A:  MOVWF  01
0116C:  BRA    1182
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
0116E:  BRA    117C
01170:  BTFSS  xC8.7
01172:  BRA    117C
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
01174:  MOVFF  7CA,7C9
....................       modbus_rx.len = 1; 
01178:  MOVLW  01
0117A:  MOVWF  xC7
....................    } 
....................    modbus_serial_new=FALSE; 
0117C:  BCF    xC2.0
....................    return TRUE; 
0117E:  MOVLW  01
01180:  MOVWF  01
.................... } 
01182:  MOVLB  0
01184:  GOTO   25BC (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02528:  MOVFF  8E0,8E8
0252C:  MOVLW  06
0252E:  MOVLB  8
02530:  MOVWF  xE9
02532:  MOVLB  0
02534:  CALL   12CE
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02538:  MOVFF  8E2,8E5
0253C:  MOVFF  8E2,8EA
02540:  CALL   12A6
....................    modbus_serial_putc(make8(reg_address,0)); 
02544:  MOVFF  8E1,8E5
02548:  MOVFF  8E1,8EA
0254C:  CALL   12A6
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02550:  MOVFF  8E4,8E5
02554:  MOVFF  8E4,8EA
02558:  CALL   12A6
....................    modbus_serial_putc(make8(reg_value,0)); 
0255C:  MOVFF  8E3,8E5
02560:  MOVFF  8E3,8EA
02564:  CALL   12A6
....................  
....................    modbus_serial_send_stop(); 
02568:  CALL   12FE
.................... } 
0256C:  GOTO   27A0 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02570:  MOVFF  8DE,8E8
02574:  MOVLW  10
02576:  MOVLB  8
02578:  MOVWF  xE9
0257A:  MOVLB  0
0257C:  CALL   12CE
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02580:  MOVFF  8E0,8E3
02584:  MOVFF  8E0,8EA
02588:  CALL   12A6
....................    modbus_serial_putc(make8(start_address,0)); 
0258C:  MOVFF  8DF,8E3
02590:  MOVFF  8DF,8EA
02594:  CALL   12A6
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02598:  MOVFF  8E2,8E3
0259C:  MOVFF  8E2,8EA
025A0:  CALL   12A6
....................    modbus_serial_putc(make8(quantity,0)); 
025A4:  MOVFF  8E1,8E3
025A8:  MOVFF  8E1,8EA
025AC:  CALL   12A6
....................  
....................    modbus_serial_send_stop(); 
025B0:  CALL   12FE
.................... } 
025B4:  GOTO   2862 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0132E:  MOVLB  8
01330:  MOVF   xDF,W
01332:  IORLW  80
01334:  MOVWF  xE2
01336:  MOVFF  8E0,8E3
0133A:  MOVFF  8DE,8E8
0133E:  MOVWF  xE9
01340:  MOVLB  0
01342:  RCALL  12CE
....................    modbus_serial_putc(error); 
01344:  MOVFF  8E1,8EA
01348:  RCALL  12A6
....................    modbus_serial_send_stop(); 
0134A:  RCALL  12FE
.................... } 
0134C:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          53 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1013 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
0149E:  MOVLB  1
014A0:  CLRF   xCD
014A2:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
014A4:  CLRF   xCF
014A6:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
014A8:  CLRF   xD1
014AA:  CLRF   xD0
.................... } 
014AC:  MOVLB  0
014AE:  GOTO   1F46 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0143A:  BCF    FF2.6
0143C:  BCF    FF2.7
0143E:  BTFSC  FF2.7
01440:  BRA    143C
....................  
.................... 	current.pulse_count[0]=0; 
01442:  CLRF   xAA
01444:  CLRF   xA9
.................... 	current.pulse_count[1]=0; 
01446:  CLRF   xAC
01448:  CLRF   xAB
.................... 	current.pulse_count[2]=0; 
0144A:  CLRF   xAE
0144C:  CLRF   xAD
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
0144E:  SETF   x9E
01450:  SETF   x9D
.................... 	current.pulse_min_period[1]=65535; 
01452:  SETF   xA0
01454:  SETF   x9F
.................... 	current.pulse_min_period[2]=65535; 
01456:  SETF   xA2
01458:  SETF   xA1
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
0145A:  CLRF   xA4
0145C:  CLRF   xA3
.................... 	current.pulse_max_period[1]=0; 
0145E:  CLRF   xA6
01460:  CLRF   xA5
.................... 	current.pulse_max_period[2]=0; 
01462:  CLRF   xA8
01464:  CLRF   xA7
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01466:  MOVLB  1
01468:  CLRF   xD7
0146A:  CLRF   xD6
....................  
.................... 	enable_interrupts(GLOBAL); 
0146C:  MOVLW  C0
0146E:  IORWF  FF2,F
.................... } 
01470:  MOVLB  0
01472:  GOTO   1EF6 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
01476:  BCF    FF2.6
01478:  BCF    FF2.7
0147A:  BTFSC  FF2.7
0147C:  BRA    1478
.................... 	current.pulse_sum[0]=0; 
0147E:  CLRF   xB2
01480:  CLRF   xB1
01482:  CLRF   xB0
01484:  CLRF   xAF
.................... 	current.pulse_sum[1]=0; 
01486:  CLRF   xB6
01488:  CLRF   xB5
0148A:  CLRF   xB4
0148C:  CLRF   xB3
.................... 	current.pulse_sum[2]=0; 
0148E:  CLRF   xBA
01490:  CLRF   xB9
01492:  CLRF   xB8
01494:  CLRF   xB7
.................... 	enable_interrupts(GLOBAL); 
01496:  MOVLW  C0
01498:  IORWF  FF2,F
.................... } 
0149A:  GOTO   1F06 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
0134E:  BCF    FF2.6
01350:  BCF    FF2.7
01352:  BTFSC  FF2.7
01354:  BRA    1350
.................... 	l=current.pulse_sum[ch]; 
01356:  MOVLB  9
01358:  CLRF   xDD
0135A:  MOVFF  8F0,9DC
0135E:  CLRF   xDF
01360:  MOVLW  04
01362:  MOVWF  xDE
01364:  MOVLB  0
01366:  CALL   0890
0136A:  MOVFF  02,03
0136E:  MOVF   01,W
01370:  ADDLW  AF
01372:  MOVWF  FE9
01374:  MOVLW  00
01376:  ADDWFC 02,W
01378:  MOVWF  FEA
0137A:  MOVFF  FEF,00
0137E:  MOVFF  FEC,01
01382:  MOVFF  FEC,02
01386:  MOVFF  FEC,03
0138A:  MOVFF  03,8F4
0138E:  MOVFF  02,8F3
01392:  MOVFF  01,8F2
01396:  MOVFF  00,8F1
.................... 	enable_interrupts(GLOBAL); 
0139A:  MOVLW  C0
0139C:  IORWF  FF2,F
....................  
.................... 	return l; 
0139E:  MOVFF  8F1,00
013A2:  MOVFF  8F2,01
013A6:  MOVFF  8F3,02
013AA:  MOVFF  8F4,03
.................... } 
013AE:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
014B2:  MOVLB  8
014B4:  MOVF   xEB,W
014B6:  SUBLW  06
014B8:  BC    150E
014BA:  XORLW  FF
014BC:  BNZ   14C4
014BE:  MOVF   xEA,W
014C0:  SUBLW  CF
014C2:  BC    150E
014C4:  MOVF   xEB,W
014C6:  SUBLW  09
014C8:  BNC   150E
014CA:  BNZ   14D2
014CC:  MOVF   xEA,W
014CE:  SUBLW  CF
014D0:  BNC   150E
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
014D2:  MOVLW  D0
014D4:  SUBWF  xEA,W
014D6:  MOVWF  xF0
014D8:  MOVLW  07
014DA:  SUBWFB xEB,W
014DC:  MOVWF  xF1
014DE:  MOVLW  02
014E0:  ADDWF  xF1,F
014E2:  MOVFF  FF2,8F2
014E6:  BCF    FF2.6
014E8:  BCF    FF2.7
014EA:  MOVFF  8F1,FAA
014EE:  MOVFF  8F0,FA9
014F2:  BCF    FA6.6
014F4:  BCF    FA6.7
014F6:  BSF    FA6.0
014F8:  MOVF   FA8,W
014FA:  BTFSC  xF2.6
014FC:  BSF    FF2.6
014FE:  BTFSC  xF2.7
01500:  BSF    FF2.7
01502:  CLRF   03
01504:  MOVWF  01
01506:  MOVF   03,W
01508:  MOVWF  02
0150A:  GOTO   20BA
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
0150E:  MOVF   xEB,W
01510:  SUBLW  03
01512:  BC    1592
01514:  XORLW  FF
01516:  BNZ   151E
01518:  MOVF   xEA,W
0151A:  SUBLW  4B
0151C:  BC    1592
0151E:  MOVF   xEB,W
01520:  SUBLW  04
01522:  BNC   1592
01524:  BNZ   152C
01526:  MOVF   xEA,W
01528:  SUBLW  93
0152A:  BNC   1592
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
0152C:  MOVLW  4C
0152E:  SUBWF  xEA,W
01530:  MOVWF  xEC
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01532:  MOVFF  8EC,8F0
01536:  MOVLW  06
01538:  MOVWF  xF1
0153A:  MOVLB  0
0153C:  CALL   0B02
01540:  MOVFF  00,8ED
.................... 		n = n / 6; /* number of sentence */ 
01544:  MOVFF  8EC,8F0
01548:  MOVLW  06
0154A:  MOVLB  8
0154C:  MOVWF  xF1
0154E:  MOVLB  0
01550:  CALL   0B02
01554:  MOVFF  01,8EC
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
01558:  MOVLB  8
0155A:  MOVF   xEC,W
0155C:  MULLW  06
0155E:  MOVF   FF3,W
01560:  CLRF   03
01562:  ADDLW  19
01564:  MOVWF  xF0
01566:  MOVLW  00
01568:  ADDWFC 03,W
0156A:  MOVWF  xF1
0156C:  CLRF   03
0156E:  MOVF   xED,W
01570:  ADDWF  xF0,W
01572:  MOVWF  01
01574:  MOVF   xF1,W
01576:  ADDWFC 03,F
01578:  MOVF   01,W
0157A:  ADDLW  36
0157C:  MOVWF  FE9
0157E:  MOVLW  00
01580:  ADDWFC 03,W
01582:  MOVWF  FEA
01584:  MOVF   FEF,W
01586:  CLRF   03
01588:  MOVWF  01
0158A:  MOVFF  03,02
0158E:  GOTO   20BA
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
01592:  MOVF   xEB,W
01594:  SUBLW  12
01596:  BC    15DA
01598:  XORLW  FF
0159A:  BNZ   15A2
0159C:  MOVF   xEA,W
0159E:  SUBLW  87
015A0:  BC    15DA
015A2:  MOVF   xEB,W
015A4:  SUBLW  17
015A6:  BNC   15DA
015A8:  BNZ   15B0
015AA:  MOVF   xEA,W
015AC:  SUBLW  47
015AE:  BNC   15DA
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
015B0:  MOVLW  88
015B2:  SUBWF  xEA,F
015B4:  MOVLW  13
015B6:  SUBWFB xEB,F
....................  
....................  		p  = nmea.sentence[0]; 
015B8:  MOVLW  04
015BA:  MOVWF  xEF
015BC:  MOVLW  02
015BE:  MOVWF  xEE
.................... 		return (int16) p[addr]; 
015C0:  MOVF   xEE,W
015C2:  ADDWF  xEA,W
015C4:  MOVWF  FE9
015C6:  MOVF   xEF,W
015C8:  ADDWFC xEB,W
015CA:  MOVWF  FEA
015CC:  MOVF   FEF,W
015CE:  CLRF   03
015D0:  MOVWF  01
015D2:  MOVFF  03,02
015D6:  GOTO   20BA
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
015DA:  MOVF   xEB,W
015DC:  SUBLW  16
015DE:  BC    164A
015E0:  XORLW  FF
015E2:  BNZ   15EA
015E4:  MOVF   xEA,W
015E6:  SUBLW  6F
015E8:  BC    164A
015EA:  MOVF   xEB,W
015EC:  SUBLW  19
015EE:  BNC   164A
015F0:  BNZ   15F8
015F2:  MOVF   xEA,W
015F4:  SUBLW  4F
015F6:  BNC   164A
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
015F8:  MOVLW  70
015FA:  SUBWF  xEA,F
015FC:  MOVLW  17
015FE:  SUBWFB xEB,F
.................... 		addr = addr * 2; 
01600:  BCF    FD8.0
01602:  RLCF   xEA,F
01604:  RLCF   xEB,F
....................  
....................  		p  = nmea.sentence[0]; 
01606:  MOVLW  04
01608:  MOVWF  xEF
0160A:  MOVLW  02
0160C:  MOVWF  xEE
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0160E:  MOVF   xEE,W
01610:  ADDWF  xEA,W
01612:  MOVWF  FE9
01614:  MOVF   xEF,W
01616:  ADDWFC xEB,W
01618:  MOVWF  FEA
0161A:  MOVFF  FEF,8F0
0161E:  MOVLW  01
01620:  ADDWF  xEA,W
01622:  MOVWF  xF1
01624:  MOVLW  00
01626:  ADDWFC xEB,W
01628:  MOVWF  xF2
0162A:  MOVF   xEE,W
0162C:  ADDWF  xF1,W
0162E:  MOVWF  FE9
01630:  MOVF   xEF,W
01632:  ADDWFC xF2,W
01634:  MOVWF  FEA
01636:  MOVFF  FEF,8F3
0163A:  MOVFF  8F0,03
0163E:  MOVFF  8F3,01
01642:  MOVFF  8F0,02
01646:  GOTO   20BA
.................... 	} 
....................  
....................  
....................  
.................... 	switch ( addr ) { 
0164A:  MOVF   xEA,W
0164C:  MOVWF  00
0164E:  MOVF   xEB,W
01650:  MOVWF  03
01652:  MOVF   03,W
01654:  BNZ   1660
01656:  MOVF   00,F
01658:  MOVLB  0
0165A:  BTFSC  FD8.2
0165C:  BRA    1AAE
0165E:  MOVLB  8
01660:  MOVF   03,W
01662:  BNZ   1670
01664:  MOVLW  01
01666:  SUBWF  00,W
01668:  MOVLB  0
0166A:  BTFSC  FD8.2
0166C:  BRA    1ABC
0166E:  MOVLB  8
01670:  MOVF   03,W
01672:  BNZ   1680
01674:  MOVLW  02
01676:  SUBWF  00,W
01678:  MOVLB  0
0167A:  BTFSC  FD8.2
0167C:  BRA    1ACA
0167E:  MOVLB  8
01680:  MOVF   03,W
01682:  BNZ   1690
01684:  MOVLW  03
01686:  SUBWF  00,W
01688:  MOVLB  0
0168A:  BTFSC  FD8.2
0168C:  BRA    1AD8
0168E:  MOVLB  8
01690:  MOVF   03,W
01692:  BNZ   16A0
01694:  MOVLW  04
01696:  SUBWF  00,W
01698:  MOVLB  0
0169A:  BTFSC  FD8.2
0169C:  BRA    1AE6
0169E:  MOVLB  8
016A0:  MOVF   03,W
016A2:  BNZ   16B0
016A4:  MOVLW  05
016A6:  SUBWF  00,W
016A8:  MOVLB  0
016AA:  BTFSC  FD8.2
016AC:  BRA    1B0C
016AE:  MOVLB  8
016B0:  MOVF   03,W
016B2:  BNZ   16C0
016B4:  MOVLW  06
016B6:  SUBWF  00,W
016B8:  MOVLB  0
016BA:  BTFSC  FD8.2
016BC:  BRA    1B1A
016BE:  MOVLB  8
016C0:  MOVF   03,W
016C2:  BNZ   16D0
016C4:  MOVLW  07
016C6:  SUBWF  00,W
016C8:  MOVLB  0
016CA:  BTFSC  FD8.2
016CC:  BRA    1B28
016CE:  MOVLB  8
016D0:  MOVF   03,W
016D2:  BNZ   16E0
016D4:  MOVLW  08
016D6:  SUBWF  00,W
016D8:  MOVLB  0
016DA:  BTFSC  FD8.2
016DC:  BRA    1B36
016DE:  MOVLB  8
016E0:  MOVF   03,W
016E2:  BNZ   16F0
016E4:  MOVLW  09
016E6:  SUBWF  00,W
016E8:  MOVLB  0
016EA:  BTFSC  FD8.2
016EC:  BRA    1B44
016EE:  MOVLB  8
016F0:  MOVF   03,W
016F2:  BNZ   1700
016F4:  MOVLW  0A
016F6:  SUBWF  00,W
016F8:  MOVLB  0
016FA:  BTFSC  FD8.2
016FC:  BRA    1B52
016FE:  MOVLB  8
01700:  MOVF   03,W
01702:  BNZ   1710
01704:  MOVLW  0B
01706:  SUBWF  00,W
01708:  MOVLB  0
0170A:  BTFSC  FD8.2
0170C:  BRA    1B7C
0170E:  MOVLB  8
01710:  MOVF   03,W
01712:  BNZ   1720
01714:  MOVLW  0C
01716:  SUBWF  00,W
01718:  MOVLB  0
0171A:  BTFSC  FD8.2
0171C:  BRA    1B8A
0171E:  MOVLB  8
01720:  MOVF   03,W
01722:  BNZ   1730
01724:  MOVLW  0D
01726:  SUBWF  00,W
01728:  MOVLB  0
0172A:  BTFSC  FD8.2
0172C:  BRA    1B98
0172E:  MOVLB  8
01730:  MOVF   03,W
01732:  BNZ   1740
01734:  MOVLW  0E
01736:  SUBWF  00,W
01738:  MOVLB  0
0173A:  BTFSC  FD8.2
0173C:  BRA    1BA6
0173E:  MOVLB  8
01740:  MOVF   03,W
01742:  BNZ   1750
01744:  MOVLW  0F
01746:  SUBWF  00,W
01748:  MOVLB  0
0174A:  BTFSC  FD8.2
0174C:  BRA    1BB4
0174E:  MOVLB  8
01750:  MOVF   03,W
01752:  BNZ   1760
01754:  MOVLW  10
01756:  SUBWF  00,W
01758:  MOVLB  0
0175A:  BTFSC  FD8.2
0175C:  BRA    1BC2
0175E:  MOVLB  8
01760:  MOVF   03,W
01762:  BNZ   1770
01764:  MOVLW  11
01766:  SUBWF  00,W
01768:  MOVLB  0
0176A:  BTFSC  FD8.2
0176C:  BRA    1BEC
0176E:  MOVLB  8
01770:  MOVF   03,W
01772:  BNZ   1780
01774:  MOVLW  12
01776:  SUBWF  00,W
01778:  MOVLB  0
0177A:  BTFSC  FD8.2
0177C:  BRA    1BFA
0177E:  MOVLB  8
01780:  MOVF   03,W
01782:  BNZ   1790
01784:  MOVLW  13
01786:  SUBWF  00,W
01788:  MOVLB  0
0178A:  BTFSC  FD8.2
0178C:  BRA    1C28
0178E:  MOVLB  8
01790:  MOVF   03,W
01792:  BNZ   17A0
01794:  MOVLW  14
01796:  SUBWF  00,W
01798:  MOVLB  0
0179A:  BTFSC  FD8.2
0179C:  BRA    1C40
0179E:  MOVLB  8
017A0:  MOVF   03,W
017A2:  BNZ   17B0
017A4:  MOVLW  15
017A6:  SUBWF  00,W
017A8:  MOVLB  0
017AA:  BTFSC  FD8.2
017AC:  BRA    1C4E
017AE:  MOVLB  8
017B0:  MOVF   03,W
017B2:  BNZ   17C0
017B4:  MOVLW  16
017B6:  SUBWF  00,W
017B8:  MOVLB  0
017BA:  BTFSC  FD8.2
017BC:  BRA    1C7C
017BE:  MOVLB  8
017C0:  MOVF   03,W
017C2:  BNZ   17D0
017C4:  MOVLW  17
017C6:  SUBWF  00,W
017C8:  MOVLB  0
017CA:  BTFSC  FD8.2
017CC:  BRA    1C96
017CE:  MOVLB  8
017D0:  MOVF   03,W
017D2:  BNZ   17E0
017D4:  MOVLW  18
017D6:  SUBWF  00,W
017D8:  MOVLB  0
017DA:  BTFSC  FD8.2
017DC:  BRA    1CA4
017DE:  MOVLB  8
017E0:  MOVF   03,W
017E2:  BNZ   17F0
017E4:  MOVLW  19
017E6:  SUBWF  00,W
017E8:  MOVLB  0
017EA:  BTFSC  FD8.2
017EC:  BRA    1CD2
017EE:  MOVLB  8
017F0:  MOVF   03,W
017F2:  BNZ   1800
017F4:  MOVLW  1A
017F6:  SUBWF  00,W
017F8:  MOVLB  0
017FA:  BTFSC  FD8.2
017FC:  BRA    1CEC
017FE:  MOVLB  8
01800:  MOVF   03,W
01802:  BNZ   1810
01804:  MOVLW  1B
01806:  SUBWF  00,W
01808:  MOVLB  0
0180A:  BTFSC  FD8.2
0180C:  BRA    1CFA
0180E:  MOVLB  8
01810:  MOVF   03,W
01812:  BNZ   1820
01814:  MOVLW  1C
01816:  SUBWF  00,W
01818:  MOVLB  0
0181A:  BTFSC  FD8.2
0181C:  BRA    1D28
0181E:  MOVLB  8
01820:  MOVF   03,W
01822:  BNZ   1830
01824:  MOVLW  1D
01826:  SUBWF  00,W
01828:  MOVLB  0
0182A:  BTFSC  FD8.2
0182C:  BRA    1D42
0182E:  MOVLB  8
01830:  MOVF   03,W
01832:  BNZ   1840
01834:  MOVLW  1E
01836:  SUBWF  00,W
01838:  MOVLB  0
0183A:  BTFSC  FD8.2
0183C:  BRA    1D50
0183E:  MOVLB  8
01840:  MOVF   03,W
01842:  BNZ   1850
01844:  MOVLW  1F
01846:  SUBWF  00,W
01848:  MOVLB  0
0184A:  BTFSC  FD8.2
0184C:  BRA    1D7E
0184E:  MOVLB  8
01850:  MOVF   03,W
01852:  BNZ   1860
01854:  MOVLW  20
01856:  SUBWF  00,W
01858:  MOVLB  0
0185A:  BTFSC  FD8.2
0185C:  BRA    1D98
0185E:  MOVLB  8
01860:  MOVF   03,W
01862:  BNZ   1870
01864:  MOVLW  21
01866:  SUBWF  00,W
01868:  MOVLB  0
0186A:  BTFSC  FD8.2
0186C:  BRA    1DA6
0186E:  MOVLB  8
01870:  MOVF   03,W
01872:  BNZ   1880
01874:  MOVLW  22
01876:  SUBWF  00,W
01878:  MOVLB  0
0187A:  BTFSC  FD8.2
0187C:  BRA    1DD4
0187E:  MOVLB  8
01880:  MOVF   03,W
01882:  BNZ   1890
01884:  MOVLW  23
01886:  SUBWF  00,W
01888:  MOVLB  0
0188A:  BTFSC  FD8.2
0188C:  BRA    1DEE
0188E:  MOVLB  8
01890:  MOVF   03,W
01892:  BNZ   18A0
01894:  MOVLW  24
01896:  SUBWF  00,W
01898:  MOVLB  0
0189A:  BTFSC  FD8.2
0189C:  BRA    1DFC
0189E:  MOVLB  8
018A0:  MOVF   03,W
018A2:  BNZ   18B0
018A4:  MOVLW  25
018A6:  SUBWF  00,W
018A8:  MOVLB  0
018AA:  BTFSC  FD8.2
018AC:  BRA    1E2A
018AE:  MOVLB  8
018B0:  MOVF   03,W
018B2:  BNZ   18C0
018B4:  MOVLW  26
018B6:  SUBWF  00,W
018B8:  MOVLB  0
018BA:  BTFSC  FD8.2
018BC:  BRA    1E44
018BE:  MOVLB  8
018C0:  MOVF   03,W
018C2:  BNZ   18D0
018C4:  MOVLW  27
018C6:  SUBWF  00,W
018C8:  MOVLB  0
018CA:  BTFSC  FD8.2
018CC:  BRA    1E52
018CE:  MOVLB  8
018D0:  MOVF   03,W
018D2:  BNZ   18E0
018D4:  MOVLW  28
018D6:  SUBWF  00,W
018D8:  MOVLB  0
018DA:  BTFSC  FD8.2
018DC:  BRA    1E80
018DE:  MOVLB  8
018E0:  MOVF   03,W
018E2:  BNZ   18F0
018E4:  MOVLW  29
018E6:  SUBWF  00,W
018E8:  MOVLB  0
018EA:  BTFSC  FD8.2
018EC:  BRA    1E9A
018EE:  MOVLB  8
018F0:  MOVF   03,W
018F2:  BNZ   1900
018F4:  MOVLW  2A
018F6:  SUBWF  00,W
018F8:  MOVLB  0
018FA:  BTFSC  FD8.2
018FC:  BRA    1EA8
018FE:  MOVLB  8
01900:  MOVF   03,W
01902:  BNZ   1910
01904:  MOVLW  2B
01906:  SUBWF  00,W
01908:  MOVLB  0
0190A:  BTFSC  FD8.2
0190C:  BRA    1EC2
0190E:  MOVLB  8
01910:  MOVF   03,W
01912:  BNZ   1920
01914:  MOVLW  2C
01916:  SUBWF  00,W
01918:  MOVLB  0
0191A:  BTFSC  FD8.2
0191C:  BRA    1ED2
0191E:  MOVLB  8
01920:  MOVF   03,W
01922:  BNZ   1930
01924:  MOVLW  2D
01926:  SUBWF  00,W
01928:  MOVLB  0
0192A:  BTFSC  FD8.2
0192C:  BRA    1EE2
0192E:  MOVLB  8
01930:  MOVF   03,W
01932:  BNZ   1940
01934:  MOVLW  2E
01936:  SUBWF  00,W
01938:  MOVLB  0
0193A:  BTFSC  FD8.2
0193C:  BRA    1EF2
0193E:  MOVLB  8
01940:  MOVF   03,W
01942:  BNZ   1950
01944:  MOVLW  2F
01946:  SUBWF  00,W
01948:  MOVLB  0
0194A:  BTFSC  FD8.2
0194C:  BRA    1F02
0194E:  MOVLB  8
01950:  MOVF   03,W
01952:  BNZ   1960
01954:  MOVLW  30
01956:  SUBWF  00,W
01958:  MOVLB  0
0195A:  BTFSC  FD8.2
0195C:  BRA    1F12
0195E:  MOVLB  8
01960:  MOVF   03,W
01962:  BNZ   1970
01964:  MOVLW  31
01966:  SUBWF  00,W
01968:  MOVLB  0
0196A:  BTFSC  FD8.2
0196C:  BRA    1F22
0196E:  MOVLB  8
01970:  MOVF   03,W
01972:  BNZ   1980
01974:  MOVLW  32
01976:  SUBWF  00,W
01978:  MOVLB  0
0197A:  BTFSC  FD8.2
0197C:  BRA    1F32
0197E:  MOVLB  8
01980:  MOVF   03,W
01982:  BNZ   1990
01984:  MOVLW  33
01986:  SUBWF  00,W
01988:  MOVLB  0
0198A:  BTFSC  FD8.2
0198C:  BRA    1F42
0198E:  MOVLB  8
01990:  MOVF   03,W
01992:  BNZ   19A0
01994:  MOVLW  34
01996:  SUBWF  00,W
01998:  MOVLB  0
0199A:  BTFSC  FD8.2
0199C:  BRA    1F52
0199E:  MOVLB  8
019A0:  MOVF   03,W
019A2:  BNZ   19B0
019A4:  MOVLW  35
019A6:  SUBWF  00,W
019A8:  MOVLB  0
019AA:  BTFSC  FD8.2
019AC:  BRA    1F62
019AE:  MOVLB  8
019B0:  MOVLW  03
019B2:  SUBWF  03,W
019B4:  BNZ   19C2
019B6:  MOVLW  E8
019B8:  SUBWF  00,W
019BA:  MOVLB  0
019BC:  BTFSC  FD8.2
019BE:  BRA    1F72
019C0:  MOVLB  8
019C2:  MOVLW  03
019C4:  SUBWF  03,W
019C6:  BNZ   19D4
019C8:  MOVLW  E9
019CA:  SUBWF  00,W
019CC:  MOVLB  0
019CE:  BTFSC  FD8.2
019D0:  BRA    1F82
019D2:  MOVLB  8
019D4:  MOVLW  03
019D6:  SUBWF  03,W
019D8:  BNZ   19E6
019DA:  MOVLW  EA
019DC:  SUBWF  00,W
019DE:  MOVLB  0
019E0:  BTFSC  FD8.2
019E2:  BRA    1F90
019E4:  MOVLB  8
019E6:  MOVLW  03
019E8:  SUBWF  03,W
019EA:  BNZ   19F8
019EC:  MOVLW  EB
019EE:  SUBWF  00,W
019F0:  MOVLB  0
019F2:  BTFSC  FD8.2
019F4:  BRA    1F9E
019F6:  MOVLB  8
019F8:  MOVLW  03
019FA:  SUBWF  03,W
019FC:  BNZ   1A0A
019FE:  MOVLW  EC
01A00:  SUBWF  00,W
01A02:  MOVLB  0
01A04:  BTFSC  FD8.2
01A06:  BRA    1FAC
01A08:  MOVLB  8
01A0A:  MOVLW  03
01A0C:  SUBWF  03,W
01A0E:  BNZ   1A1C
01A10:  MOVLW  ED
01A12:  SUBWF  00,W
01A14:  MOVLB  0
01A16:  BTFSC  FD8.2
01A18:  BRA    1FBA
01A1A:  MOVLB  8
01A1C:  MOVLW  03
01A1E:  SUBWF  03,W
01A20:  BNZ   1A2E
01A22:  MOVLW  EE
01A24:  SUBWF  00,W
01A26:  MOVLB  0
01A28:  BTFSC  FD8.2
01A2A:  BRA    1FC8
01A2C:  MOVLB  8
01A2E:  MOVLW  03
01A30:  SUBWF  03,W
01A32:  BNZ   1A40
01A34:  MOVLW  EF
01A36:  SUBWF  00,W
01A38:  MOVLB  0
01A3A:  BTFSC  FD8.2
01A3C:  BRA    1FD8
01A3E:  MOVLB  8
01A40:  MOVLW  03
01A42:  SUBWF  03,W
01A44:  BNZ   1A52
01A46:  MOVLW  F0
01A48:  SUBWF  00,W
01A4A:  MOVLB  0
01A4C:  BTFSC  FD8.2
01A4E:  BRA    1FE6
01A50:  MOVLB  8
01A52:  MOVLW  03
01A54:  SUBWF  03,W
01A56:  BNZ   1A64
01A58:  MOVLW  F1
01A5A:  SUBWF  00,W
01A5C:  MOVLB  0
01A5E:  BTFSC  FD8.2
01A60:  BRA    1FF6
01A62:  MOVLB  8
01A64:  MOVLW  03
01A66:  SUBWF  03,W
01A68:  BNZ   1A76
01A6A:  MOVLW  F2
01A6C:  SUBWF  00,W
01A6E:  MOVLB  0
01A70:  BTFSC  FD8.2
01A72:  BRA    2004
01A74:  MOVLB  8
01A76:  MOVLW  03
01A78:  SUBWF  03,W
01A7A:  BNZ   1A88
01A7C:  MOVLW  F3
01A7E:  SUBWF  00,W
01A80:  MOVLB  0
01A82:  BTFSC  FD8.2
01A84:  BRA    2012
01A86:  MOVLB  8
01A88:  MOVLW  03
01A8A:  SUBWF  03,W
01A8C:  BNZ   1A9A
01A8E:  MOVLW  F4
01A90:  SUBWF  00,W
01A92:  MOVLB  0
01A94:  BTFSC  FD8.2
01A96:  BRA    2022
01A98:  MOVLB  8
01A9A:  MOVLW  03
01A9C:  SUBWF  03,W
01A9E:  BNZ   1AAC
01AA0:  MOVLW  F5
01AA2:  SUBWF  00,W
01AA4:  MOVLB  0
01AA6:  BTFSC  FD8.2
01AA8:  BRA    2032
01AAA:  MOVLB  8
01AAC:  BRA    20B2
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01AAE:  MOVFF  A9,01
01AB2:  MOVFF  AA,02
01AB6:  MOVLB  8
01AB8:  BRA    20BA
01ABA:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01ABC:  MOVF   x97,W
01ABE:  MOVWF  01
01AC0:  MOVF   x98,W
01AC2:  MOVWF  02
01AC4:  MOVLB  8
01AC6:  BRA    20BA
01AC8:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01ACA:  MOVF   x9D,W
01ACC:  MOVWF  01
01ACE:  MOVF   x9E,W
01AD0:  MOVWF  02
01AD2:  MOVLB  8
01AD4:  BRA    20BA
01AD6:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01AD8:  MOVF   xA3,W
01ADA:  MOVWF  01
01ADC:  MOVF   xA4,W
01ADE:  MOVWF  02
01AE0:  MOVLB  8
01AE2:  BRA    20BA
01AE4:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01AE6:  MOVLB  8
01AE8:  CLRF   xF0
01AEA:  MOVLB  0
01AEC:  RCALL  134E
01AEE:  MOVFF  03,8CC
01AF2:  MOVFF  02,8CB
01AF6:  MOVFF  01,8CA
01AFA:  MOVFF  00,8C9
01AFE:  MOVLB  8
01B00:  MOVF   xC9,W
01B02:  MOVWF  01
01B04:  MOVF   xCA,W
01B06:  MOVWF  02
01B08:  BRA    20BA
01B0A:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01B0C:  MOVLB  8
01B0E:  MOVF   xCB,W
01B10:  MOVWF  01
01B12:  MOVF   xCC,W
01B14:  MOVWF  02
01B16:  BRA    20BA
01B18:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01B1A:  MOVF   xAB,W
01B1C:  MOVWF  01
01B1E:  MOVF   xAC,W
01B20:  MOVWF  02
01B22:  MOVLB  8
01B24:  BRA    20BA
01B26:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01B28:  MOVF   x99,W
01B2A:  MOVWF  01
01B2C:  MOVF   x9A,W
01B2E:  MOVWF  02
01B30:  MOVLB  8
01B32:  BRA    20BA
01B34:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01B36:  MOVF   x9F,W
01B38:  MOVWF  01
01B3A:  MOVF   xA0,W
01B3C:  MOVWF  02
01B3E:  MOVLB  8
01B40:  BRA    20BA
01B42:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01B44:  MOVF   xA5,W
01B46:  MOVWF  01
01B48:  MOVF   xA6,W
01B4A:  MOVWF  02
01B4C:  MOVLB  8
01B4E:  BRA    20BA
01B50:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01B52:  MOVLW  01
01B54:  MOVLB  8
01B56:  MOVWF  xF0
01B58:  MOVLB  0
01B5A:  CALL   134E
01B5E:  MOVFF  03,8CC
01B62:  MOVFF  02,8CB
01B66:  MOVFF  01,8CA
01B6A:  MOVFF  00,8C9
01B6E:  MOVLB  8
01B70:  MOVF   xC9,W
01B72:  MOVWF  01
01B74:  MOVF   xCA,W
01B76:  MOVWF  02
01B78:  BRA    20BA
01B7A:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01B7C:  MOVLB  8
01B7E:  MOVF   xCB,W
01B80:  MOVWF  01
01B82:  MOVF   xCC,W
01B84:  MOVWF  02
01B86:  BRA    20BA
01B88:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01B8A:  MOVF   xAD,W
01B8C:  MOVWF  01
01B8E:  MOVF   xAE,W
01B90:  MOVWF  02
01B92:  MOVLB  8
01B94:  BRA    20BA
01B96:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01B98:  MOVF   x9B,W
01B9A:  MOVWF  01
01B9C:  MOVF   x9C,W
01B9E:  MOVWF  02
01BA0:  MOVLB  8
01BA2:  BRA    20BA
01BA4:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01BA6:  MOVF   xA1,W
01BA8:  MOVWF  01
01BAA:  MOVF   xA2,W
01BAC:  MOVWF  02
01BAE:  MOVLB  8
01BB0:  BRA    20BA
01BB2:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01BB4:  MOVF   xA7,W
01BB6:  MOVWF  01
01BB8:  MOVF   xA8,W
01BBA:  MOVWF  02
01BBC:  MOVLB  8
01BBE:  BRA    20BA
01BC0:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01BC2:  MOVLW  02
01BC4:  MOVLB  8
01BC6:  MOVWF  xF0
01BC8:  MOVLB  0
01BCA:  CALL   134E
01BCE:  MOVFF  03,8CC
01BD2:  MOVFF  02,8CB
01BD6:  MOVFF  01,8CA
01BDA:  MOVFF  00,8C9
01BDE:  MOVLB  8
01BE0:  MOVF   xC9,W
01BE2:  MOVWF  01
01BE4:  MOVF   xCA,W
01BE6:  MOVWF  02
01BE8:  BRA    20BA
01BEA:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01BEC:  MOVLB  8
01BEE:  MOVF   xCB,W
01BF0:  MOVWF  01
01BF2:  MOVF   xCC,W
01BF4:  MOVWF  02
01BF6:  BRA    20BA
01BF8:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01BFA:  CLRF   03
01BFC:  MOVLB  1
01BFE:  MOVF   xCB,W
01C00:  MOVWF  02
01C02:  BCF    FD8.0
01C04:  RLCF   02,F
01C06:  RLCF   03,F
01C08:  MOVF   02,W
01C0A:  ADDLW  CB
01C0C:  MOVWF  FE9
01C0E:  MOVLW  00
01C10:  ADDWFC 03,W
01C12:  MOVWF  FEA
01C14:  MOVFF  FEC,03
01C18:  MOVF   FED,F
01C1A:  MOVF   FEF,W
01C1C:  MOVWF  01
01C1E:  MOVF   03,W
01C20:  MOVWF  02
01C22:  MOVLB  8
01C24:  BRA    20BA
01C26:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
01C28:  MOVLB  8
01C2A:  CLRF   xF0
01C2C:  MOVLB  0
01C2E:  CALL   13B0
01C32:  MOVF   01,W
01C34:  MOVWF  01
01C36:  MOVF   02,W
01C38:  MOVWF  02
01C3A:  MOVLB  8
01C3C:  BRA    20BA
01C3E:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01C40:  MOVF   xBB,W
01C42:  MOVWF  01
01C44:  MOVF   xBC,W
01C46:  MOVWF  02
01C48:  MOVLB  8
01C4A:  BRA    20BA
01C4C:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01C4E:  CLRF   03
01C50:  MOVLB  1
01C52:  MOVF   xCB,W
01C54:  MOVWF  02
01C56:  BCF    FD8.0
01C58:  RLCF   02,F
01C5A:  RLCF   03,F
01C5C:  MOVF   02,W
01C5E:  ADDLW  EB
01C60:  MOVWF  FE9
01C62:  MOVLW  00
01C64:  ADDWFC 03,W
01C66:  MOVWF  FEA
01C68:  MOVFF  FEC,03
01C6C:  MOVF   FED,F
01C6E:  MOVF   FEF,W
01C70:  MOVWF  01
01C72:  MOVF   03,W
01C74:  MOVWF  02
01C76:  MOVLB  8
01C78:  BRA    20BA
01C7A:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01C7C:  MOVLW  01
01C7E:  MOVLB  8
01C80:  MOVWF  xF0
01C82:  MOVLB  0
01C84:  CALL   13B0
01C88:  MOVF   01,W
01C8A:  MOVWF  01
01C8C:  MOVF   02,W
01C8E:  MOVWF  02
01C90:  MOVLB  8
01C92:  BRA    20BA
01C94:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
01C96:  MOVF   xBD,W
01C98:  MOVWF  01
01C9A:  MOVF   xBE,W
01C9C:  MOVWF  02
01C9E:  MOVLB  8
01CA0:  BRA    20BA
01CA2:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
01CA4:  CLRF   03
01CA6:  MOVLB  1
01CA8:  MOVF   xCB,W
01CAA:  MOVWF  02
01CAC:  BCF    FD8.0
01CAE:  RLCF   02,F
01CB0:  RLCF   03,F
01CB2:  MOVF   02,W
01CB4:  ADDLW  0B
01CB6:  MOVWF  FE9
01CB8:  MOVLW  01
01CBA:  ADDWFC 03,W
01CBC:  MOVWF  FEA
01CBE:  MOVFF  FEC,03
01CC2:  MOVF   FED,F
01CC4:  MOVF   FEF,W
01CC6:  MOVWF  01
01CC8:  MOVF   03,W
01CCA:  MOVWF  02
01CCC:  MOVLB  8
01CCE:  BRA    20BA
01CD0:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01CD2:  MOVLW  02
01CD4:  MOVLB  8
01CD6:  MOVWF  xF0
01CD8:  MOVLB  0
01CDA:  CALL   13B0
01CDE:  MOVF   01,W
01CE0:  MOVWF  01
01CE2:  MOVF   02,W
01CE4:  MOVWF  02
01CE6:  MOVLB  8
01CE8:  BRA    20BA
01CEA:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
01CEC:  MOVF   xBF,W
01CEE:  MOVWF  01
01CF0:  MOVF   xC0,W
01CF2:  MOVWF  02
01CF4:  MOVLB  8
01CF6:  BRA    20BA
01CF8:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
01CFA:  CLRF   03
01CFC:  MOVLB  1
01CFE:  MOVF   xCB,W
01D00:  MOVWF  02
01D02:  BCF    FD8.0
01D04:  RLCF   02,F
01D06:  RLCF   03,F
01D08:  MOVF   02,W
01D0A:  ADDLW  2B
01D0C:  MOVWF  FE9
01D0E:  MOVLW  01
01D10:  ADDWFC 03,W
01D12:  MOVWF  FEA
01D14:  MOVFF  FEC,03
01D18:  MOVF   FED,F
01D1A:  MOVF   FEF,W
01D1C:  MOVWF  01
01D1E:  MOVF   03,W
01D20:  MOVWF  02
01D22:  MOVLB  8
01D24:  BRA    20BA
01D26:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
01D28:  MOVLW  03
01D2A:  MOVLB  8
01D2C:  MOVWF  xF0
01D2E:  MOVLB  0
01D30:  CALL   13B0
01D34:  MOVF   01,W
01D36:  MOVWF  01
01D38:  MOVF   02,W
01D3A:  MOVWF  02
01D3C:  MOVLB  8
01D3E:  BRA    20BA
01D40:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01D42:  MOVF   xC1,W
01D44:  MOVWF  01
01D46:  MOVF   xC2,W
01D48:  MOVWF  02
01D4A:  MOVLB  8
01D4C:  BRA    20BA
01D4E:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01D50:  CLRF   03
01D52:  MOVLB  1
01D54:  MOVF   xCB,W
01D56:  MOVWF  02
01D58:  BCF    FD8.0
01D5A:  RLCF   02,F
01D5C:  RLCF   03,F
01D5E:  MOVF   02,W
01D60:  ADDLW  4B
01D62:  MOVWF  FE9
01D64:  MOVLW  01
01D66:  ADDWFC 03,W
01D68:  MOVWF  FEA
01D6A:  MOVFF  FEC,03
01D6E:  MOVF   FED,F
01D70:  MOVF   FEF,W
01D72:  MOVWF  01
01D74:  MOVF   03,W
01D76:  MOVWF  02
01D78:  MOVLB  8
01D7A:  BRA    20BA
01D7C:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01D7E:  MOVLW  04
01D80:  MOVLB  8
01D82:  MOVWF  xF0
01D84:  MOVLB  0
01D86:  CALL   13B0
01D8A:  MOVF   01,W
01D8C:  MOVWF  01
01D8E:  MOVF   02,W
01D90:  MOVWF  02
01D92:  MOVLB  8
01D94:  BRA    20BA
01D96:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01D98:  MOVF   xC3,W
01D9A:  MOVWF  01
01D9C:  MOVF   xC4,W
01D9E:  MOVWF  02
01DA0:  MOVLB  8
01DA2:  BRA    20BA
01DA4:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01DA6:  CLRF   03
01DA8:  MOVLB  1
01DAA:  MOVF   xCB,W
01DAC:  MOVWF  02
01DAE:  BCF    FD8.0
01DB0:  RLCF   02,F
01DB2:  RLCF   03,F
01DB4:  MOVF   02,W
01DB6:  ADDLW  6B
01DB8:  MOVWF  FE9
01DBA:  MOVLW  01
01DBC:  ADDWFC 03,W
01DBE:  MOVWF  FEA
01DC0:  MOVFF  FEC,03
01DC4:  MOVF   FED,F
01DC6:  MOVF   FEF,W
01DC8:  MOVWF  01
01DCA:  MOVF   03,W
01DCC:  MOVWF  02
01DCE:  MOVLB  8
01DD0:  BRA    20BA
01DD2:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01DD4:  MOVLW  05
01DD6:  MOVLB  8
01DD8:  MOVWF  xF0
01DDA:  MOVLB  0
01DDC:  CALL   13B0
01DE0:  MOVF   01,W
01DE2:  MOVWF  01
01DE4:  MOVF   02,W
01DE6:  MOVWF  02
01DE8:  MOVLB  8
01DEA:  BRA    20BA
01DEC:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01DEE:  MOVF   xC5,W
01DF0:  MOVWF  01
01DF2:  MOVF   xC6,W
01DF4:  MOVWF  02
01DF6:  MOVLB  8
01DF8:  BRA    20BA
01DFA:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01DFC:  CLRF   03
01DFE:  MOVLB  1
01E00:  MOVF   xCB,W
01E02:  MOVWF  02
01E04:  BCF    FD8.0
01E06:  RLCF   02,F
01E08:  RLCF   03,F
01E0A:  MOVF   02,W
01E0C:  ADDLW  8B
01E0E:  MOVWF  FE9
01E10:  MOVLW  01
01E12:  ADDWFC 03,W
01E14:  MOVWF  FEA
01E16:  MOVFF  FEC,03
01E1A:  MOVF   FED,F
01E1C:  MOVF   FEF,W
01E1E:  MOVWF  01
01E20:  MOVF   03,W
01E22:  MOVWF  02
01E24:  MOVLB  8
01E26:  BRA    20BA
01E28:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01E2A:  MOVLW  06
01E2C:  MOVLB  8
01E2E:  MOVWF  xF0
01E30:  MOVLB  0
01E32:  CALL   13B0
01E36:  MOVF   01,W
01E38:  MOVWF  01
01E3A:  MOVF   02,W
01E3C:  MOVWF  02
01E3E:  MOVLB  8
01E40:  BRA    20BA
01E42:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01E44:  MOVF   xC7,W
01E46:  MOVWF  01
01E48:  MOVF   xC8,W
01E4A:  MOVWF  02
01E4C:  MOVLB  8
01E4E:  BRA    20BA
01E50:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01E52:  CLRF   03
01E54:  MOVLB  1
01E56:  MOVF   xCB,W
01E58:  MOVWF  02
01E5A:  BCF    FD8.0
01E5C:  RLCF   02,F
01E5E:  RLCF   03,F
01E60:  MOVF   02,W
01E62:  ADDLW  AB
01E64:  MOVWF  FE9
01E66:  MOVLW  01
01E68:  ADDWFC 03,W
01E6A:  MOVWF  FEA
01E6C:  MOVFF  FEC,03
01E70:  MOVF   FED,F
01E72:  MOVF   FEF,W
01E74:  MOVWF  01
01E76:  MOVF   03,W
01E78:  MOVWF  02
01E7A:  MOVLB  8
01E7C:  BRA    20BA
01E7E:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01E80:  MOVLW  07
01E82:  MOVLB  8
01E84:  MOVWF  xF0
01E86:  MOVLB  0
01E88:  CALL   13B0
01E8C:  MOVF   01,W
01E8E:  MOVWF  01
01E90:  MOVF   02,W
01E92:  MOVWF  02
01E94:  MOVLB  8
01E96:  BRA    20BA
01E98:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01E9A:  MOVF   xC9,W
01E9C:  MOVWF  01
01E9E:  MOVF   xCA,W
01EA0:  MOVWF  02
01EA2:  MOVLB  8
01EA4:  BRA    20BA
01EA6:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01EA8:  MOVLB  1
01EAA:  MOVF   xD3,W
01EAC:  MOVWF  03
01EAE:  MOVF   xD2,W
01EB0:  INCF   xD2,F
01EB2:  BTFSC  FD8.2
01EB4:  INCF   xD3,F
01EB6:  MOVWF  01
01EB8:  MOVF   03,W
01EBA:  MOVWF  02
01EBC:  MOVLB  8
01EBE:  BRA    20BA
01EC0:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01EC2:  MOVLB  1
01EC4:  MOVF   xD6,W
01EC6:  MOVWF  01
01EC8:  MOVF   xD7,W
01ECA:  MOVWF  02
01ECC:  MOVLB  8
01ECE:  BRA    20BA
01ED0:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01ED2:  MOVLB  1
01ED4:  MOVF   xD4,W
01ED6:  MOVWF  01
01ED8:  MOVF   xD5,W
01EDA:  MOVWF  02
01EDC:  MOVLB  8
01EDE:  BRA    20BA
01EE0:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01EE2:  MOVLB  1
01EE4:  MOVF   xD9,W
01EE6:  MOVWF  01
01EE8:  MOVF   xDA,W
01EEA:  MOVWF  02
01EEC:  MOVLB  8
01EEE:  BRA    20BA
01EF0:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01EF2:  GOTO   143A
01EF6:  MOVLW  00
01EF8:  MOVWF  01
01EFA:  MOVWF  02
01EFC:  MOVLB  8
01EFE:  BRA    20BA
01F00:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01F02:  GOTO   1476
01F06:  MOVLW  00
01F08:  MOVWF  01
01F0A:  MOVWF  02
01F0C:  MOVLB  8
01F0E:  BRA    20BA
01F10:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01F12:  MOVLB  1
01F14:  MOVF   xCC,W
01F16:  MOVWF  01
01F18:  MOVF   xCD,W
01F1A:  MOVWF  02
01F1C:  MOVLB  8
01F1E:  BRA    20BA
01F20:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01F22:  MOVLB  1
01F24:  MOVF   xCE,W
01F26:  MOVWF  01
01F28:  MOVF   xCF,W
01F2A:  MOVWF  02
01F2C:  MOVLB  8
01F2E:  BRA    20BA
01F30:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01F32:  MOVLB  1
01F34:  MOVF   xD0,W
01F36:  MOVWF  01
01F38:  MOVF   xD1,W
01F3A:  MOVWF  02
01F3C:  MOVLB  8
01F3E:  BRA    20BA
01F40:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01F42:  GOTO   149E
01F46:  MOVLW  00
01F48:  MOVWF  01
01F4A:  MOVWF  02
01F4C:  MOVLB  8
01F4E:  BRA    20BA
01F50:  MOVLB  0
.................... 		case 52: return (int16) current.rda_bytes_received; 
01F52:  MOVLB  1
01F54:  MOVF   xE2,W
01F56:  MOVWF  01
01F58:  MOVF   xE3,W
01F5A:  MOVWF  02
01F5C:  MOVLB  8
01F5E:  BRA    20BA
01F60:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
01F62:  MOVLB  1
01F64:  MOVF   xE4,W
01F66:  MOVWF  01
01F68:  MOVF   xE5,W
01F6A:  MOVWF  02
01F6C:  MOVLB  8
01F6E:  BRA    20BA
01F70:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
01F72:  CLRF   03
01F74:  MOVF   3A,W
01F76:  MOVWF  01
01F78:  MOVF   03,W
01F7A:  MOVWF  02
01F7C:  MOVLB  8
01F7E:  BRA    20BA
01F80:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01F82:  MOVF   3B,W
01F84:  MOVWF  01
01F86:  MOVF   3C,W
01F88:  MOVWF  02
01F8A:  MOVLB  8
01F8C:  BRA    20BA
01F8E:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01F90:  MOVLW  50
01F92:  MOVWF  01
01F94:  MOVLW  00
01F96:  MOVWF  02
01F98:  MOVLB  8
01F9A:  BRA    20BA
01F9C:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01F9E:  MOVLW  57
01FA0:  MOVWF  01
01FA2:  MOVLW  00
01FA4:  MOVWF  02
01FA6:  MOVLB  8
01FA8:  BRA    20BA
01FAA:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01FAC:  MOVLW  58
01FAE:  MOVWF  01
01FB0:  MOVLW  00
01FB2:  MOVWF  02
01FB4:  MOVLB  8
01FB6:  BRA    20BA
01FB8:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01FBA:  MOVLW  01
01FBC:  MOVWF  01
01FBE:  MOVLW  00
01FC0:  MOVWF  02
01FC2:  MOVLB  8
01FC4:  BRA    20BA
01FC6:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01FC8:  CLRF   03
01FCA:  MOVF   36,W
01FCC:  MOVWF  01
01FCE:  MOVF   03,W
01FD0:  MOVWF  02
01FD2:  MOVLB  8
01FD4:  BRA    20BA
01FD6:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01FD8:  MOVF   3D,W
01FDA:  MOVWF  01
01FDC:  MOVF   3E,W
01FDE:  MOVWF  02
01FE0:  MOVLB  8
01FE2:  BRA    20BA
01FE4:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01FE6:  CLRF   03
01FE8:  MOVF   3F,W
01FEA:  MOVWF  01
01FEC:  MOVF   03,W
01FEE:  MOVWF  02
01FF0:  MOVLB  8
01FF2:  BRA    20BA
01FF4:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01FF6:  MOVF   40,W
01FF8:  MOVWF  01
01FFA:  MOVF   41,W
01FFC:  MOVWF  02
01FFE:  MOVLB  8
02000:  BRA    20BA
02002:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
02004:  MOVF   42,W
02006:  MOVWF  01
02008:  MOVF   43,W
0200A:  MOVWF  02
0200C:  MOVLB  8
0200E:  BRA    20BA
02010:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
02012:  CLRF   03
02014:  MOVF   44,W
02016:  MOVWF  01
02018:  MOVF   03,W
0201A:  MOVWF  02
0201C:  MOVLB  8
0201E:  BRA    20BA
02020:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
02022:  CLRF   03
02024:  MOVF   38,W
02026:  MOVWF  01
02028:  MOVF   03,W
0202A:  MOVWF  02
0202C:  MOVLB  8
0202E:  BRA    20BA
02030:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
02032:  MOVF   39,F
02034:  BNZ   2044
02036:  MOVLW  B0
02038:  MOVWF  01
0203A:  MOVLW  04
0203C:  MOVWF  02
0203E:  MOVLB  8
02040:  BRA    20BA
02042:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
02044:  DECFSZ 39,W
02046:  BRA    2056
02048:  MOVLW  60
0204A:  MOVWF  01
0204C:  MOVLW  09
0204E:  MOVWF  02
02050:  MOVLB  8
02052:  BRA    20BA
02054:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
02056:  MOVF   39,W
02058:  SUBLW  02
0205A:  BNZ   206A
0205C:  MOVLW  C0
0205E:  MOVWF  01
02060:  MOVLW  12
02062:  MOVWF  02
02064:  MOVLB  8
02066:  BRA    20BA
02068:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
0206A:  MOVF   39,W
0206C:  SUBLW  04
0206E:  BNZ   207E
02070:  MOVLW  00
02072:  MOVWF  01
02074:  MOVLW  4B
02076:  MOVWF  02
02078:  MOVLB  8
0207A:  BRA    20BA
0207C:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
0207E:  MOVF   39,W
02080:  SUBLW  05
02082:  BNZ   2092
02084:  MOVLW  00
02086:  MOVWF  01
02088:  MOVLW  96
0208A:  MOVWF  02
0208C:  MOVLB  8
0208E:  BRA    20BA
02090:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
02092:  MOVF   39,W
02094:  SUBLW  06
02096:  BNZ   20A6
02098:  MOVLW  00
0209A:  MOVWF  01
0209C:  MOVLW  E1
0209E:  MOVWF  02
020A0:  MOVLB  8
020A2:  BRA    20BA
020A4:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
020A6:  MOVLW  80
020A8:  MOVWF  01
020AA:  MOVLW  25
020AC:  MOVWF  02
020AE:  MOVLB  8
020B0:  BRA    20BA
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
020B2:  MOVLW  FF
020B4:  MOVWF  01
020B6:  MOVWF  02
020B8:  BRA    20BA
.................... 	} 
....................  
.................... } 
020BA:  MOVLB  0
020BC:  GOTO   210E (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
011B0:  MOVLB  8
011B2:  MOVF   xE0,W
011B4:  SUBLW  1F
011B6:  BNZ   11D0
011B8:  MOVF   xE1,W
011BA:  SUBLW  4E
011BC:  BNZ   11D0
011BE:  MOVF   xE2,W
011C0:  SUBLW  20
011C2:  BNZ   11D0
011C4:  MOVF   xE3,W
011C6:  SUBLW  4E
011C8:  BNZ   11D0
.................... 		return 1; 
011CA:  MOVLW  01
011CC:  MOVWF  01
011CE:  BRA    1298
....................  
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
011D0:  MOVF   xE1,W
011D2:  SUBLW  16
011D4:  BC    11F4
011D6:  XORLW  FF
011D8:  BNZ   11E0
011DA:  MOVF   xE0,W
011DC:  SUBLW  6F
011DE:  BC    11F4
011E0:  MOVF   xE3,W
011E2:  SUBLW  19
011E4:  BNC   11F4
011E6:  BNZ   11EE
011E8:  MOVF   xE2,W
011EA:  SUBLW  50
011EC:  BNC   11F4
.................... 		return 1; 
011EE:  MOVLW  01
011F0:  MOVWF  01
011F2:  BRA    1298
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
011F4:  MOVF   xE1,W
011F6:  SUBLW  12
011F8:  BC    1218
011FA:  XORLW  FF
011FC:  BNZ   1204
011FE:  MOVF   xE0,W
01200:  SUBLW  87
01202:  BC    1218
01204:  MOVF   xE3,W
01206:  SUBLW  17
01208:  BNC   1218
0120A:  BNZ   1212
0120C:  MOVF   xE2,W
0120E:  SUBLW  48
01210:  BNC   1218
.................... 		return 1; 
01212:  MOVLW  01
01214:  MOVWF  01
01216:  BRA    1298
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01218:  MOVF   xE1,W
0121A:  SUBLW  03
0121C:  BC    123C
0121E:  XORLW  FF
01220:  BNZ   1228
01222:  MOVF   xE0,W
01224:  SUBLW  4B
01226:  BC    123C
01228:  MOVF   xE3,W
0122A:  SUBLW  04
0122C:  BNC   123C
0122E:  BNZ   1236
01230:  MOVF   xE2,W
01232:  SUBLW  94
01234:  BNC   123C
.................... 		return 1; 
01236:  MOVLW  01
01238:  MOVWF  01
0123A:  BRA    1298
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
0123C:  MOVF   xE1,W
0123E:  SUBLW  02
01240:  BC    1260
01242:  XORLW  FF
01244:  BNZ   124C
01246:  MOVF   xE0,W
01248:  SUBLW  E7
0124A:  BC    1260
0124C:  MOVF   xE3,W
0124E:  SUBLW  03
01250:  BNC   1260
01252:  BNZ   125A
01254:  MOVF   xE2,W
01256:  SUBLW  F6
01258:  BNC   1260
.................... 		return 1; 
0125A:  MOVLW  01
0125C:  MOVWF  01
0125E:  BRA    1298
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
01260:  MOVF   xE1,W
01262:  SUBLW  06
01264:  BC    1284
01266:  XORLW  FF
01268:  BNZ   1270
0126A:  MOVF   xE0,W
0126C:  SUBLW  CF
0126E:  BC    1284
01270:  MOVF   xE3,W
01272:  SUBLW  09
01274:  BNC   1284
01276:  BNZ   127E
01278:  MOVF   xE2,W
0127A:  SUBLW  D1
0127C:  BNC   1284
.................... 		return 1; 
0127E:  MOVLW  01
01280:  MOVWF  01
01282:  BRA    1298
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01284:  MOVF   xE3,F
01286:  BNZ   1294
01288:  MOVF   xE2,W
0128A:  SUBLW  36
0128C:  BNC   1294
.................... 		return 1; 
0128E:  MOVLW  01
01290:  MOVWF  01
01292:  BRA    1298
....................  
.................... 	return 0; 
01294:  MOVLW  00
01296:  MOVWF  01
.................... } 
01298:  MOVLB  0
0129A:  GOTO   26EC (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
020C0:  MOVFF  8DF,8E8
020C4:  MOVFF  8DE,8E9
020C8:  CALL   12CE
.................... 	modbus_serial_putc(register_count*2); 
020CC:  BCF    FD8.0
020CE:  MOVLB  8
020D0:  RLCF   xE2,W
020D2:  MOVWF  xE8
020D4:  RLCF   xE3,W
020D6:  MOVWF  xE9
020D8:  MOVFF  8E8,8EA
020DC:  MOVLB  0
020DE:  CALL   12A6
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
020E2:  MOVLB  8
020E4:  CLRF   xE5
020E6:  CLRF   xE4
020E8:  MOVF   xE5,W
020EA:  SUBWF  xE3,W
020EC:  BNC   2138
020EE:  BNZ   20F6
020F0:  MOVF   xE2,W
020F2:  SUBWF  xE4,W
020F4:  BC    2138
.................... 		l=map_modbus(start_address+i); 
020F6:  MOVF   xE4,W
020F8:  ADDWF  xE0,W
020FA:  MOVWF  xE8
020FC:  MOVF   xE5,W
020FE:  ADDWFC xE1,W
02100:  MOVWF  xE9
02102:  MOVWF  xEB
02104:  MOVFF  8E8,8EA
02108:  MOVLB  0
0210A:  GOTO   14B2
0210E:  MOVFF  02,8E7
02112:  MOVFF  01,8E6
.................... 		modbus_serial_putc(make8(l,1)); 
02116:  MOVFF  8E7,8E8
0211A:  MOVFF  8E7,8EA
0211E:  CALL   12A6
....................   		modbus_serial_putc(make8(l,0)); 
02122:  MOVFF  8E6,8E8
02126:  MOVFF  8E6,8EA
0212A:  CALL   12A6
.................... 	} 
0212E:  MOVLB  8
02130:  INCF   xE4,F
02132:  BTFSC  FD8.2
02134:  INCF   xE5,F
02136:  BRA    20E8
....................  
.................... 	modbus_serial_send_stop(); 
02138:  MOVLB  0
0213A:  CALL   12FE
.................... } 
0213E:  GOTO   272E (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
02142:  MOVLB  8
02144:  MOVF   xE5,W
02146:  SUBLW  06
02148:  BC    21C0
0214A:  XORLW  FF
0214C:  BNZ   2154
0214E:  MOVF   xE4,W
02150:  SUBLW  CF
02152:  BC    21C0
02154:  MOVF   xE5,W
02156:  SUBLW  09
02158:  BNC   21C0
0215A:  BNZ   2162
0215C:  MOVF   xE4,W
0215E:  SUBLW  CF
02160:  BNC   21C0
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02162:  MOVF   xE7,W
02164:  SUBLW  00
02166:  BC    2178
02168:  XORLW  FF
0216A:  BNZ   2172
0216C:  MOVF   xE6,W
0216E:  SUBLW  00
02170:  BC    2178
02172:  MOVLW  03
02174:  MOVWF  01
02176:  BRA    2524
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
02178:  MOVLW  D0
0217A:  SUBWF  xE4,W
0217C:  MOVWF  xEA
0217E:  MOVLW  07
02180:  SUBWFB xE5,W
02182:  MOVWF  xEB
02184:  MOVLW  02
02186:  ADDWF  xEB,F
02188:  MOVFF  8EB,FAA
0218C:  MOVFF  8EA,FA9
02190:  MOVFF  8E6,FA8
02194:  BCF    FA6.6
02196:  BCF    FA6.7
02198:  BSF    FA6.2
0219A:  MOVF   FF2,W
0219C:  MOVWF  00
0219E:  BCF    FF2.6
021A0:  BCF    FF2.7
021A2:  MOVLB  F
021A4:  MOVLW  55
021A6:  MOVWF  FA7
021A8:  MOVLW  AA
021AA:  MOVWF  FA7
021AC:  BSF    FA6.1
021AE:  BTFSC  FA6.1
021B0:  BRA    21AE
021B2:  BCF    FA6.2
021B4:  MOVF   00,W
021B6:  IORWF  FF2,F
.................... 		return 0; 
021B8:  MOVLW  00
021BA:  MOVWF  01
021BC:  MOVLB  8
021BE:  BRA    2524
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
021C0:  MOVF   xE5,W
021C2:  SUBLW  03
021C4:  BC    2256
021C6:  XORLW  FF
021C8:  BNZ   21D0
021CA:  MOVF   xE4,W
021CC:  SUBLW  4B
021CE:  BC    2256
021D0:  MOVF   xE5,W
021D2:  SUBLW  04
021D4:  BNC   2256
021D6:  BNZ   21DE
021D8:  MOVF   xE4,W
021DA:  SUBLW  93
021DC:  BNC   2256
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
021DE:  MOVF   xE7,W
021E0:  SUBLW  00
021E2:  BC    21F4
021E4:  XORLW  FF
021E6:  BNZ   21EE
021E8:  MOVF   xE6,W
021EA:  SUBLW  00
021EC:  BC    21F4
021EE:  MOVLW  03
021F0:  MOVWF  01
021F2:  BRA    2524
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
021F4:  MOVLW  4C
021F6:  SUBWF  xE4,W
021F8:  MOVWF  xE8
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
021FA:  MOVFF  8E8,8F0
021FE:  MOVLW  06
02200:  MOVWF  xF1
02202:  MOVLB  0
02204:  CALL   0B02
02208:  MOVFF  00,8E9
.................... 		n = n / 6; /* number of sentence */ 
0220C:  MOVFF  8E8,8F0
02210:  MOVLW  06
02212:  MOVLB  8
02214:  MOVWF  xF1
02216:  MOVLB  0
02218:  CALL   0B02
0221C:  MOVFF  01,8E8
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
02220:  MOVLB  8
02222:  MOVF   xE8,W
02224:  MULLW  06
02226:  MOVF   FF3,W
02228:  CLRF   03
0222A:  ADDLW  19
0222C:  MOVWF  xEA
0222E:  MOVLW  00
02230:  ADDWFC 03,W
02232:  MOVWF  xEB
02234:  CLRF   03
02236:  MOVF   xE9,W
02238:  ADDWF  xEA,W
0223A:  MOVWF  01
0223C:  MOVF   xEB,W
0223E:  ADDWFC 03,F
02240:  MOVF   01,W
02242:  ADDLW  36
02244:  MOVWF  FE9
02246:  MOVLW  00
02248:  ADDWFC 03,W
0224A:  MOVWF  FEA
0224C:  MOVFF  8E6,FEF
.................... 		 
.................... 		return 0; 
02250:  MOVLW  00
02252:  MOVWF  01
02254:  BRA    2524
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
02256:  MOVLB  1
02258:  MOVF   xD8,F
0225A:  BZ    2292
.................... 		if ( 1000 == address ) { 
0225C:  MOVLB  8
0225E:  MOVF   xE4,W
02260:  SUBLW  E8
02262:  BNZ   2276
02264:  MOVF   xE5,W
02266:  SUBLW  03
02268:  BNZ   2276
.................... 			config.serial_prefix=value; 
0226A:  MOVFF  8E6,3A
.................... 			return 0; 
0226E:  MOVLW  00
02270:  MOVWF  01
02272:  BRA    2524
.................... 		} else if ( 1001 == address ) { 
02274:  BRA    2290
02276:  MOVF   xE4,W
02278:  SUBLW  E9
0227A:  BNZ   2290
0227C:  MOVF   xE5,W
0227E:  SUBLW  03
02280:  BNZ   2290
.................... 			config.serial_number=value; 
02282:  MOVFF  8E7,3C
02286:  MOVFF  8E6,3B
.................... 			return 0; 
0228A:  MOVLW  00
0228C:  MOVWF  01
0228E:  BRA    2524
02290:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
02292:  MOVLB  8
02294:  MOVF   xE4,W
02296:  MOVWF  00
02298:  MOVF   xE5,W
0229A:  MOVWF  03
0229C:  MOVLW  03
0229E:  SUBWF  03,W
022A0:  BNZ   22AE
022A2:  MOVLW  EE
022A4:  SUBWF  00,W
022A6:  MOVLB  0
022A8:  BTFSC  FD8.2
022AA:  BRA    2376
022AC:  MOVLB  8
022AE:  MOVLW  03
022B0:  SUBWF  03,W
022B2:  BNZ   22C0
022B4:  MOVLW  EF
022B6:  SUBWF  00,W
022B8:  MOVLB  0
022BA:  BTFSC  FD8.2
022BC:  BRA    238E
022BE:  MOVLB  8
022C0:  MOVLW  03
022C2:  SUBWF  03,W
022C4:  BNZ   22D2
022C6:  MOVLW  F0
022C8:  SUBWF  00,W
022CA:  MOVLB  0
022CC:  BTFSC  FD8.2
022CE:  BRA    239E
022D0:  MOVLB  8
022D2:  MOVLW  03
022D4:  SUBWF  03,W
022D6:  BNZ   22E4
022D8:  MOVLW  F1
022DA:  SUBWF  00,W
022DC:  MOVLB  0
022DE:  BTFSC  FD8.2
022E0:  BRA    23B6
022E2:  MOVLB  8
022E4:  MOVLW  03
022E6:  SUBWF  03,W
022E8:  BNZ   22F6
022EA:  MOVLW  F2
022EC:  SUBWF  00,W
022EE:  MOVLB  0
022F0:  BTFSC  FD8.2
022F2:  BRA    23C2
022F4:  MOVLB  8
022F6:  MOVLW  03
022F8:  SUBWF  03,W
022FA:  BNZ   2308
022FC:  MOVLW  F3
022FE:  SUBWF  00,W
02300:  MOVLB  0
02302:  BTFSC  FD8.2
02304:  BRA    23DC
02306:  MOVLB  8
02308:  MOVLW  03
0230A:  SUBWF  03,W
0230C:  BNZ   231A
0230E:  MOVLW  F4
02310:  SUBWF  00,W
02312:  MOVLB  0
02314:  BTFSC  FD8.2
02316:  BRA    23F4
02318:  MOVLB  8
0231A:  MOVLW  03
0231C:  SUBWF  03,W
0231E:  BNZ   232C
02320:  MOVLW  F5
02322:  SUBWF  00,W
02324:  MOVLB  0
02326:  BTFSC  FD8.2
02328:  BRA    240C
0232A:  MOVLB  8
0232C:  MOVLW  07
0232E:  SUBWF  03,W
02330:  BNZ   233E
02332:  MOVLW  CD
02334:  SUBWF  00,W
02336:  MOVLB  0
02338:  BTFSC  FD8.2
0233A:  BRA    24AA
0233C:  MOVLB  8
0233E:  MOVLW  07
02340:  SUBWF  03,W
02342:  BNZ   2350
02344:  MOVLW  CE
02346:  SUBWF  00,W
02348:  MOVLB  0
0234A:  BTFSC  FD8.2
0234C:  BRA    24BE
0234E:  MOVLB  8
02350:  MOVLW  07
02352:  SUBWF  03,W
02354:  BNZ   2362
02356:  MOVLW  CF
02358:  SUBWF  00,W
0235A:  MOVLB  0
0235C:  BTFSC  FD8.2
0235E:  BRA    24D8
02360:  MOVLB  8
02362:  MOVLW  4E
02364:  SUBWF  03,W
02366:  BNZ   2374
02368:  MOVLW  1F
0236A:  SUBWF  00,W
0236C:  MOVLB  0
0236E:  BTFSC  FD8.2
02370:  BRA    24F2
02372:  MOVLB  8
02374:  BRA    251A
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
02376:  MOVLB  8
02378:  MOVF   xE7,F
0237A:  BNZ   2382
0237C:  MOVF   xE6,W
0237E:  SUBLW  80
02380:  BC    2388
02382:  MOVLW  03
02384:  MOVWF  01
02386:  BRA    2524
.................... 			config.modbus_address=value; 
02388:  MOVFF  8E6,36
.................... 			break; 
0238C:  BRA    2520
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
0238E:  MOVLB  1
02390:  BSF    xFA.1
.................... 			config.adc_sample_ticks=value; 
02392:  MOVFF  8E7,3E
02396:  MOVFF  8E6,3D
.................... 			break; 
0239A:  MOVLB  8
0239C:  BRA    2520
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
0239E:  MOVLB  8
023A0:  MOVF   xE7,F
023A2:  BNZ   23AA
023A4:  MOVF   xE6,W
023A6:  SUBLW  01
023A8:  BC    23B0
023AA:  MOVLW  03
023AC:  MOVWF  01
023AE:  BRA    2524
.................... 			config.allow_bootload_request=value; 
023B0:  MOVFF  8E6,3F
.................... 			break; 
023B4:  BRA    2520
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
023B6:  MOVFF  8E7,41
023BA:  MOVFF  8E6,40
.................... 			break; 
023BE:  MOVLB  8
023C0:  BRA    2520
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
023C2:  MOVLB  8
023C4:  MOVF   xE6,F
023C6:  BNZ   23D2
023C8:  MOVF   xE7,F
023CA:  BNZ   23D2
023CC:  MOVLW  03
023CE:  MOVWF  01
023D0:  BRA    2524
.................... 			config.pi_offtime_seconds=value; 
023D2:  MOVFF  8E7,43
023D6:  MOVFF  8E6,42
.................... 			break; 
023DA:  BRA    2520
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
023DC:  MOVLB  8
023DE:  MOVF   xE7,F
023E0:  BNZ   23E8
023E2:  MOVF   xE6,W
023E4:  SUBLW  01
023E6:  BC    23EE
023E8:  MOVLW  03
023EA:  MOVWF  01
023EC:  BRA    2524
.................... 			config.power_startup=value; 
023EE:  MOVFF  8E6,44
.................... 			break; 
023F2:  BRA    2520
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
023F4:  MOVLB  8
023F6:  MOVF   xE7,F
023F8:  BNZ   2400
023FA:  MOVF   xE6,W
023FC:  SUBLW  02
023FE:  BC    2406
02400:  MOVLW  03
02402:  MOVWF  01
02404:  BRA    2524
.................... 			config.rs485_port_mode=value; 
02406:  MOVFF  8E6,38
.................... 			break; 
0240A:  BRA    2520
.................... 		 
.................... 		case 1013: 
....................  
.................... 			n=0; 
0240C:  MOVLB  8
0240E:  CLRF   xE8
.................... 			if ( 1200 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_1200; } 
02410:  MOVF   xE6,W
02412:  SUBLW  B0
02414:  BNZ   2422
02416:  MOVF   xE7,W
02418:  SUBLW  04
0241A:  BNZ   2422
0241C:  MOVLW  01
0241E:  MOVWF  xE8
02420:  CLRF   39
.................... 			if ( 2400 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_2400; } 
02422:  MOVF   xE6,W
02424:  SUBLW  60
02426:  BNZ   2434
02428:  MOVF   xE7,W
0242A:  SUBLW  09
0242C:  BNZ   2434
0242E:  MOVLW  01
02430:  MOVWF  xE8
02432:  MOVWF  39
.................... 			if ( 4800 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_4800; } 
02434:  MOVF   xE6,W
02436:  SUBLW  C0
02438:  BNZ   2448
0243A:  MOVF   xE7,W
0243C:  SUBLW  12
0243E:  BNZ   2448
02440:  MOVLW  01
02442:  MOVWF  xE8
02444:  MOVLW  02
02446:  MOVWF  39
.................... 			if ( 9600 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_9600; } 
02448:  MOVF   xE6,W
0244A:  SUBLW  80
0244C:  BNZ   245C
0244E:  MOVF   xE7,W
02450:  SUBLW  25
02452:  BNZ   245C
02454:  MOVLW  01
02456:  MOVWF  xE8
02458:  MOVLW  03
0245A:  MOVWF  39
.................... 			if ( 19200 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_19200; } 
0245C:  MOVF   xE6,F
0245E:  BNZ   246E
02460:  MOVF   xE7,W
02462:  SUBLW  4B
02464:  BNZ   246E
02466:  MOVLW  01
02468:  MOVWF  xE8
0246A:  MOVLW  04
0246C:  MOVWF  39
.................... 			if ( 38400 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_38400; } 
0246E:  MOVF   xE6,F
02470:  BNZ   2480
02472:  MOVF   xE7,W
02474:  SUBLW  96
02476:  BNZ   2480
02478:  MOVLW  01
0247A:  MOVWF  xE8
0247C:  MOVLW  05
0247E:  MOVWF  39
.................... 			if ( 57600 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_57600; } 
02480:  MOVF   xE6,F
02482:  BNZ   2492
02484:  MOVF   xE7,W
02486:  SUBLW  E1
02488:  BNZ   2492
0248A:  MOVLW  01
0248C:  MOVWF  xE8
0248E:  MOVLW  06
02490:  MOVWF  39
....................  
.................... 			if (  1==n ) { 
02492:  DECFSZ xE8,W
02494:  BRA    24A0
.................... 				set_rs485_speed(); 
02496:  MOVLB  0
02498:  CALL   08CC
.................... 			}  else { 
0249C:  BRA    24A6
0249E:  MOVLB  8
.................... 				return ILLEGAL_DATA_VALUE; 
024A0:  MOVLW  03
024A2:  MOVWF  01
024A4:  BRA    2524
.................... 			} 
.................... 			break; 
024A6:  MOVLB  8
024A8:  BRA    2520
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
024AA:  MOVLB  8
024AC:  DECFSZ xE6,W
024AE:  BRA    24B4
024B0:  MOVF   xE7,F
024B2:  BZ    24BA
024B4:  MOVLW  03
024B6:  MOVWF  01
024B8:  BRA    2524
.................... 			reset_cpu(); 
024BA:  RESET
024BC:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
024BE:  MOVLB  8
024C0:  DECFSZ xE6,W
024C2:  BRA    24C8
024C4:  MOVF   xE7,F
024C6:  BZ    24CE
024C8:  MOVLW  03
024CA:  MOVWF  01
024CC:  BRA    2524
.................... 			write_default_param_file(); 
024CE:  MOVLB  0
024D0:  CALL   0D3A
.................... 			break; 
024D4:  MOVLB  8
024D6:  BRA    2520
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
024D8:  MOVLB  8
024DA:  DECFSZ xE6,W
024DC:  BRA    24E2
024DE:  MOVF   xE7,F
024E0:  BZ    24E8
024E2:  MOVLW  03
024E4:  MOVWF  01
024E6:  BRA    2524
.................... 			write_param_file(); 
024E8:  MOVLB  0
024EA:  CALL   0CE6
.................... 			break; 
024EE:  MOVLB  8
024F0:  BRA    2520
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
024F2:  MOVLB  8
024F4:  MOVF   xE6,W
024F6:  SUBLW  0A
024F8:  BNZ   2500
024FA:  MOVF   xE7,W
024FC:  SUBLW  07
024FE:  BZ    250C
.................... 				current.factory_unlocked=0; 
02500:  MOVLB  1
02502:  CLRF   xD8
.................... 				return ILLEGAL_DATA_VALUE; 
02504:  MOVLW  03
02506:  MOVWF  01
02508:  MOVLB  8
0250A:  BRA    2524
.................... 			} 
.................... 			current.factory_unlocked=1; 
0250C:  MOVLW  01
0250E:  MOVLB  1
02510:  MOVWF  xD8
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02512:  MOVLW  C8
02514:  MOVWF  xF7
.................... 			break; 
02516:  MOVLB  8
02518:  BRA    2520
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
0251A:  MOVLW  02
0251C:  MOVWF  01
0251E:  BRA    2524
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02520:  MOVLW  00
02522:  MOVWF  01
.................... } 
02524:  MOVLB  0
02526:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
025B8:  GOTO   1162
025BC:  MOVF   01,F
025BE:  BTFSC  FD8.2
025C0:  BRA    28A4
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
025C2:  DECFSZ 38,W
025C4:  BRA    2678
025C6:  MOVF   36,W
025C8:  MOVLB  7
025CA:  SUBWF  xC6,W
025CC:  BTFSS  FD8.2
025CE:  BRA    25D4
025D0:  MOVLB  0
025D2:  BRA    2678
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
025D4:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
025D6:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
025D8:  CLRWDT
025DA:  MOVLW  02
025DC:  MOVLB  8
025DE:  MOVWF  xDE
025E0:  MOVLW  B5
025E2:  MOVWF  xDF
025E4:  MOVLB  0
025E6:  CALL   1188
025EA:  MOVLB  8
025EC:  DECFSZ xDE,F
025EE:  BRA    25E0
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
025F0:  MOVLB  7
025F2:  MOVF   xC6,W
025F4:  MOVLB  0
025F6:  CALL   11A8
.................... 			delay_us(104); //one stop bit @ 9600 baud 
025FA:  CLRWDT
025FC:  MOVLW  67
025FE:  MOVWF  00
02600:  DECFSZ 00,F
02602:  BRA    2600
02604:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02606:  MOVLB  7
02608:  MOVF   xC8,W
0260A:  MOVLB  0
0260C:  CALL   11A8
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02610:  CLRWDT
02612:  MOVLW  67
02614:  MOVWF  00
02616:  DECFSZ 00,F
02618:  BRA    2616
0261A:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
0261C:  MOVLB  8
0261E:  CLRF   xDD
02620:  MOVLW  02
02622:  MOVLB  7
02624:  ADDWF  xC7,W
02626:  MOVLB  8
02628:  SUBWF  xDD,W
0262A:  BC    2658
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
0262C:  MOVLW  CA
0262E:  ADDWF  xDD,W
02630:  MOVWF  FE9
02632:  MOVLW  07
02634:  MOVWF  FEA
02636:  BTFSC  FD8.0
02638:  INCF   FEA,F
0263A:  MOVFF  FEF,8DE
0263E:  MOVF   xDE,W
02640:  MOVLB  0
02642:  CALL   11A8
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02646:  CLRWDT
02648:  MOVLW  67
0264A:  MOVWF  00
0264C:  DECFSZ 00,F
0264E:  BRA    264C
02650:  NOP   
.................... 			} 
02652:  MOVLB  8
02654:  INCF   xDD,F
02656:  BRA    2620
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02658:  BTFSS  F72.1
0265A:  BRA    2658
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
0265C:  CLRWDT
0265E:  MOVLW  02
02660:  MOVWF  xDE
02662:  MOVLW  B5
02664:  MOVWF  xDF
02666:  MOVLB  0
02668:  CALL   1188
0266C:  MOVLB  8
0266E:  DECFSZ xDE,F
02670:  BRA    2662
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02672:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02674:  BCF    F8C.0
02676:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02678:  MOVF   36,W
0267A:  SUBLW  80
0267C:  BZ    268A
0267E:  MOVF   36,W
02680:  MOVLB  7
02682:  SUBWF  xC6,W
02684:  BTFSS  FD8.2
02686:  BRA    288E
02688:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
0268A:  MOVLB  1
0268C:  INCFSZ xCC,W
0268E:  BRA    2696
02690:  INCFSZ xCD,W
02692:  BRA    2696
02694:  BRA    269C
.................... 				current.modbus_our_packets++; 
02696:  INCF   xCC,F
02698:  BTFSC  FD8.2
0269A:  INCF   xCD,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
0269C:  MOVLW  14
0269E:  MOVWF  xF7
....................  
.................... 			switch(modbus_rx.func) { 
026A0:  MOVLB  7
026A2:  MOVF   xC8,W
026A4:  XORLW  03
026A6:  MOVLB  0
026A8:  BZ    26BA
026AA:  XORLW  07
026AC:  BZ    26BA
026AE:  XORLW  02
026B0:  BZ    2732
026B2:  XORLW  16
026B4:  BTFSC  FD8.2
026B6:  BRA    27A4
026B8:  BRA    2866
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
026BA:  MOVFF  7CA,8D9
026BE:  MOVFF  7CB,8D8
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
026C2:  MOVFF  7CC,8DB
026C6:  MOVFF  7CD,8DA
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
026CA:  MOVLB  8
026CC:  MOVF   xDA,W
026CE:  ADDWF  xD8,W
026D0:  MOVWF  xDE
026D2:  MOVF   xDB,W
026D4:  ADDWFC xD9,W
026D6:  MOVWF  xDF
026D8:  MOVFF  8D9,8E1
026DC:  MOVFF  8D8,8E0
026E0:  MOVWF  xE3
026E2:  MOVFF  8DE,8E2
026E6:  MOVLB  0
026E8:  GOTO   11B0
026EC:  MOVF   01,F
026EE:  BNZ   2714
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
026F0:  MOVFF  7C6,8DE
026F4:  MOVLB  8
026F6:  CLRF   xE0
026F8:  MOVFF  7C8,8DF
026FC:  MOVLW  02
026FE:  MOVWF  xE1
02700:  MOVLB  0
02702:  CALL   132E
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02706:  MOVLB  1
02708:  CLRF   xD1
0270A:  MOVLW  02
0270C:  MOVWF  xD0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0270E:  CLRF   xF7
.................... 					} else { 
02710:  BRA    2730
02712:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02714:  MOVFF  7C8,8DE
02718:  MOVFF  7C6,8DF
0271C:  MOVFF  8D9,8E1
02720:  MOVFF  8D8,8E0
02724:  MOVFF  8DB,8E3
02728:  MOVFF  8DA,8E2
0272C:  BRA    20C0
0272E:  MOVLB  1
.................... 					} 
.................... 					break; 
02730:  BRA    2886
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02732:  MOVFF  7CA,8D9
02736:  MOVFF  7CB,8D8
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
0273A:  MOVFF  7CC,8DF
0273E:  MOVFF  7CD,8DE
02742:  MOVFF  8D9,8E5
02746:  MOVFF  8D8,8E4
0274A:  MOVFF  7CC,8E7
0274E:  MOVFF  7CD,8E6
02752:  RCALL  2142
02754:  MOVFF  01,8DC
....................  
.................... 					if ( result ) { 
02758:  MOVLB  8
0275A:  MOVF   xDC,F
0275C:  BZ    2780
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
0275E:  MOVFF  7C6,8DE
02762:  CLRF   xE0
02764:  MOVFF  7C8,8DF
02768:  MOVFF  8DC,8E1
0276C:  MOVLB  0
0276E:  CALL   132E
.................... 						current.modbus_last_error=result; 
02772:  MOVLB  1
02774:  CLRF   xD1
02776:  MOVFF  8DC,1D0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0277A:  CLRF   xF7
.................... 					}  else { 
0277C:  BRA    27A2
0277E:  MOVLB  8
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02780:  MOVFF  7CC,8DF
02784:  MOVFF  7CD,8DE
02788:  MOVFF  7C6,8E0
0278C:  MOVFF  8D9,8E2
02790:  MOVFF  8D8,8E1
02794:  MOVFF  7CC,8E4
02798:  MOVFF  7CD,8E3
0279C:  MOVLB  0
0279E:  BRA    2528
027A0:  MOVLB  1
.................... 					} 
.................... 					break; 
027A2:  BRA    2886
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
027A4:  MOVFF  7CA,8D9
027A8:  MOVFF  7CB,8D8
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
027AC:  MOVFF  7CC,8DB
027B0:  MOVFF  7CD,8DA
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
027B4:  MOVLB  8
027B6:  CLRF   xDD
027B8:  MOVF   xDB,F
027BA:  BNZ   27C2
027BC:  MOVF   xDA,W
027BE:  SUBWF  xDD,W
027C0:  BC    2846
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
027C2:  MOVF   xDD,W
027C4:  ADDWF  xD8,W
027C6:  MOVWF  xDE
027C8:  MOVLW  00
027CA:  ADDWFC xD9,W
027CC:  MOVWF  xDF
027CE:  BCF    FD8.0
027D0:  RLCF   xDD,W
027D2:  ADDLW  05
027D4:  ADDLW  CA
027D6:  MOVWF  FE9
027D8:  MOVLW  07
027DA:  MOVWF  FEA
027DC:  BTFSC  FD8.0
027DE:  INCF   FEA,F
027E0:  MOVFF  FEF,8E0
027E4:  BCF    FD8.0
027E6:  RLCF   xDD,W
027E8:  ADDLW  06
027EA:  ADDLW  CA
027EC:  MOVWF  FE9
027EE:  MOVLW  07
027F0:  MOVWF  FEA
027F2:  BTFSC  FD8.0
027F4:  INCF   FEA,F
027F6:  MOVFF  FEF,8E1
027FA:  MOVFF  8E0,8E3
027FE:  MOVFF  8E1,8E2
02802:  MOVFF  8DF,8E5
02806:  MOVFF  8DE,8E4
0280A:  MOVFF  8E0,8E7
0280E:  MOVFF  8E1,8E6
02812:  MOVLB  0
02814:  RCALL  2142
02816:  MOVFF  01,8DC
....................  
.................... 						if ( result ) { 
0281A:  MOVLB  8
0281C:  MOVF   xDC,F
0281E:  BZ    2842
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02820:  MOVFF  7C6,8DE
02824:  CLRF   xE0
02826:  MOVFF  7C8,8DF
0282A:  MOVFF  8DC,8E1
0282E:  MOVLB  0
02830:  CALL   132E
.................... 							current.modbus_last_error=result; 
02834:  MOVLB  1
02836:  CLRF   xD1
02838:  MOVFF  8DC,1D0
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
0283C:  CLRF   xF7
.................... 			 
.................... 							break; 
0283E:  MOVLB  8
02840:  BRA    2846
.................... 						} 
.................... 					} 
02842:  INCF   xDD,F
02844:  BRA    27B8
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02846:  MOVF   xDC,F
02848:  BNZ   2862
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
0284A:  MOVFF  7C6,8DE
0284E:  MOVFF  8D9,8E0
02852:  MOVFF  8D8,8DF
02856:  MOVFF  8DB,8E2
0285A:  MOVFF  8DA,8E1
0285E:  MOVLB  0
02860:  BRA    2570
.................... 					} 
....................  
.................... 					break;   
02862:  MOVLB  1
02864:  BRA    2886
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02866:  MOVFF  7C6,8DE
0286A:  MOVLB  8
0286C:  CLRF   xE0
0286E:  MOVFF  7C8,8DF
02872:  MOVLW  01
02874:  MOVWF  xE1
02876:  MOVLB  0
02878:  CALL   132E
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
0287C:  MOVLB  1
0287E:  CLRF   xD1
02880:  MOVLW  01
02882:  MOVWF  xD0
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02884:  CLRF   xF7
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02886:  CLRF   xDA
02888:  CLRF   xD9
....................  
.................... 		} else { 
0288A:  BRA    28A4
0288C:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
0288E:  MOVLB  1
02890:  INCFSZ xCE,W
02892:  BRA    289A
02894:  INCFSZ xCF,W
02896:  BRA    289A
02898:  BRA    28A0
.................... 				current.modbus_other_packets++; 
0289A:  INCF   xCE,F
0289C:  BTFSC  FD8.2
0289E:  INCF   xCF,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
028A0:  MOVLW  0A
028A2:  MOVWF  xF7
028A4:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
028A6:  GOTO   2D3A (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00442:  MOVLB  9
00444:  BTFSS  xEB.0
00446:  BRA    0460
00448:  MOVLB  1
0044A:  INCFSZ xE6,W
0044C:  BRA    0458
0044E:  INCFSZ xE7,W
00450:  BRA    0458
00452:  MOVLB  9
00454:  BRA    0460
00456:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00458:  INCF   xE6,F
0045A:  BTFSC  FD8.2
0045C:  INCF   xE7,F
0045E:  MOVLB  9
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00460:  BTFSS  xEB.2
00462:  BRA    047C
00464:  MOVLB  1
00466:  INCFSZ xE8,W
00468:  BRA    0474
0046A:  INCFSZ xE9,W
0046C:  BRA    0474
0046E:  MOVLB  9
00470:  BRA    047C
00472:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00474:  INCF   xE8,F
00476:  BTFSC  FD8.2
00478:  INCF   xE9,F
0047A:  MOVLB  9
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0047C:  BTFSS  xEB.4
0047E:  BRA    0498
00480:  MOVLB  1
00482:  INCFSZ xEA,W
00484:  BRA    0490
00486:  INCFSZ xEB,W
00488:  BRA    0490
0048A:  MOVLB  9
0048C:  BRA    0498
0048E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00490:  INCF   xEA,F
00492:  BTFSC  FD8.2
00494:  INCF   xEB,F
00496:  MOVLB  9
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00498:  BCF    xEB.1
0049A:  BTFSC  F81.0
0049C:  BSF    xEB.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0049E:  BTFSC  xEB.1
004A0:  BRA    0524
004A2:  MOVLB  7
004A4:  BTFSC  xC2.1
004A6:  BRA    04AC
004A8:  MOVLB  9
004AA:  BRA    0524
.................... 		current.pulse_count[0]++; 
004AC:  MOVLB  0
004AE:  INCF   xA9,F
004B0:  BTFSC  FD8.2
004B2:  INCF   xAA,F
.................... 		current.pulse_sum[0]++; 
004B4:  MOVLW  01
004B6:  ADDWF  xAF,F
004B8:  BTFSC  FD8.0
004BA:  INCF   xB0,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xB1,F
004C0:  BTFSC  FD8.2
004C2:  INCF   xB2,F
.................... 		if ( 1 == ext0_state ) { 
004C4:  MOVLB  7
004C6:  BTFSS  xC2.2
004C8:  BRA    0512
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004CA:  MOVLB  9
004CC:  BCF    xEB.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004CE:  MOVFF  1E7,98
004D2:  MOVFF  1E6,97
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004D6:  MOVLB  0
004D8:  MOVF   x98,W
004DA:  SUBWF  x9E,W
004DC:  BNC   04EE
004DE:  BNZ   04E6
004E0:  MOVF   x9D,W
004E2:  SUBWF  x97,W
004E4:  BC    04EE
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
004E6:  MOVFF  98,9E
004EA:  MOVFF  97,9D
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
004EE:  MOVF   xA4,W
004F0:  SUBWF  x98,W
004F2:  BNC   050E
004F4:  BNZ   04FC
004F6:  MOVF   x97,W
004F8:  SUBWF  xA3,W
004FA:  BC    050E
004FC:  INCFSZ x97,W
004FE:  BRA    0506
00500:  INCFSZ x98,W
00502:  BRA    0506
00504:  BRA    050E
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00506:  MOVFF  98,A4
0050A:  MOVFF  97,A3
.................... 			} 
.................... 			ext0_state=0; 
0050E:  MOVLB  7
00510:  BCF    xC2.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00512:  BTFSC  xC2.2
00514:  BRA    0524
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00516:  MOVLB  1
00518:  CLRF   xE7
0051A:  CLRF   xE6
.................... 			ext0_count=1; 
0051C:  MOVLB  9
0051E:  BSF    xEB.0
.................... 			ext0_state=1; 
00520:  MOVLB  7
00522:  BSF    xC2.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00524:  MOVLB  7
00526:  BCF    xC2.1
00528:  MOVLB  9
0052A:  BTFSS  xEB.1
0052C:  BRA    0534
0052E:  MOVLB  7
00530:  BSF    xC2.1
00532:  MOVLB  9
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00534:  BCF    xEB.3
00536:  BTFSC  F81.1
00538:  BSF    xEB.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0053A:  BTFSC  xEB.3
0053C:  BRA    05C0
0053E:  MOVLB  7
00540:  BTFSC  xC2.3
00542:  BRA    0548
00544:  MOVLB  9
00546:  BRA    05C0
.................... 		current.pulse_count[1]++; 
00548:  MOVLB  0
0054A:  INCF   xAB,F
0054C:  BTFSC  FD8.2
0054E:  INCF   xAC,F
.................... 		current.pulse_sum[1]++; 
00550:  MOVLW  01
00552:  ADDWF  xB3,F
00554:  BTFSC  FD8.0
00556:  INCF   xB4,F
00558:  BTFSC  FD8.2
0055A:  INCF   xB5,F
0055C:  BTFSC  FD8.2
0055E:  INCF   xB6,F
.................... 		if ( 1 == ext1_state ) { 
00560:  MOVLB  7
00562:  BTFSS  xC2.4
00564:  BRA    05AE
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00566:  MOVLB  9
00568:  BCF    xEB.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
0056A:  MOVFF  1E9,9A
0056E:  MOVFF  1E8,99
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00572:  MOVLB  0
00574:  MOVF   x9A,W
00576:  SUBWF  xA0,W
00578:  BNC   058A
0057A:  BNZ   0582
0057C:  MOVF   x9F,W
0057E:  SUBWF  x99,W
00580:  BC    058A
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
00582:  MOVFF  9A,A0
00586:  MOVFF  99,9F
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
0058A:  MOVF   xA6,W
0058C:  SUBWF  x9A,W
0058E:  BNC   05AA
00590:  BNZ   0598
00592:  MOVF   x99,W
00594:  SUBWF  xA5,W
00596:  BC    05AA
00598:  INCFSZ x99,W
0059A:  BRA    05A2
0059C:  INCFSZ x9A,W
0059E:  BRA    05A2
005A0:  BRA    05AA
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005A2:  MOVFF  9A,A6
005A6:  MOVFF  99,A5
.................... 			} 
.................... 			ext1_state=0; 
005AA:  MOVLB  7
005AC:  BCF    xC2.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005AE:  BTFSC  xC2.4
005B0:  BRA    05C0
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005B2:  MOVLB  1
005B4:  CLRF   xE9
005B6:  CLRF   xE8
.................... 			ext1_count=1; 
005B8:  MOVLB  9
005BA:  BSF    xEB.2
.................... 			ext1_state=1; 
005BC:  MOVLB  7
005BE:  BSF    xC2.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005C0:  MOVLB  7
005C2:  BCF    xC2.3
005C4:  MOVLB  9
005C6:  BTFSS  xEB.3
005C8:  BRA    05D0
005CA:  MOVLB  7
005CC:  BSF    xC2.3
005CE:  MOVLB  9
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005D0:  BCF    xEB.5
005D2:  BTFSC  F81.2
005D4:  BSF    xEB.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005D6:  BTFSC  xEB.5
005D8:  BRA    065C
005DA:  MOVLB  7
005DC:  BTFSC  xC2.5
005DE:  BRA    05E4
005E0:  MOVLB  9
005E2:  BRA    065C
.................... 		current.pulse_count[2]++; 
005E4:  MOVLB  0
005E6:  INCF   xAD,F
005E8:  BTFSC  FD8.2
005EA:  INCF   xAE,F
.................... 		current.pulse_sum[2]++; 
005EC:  MOVLW  01
005EE:  ADDWF  xB7,F
005F0:  BTFSC  FD8.0
005F2:  INCF   xB8,F
005F4:  BTFSC  FD8.2
005F6:  INCF   xB9,F
005F8:  BTFSC  FD8.2
005FA:  INCF   xBA,F
.................... 		if ( 1 == ext2_state ) { 
005FC:  MOVLB  7
005FE:  BTFSS  xC2.6
00600:  BRA    064A
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
00602:  MOVLB  9
00604:  BCF    xEB.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00606:  MOVFF  1EB,9C
0060A:  MOVFF  1EA,9B
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0060E:  MOVLB  0
00610:  MOVF   x9C,W
00612:  SUBWF  xA2,W
00614:  BNC   0626
00616:  BNZ   061E
00618:  MOVF   xA1,W
0061A:  SUBWF  x9B,W
0061C:  BC    0626
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0061E:  MOVFF  9C,A2
00622:  MOVFF  9B,A1
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00626:  MOVF   xA8,W
00628:  SUBWF  x9C,W
0062A:  BNC   0646
0062C:  BNZ   0634
0062E:  MOVF   x9B,W
00630:  SUBWF  xA7,W
00632:  BC    0646
00634:  INCFSZ x9B,W
00636:  BRA    063E
00638:  INCFSZ x9C,W
0063A:  BRA    063E
0063C:  BRA    0646
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0063E:  MOVFF  9C,A8
00642:  MOVFF  9B,A7
.................... 			} 
.................... 			ext2_state=0; 
00646:  MOVLB  7
00648:  BCF    xC2.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
0064A:  BTFSC  xC2.6
0064C:  BRA    065C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0064E:  MOVLB  1
00650:  CLRF   xEB
00652:  CLRF   xEA
.................... 			ext2_count=1; 
00654:  MOVLB  9
00656:  BSF    xEB.4
.................... 			ext2_state=1; 
00658:  MOVLB  7
0065A:  BSF    xC2.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0065C:  MOVLB  7
0065E:  BCF    xC2.5
00660:  MOVLB  9
00662:  BTFSS  xEB.5
00664:  BRA    066C
00666:  MOVLB  7
00668:  BSF    xC2.5
0066A:  MOVLB  9
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0066C:  MOVLB  8
0066E:  INCF   xCD,F
.................... 	if ( 10 == tick ) { 
00670:  MOVF   xCD,W
00672:  SUBLW  0A
00674:  BNZ   067E
.................... 		tick=0; 
00676:  CLRF   xCD
.................... 		timers.now_millisecond=1; 
00678:  MOVLB  1
0067A:  BSF    xFA.2
0067C:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0067E:  BCF    F9E.1
00680:  MOVLB  0
00682:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
0069E:  BRA    0686
006A0:  MOVFF  01,9E8
.................... 	current.rda2_bytes_received++; 
006A4:  MOVLB  1
006A6:  INCF   xE4,F
006A8:  BTFSC  FD8.2
006AA:  INCF   xE5,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
006AC:  DECFSZ 38,W
006AE:  BRA    06D2
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006B0:  MOVLB  2
006B2:  CLRF   xFF
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006B4:  INCFSZ xFE,W
006B6:  BRA    06BA
006B8:  BRA    06CE
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006BA:  MOVLW  FE
006BC:  ADDWF  xFE,W
006BE:  MOVWF  FE9
006C0:  MOVLW  01
006C2:  MOVWF  FEA
006C4:  BTFSC  FD8.0
006C6:  INCF   FEA,F
006C8:  MOVFF  9E8,FEF
.................... 			timers.rda2_buff_pos++; 
006CC:  INCF   xFE,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006CE:  BRA    0714
006D0:  MOVLB  1
006D2:  MOVF   38,W
006D4:  SUBLW  02
006D6:  BNZ   0716
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
006D8:  MOVLB  9
006DA:  MOVF   xE8,W
006DC:  SUBLW  0A
006DE:  BZ    06E6
006E0:  MOVF   xE8,W
006E2:  SUBLW  0D
006E4:  BNZ   06F6
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
006E6:  MOVLB  2
006E8:  MOVF   xFE,F
006EA:  BZ    06F2
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
006EC:  MOVLW  14
006EE:  MOVWF  xFF
.................... 			}  else { 
006F0:  BRA    06F2
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
006F2:  BRA    0714
006F4:  MOVLB  9
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
006F6:  MOVLB  2
006F8:  CLRF   xFF
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006FA:  INCFSZ xFE,W
006FC:  BRA    0700
006FE:  BRA    0714
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
00700:  MOVLW  FE
00702:  ADDWF  xFE,W
00704:  MOVWF  FE9
00706:  MOVLW  01
00708:  MOVWF  FEA
0070A:  BTFSC  FD8.0
0070C:  INCF   FEA,F
0070E:  MOVFF  9E8,FEF
.................... 				timers.rda2_buff_pos++; 
00712:  INCF   xFE,F
00714:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... #if 0 
.................... /* transmit buffer empty for Modbus to raspberry pi buffer */ 
.................... #int_tbe 
.................... void isr_uart1_tbe() { 
.................... 	if ( timers.rda_tx_pos == timers.rda_tx_length ) { 
.................... 		/* done transmitting */ 
.................... 	} else { 
.................... 		/* put another character into TX buffer */ 
.................... 	} 
....................  
.................... } 
.................... #endif 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00716:  BCF    FA4.5
00718:  MOVLB  0
0071A:  GOTO   0088
.................... #int_rda 
.................... void isr_uart1_rx() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
00760:  RCALL  071E
00762:  MOVFF  01,9E8
....................  
.................... 	current.rda_bytes_received++; 
00766:  MOVLB  1
00768:  INCF   xE2,F
0076A:  BTFSC  FD8.2
0076C:  INCF   xE3,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
0076E:  MOVLB  7
00770:  BTFSC  xC2.0
00772:  BRA    07CA
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00774:  MOVF   xC3,F
00776:  BNZ   0788
.................... 			modbus_serial_crc.d = 0xFFFF; 
00778:  SETF   xC5
0077A:  SETF   xC4
.................... 			modbus_rx.address = c; 
0077C:  MOVFF  9E8,7C6
.................... 			modbus_serial_state++; 
00780:  INCF   xC3,F
.................... 			modbus_rx.len = 0; 
00782:  CLRF   xC7
.................... 			modbus_rx.error=0; 
00784:  CLRF   xC9
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00786:  BRA    07B6
00788:  DECFSZ xC3,W
0078A:  BRA    0794
.................... 			modbus_rx.func = c; 
0078C:  MOVFF  9E8,7C8
.................... 			modbus_serial_state++; 
00790:  INCF   xC3,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00792:  BRA    07B6
00794:  MOVF   xC3,W
00796:  SUBLW  02
00798:  BNZ   07B6
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0079A:  INCFSZ xC7,W
0079C:  BRA    07A2
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0079E:  MOVLW  FE
007A0:  MOVWF  xC7
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
007A2:  MOVLW  CA
007A4:  ADDWF  xC7,W
007A6:  MOVWF  FE9
007A8:  MOVLW  07
007AA:  MOVWF  FEA
007AC:  BTFSC  FD8.0
007AE:  INCF   FEA,F
007B0:  MOVFF  9E8,FEF
.................... 			modbus_rx.len++; 
007B4:  INCF   xC7,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
007B6:  MOVFF  9E8,9E9
007BA:  MOVLB  0
007BC:  RCALL  0734
.................... 		modbus_enable_timeout(TRUE); 
007BE:  MOVLW  01
007C0:  MOVLB  9
007C2:  MOVWF  xE9
007C4:  MOVLB  0
007C6:  RCALL  03FC
007C8:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
007CA:  BCF    F9E.5
007CC:  MOVLB  0
007CE:  GOTO   0088
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
008CC:  MOVF   39,W
008CE:  XORLW  00
008D0:  BZ    08E8
008D2:  XORLW  01
008D4:  BZ    08F8
008D6:  XORLW  03
008D8:  BZ    0908
008DA:  XORLW  06
008DC:  BZ    0918
008DE:  XORLW  01
008E0:  BZ    0924
008E2:  XORLW  03
008E4:  BZ    0934
008E6:  BRA    0940
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
008E8:  BSF    F70.3
008EA:  MOVLW  C3
008EC:  MOVWF  F75
008EE:  MOVLW  09
008F0:  MOVWF  F76
008F2:  MOVLW  A6
008F4:  MOVWF  F72
008F6:  BRA    094C
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
008F8:  BSF    F70.3
008FA:  MOVLW  E1
008FC:  MOVWF  F75
008FE:  MOVLW  04
00900:  MOVWF  F76
00902:  MOVLW  A6
00904:  MOVWF  F72
00906:  BRA    094C
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
00908:  BSF    F70.3
0090A:  MOVLW  70
0090C:  MOVWF  F75
0090E:  MOVLW  02
00910:  MOVWF  F76
00912:  MOVLW  A6
00914:  MOVWF  F72
00916:  BRA    094C
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
00918:  BCF    F70.3
0091A:  MOVLW  26
0091C:  MOVWF  F75
0091E:  MOVLW  A6
00920:  MOVWF  F72
00922:  BRA    094C
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
00924:  BSF    F70.3
00926:  MOVLW  4D
00928:  MOVWF  F75
0092A:  MOVLW  00
0092C:  MOVWF  F76
0092E:  MOVLW  A6
00930:  MOVWF  F72
00932:  BRA    094C
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
00934:  BCF    F70.3
00936:  MOVLW  0C
00938:  MOVWF  F75
0093A:  MOVLW  A6
0093C:  MOVWF  F72
0093E:  BRA    094C
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
00940:  BCF    F70.3
00942:  MOVLW  4D
00944:  MOVWF  F75
00946:  MOVLW  A6
00948:  MOVWF  F72
0094A:  BRA    094C
.................... 	} 
.................... } 
0094C:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... 	setup_adc(ADC_OFF); 
0094E:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
00950:  MOVLW  08
00952:  MOVWF  F61
00954:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
00956:  MOVLW  00
00958:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
0095A:  MOVLW  FF
0095C:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
0095E:  MOVLW  92
00960:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00962:  MOVLW  80
00964:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00966:  BCF    F96.0
00968:  BCF    F96.1
0096A:  BCF    F96.2
0096C:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
0096E:  MOVLB  1
00970:  CLRF   xF7
.................... 	timers.load_off_seconds=2; 
00972:  CLRF   xF9
00974:  MOVLW  02
00976:  MOVWF  xF8
.................... 	timers.now_adc_sample=0; 
00978:  BCF    xFA.0
.................... 	timers.now_adc_reset_count=0; 
0097A:  BCF    xFA.1
.................... 	timers.now_millisecond=0; 
0097C:  BCF    xFA.2
.................... 	timers.port_b=0b11111111; 
0097E:  SETF   xFB
.................... 	timers.port_c=0b11111111; 
00980:  SETF   xFC
....................  
.................... 	timers.rda2_buff_pos=0; 
00982:  MOVLB  2
00984:  CLRF   xFE
.................... 	timers.rda2_buff_gap=255; 
00986:  SETF   xFF
.................... 	timers.now_parse_rda2=0; 
00988:  MOVLB  1
0098A:  BCF    xFD.0
....................  
.................... 	timers.rda_tx_length=0; 
0098C:  MOVLB  4
0098E:  CLRF   x00
.................... 	timers.rda_tx_pos=0; 
00990:  CLRF   x01
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
00992:  MOVLB  8
00994:  CLRF   xD8
00996:  MOVF   xD8,W
00998:  SUBLW  02
0099A:  BNC   0A4A
.................... 		current.pulse_period[i]=0; 
0099C:  CLRF   03
0099E:  MOVFF  8D8,02
009A2:  BCF    FD8.0
009A4:  RLCF   02,F
009A6:  RLCF   03,F
009A8:  MOVF   02,W
009AA:  ADDLW  97
009AC:  MOVWF  FE9
009AE:  MOVLW  00
009B0:  ADDWFC 03,W
009B2:  MOVWF  FEA
009B4:  CLRF   FEC
009B6:  MOVF   FED,F
009B8:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
009BA:  CLRF   03
009BC:  MOVFF  8D8,02
009C0:  BCF    FD8.0
009C2:  RLCF   02,F
009C4:  RLCF   03,F
009C6:  MOVF   02,W
009C8:  ADDLW  9D
009CA:  MOVWF  FE9
009CC:  MOVLW  00
009CE:  ADDWFC 03,W
009D0:  MOVWF  FEA
009D2:  SETF   FEC
009D4:  MOVF   FED,F
009D6:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
009D8:  CLRF   03
009DA:  MOVFF  8D8,02
009DE:  BCF    FD8.0
009E0:  RLCF   02,F
009E2:  RLCF   03,F
009E4:  MOVF   02,W
009E6:  ADDLW  A3
009E8:  MOVWF  FE9
009EA:  MOVLW  00
009EC:  ADDWFC 03,W
009EE:  MOVWF  FEA
009F0:  CLRF   FEC
009F2:  MOVF   FED,F
009F4:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
009F6:  CLRF   03
009F8:  MOVFF  8D8,02
009FC:  BCF    FD8.0
009FE:  RLCF   02,F
00A00:  RLCF   03,F
00A02:  MOVF   02,W
00A04:  ADDLW  A9
00A06:  MOVWF  FE9
00A08:  MOVLW  00
00A0A:  ADDWFC 03,W
00A0C:  MOVWF  FEA
00A0E:  CLRF   FEC
00A10:  MOVF   FED,F
00A12:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00A14:  MOVLB  9
00A16:  CLRF   xDD
00A18:  MOVFF  8D8,9DC
00A1C:  CLRF   xDF
00A1E:  MOVLW  04
00A20:  MOVWF  xDE
00A22:  MOVLB  0
00A24:  RCALL  0890
00A26:  MOVF   01,W
00A28:  ADDLW  AF
00A2A:  MOVWF  FE9
00A2C:  MOVLW  00
00A2E:  ADDWFC 02,W
00A30:  MOVWF  FEA
00A32:  MOVF   FEE,F
00A34:  MOVF   FEE,F
00A36:  CLRF   FEC
00A38:  MOVF   FED,F
00A3A:  CLRF   FEF
00A3C:  MOVF   FED,F
00A3E:  CLRF   FEF
00A40:  MOVF   FED,F
00A42:  CLRF   FEF
.................... 	} 
00A44:  MOVLB  8
00A46:  INCF   xD8,F
00A48:  BRA    0996
....................  
.................... 	current.modbus_our_packets=0; 
00A4A:  MOVLB  1
00A4C:  CLRF   xCD
00A4E:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
00A50:  CLRF   xCF
00A52:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
00A54:  CLRF   xD1
00A56:  CLRF   xD0
.................... 	current.sequence_number=0; 
00A58:  CLRF   xD3
00A5A:  CLRF   xD2
.................... 	current.uptime_minutes=0; 
00A5C:  CLRF   xD5
00A5E:  CLRF   xD4
.................... 	current.interval_milliseconds=0; 
00A60:  CLRF   xD7
00A62:  CLRF   xD6
.................... 	current.adc_buffer_index=0; 
00A64:  CLRF   xCB
.................... 	current.factory_unlocked=0; 
00A66:  CLRF   xD8
.................... 	current.watchdog_seconds=0; 
00A68:  CLRF   xDA
00A6A:  CLRF   xD9
.................... 	current.rda_bytes_received=0; 
00A6C:  CLRF   xE3
00A6E:  CLRF   xE2
.................... 	current.rda2_bytes_received=0; 
00A70:  CLRF   xE5
00A72:  CLRF   xE4
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
00A74:  MOVLW  04
00A76:  MOVWF  FEA
00A78:  MOVLW  02
00A7A:  MOVWF  FE9
00A7C:  CLRF   00
00A7E:  MOVLW  03
00A80:  MOVWF  02
00A82:  MOVLW  C0
00A84:  MOVWF  01
00A86:  MOVLB  0
00A88:  RCALL  08B2
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00A8A:  MOVFF  4C,1DD
00A8E:  MOVFF  4B,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
00A92:  MOVFF  48,1DF
00A96:  MOVFF  47,1DE
.................... 	current.power_override_timeout=0; 
00A9A:  MOVLB  1
00A9C:  CLRF   xE1
00A9E:  CLRF   xE0
....................  
.................... 	/* UART2 - RS-485 port */ 
.................... 	set_rs485_speed(); 
00AA0:  MOVLB  0
00AA2:  RCALL  08CC
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00AA4:  MOVLW  00
00AA6:  IORLW  05
00AA8:  MOVWF  FBA
00AAA:  MOVLW  4A
00AAC:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00AAE:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00AB0:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00AB2:  GOTO   2BB6 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00FFA:  MOVLB  1
00FFC:  BCF    xFA.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00FFE:  BCF    FD8.0
01000:  MOVLB  8
01002:  RLCF   xD3,W
01004:  MOVWF  xD8
01006:  RLCF   xD4,W
01008:  MOVWF  xD9
0100A:  MOVLW  00
0100C:  MOVLB  1
0100E:  BTFSS  xFC.5
01010:  MOVLW  01
01012:  MOVLB  8
01014:  IORWF  xD8,F
01016:  MOVFF  8D8,8D3
0101A:  MOVF   xD9,W
0101C:  IORLW  E0
0101E:  MOVWF  xD4
.................... 	if ( b2_state==0xf000) { 
01020:  MOVF   xD3,F
01022:  BNZ   102A
01024:  MOVF   xD4,W
01026:  SUBLW  F0
01028:  BNZ   102A
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
0102A:  MOVLB  1
0102C:  INCFSZ xE6,W
0102E:  BRA    103C
01030:  INCFSZ xE7,W
01032:  BRA    103C
.................... 				current.pulse_period[0]=0; 
01034:  MOVLB  0
01036:  CLRF   x98
01038:  CLRF   x97
0103A:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
0103C:  INCFSZ xE8,W
0103E:  BRA    104C
01040:  INCFSZ xE9,W
01042:  BRA    104C
.................... 				current.pulse_period[1]=0; 
01044:  MOVLB  0
01046:  CLRF   x9A
01048:  CLRF   x99
0104A:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
0104C:  INCFSZ xEA,W
0104E:  BRA    105C
01050:  INCFSZ xEB,W
01052:  BRA    105C
.................... 				current.pulse_period[2]=0; 
01054:  MOVLB  0
01056:  CLRF   x9C
01058:  CLRF   x9B
0105A:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
0105C:  MOVFF  F81,1FB
.................... 	timers.port_c=port_c; 
01060:  MOVFF  F82,1FC
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
01064:  MOVF   xF7,F
01066:  BNZ   106C
.................... 		output_low(LED_GREEN); 
01068:  BCF    F89.3
.................... 	} else { 
0106A:  BRA    1070
.................... 		output_high(LED_GREEN); 
0106C:  BSF    F89.3
.................... 		timers.led_on_green--; 
0106E:  DECF   xF7,F
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
01070:  INCFSZ xD6,W
01072:  BRA    107A
01074:  INCFSZ xD7,W
01076:  BRA    107A
01078:  BRA    1080
.................... 		current.interval_milliseconds++; 
0107A:  INCF   xD6,F
0107C:  BTFSC  FD8.2
0107E:  INCF   xD7,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
01080:  MOVLB  8
01082:  INCF   xD1,F
01084:  BTFSC  FD8.2
01086:  INCF   xD2,F
.................... 	if ( 1000 == ticks ) { 
01088:  MOVF   xD1,W
0108A:  SUBLW  E8
0108C:  BNZ   1112
0108E:  MOVF   xD2,W
01090:  SUBLW  03
01092:  BNZ   1112
.................... 		ticks=0; 
01094:  CLRF   xD2
01096:  CLRF   xD1
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
01098:  MOVLB  1
0109A:  INCFSZ xD9,W
0109C:  BRA    10A4
0109E:  INCFSZ xDA,W
010A0:  BRA    10A4
010A2:  BRA    10AA
.................... 			current.watchdog_seconds++; 
010A4:  INCF   xD9,F
010A6:  BTFSC  FD8.2
010A8:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
010AA:  MOVF   40,F
010AC:  BNZ   10B2
010AE:  MOVF   41,F
010B0:  BZ    10D0
010B2:  MOVF   41,W
010B4:  SUBWF  xDA,W
010B6:  BNC   10D0
010B8:  BNZ   10C0
010BA:  MOVF   xD9,W
010BC:  SUBWF  40,W
010BE:  BC    10D0
010C0:  MOVF   xF8,F
010C2:  BNZ   10D0
010C4:  MOVF   xF9,F
010C6:  BNZ   10D0
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
010C8:  MOVFF  43,1F9
010CC:  MOVFF  42,1F8
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
010D0:  MOVF   xF8,F
010D2:  BNZ   10DC
010D4:  MOVF   xF9,F
010D6:  BNZ   10DC
.................... 			output_high(PI_POWER_EN); 
010D8:  BSF    F8B.0
.................... 		} else { 
010DA:  BRA    10F2
.................... 			output_low(PI_POWER_EN); 
010DC:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
010DE:  MOVF   xF8,W
010E0:  BTFSC  FD8.2
010E2:  DECF   xF9,F
010E4:  DECF   xF8,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
010E6:  MOVF   xF8,F
010E8:  BNZ   10F2
010EA:  MOVF   xF9,F
010EC:  BNZ   10F2
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
010EE:  CLRF   xDA
010F0:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
010F2:  MOVLB  8
010F4:  INCF   xCE,F
.................... 		if ( 60 == uptimeTicks ) { 
010F6:  MOVF   xCE,W
010F8:  SUBLW  3C
010FA:  BNZ   1112
.................... 			uptimeTicks=0; 
010FC:  CLRF   xCE
.................... 			if ( current.uptime_minutes < 65535 )  
010FE:  MOVLB  1
01100:  INCFSZ xD4,W
01102:  BRA    110A
01104:  INCFSZ xD5,W
01106:  BRA    110A
01108:  BRA    1110
.................... 				current.uptime_minutes++; 
0110A:  INCF   xD4,F
0110C:  BTFSC  FD8.2
0110E:  INCF   xD5,F
01110:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
.................... #if 0 
.................... 	LVD code  
.................... 	if ( 65535 == adcValue ) { 
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
.................... 	} 
....................  
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
01112:  MOVLB  1
01114:  BTFSS  xFA.1
01116:  BRA    1120
.................... 		timers.now_adc_reset_count=0; 
01118:  BCF    xFA.1
.................... 		adcTicks=0; 
0111A:  MOVLB  8
0111C:  CLRF   xD0
0111E:  CLRF   xCF
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01120:  MOVLB  8
01122:  INCF   xCF,F
01124:  BTFSC  FD8.2
01126:  INCF   xD0,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
01128:  MOVF   3D,W
0112A:  SUBWF  xCF,W
0112C:  BNZ   1142
0112E:  MOVF   3E,W
01130:  SUBWF  xD0,W
01132:  BNZ   1142
.................... 		adcTicks=0; 
01134:  CLRF   xD0
01136:  CLRF   xCF
.................... 		timers.now_adc_sample=1; 
01138:  MOVLB  1
0113A:  BSF    xFA.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
0113C:  MOVLB  8
0113E:  SETF   xD6
01140:  SETF   xD5
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01142:  MOVLB  2
01144:  INCFSZ xFF,W
01146:  BRA    114A
01148:  BRA    114C
.................... 		timers.rda2_buff_gap++; 
0114A:  INCF   xFF,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
0114C:  MOVF   xFF,W
0114E:  SUBLW  09
01150:  BC    115C
01152:  MOVF   xFE,F
01154:  BZ    115C
.................... 		timers.now_parse_rda2=1;	 
01156:  MOVLB  1
01158:  BSF    xFD.0
0115A:  MOVLB  2
.................... 	} 
.................... } 
0115C:  MOVLB  0
0115E:  GOTO   2D28 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
028AA:  MOVLB  9
028AC:  CLRF   xE4
028AE:  MOVF   xE2,W
028B0:  SUBWF  xE4,W
028B2:  BC    2920
028B4:  CLRF   03
028B6:  MOVF   xE4,W
028B8:  ADDWF  xE0,W
028BA:  MOVWF  FE9
028BC:  MOVF   xE1,W
028BE:  ADDWFC 03,W
028C0:  MOVWF  FEA
028C2:  MOVF   FEF,F
028C4:  BZ    2920
028C6:  CLRF   03
028C8:  MOVF   xE4,W
028CA:  ADDWF  xE0,W
028CC:  MOVWF  FE9
028CE:  MOVF   xE1,W
028D0:  ADDWFC 03,W
028D2:  MOVWF  FEA
028D4:  MOVF   FEF,W
028D6:  SUBLW  0A
028D8:  BZ    2920
028DA:  CLRF   03
028DC:  MOVF   xE4,W
028DE:  ADDWF  xE0,W
028E0:  MOVWF  FE9
028E2:  MOVF   xE1,W
028E4:  ADDWFC 03,W
028E6:  MOVWF  FEA
028E8:  MOVF   FEF,W
028EA:  SUBLW  0D
028EC:  BZ    2920
.................... 		dest[i] = src[i]; 
028EE:  CLRF   03
028F0:  MOVF   xE4,W
028F2:  ADDWF  xDE,W
028F4:  MOVWF  01
028F6:  MOVF   xDF,W
028F8:  ADDWFC 03,F
028FA:  MOVFF  03,9E6
028FE:  CLRF   03
02900:  MOVF   xE4,W
02902:  ADDWF  xE0,W
02904:  MOVWF  FE9
02906:  MOVF   xE1,W
02908:  ADDWFC 03,W
0290A:  MOVWF  FEA
0290C:  MOVFF  FEF,9E7
02910:  MOVFF  9E6,FEA
02914:  MOVFF  01,FE9
02918:  MOVFF  9E7,FEF
.................... 	} 
0291C:  INCF   xE4,F
0291E:  BRA    28AE
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
02920:  MOVF   xE3,W
02922:  SUBWF  xE4,W
02924:  BC    293A
.................... 		dest[i] = '\0'; 
02926:  CLRF   03
02928:  MOVF   xE4,W
0292A:  ADDWF  xDE,W
0292C:  MOVWF  FE9
0292E:  MOVF   xDF,W
02930:  ADDWFC 03,W
02932:  MOVWF  FEA
02934:  CLRF   FEF
.................... 	} 
02936:  INCF   xE4,F
02938:  BRA    2920
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
0293A:  MOVLW  01
0293C:  SUBWF  xE3,W
0293E:  CLRF   03
02940:  ADDWF  xDE,W
02942:  MOVWF  FE9
02944:  MOVF   xDF,W
02946:  ADDWFC 03,W
02948:  MOVWF  FEA
0294A:  CLRF   FEF
.................... } 
0294C:  MOVLB  0
0294E:  RETURN 0
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
029E8:  MOVFF  2FE,9D8
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
029EC:  MOVLB  2
029EE:  SETF   xFE
.................... 	memcpy(buff,timers.rda2_buff,length); 
029F0:  MOVLW  08
029F2:  MOVWF  FEA
029F4:  MOVLW  D8
029F6:  MOVWF  FE9
029F8:  MOVLW  01
029FA:  MOVWF  FE2
029FC:  MOVLW  FE
029FE:  MOVWF  FE1
02A00:  MOVLB  9
02A02:  MOVF   xD8,W
02A04:  MOVWF  01
02A06:  BZ    2A10
02A08:  MOVFF  FE6,FEE
02A0C:  DECFSZ 01,F
02A0E:  BRA    2A08
.................... 	timers.rda2_buff_gap=0; 
02A10:  MOVLB  2
02A12:  CLRF   xFF
.................... 	timers.rda2_buff_pos=0; 
02A14:  CLRF   xFE
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02A16:  DECFSZ 38,W
02A18:  BRA    2A50
.................... 		/* transmit back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02A1A:  MOVLB  9
02A1C:  CLRF   xDA
02A1E:  CLRF   xD9
02A20:  MOVF   xDA,F
02A22:  BNZ   2A4C
02A24:  MOVF   xD8,W
02A26:  SUBWF  xD9,W
02A28:  BC    2A4C
.................... 			fputc(buff[l],STREAM_PI); 
02A2A:  MOVLW  D8
02A2C:  ADDWF  xD9,W
02A2E:  MOVWF  FE9
02A30:  MOVLW  08
02A32:  ADDWFC xDA,W
02A34:  MOVWF  FEA
02A36:  MOVFF  FEF,9DC
02A3A:  MOVF   xDC,W
02A3C:  MOVLB  0
02A3E:  CALL   129E
.................... 		} 
02A42:  MOVLB  9
02A44:  INCF   xD9,F
02A46:  BTFSC  FD8.2
02A48:  INCF   xDA,F
02A4A:  BRA    2A20
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
02A4C:  BRA    2B0C
02A4E:  MOVLB  2
02A50:  MOVF   38,W
02A52:  SUBLW  02
02A54:  BNZ   2B0E
.................... 		/* do something */ 
....................  
.................... 		/* put copy in 11th slot no mater what ... for debugging */ 
.................... 		strncpy_terminate_trim(nmea.sentence[11],buff,length,NMEA_SENTENCE_LENGTH); 
02A56:  MOVLW  07
02A58:  MOVLB  9
02A5A:  MOVWF  xDF
02A5C:  MOVLW  72
02A5E:  MOVWF  xDE
02A60:  MOVLW  08
02A62:  MOVWF  xE1
02A64:  MOVLW  D8
02A66:  MOVWF  xE0
02A68:  MOVFF  9D8,9E2
02A6C:  MOVLW  50
02A6E:  MOVWF  xE3
02A70:  MOVLB  0
02A72:  RCALL  28AA
....................  
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
02A74:  MOVLB  9
02A76:  MOVF   xD8,W
02A78:  SUBLW  05
02A7A:  BNC   2A7E
.................... 			return; 
02A7C:  BRA    2B0C
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
02A7E:  CLRF   xDB
02A80:  MOVF   xDB,W
02A82:  SUBLW  0B
02A84:  BNC   2B0C
.................... 			/* compare first six characters */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) ) { 
02A86:  MOVF   xDB,W
02A88:  MULLW  06
02A8A:  MOVF   FF3,W
02A8C:  CLRF   03
02A8E:  ADDLW  4F
02A90:  MOVWF  01
02A92:  MOVLW  00
02A94:  ADDWFC 03,F
02A96:  MOVFF  01,9DC
02A9A:  MOVFF  03,9DD
02A9E:  MOVLW  08
02AA0:  MOVWF  xDF
02AA2:  MOVLW  D8
02AA4:  MOVWF  xDE
02AA6:  MOVFF  03,9E1
02AAA:  MOVFF  01,9E0
02AAE:  CLRF   xE3
02AB0:  MOVLW  06
02AB2:  MOVWF  xE2
02AB4:  MOVLB  0
02AB6:  BRA    2950
02AB8:  MOVF   01,F
02ABA:  BZ    2ABE
.................... 				/* no match */ 
.................... 				continue; 
02ABC:  BRA    2B06
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
02ABE:  MOVLB  9
02AC0:  CLRF   xDD
02AC2:  MOVFF  9DB,9DC
02AC6:  CLRF   xDF
02AC8:  MOVLW  50
02ACA:  MOVWF  xDE
02ACC:  MOVLB  0
02ACE:  CALL   0890
02AD2:  MOVFF  02,03
02AD6:  MOVF   01,W
02AD8:  ADDLW  02
02ADA:  MOVWF  01
02ADC:  MOVLW  04
02ADE:  ADDWFC 03,F
02AE0:  MOVFF  01,9DC
02AE4:  MOVLB  9
02AE6:  MOVFF  03,9DD
02AEA:  MOVFF  03,9DF
02AEE:  MOVFF  01,9DE
02AF2:  MOVLW  08
02AF4:  MOVWF  xE1
02AF6:  MOVLW  D8
02AF8:  MOVWF  xE0
02AFA:  MOVFF  9D8,9E2
02AFE:  MOVLW  50
02B00:  MOVWF  xE3
02B02:  MOVLB  0
02B04:  RCALL  28AA
.................... 		} 
02B06:  MOVLB  9
02B08:  INCF   xDB,F
02B0A:  BRA    2A80
02B0C:  MOVLB  2
.................... 	} 
.................... } 
02B0E:  MOVLB  0
02B10:  GOTO   2D46 (RETURN)
....................  
....................  
.................... void main(void) { 
02B14:  CLRF   FF8
02B16:  BCF    FF1.2
02B18:  BSF    F9F.1
02B1A:  BCF    F9F.5
02B1C:  BCF    FA5.5
02B1E:  BSF    FD0.7
02B20:  BSF    07.7
02B22:  CLRF   FEA
02B24:  CLRF   FE9
02B26:  CLRF   35
02B28:  BCF    FB8.3
02B2A:  MOVLW  0C
02B2C:  MOVWF  FAF
02B2E:  MOVLW  A6
02B30:  MOVWF  FAC
02B32:  MOVLW  90
02B34:  MOVWF  FAB
02B36:  BCF    F70.3
02B38:  MOVLW  4D
02B3A:  MOVWF  F75
02B3C:  MOVLW  A6
02B3E:  MOVWF  F72
02B40:  MOVLW  90
02B42:  MOVWF  F71
02B44:  MOVLB  7
02B46:  BCF    xC2.0
02B48:  CLRF   xC3
02B4A:  MOVLB  8
02B4C:  CLRF   xCD
02B4E:  MOVLB  7
02B50:  BCF    xC2.1
02B52:  BCF    xC2.2
02B54:  BCF    xC2.3
02B56:  BCF    xC2.4
02B58:  BCF    xC2.5
02B5A:  BCF    xC2.6
02B5C:  MOVLB  8
02B5E:  CLRF   xCE
02B60:  CLRF   xD0
02B62:  CLRF   xCF
02B64:  CLRF   xD2
02B66:  CLRF   xD1
02B68:  CLRF   xD4
02B6A:  CLRF   xD3
02B6C:  MOVF   FC1,W
02B6E:  ANDLW  F0
02B70:  MOVWF  FC1
02B72:  MOVLW  00
02B74:  MOVLB  F
02B76:  MOVWF  x38
02B78:  MOVWF  x3C
02B7A:  MOVWF  x39
02B7C:  MOVWF  x3A
02B7E:  MOVWF  x3B
02B80:  MOVLB  1
02B82:  CLRF   x88
02B84:  CLRF   F77
02B86:  CLRF   F78
02B88:  CLRF   F79
02B8A:  CLRF   2F
02B8C:  CLRF   30
02B8E:  MOVLB  8
02B90:  CLRF   xC9
02B92:  CLRF   xCA
02B94:  CLRF   xCB
02B96:  CLRF   xCC
02B98:  CLRF   xD5
02B9A:  CLRF   xD6
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02B9C:  MOVF   FD0,W
02B9E:  ANDLW  0F
02BA0:  BTFSS  FD0.4
02BA2:  MOVLW  00
02BA4:  BSF    FD0.0
02BA6:  BSF    FD0.1
02BA8:  BSF    FD0.4
02BAA:  BSF    FD8.3
02BAC:  BSF    FD8.4
02BAE:  MOVWF  xD7
....................  
.................... 	init(); 
02BB0:  MOVLB  0
02BB2:  GOTO   094E
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
02BB6:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
02BB8:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
02BBA:  MOVLW  D2
02BBC:  MOVWF  FF6
02BBE:  MOVLW  07
02BC0:  MOVWF  FF7
02BC2:  MOVLW  07
02BC4:  MOVLB  8
02BC6:  MOVWF  xD8
02BC8:  MOVLB  0
02BCA:  CALL   0AB6
02BCE:  MOVLW  DE
02BD0:  MOVWF  FF6
02BD2:  MOVLW  07
02BD4:  MOVWF  FF7
02BD6:  CALL   0AE0
02BDA:  MOVLW  0D
02BDC:  BTFSS  FA4.4
02BDE:  BRA    2BDC
02BE0:  MOVWF  F73
02BE2:  MOVLW  0A
02BE4:  BTFSS  FA4.4
02BE6:  BRA    2BE4
02BE8:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
02BEA:  MOVLW  E8
02BEC:  MOVWF  FF6
02BEE:  MOVLW  07
02BF0:  MOVWF  FF7
02BF2:  MOVLW  12
02BF4:  MOVLB  8
02BF6:  MOVWF  xD8
02BF8:  MOVLB  0
02BFA:  CALL   0AB6
02BFE:  MOVFF  8D7,8D8
02C02:  MOVLW  1B
02C04:  MOVLB  8
02C06:  MOVWF  xD9
02C08:  MOVLB  0
02C0A:  GOTO   0B2E
02C0E:  MOVLW  20
02C10:  BTFSS  FA4.4
02C12:  BRA    2C10
02C14:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
02C16:  MOVLB  8
02C18:  MOVF   xD7,W
02C1A:  XORLW  07
02C1C:  MOVLB  0
02C1E:  BZ    2C3A
02C20:  XORLW  0C
02C22:  BZ    2C48
02C24:  XORLW  04
02C26:  BZ    2C56
02C28:  XORLW  03
02C2A:  BZ    2C64
02C2C:  XORLW  02
02C2E:  BZ    2C72
02C30:  XORLW  0D
02C32:  BZ    2C80
02C34:  XORLW  03
02C36:  BZ    2C8E
02C38:  BRA    2C9C
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
02C3A:  MOVLW  FE
02C3C:  MOVWF  FF6
02C3E:  MOVLW  07
02C40:  MOVWF  FF7
02C42:  CALL   0AE0
02C46:  BRA    2CA8
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
02C48:  MOVLW  0A
02C4A:  MOVWF  FF6
02C4C:  MOVLW  08
02C4E:  MOVWF  FF7
02C50:  CALL   0AE0
02C54:  BRA    2CA8
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
02C56:  MOVLW  1A
02C58:  MOVWF  FF6
02C5A:  MOVLW  08
02C5C:  MOVWF  FF7
02C5E:  CALL   0AE0
02C62:  BRA    2CA8
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
02C64:  MOVLW  28
02C66:  MOVWF  FF6
02C68:  MOVLW  08
02C6A:  MOVWF  FF7
02C6C:  CALL   0AE0
02C70:  BRA    2CA8
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
02C72:  MOVLW  38
02C74:  MOVWF  FF6
02C76:  MOVLW  08
02C78:  MOVWF  FF7
02C7A:  CALL   0AE0
02C7E:  BRA    2CA8
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
02C80:  MOVLW  4A
02C82:  MOVWF  FF6
02C84:  MOVLW  08
02C86:  MOVWF  FF7
02C88:  CALL   0AE0
02C8C:  BRA    2CA8
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
02C8E:  MOVLW  5A
02C90:  MOVWF  FF6
02C92:  MOVLW  08
02C94:  MOVWF  FF7
02C96:  CALL   0AE0
02C9A:  BRA    2CA8
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
02C9C:  MOVLW  6C
02C9E:  MOVWF  FF6
02CA0:  MOVLW  08
02CA2:  MOVWF  FF7
02CA4:  CALL   0AE0
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
02CA8:  MOVLW  76
02CAA:  MOVWF  FF6
02CAC:  MOVLW  08
02CAE:  MOVWF  FF7
02CB0:  CALL   0AE0
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
02CB4:  GOTO   0DE6
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02CB8:  MOVF   36,W
02CBA:  SUBLW  80
02CBC:  BC    2CC2
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
02CBE:  CALL   0D3A
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... //	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02CC2:  BSF    FAB.7
02CC4:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
02CC6:  GOTO   0E44
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02CCA:  MOVLB  8
02CCC:  CLRF   xD7
02CCE:  MOVF   xD7,W
02CD0:  SUBLW  1D
02CD2:  BNC   2CE0
.................... 		adc_update(); 
02CD4:  MOVLB  0
02CD6:  CALL   0F02
.................... 	} 
02CDA:  MOVLB  8
02CDC:  INCF   xD7,F
02CDE:  BRA    2CCE
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
02CE0:  MOVFF  44,1DB
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
02CE4:  BTFSS  F72.1
02CE6:  BRA    2CE4
.................... 	output_low(RS485_DE); 
02CE8:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
02CEA:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
02CEC:  MOVLW  7A
02CEE:  MOVWF  FF6
02CF0:  MOVLW  08
02CF2:  MOVWF  FF7
02CF4:  MOVLW  07
02CF6:  MOVWF  xD8
02CF8:  MOVLB  0
02CFA:  GOTO   0FAA
02CFE:  MOVLW  86
02D00:  MOVWF  FF6
02D02:  MOVLW  08
02D04:  MOVWF  FF7
02D06:  GOTO   0FD6
02D0A:  MOVLW  0D
02D0C:  BTFSS  F9E.4
02D0E:  BRA    2D0C
02D10:  MOVWF  FAD
02D12:  MOVLW  0A
02D14:  BTFSS  F9E.4
02D16:  BRA    2D14
02D18:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
02D1A:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
02D1C:  MOVLB  1
02D1E:  BTFSS  xFA.2
02D20:  BRA    2D2A
.................... 			periodic_millisecond(); 
02D22:  MOVLB  0
02D24:  GOTO   0FFA
02D28:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
02D2A:  BTFSS  xFA.0
02D2C:  BRA    2D36
.................... 			timers.now_adc_sample=0; 
02D2E:  BCF    xFA.0
.................... 			adc_update(); 
02D30:  MOVLB  0
02D32:  CALL   0F02
.................... 		} 
....................  
.................... 		modbus_process(); 
02D36:  MOVLB  0
02D38:  BRA    25B8
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
02D3A:  MOVLB  1
02D3C:  BTFSS  xFD.0
02D3E:  BRA    2D48
.................... 			timers.now_parse_rda2=0; 
02D40:  BCF    xFD.0
.................... 			rs485_to_host(); 
02D42:  MOVLB  0
02D44:  BRA    29E8
02D46:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
02D48:  MOVLB  0
02D4A:  BRA    2D1A
.................... } 
02D4C:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
