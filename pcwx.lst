CCS PCH C Compiler, Version 4.135, 4375               03-Nov-15 06:58

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 9804 bytes (15%)
                         Largest free fragment is 55728
               RAM used: 1229 (32%) at main() level
                         1493 (38%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   23AE
*
00008:  GOTO   00D6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   03B0
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   06B2
0007C:  BTFSS  FA3.5
0007E:  GOTO   0088
00082:  BTFSC  FA4.5
00084:  GOTO   0638
00088:  MOVFF  0E,00
0008C:  MOVFF  0F,01
00090:  MOVFF  10,02
00094:  MOVFF  11,03
00098:  MOVFF  0C,FE9
0009C:  MOVFF  07,FEA
000A0:  BSF    07.7
000A2:  MOVFF  08,FE1
000A6:  MOVFF  09,FE2
000AA:  MOVFF  0A,FD9
000AE:  MOVFF  0B,FDA
000B2:  MOVFF  12,FF3
000B6:  MOVFF  13,FF4
000BA:  MOVFF  14,FFA
000BE:  MOVFF  15,FF5
000C2:  MOVFF  16,FF6
000C6:  MOVFF  17,FF7
000CA:  MOVF   04,W
000CC:  MOVFF  06,FE0
000D0:  MOVFF  05,FD8
000D4:  RETFIE 0
000D6:  MOVWF  1A
000D8:  MOVFF  FD8,1B
000DC:  MOVFF  FE0,1C
000E0:  MOVLB  0
000E2:  MOVFF  FE9,22
000E6:  MOVFF  FEA,1D
000EA:  MOVFF  FE1,1E
000EE:  MOVFF  FE2,1F
000F2:  MOVFF  FD9,20
000F6:  MOVFF  FDA,21
000FA:  MOVFF  FF3,28
000FE:  MOVFF  FF4,29
00102:  MOVFF  FFA,2A
00106:  MOVFF  FF5,2B
0010A:  MOVFF  FF6,2C
0010E:  MOVFF  FF7,2D
00112:  MOVFF  00,24
00116:  MOVFF  01,25
0011A:  MOVFF  02,26
0011E:  MOVFF  03,27
00122:  BTFSS  F9D.1
00124:  GOTO   012E
00128:  BTFSC  F9E.1
0012A:  GOTO   03E2
0012E:  MOVFF  24,00
00132:  MOVFF  25,01
00136:  MOVFF  26,02
0013A:  MOVFF  27,03
0013E:  MOVFF  22,FE9
00142:  MOVFF  1D,FEA
00146:  BSF    1D.7
00148:  MOVFF  1E,FE1
0014C:  MOVFF  1F,FE2
00150:  MOVFF  20,FD9
00154:  MOVFF  21,FDA
00158:  MOVFF  28,FF3
0015C:  MOVFF  29,FF4
00160:  MOVFF  2A,FFA
00164:  MOVFF  2B,FF5
00168:  MOVFF  2C,FF6
0016C:  MOVFF  2D,FF7
00170:  MOVF   1A,W
00172:  MOVFF  1C,FE0
00176:  MOVFF  1B,FD8
0017A:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
010A8:  MOVLW  05
010AA:  MOVLB  4
010AC:  SUBWF  xD4,F
010AE:  BNC   10C4
010B0:  MOVLW  04
010B2:  MOVWF  FEA
010B4:  MOVLW  D4
010B6:  MOVWF  FE9
010B8:  MOVF   FEF,W
010BA:  BZ    10C4
010BC:  BRA    10C0
010BE:  CLRWDT
010C0:  DECFSZ FEF,F
010C2:  BRA    10BE
010C4:  MOVLB  0
010C6:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00668:  BTFSS  F9E.5
0066A:  BRA    0668
0066C:  MOVFF  FAB,35
00670:  MOVFF  FAE,01
00674:  BTFSS  35.1
00676:  BRA    067C
00678:  BCF    FAB.4
0067A:  BSF    FAB.4
0067C:  RETURN 0
*
0114A:  BTFSS  F9E.4
0114C:  BRA    114A
0114E:  MOVWF  FAD
01150:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
00620:  BTFSS  FA4.5
00622:  BRA    0620
00624:  MOVFF  F71,35
00628:  MOVFF  F74,01
0062C:  BTFSS  35.1
0062E:  BRA    0634
00630:  BCF    F71.4
00632:  BSF    F71.4
00634:  GOTO   063A (RETURN)
*
0067E:  BTFSS  FA4.4
00680:  BRA    067E
00682:  MOVWF  F73
00684:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
.................... 	int8 modbus_bridge; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda; 
.................... 	int8 rda_buff[256]; 
.................... 	int8 rda_buff_pos; 
.................... 	int8 rda_buff_gap; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
.................... } struct_time_keep; 
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00D5E:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00CBE:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00CC0:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00CC2:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00CC4:  MOVLB  4
00CC6:  MOVF   xD0,F
00CC8:  BNZ   0CD0
.................... 		c=0b00011; 
00CCA:  MOVLW  03
00CCC:  MOVWF  xD4
.................... 	else if ( 1 == ch )  
00CCE:  BRA    0D1A
00CD0:  DECFSZ xD0,W
00CD2:  BRA    0CDA
.................... 		c=0b10011; 
00CD4:  MOVLW  13
00CD6:  MOVWF  xD4
.................... 	else if ( 2 == ch )  
00CD8:  BRA    0D1A
00CDA:  MOVF   xD0,W
00CDC:  SUBLW  02
00CDE:  BNZ   0CE6
.................... 		c=0b01011; 
00CE0:  MOVLW  0B
00CE2:  MOVWF  xD4
.................... 	else if ( 3 == ch )  
00CE4:  BRA    0D1A
00CE6:  MOVF   xD0,W
00CE8:  SUBLW  03
00CEA:  BNZ   0CF2
.................... 		c=0b11011; 
00CEC:  MOVLW  1B
00CEE:  MOVWF  xD4
.................... 	else if ( 4 == ch ) 
00CF0:  BRA    0D1A
00CF2:  MOVF   xD0,W
00CF4:  SUBLW  04
00CF6:  BNZ   0CFE
.................... 		c=0b00111; 
00CF8:  MOVLW  07
00CFA:  MOVWF  xD4
.................... 	else if ( 5 == ch )  
00CFC:  BRA    0D1A
00CFE:  MOVF   xD0,W
00D00:  SUBLW  05
00D02:  BNZ   0D0A
.................... 		c=0b10111; 
00D04:  MOVLW  17
00D06:  MOVWF  xD4
.................... 	else if ( 6 == ch ) 
00D08:  BRA    0D1A
00D0A:  MOVF   xD0,W
00D0C:  SUBLW  06
00D0E:  BNZ   0D16
.................... 		c=0b01111; 
00D10:  MOVLW  0F
00D12:  MOVWF  xD4
.................... 	else 
00D14:  BRA    0D1A
.................... 		c=0b11111; 
00D16:  MOVLW  1F
00D18:  MOVWF  xD4
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00D1A:  CLRF   xD3
00D1C:  MOVF   xD3,W
00D1E:  SUBLW  04
00D20:  BNC   0D38
.................... 		output_low(MCP3208_CLK); 
00D22:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00D24:  BTFSC  xD4.0
00D26:  BRA    0D2C
00D28:  BCF    F8B.5
00D2A:  BRA    0D2E
00D2C:  BSF    F8B.5
.................... 		c=c>>1; 
00D2E:  BCF    FD8.0
00D30:  RRCF   xD4,F
.................... 		output_high(MCP3208_CLK); 
00D32:  BSF    F8B.3
.................... 	} 
00D34:  INCF   xD3,F
00D36:  BRA    0D1C
....................  
....................  
.................... 	value=0; 
00D38:  CLRF   xD2
00D3A:  CLRF   xD1
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00D3C:  CLRF   xD3
00D3E:  MOVF   xD3,W
00D40:  SUBLW  0D
00D42:  BNC   0D5A
.................... 		output_low(MCP3208_CLK); 
00D44:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00D46:  BTFSC  F82.4
00D48:  BRA    0D4E
00D4A:  BCF    FD8.0
00D4C:  BRA    0D50
00D4E:  BSF    FD8.0
00D50:  RLCF   xD1,F
00D52:  RLCF   xD2,F
.................... 		output_high(MCP3208_CLK); 
00D54:  BSF    F8B.3
.................... 	} 
00D56:  INCF   xD3,F
00D58:  BRA    0D3E
....................  
.................... 	bit_clear(value,13); 
00D5A:  BCF    xD2.5
.................... 	bit_clear(value,12); 
00D5C:  BCF    xD2.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00D60:  MOVFF  4D1,01
00D64:  MOVFF  4D2,02
.................... } 
00D68:  MOVLB  0
00D6A:  GOTO   0DDA (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00E64:  MOVLB  4
00E66:  CLRF   xE8
00E68:  MOVFF  4E1,4E7
00E6C:  CLRF   xEA
00E6E:  MOVLW  20
00E70:  MOVWF  xE9
00E72:  MOVLB  0
00E74:  RCALL  0826
00E76:  MOVFF  02,03
00E7A:  MOVF   01,W
00E7C:  ADDLW  82
00E7E:  MOVWF  01
00E80:  MOVLW  00
00E82:  ADDWFC 03,F
00E84:  MOVFF  01,4E5
00E88:  MOVLB  4
00E8A:  MOVFF  03,4E6
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00E8E:  CLRF   xE3
00E90:  CLRF   xE2
.................... 	for( i = 0; i < 16 ; i++ ) { 
00E92:  CLRF   xE4
00E94:  MOVF   xE4,W
00E96:  SUBLW  0F
00E98:  BNC   0EBC
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00E9A:  BCF    FD8.0
00E9C:  RLCF   xE4,W
00E9E:  CLRF   03
00EA0:  ADDWF  xE5,W
00EA2:  MOVWF  FE9
00EA4:  MOVF   xE6,W
00EA6:  ADDWFC 03,W
00EA8:  MOVWF  FEA
00EAA:  MOVFF  FEC,03
00EAE:  MOVF   FED,F
00EB0:  MOVF   FEF,W
00EB2:  ADDWF  xE2,F
00EB4:  MOVF   03,W
00EB6:  ADDWFC xE3,F
.................... 	} 
00EB8:  INCF   xE4,F
00EBA:  BRA    0E94
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00EBC:  MOVLW  08
00EBE:  ADDWF  xE2,W
00EC0:  MOVWF  xE7
00EC2:  MOVLW  00
00EC4:  ADDWFC xE3,W
00EC6:  MOVWF  xE8
00EC8:  RRCF   xE8,W
00ECA:  MOVWF  03
00ECC:  RRCF   xE7,W
00ECE:  MOVWF  02
00ED0:  RRCF   03,F
00ED2:  RRCF   02,F
00ED4:  RRCF   03,F
00ED6:  RRCF   02,F
00ED8:  RRCF   03,F
00EDA:  RRCF   02,F
00EDC:  MOVLW  0F
00EDE:  ANDWF  03,F
00EE0:  MOVFF  02,01
00EE4:  MOVFF  03,02
.................... } 
00EE8:  MOVLB  0
00EEA:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00D6E:  MOVLB  1
00D70:  INCF   x82,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00D72:  MOVF   x82,W
00D74:  SUBLW  0F
00D76:  BC    0D7A
.................... 		current.adc_buffer_index=0; 
00D78:  CLRF   x82
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00D7A:  MOVLB  4
00D7C:  CLRF   xCD
00D7E:  MOVF   xCD,W
00D80:  SUBLW  07
00D82:  BNC   0E10
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00D84:  CLRF   xE8
00D86:  MOVFF  4CD,4E7
00D8A:  CLRF   xEA
00D8C:  MOVLW  20
00D8E:  MOVWF  xE9
00D90:  MOVLB  0
00D92:  RCALL  0826
00D94:  MOVFF  02,03
00D98:  MOVF   01,W
00D9A:  ADDLW  34
00D9C:  MOVLB  4
00D9E:  MOVWF  xCE
00DA0:  MOVLW  00
00DA2:  ADDWFC 02,W
00DA4:  MOVWF  xCF
00DA6:  CLRF   03
00DA8:  MOVLB  1
00DAA:  MOVFF  182,02
00DAE:  BCF    FD8.0
00DB0:  RLCF   02,F
00DB2:  RLCF   03,F
00DB4:  MOVF   02,W
00DB6:  MOVLB  4
00DB8:  ADDWF  xCE,W
00DBA:  MOVWF  01
00DBC:  MOVF   xCF,W
00DBE:  ADDWFC 03,F
00DC0:  MOVF   01,W
00DC2:  ADDLW  4E
00DC4:  MOVWF  01
00DC6:  MOVLW  00
00DC8:  ADDWFC 03,F
00DCA:  MOVFF  01,4CE
00DCE:  MOVFF  03,4CF
00DD2:  MOVFF  4CD,4D0
00DD6:  MOVLB  0
00DD8:  BRA    0CBE
00DDA:  MOVFF  4CF,FEA
00DDE:  MOVFF  4CE,FE9
00DE2:  MOVFF  02,FEC
00DE6:  MOVF   FED,F
00DE8:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00DEC:  CLRF   03
00DEE:  MOVLB  4
00DF0:  MOVFF  4CD,02
00DF4:  BCF    FD8.0
00DF6:  RLCF   02,F
00DF8:  RLCF   03,F
00DFA:  MOVF   02,W
00DFC:  ADDLW  72
00DFE:  MOVWF  FE9
00E00:  MOVLW  00
00E02:  ADDWFC 03,W
00E04:  MOVWF  FEA
00E06:  CLRF   FEC
00E08:  MOVF   FED,F
00E0A:  CLRF   FEF
....................  
.................... 	} 
00E0C:  INCF   xCD,F
00E0E:  BRA    0D7E
.................... } 
00E10:  MOVLB  0
00E12:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00B04:  MOVF   xE8,W
00B06:  XORWF  xE9,W
00B08:  MOVWF  01
*
00B56:  MOVF   xE8,W
00B58:  XORWF  xE9,W
00B5A:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00A8E:  MOVLB  4
00A90:  CLRF   xD6
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00A92:  MOVFF  4D5,03
00A96:  MOVF   xD4,W
00A98:  BTFSC  FD8.2
00A9A:  DECF   xD5,F
00A9C:  DECF   xD4,F
00A9E:  MOVWF  xD7
00AA0:  MOVFF  03,4D8
00AA4:  MOVF   xD7,F
00AA6:  BNZ   0AAC
00AA8:  MOVF   xD8,F
00AAA:  BZ    0B16
.................... 		*data = read_eeprom( address++ ); 
00AAC:  MOVFF  4D3,03
00AB0:  MOVF   xD2,W
00AB2:  MOVWF  FE9
00AB4:  MOVFF  03,FEA
00AB8:  MOVF   xD1,W
00ABA:  MOVWF  03
00ABC:  MOVF   xD0,W
00ABE:  INCF   xD0,F
00AC0:  BTFSC  FD8.2
00AC2:  INCF   xD1,F
00AC4:  MOVWF  xD9
00AC6:  MOVFF  03,4DA
00ACA:  MOVFF  FF2,4DB
00ACE:  BCF    FF2.6
00AD0:  BCF    FF2.7
00AD2:  MOVFF  4DA,FAA
00AD6:  MOVFF  4D9,FA9
00ADA:  BCF    FA6.6
00ADC:  BCF    FA6.7
00ADE:  BSF    FA6.0
00AE0:  MOVF   FA8,W
00AE2:  BTFSC  xDB.6
00AE4:  BSF    FF2.6
00AE6:  BTFSC  xDB.7
00AE8:  BSF    FF2.7
00AEA:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00AEC:  MOVFF  4D3,03
00AF0:  MOVF   xD2,W
00AF2:  MOVWF  FE9
00AF4:  MOVFF  03,FEA
00AF8:  MOVFF  FEF,4D7
00AFC:  MOVFF  4D6,4E8
00B00:  MOVFF  4D7,4E9
*
00B0A:  MOVFF  01,4D6
.................... 		data++; 
00B0E:  INCF   xD2,F
00B10:  BTFSC  FD8.2
00B12:  INCF   xD3,F
.................... 	} 
00B14:  BRA    0A92
.................... 	return crc; 
00B16:  MOVFF  4D6,01
.................... } 
00B1A:  MOVLB  0
00B1C:  GOTO   0C72 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00B20:  MOVLB  4
00B22:  CLRF   xE6
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B24:  MOVFF  4E5,03
00B28:  MOVF   xE4,W
00B2A:  BTFSC  FD8.2
00B2C:  DECF   xE5,F
00B2E:  DECF   xE4,F
00B30:  MOVWF  xE7
00B32:  MOVFF  03,4E8
00B36:  MOVF   xE7,F
00B38:  BNZ   0B3E
00B3A:  MOVF   xE8,F
00B3C:  BZ    0BBC
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00B3E:  MOVFF  4E3,03
00B42:  MOVF   xE2,W
00B44:  MOVWF  FE9
00B46:  MOVFF  03,FEA
00B4A:  MOVFF  FEF,4E7
00B4E:  MOVFF  4E6,4E8
00B52:  MOVFF  4E7,4E9
*
00B5C:  MOVFF  01,4E6
.................... 		write_eeprom( address++, *data++ ); 
00B60:  MOVF   xE1,W
00B62:  MOVWF  03
00B64:  MOVF   xE0,W
00B66:  INCF   xE0,F
00B68:  BTFSC  FD8.2
00B6A:  INCF   xE1,F
00B6C:  MOVWF  xE7
00B6E:  MOVFF  03,4E8
00B72:  MOVF   xE3,W
00B74:  MOVWF  03
00B76:  MOVF   xE2,W
00B78:  INCF   xE2,F
00B7A:  BTFSC  FD8.2
00B7C:  INCF   xE3,F
00B7E:  MOVWF  FE9
00B80:  MOVFF  03,FEA
00B84:  MOVFF  FEF,4E9
00B88:  MOVFF  4E8,FAA
00B8C:  MOVFF  4E7,FA9
00B90:  MOVFF  4E9,FA8
00B94:  BCF    FA6.6
00B96:  BCF    FA6.7
00B98:  BSF    FA6.2
00B9A:  MOVF   FF2,W
00B9C:  MOVWF  00
00B9E:  BCF    FF2.6
00BA0:  BCF    FF2.7
00BA2:  MOVLB  F
00BA4:  MOVLW  55
00BA6:  MOVWF  FA7
00BA8:  MOVLW  AA
00BAA:  MOVWF  FA7
00BAC:  BSF    FA6.1
00BAE:  BTFSC  FA6.1
00BB0:  BRA    0BAE
00BB2:  BCF    FA6.2
00BB4:  MOVF   00,W
00BB6:  IORWF  FF2,F
.................... 	} 
00BB8:  MOVLB  4
00BBA:  BRA    0B24
....................  
.................... 	return crc; 
00BBC:  MOVFF  4E6,01
.................... } 
00BC0:  MOVLB  0
00BC2:  GOTO   0BE6 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00BC6:  MOVLB  4
00BC8:  CLRF   xDF
00BCA:  MOVLW  36
00BCC:  MOVWF  xDE
00BCE:  CLRF   xE1
00BD0:  MOVLW  02
00BD2:  MOVWF  xE0
00BD4:  MOVFF  4DF,4E3
00BD8:  MOVFF  4DE,4E2
00BDC:  CLRF   xE5
00BDE:  MOVLW  18
00BE0:  MOVWF  xE4
00BE2:  MOVLB  0
00BE4:  BRA    0B20
00BE6:  MOVFF  01,4DD
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00BEA:  CLRF   FAA
00BEC:  CLRF   FA9
00BEE:  MOVFF  4DD,FA8
00BF2:  BCF    FA6.6
00BF4:  BCF    FA6.7
00BF6:  BSF    FA6.2
00BF8:  MOVF   FF2,W
00BFA:  MOVWF  00
00BFC:  BCF    FF2.6
00BFE:  BCF    FF2.7
00C00:  MOVLB  F
00C02:  MOVLW  55
00C04:  MOVWF  FA7
00C06:  MOVLW  AA
00C08:  MOVWF  FA7
00C0A:  BSF    FA6.1
00C0C:  BTFSC  FA6.1
00C0E:  BRA    0C0C
00C10:  BCF    FA6.2
00C12:  MOVF   00,W
00C14:  IORWF  FF2,F
.................... } 
00C16:  MOVLB  0
00C18:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00C1A:  MOVLW  96
00C1C:  MOVLB  1
00C1E:  MOVWF  xAB
....................  
.................... 	config.modbus_address=38; 
00C20:  MOVLW  26
00C22:  MOVWF  36
.................... 	config.modbus_bridge=1; 
00C24:  MOVLW  01
00C26:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00C28:  MOVLW  50
00C2A:  MOVWF  39
.................... 	config.serial_number=9876; 
00C2C:  MOVLW  26
00C2E:  MOVWF  3B
00C30:  MOVLW  94
00C32:  MOVWF  3A
....................  
.................... 	config.adc_sample_ticks=20; 
00C34:  CLRF   3D
00C36:  MOVLW  14
00C38:  MOVWF  3C
.................... 	config.allow_bootload_request=0; 
00C3A:  CLRF   3E
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00C3C:  MOVLW  02
00C3E:  MOVWF  40
00C40:  MOVLW  76
00C42:  MOVWF  3F
.................... 	config.pi_offtime_seconds=2; 
00C44:  CLRF   42
00C46:  MOVLW  02
00C48:  MOVWF  41
.................... 	config.power_startup=0; 
00C4A:  CLRF   43
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00C4C:  MOVLB  0
00C4E:  RCALL  0BC6
....................  
.................... } 
00C50:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00C52:  MOVLB  4
00C54:  CLRF   xCF
00C56:  MOVLW  36
00C58:  MOVWF  xCE
00C5A:  CLRF   xD1
00C5C:  MOVLW  02
00C5E:  MOVWF  xD0
00C60:  MOVFF  4CF,4D3
00C64:  MOVFF  4CE,4D2
00C68:  CLRF   xD5
00C6A:  MOVLW  18
00C6C:  MOVWF  xD4
00C6E:  MOVLB  0
00C70:  BRA    0A8E
00C72:  MOVFF  01,4CD
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00C76:  MOVFF  FF2,4CE
00C7A:  BCF    FF2.6
00C7C:  BCF    FF2.7
00C7E:  CLRF   FAA
00C80:  CLRF   FA9
00C82:  BCF    FA6.6
00C84:  BCF    FA6.7
00C86:  BSF    FA6.0
00C88:  MOVF   FA8,W
00C8A:  MOVLB  4
00C8C:  BTFSC  xCE.6
00C8E:  BSF    FF2.6
00C90:  BTFSC  xCE.7
00C92:  BSF    FF2.7
00C94:  SUBWF  xCD,W
00C96:  BZ    0C9E
.................... 		write_default_param_file(); 
00C98:  MOVLB  0
00C9A:  RCALL  0C1A
00C9C:  MOVLB  4
.................... 	} 
.................... } 
00C9E:  MOVLB  0
00CA0:  GOTO   2552 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
011AC:  BTFSS  FAC.1
011AE:  BRA    11AC
.................... } 
011B0:  GOTO   11CA (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
*
00CA4:  BTFSS  F9E.5
00CA6:  BRA    0CAC
.................... 		fgetc(STREAM_PI); 
00CA8:  RCALL  0668
.................... 	} 
00CAA:  BRA    0CA4
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00CAC:  BSF    F9D.5
.................... } 
00CAE:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00CB0:  RCALL  0CA4
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00CB2:  MOVLW  C6
00CB4:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00CB6:  MOVLW  C0
00CB8:  IORWF  FF2,F
.................... } 
00CBA:  GOTO   25CC (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0039C:  BCF    FF2.5
.................... 	if (enable) { 
0039E:  MOVLB  5
003A0:  MOVF   xD2,F
003A2:  BZ    03AC
.................... 		set_timer0(0); 
003A4:  CLRF   FD7
003A6:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
003A8:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
003AA:  BSF    FF2.5
.................... 	} 
.................... } 
003AC:  MOVLB  0
003AE:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
003B0:  MOVLB  3
003B2:  MOVF   xB8,W
003B4:  SUBLW  02
003B6:  BNZ   03CC
003B8:  MOVF   xB9,F
003BA:  BNZ   03CC
003BC:  MOVF   xBA,F
003BE:  BNZ   03CC
003C0:  BTFSC  xB7.0
003C2:  BRA    03CC
....................    { 
....................       modbus_rx.len-=2; 
003C4:  MOVLW  02
003C6:  SUBWF  xBC,F
....................       modbus_serial_new=TRUE; 
003C8:  BSF    xB7.0
....................    } 
....................    else 
003CA:  BRA    03CE
....................       modbus_serial_new=FALSE; 
003CC:  BCF    xB7.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
003CE:  SETF   xBA
003D0:  SETF   xB9
....................    modbus_serial_state=MODBUS_GETADDY; 
003D2:  CLRF   xB8
....................    modbus_enable_timeout(FALSE); 
003D4:  MOVLB  5
003D6:  CLRF   xD2
003D8:  MOVLB  0
003DA:  RCALL  039C
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
003DC:  BCF    FF2.2
003DE:  GOTO   0088
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00686:  MOVLB  3
00688:  MOVF   xBA,W
0068A:  MOVLB  5
0068C:  XORWF  xD2,W
0068E:  MOVWF  xD3
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
00690:  CLRF   03
00692:  MOVF   xD3,W
00694:  MOVLB  0
00696:  RCALL  017C
00698:  MOVWF  01
0069A:  MOVLB  3
0069C:  MOVF   xB9,W
0069E:  XORWF  01,W
006A0:  MOVWF  xBA
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006A2:  CLRF   03
006A4:  MOVLB  5
006A6:  MOVF   xD3,W
006A8:  MOVLB  0
006AA:  RCALL  028C
006AC:  MOVFF  FE8,3B9
.................... } 
006B0:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, STREAM_PI); 
*
01152:  MOVLB  4
01154:  MOVF   xDF,W
01156:  MOVLB  0
01158:  RCALL  114A
0115A:  CLRF   19
0115C:  BTFSC  FF2.6
0115E:  BSF    19.6
01160:  BCF    FF2.6
01162:  BTFSC  FF2.7
01164:  BSF    19.7
01166:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
01168:  MOVFF  4DF,5D2
0116C:  CALL   0686
01170:  BTFSC  19.6
01172:  BSF    FF2.6
01174:  BTFSC  19.7
01176:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
01178:  CLRWDT
0117A:  MOVLW  08
0117C:  MOVWF  00
0117E:  DECFSZ 00,F
01180:  BRA    117E
01182:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
01184:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
01186:  MOVLB  3
01188:  SETF   xBA
0118A:  SETF   xB9
....................    modbus_serial_new=FALSE; 
0118C:  BCF    xB7.0
....................  
....................    RCV_OFF(); 
0118E:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
01190:  CLRWDT
01192:  MOVLW  3C
01194:  MOVWF  00
01196:  DECFSZ 00,F
01198:  BRA    1196
0119A:  NOP   
....................  
....................    modbus_serial_putc(to); 
0119C:  MOVFF  4DD,4DF
011A0:  MOVLB  0
011A2:  RCALL  1152
....................    modbus_serial_putc(func); 
011A4:  MOVFF  4DE,4DF
011A8:  RCALL  1152
.................... } 
011AA:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
011B4:  MOVFF  3BA,4DE
....................    crc_low=modbus_serial_crc.b[0]; 
011B8:  MOVFF  3B9,4DD
....................  
....................    modbus_serial_putc(crc_high); 
011BC:  MOVFF  4DE,4DF
011C0:  RCALL  1152
....................    modbus_serial_putc(crc_low); 
011C2:  MOVFF  4DD,4DF
011C6:  RCALL  1152
....................  
....................    WAIT_FOR_HW_BUFFER(); 
011C8:  BRA    11AC
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(61); /* 57600 */ 
011CA:  CLRWDT
011CC:  MOVLW  3C
011CE:  MOVWF  00
011D0:  DECFSZ 00,F
011D2:  BRA    11D0
011D4:  NOP   
....................  
....................  
....................    RCV_ON(); 
011D6:  RCALL  0CA4
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
011D8:  MOVLB  3
011DA:  SETF   xBA
011DC:  SETF   xB9
.................... } 
011DE:  MOVLB  0
011E0:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
01082:  MOVLB  3
01084:  BTFSC  xB7.0
01086:  BRA    1090
....................       return FALSE; 
01088:  MOVLW  00
0108A:  MOVWF  01
0108C:  BRA    10A2
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
0108E:  BRA    109C
01090:  BTFSS  xBD.7
01092:  BRA    109C
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
01094:  MOVFF  3BF,3BE
....................       modbus_rx.len = 1; 
01098:  MOVLW  01
0109A:  MOVWF  xBC
....................    } 
....................    modbus_serial_new=FALSE; 
0109C:  BCF    xB7.0
....................    return TRUE; 
0109E:  MOVLW  01
010A0:  MOVWF  01
.................... } 
010A2:  MOVLB  0
010A4:  GOTO   205A (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01FC6:  MOVFF  4D5,4DD
01FCA:  MOVLW  06
01FCC:  MOVLB  4
01FCE:  MOVWF  xDE
01FD0:  MOVLB  0
01FD2:  CALL   1186
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01FD6:  MOVFF  4D7,4DA
01FDA:  MOVFF  4D7,4DF
01FDE:  CALL   1152
....................    modbus_serial_putc(make8(reg_address,0)); 
01FE2:  MOVFF  4D6,4DA
01FE6:  MOVFF  4D6,4DF
01FEA:  CALL   1152
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01FEE:  MOVFF  4D9,4DA
01FF2:  MOVFF  4D9,4DF
01FF6:  CALL   1152
....................    modbus_serial_putc(make8(reg_value,0)); 
01FFA:  MOVFF  4D8,4DA
01FFE:  MOVFF  4D8,4DF
02002:  CALL   1152
....................  
....................    modbus_serial_send_stop(); 
02006:  CALL   11B4
.................... } 
0200A:  GOTO   223E (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
0200E:  MOVFF  4D3,4DD
02012:  MOVLW  10
02014:  MOVLB  4
02016:  MOVWF  xDE
02018:  MOVLB  0
0201A:  CALL   1186
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0201E:  MOVFF  4D5,4D8
02022:  MOVFF  4D5,4DF
02026:  CALL   1152
....................    modbus_serial_putc(make8(start_address,0)); 
0202A:  MOVFF  4D4,4D8
0202E:  MOVFF  4D4,4DF
02032:  CALL   1152
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02036:  MOVFF  4D7,4D8
0203A:  MOVFF  4D7,4DF
0203E:  CALL   1152
....................    modbus_serial_putc(make8(quantity,0)); 
02042:  MOVFF  4D6,4D8
02046:  MOVFF  4D6,4DF
0204A:  CALL   1152
....................  
....................    modbus_serial_send_stop(); 
0204E:  CALL   11B4
.................... } 
02052:  GOTO   2300 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
011E2:  MOVLB  4
011E4:  MOVF   xD4,W
011E6:  IORLW  80
011E8:  MOVWF  xD7
011EA:  MOVFF  4D5,4D8
011EE:  MOVFF  4D3,4DD
011F2:  MOVWF  xDE
011F4:  MOVLB  0
011F6:  RCALL  1186
....................    modbus_serial_putc(error); 
011F8:  MOVFF  4D6,4DF
011FC:  RCALL  1152
....................    modbus_serial_send_stop(); 
011FE:  RCALL  11B4
.................... } 
01200:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1012 
....................  
.................... #define MIN_EE_REGISTER      2000 
.................... #define MAX_EE_REGISTER      MIN_EE_REGISTER + 512 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
012C8:  MOVLB  1
012CA:  CLRF   x84
012CC:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
012CE:  CLRF   x86
012D0:  CLRF   x85
.................... 	current.modbus_last_error=0; 
012D2:  CLRF   x88
012D4:  CLRF   x87
.................... } 
012D6:  MOVLB  0
012D8:  GOTO   1BFE (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
01264:  BCF    FF2.6
01266:  BCF    FF2.7
01268:  BTFSC  FF2.7
0126A:  BRA    1266
....................  
.................... 	current.pulse_count[0]=0; 
0126C:  CLRF   x61
0126E:  CLRF   x60
.................... 	current.pulse_count[1]=0; 
01270:  CLRF   x63
01272:  CLRF   x62
.................... 	current.pulse_count[2]=0; 
01274:  CLRF   x65
01276:  CLRF   x64
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
01278:  SETF   55
0127A:  SETF   54
.................... 	current.pulse_min_period[1]=65535; 
0127C:  SETF   57
0127E:  SETF   56
.................... 	current.pulse_min_period[2]=65535; 
01280:  SETF   59
01282:  SETF   58
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
01284:  CLRF   5B
01286:  CLRF   5A
.................... 	current.pulse_max_period[1]=0; 
01288:  CLRF   5D
0128A:  CLRF   5C
.................... 	current.pulse_max_period[2]=0; 
0128C:  CLRF   5F
0128E:  CLRF   5E
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
01290:  MOVLB  1
01292:  CLRF   x8E
01294:  CLRF   x8D
....................  
.................... 	enable_interrupts(GLOBAL); 
01296:  MOVLW  C0
01298:  IORWF  FF2,F
.................... } 
0129A:  MOVLB  0
0129C:  GOTO   1BAE (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
012A0:  BCF    FF2.6
012A2:  BCF    FF2.7
012A4:  BTFSC  FF2.7
012A6:  BRA    12A2
.................... 	current.pulse_sum[0]=0; 
012A8:  CLRF   x69
012AA:  CLRF   x68
012AC:  CLRF   x67
012AE:  CLRF   x66
.................... 	current.pulse_sum[1]=0; 
012B0:  CLRF   x6D
012B2:  CLRF   x6C
012B4:  CLRF   x6B
012B6:  CLRF   x6A
.................... 	current.pulse_sum[2]=0; 
012B8:  CLRF   x71
012BA:  CLRF   x70
012BC:  CLRF   x6F
012BE:  CLRF   x6E
.................... 	enable_interrupts(GLOBAL); 
012C0:  MOVLW  C0
012C2:  IORWF  FF2,F
.................... } 
012C4:  GOTO   1BBE (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01202:  BCF    FF2.6
01204:  BCF    FF2.7
01206:  BTFSC  FF2.7
01208:  BRA    1204
.................... 	l=current.pulse_sum[ch]; 
0120A:  MOVLB  4
0120C:  CLRF   xE8
0120E:  MOVFF  4E1,4E7
01212:  CLRF   xEA
01214:  MOVLW  04
01216:  MOVWF  xE9
01218:  MOVLB  0
0121A:  CALL   0826
0121E:  MOVFF  02,03
01222:  MOVF   01,W
01224:  ADDLW  66
01226:  MOVWF  FE9
01228:  MOVLW  00
0122A:  ADDWFC 02,W
0122C:  MOVWF  FEA
0122E:  MOVFF  FEF,00
01232:  MOVFF  FEC,01
01236:  MOVFF  FEC,02
0123A:  MOVFF  FEC,03
0123E:  MOVFF  03,4E5
01242:  MOVFF  02,4E4
01246:  MOVFF  01,4E3
0124A:  MOVFF  00,4E2
.................... 	enable_interrupts(GLOBAL); 
0124E:  MOVLW  C0
01250:  IORWF  FF2,F
....................  
.................... 	return l; 
01252:  MOVFF  4E2,00
01256:  MOVFF  4E3,01
0125A:  MOVFF  4E4,02
0125E:  MOVFF  4E5,03
.................... } 
01262:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
012DC:  MOVLB  4
012DE:  MOVF   xE0,W
012E0:  SUBLW  06
012E2:  BC    1338
012E4:  XORLW  FF
012E6:  BNZ   12EE
012E8:  MOVF   xDF,W
012EA:  SUBLW  CF
012EC:  BC    1338
012EE:  MOVF   xE0,W
012F0:  SUBLW  09
012F2:  BNC   1338
012F4:  BNZ   12FC
012F6:  MOVF   xDF,W
012F8:  SUBLW  CF
012FA:  BNC   1338
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
012FC:  MOVLW  D0
012FE:  SUBWF  xDF,W
01300:  MOVWF  xE1
01302:  MOVLW  07
01304:  SUBWFB xE0,W
01306:  MOVWF  xE2
01308:  MOVLW  02
0130A:  ADDWF  xE2,F
0130C:  MOVFF  FF2,4E3
01310:  BCF    FF2.6
01312:  BCF    FF2.7
01314:  MOVFF  4E2,FAA
01318:  MOVFF  4E1,FA9
0131C:  BCF    FA6.6
0131E:  BCF    FA6.7
01320:  BSF    FA6.0
01322:  MOVF   FA8,W
01324:  BTFSC  xE3.6
01326:  BSF    FF2.6
01328:  BTFSC  xE3.7
0132A:  BSF    FF2.7
0132C:  CLRF   03
0132E:  MOVWF  01
01330:  MOVF   03,W
01332:  MOVWF  02
01334:  GOTO   1CD0
.................... 	} 
....................  
.................... 	switch ( addr ) { 
01338:  MOVF   xDF,W
0133A:  MOVWF  00
0133C:  MOVF   xE0,W
0133E:  MOVWF  03
01340:  MOVF   03,W
01342:  BNZ   134E
01344:  MOVF   00,F
01346:  MOVLB  0
01348:  BTFSC  FD8.2
0134A:  BRA    176A
0134C:  MOVLB  4
0134E:  MOVF   03,W
01350:  BNZ   135E
01352:  MOVLW  01
01354:  SUBWF  00,W
01356:  MOVLB  0
01358:  BTFSC  FD8.2
0135A:  BRA    1778
0135C:  MOVLB  4
0135E:  MOVF   03,W
01360:  BNZ   136E
01362:  MOVLW  02
01364:  SUBWF  00,W
01366:  MOVLB  0
01368:  BTFSC  FD8.2
0136A:  BRA    1786
0136C:  MOVLB  4
0136E:  MOVF   03,W
01370:  BNZ   137E
01372:  MOVLW  03
01374:  SUBWF  00,W
01376:  MOVLB  0
01378:  BTFSC  FD8.2
0137A:  BRA    1794
0137C:  MOVLB  4
0137E:  MOVF   03,W
01380:  BNZ   138E
01382:  MOVLW  04
01384:  SUBWF  00,W
01386:  MOVLB  0
01388:  BTFSC  FD8.2
0138A:  BRA    17A2
0138C:  MOVLB  4
0138E:  MOVF   03,W
01390:  BNZ   139E
01392:  MOVLW  05
01394:  SUBWF  00,W
01396:  MOVLB  0
01398:  BTFSC  FD8.2
0139A:  BRA    17C8
0139C:  MOVLB  4
0139E:  MOVF   03,W
013A0:  BNZ   13AE
013A2:  MOVLW  06
013A4:  SUBWF  00,W
013A6:  MOVLB  0
013A8:  BTFSC  FD8.2
013AA:  BRA    17D6
013AC:  MOVLB  4
013AE:  MOVF   03,W
013B0:  BNZ   13BE
013B2:  MOVLW  07
013B4:  SUBWF  00,W
013B6:  MOVLB  0
013B8:  BTFSC  FD8.2
013BA:  BRA    17E4
013BC:  MOVLB  4
013BE:  MOVF   03,W
013C0:  BNZ   13CE
013C2:  MOVLW  08
013C4:  SUBWF  00,W
013C6:  MOVLB  0
013C8:  BTFSC  FD8.2
013CA:  BRA    17F2
013CC:  MOVLB  4
013CE:  MOVF   03,W
013D0:  BNZ   13DE
013D2:  MOVLW  09
013D4:  SUBWF  00,W
013D6:  MOVLB  0
013D8:  BTFSC  FD8.2
013DA:  BRA    1800
013DC:  MOVLB  4
013DE:  MOVF   03,W
013E0:  BNZ   13EE
013E2:  MOVLW  0A
013E4:  SUBWF  00,W
013E6:  MOVLB  0
013E8:  BTFSC  FD8.2
013EA:  BRA    180E
013EC:  MOVLB  4
013EE:  MOVF   03,W
013F0:  BNZ   13FE
013F2:  MOVLW  0B
013F4:  SUBWF  00,W
013F6:  MOVLB  0
013F8:  BTFSC  FD8.2
013FA:  BRA    1836
013FC:  MOVLB  4
013FE:  MOVF   03,W
01400:  BNZ   140E
01402:  MOVLW  0C
01404:  SUBWF  00,W
01406:  MOVLB  0
01408:  BTFSC  FD8.2
0140A:  BRA    1844
0140C:  MOVLB  4
0140E:  MOVF   03,W
01410:  BNZ   141E
01412:  MOVLW  0D
01414:  SUBWF  00,W
01416:  MOVLB  0
01418:  BTFSC  FD8.2
0141A:  BRA    1852
0141C:  MOVLB  4
0141E:  MOVF   03,W
01420:  BNZ   142E
01422:  MOVLW  0E
01424:  SUBWF  00,W
01426:  MOVLB  0
01428:  BTFSC  FD8.2
0142A:  BRA    1860
0142C:  MOVLB  4
0142E:  MOVF   03,W
01430:  BNZ   143E
01432:  MOVLW  0F
01434:  SUBWF  00,W
01436:  MOVLB  0
01438:  BTFSC  FD8.2
0143A:  BRA    186E
0143C:  MOVLB  4
0143E:  MOVF   03,W
01440:  BNZ   144E
01442:  MOVLW  10
01444:  SUBWF  00,W
01446:  MOVLB  0
01448:  BTFSC  FD8.2
0144A:  BRA    187C
0144C:  MOVLB  4
0144E:  MOVF   03,W
01450:  BNZ   145E
01452:  MOVLW  11
01454:  SUBWF  00,W
01456:  MOVLB  0
01458:  BTFSC  FD8.2
0145A:  BRA    18A4
0145C:  MOVLB  4
0145E:  MOVF   03,W
01460:  BNZ   146E
01462:  MOVLW  12
01464:  SUBWF  00,W
01466:  MOVLB  0
01468:  BTFSC  FD8.2
0146A:  BRA    18B2
0146C:  MOVLB  4
0146E:  MOVF   03,W
01470:  BNZ   147E
01472:  MOVLW  13
01474:  SUBWF  00,W
01476:  MOVLB  0
01478:  BTFSC  FD8.2
0147A:  BRA    18E0
0147C:  MOVLB  4
0147E:  MOVF   03,W
01480:  BNZ   148E
01482:  MOVLW  14
01484:  SUBWF  00,W
01486:  MOVLB  0
01488:  BTFSC  FD8.2
0148A:  BRA    18F8
0148C:  MOVLB  4
0148E:  MOVF   03,W
01490:  BNZ   149E
01492:  MOVLW  15
01494:  SUBWF  00,W
01496:  MOVLB  0
01498:  BTFSC  FD8.2
0149A:  BRA    1906
0149C:  MOVLB  4
0149E:  MOVF   03,W
014A0:  BNZ   14AE
014A2:  MOVLW  16
014A4:  SUBWF  00,W
014A6:  MOVLB  0
014A8:  BTFSC  FD8.2
014AA:  BRA    1934
014AC:  MOVLB  4
014AE:  MOVF   03,W
014B0:  BNZ   14BE
014B2:  MOVLW  17
014B4:  SUBWF  00,W
014B6:  MOVLB  0
014B8:  BTFSC  FD8.2
014BA:  BRA    194E
014BC:  MOVLB  4
014BE:  MOVF   03,W
014C0:  BNZ   14CE
014C2:  MOVLW  18
014C4:  SUBWF  00,W
014C6:  MOVLB  0
014C8:  BTFSC  FD8.2
014CA:  BRA    195C
014CC:  MOVLB  4
014CE:  MOVF   03,W
014D0:  BNZ   14DE
014D2:  MOVLW  19
014D4:  SUBWF  00,W
014D6:  MOVLB  0
014D8:  BTFSC  FD8.2
014DA:  BRA    198A
014DC:  MOVLB  4
014DE:  MOVF   03,W
014E0:  BNZ   14EE
014E2:  MOVLW  1A
014E4:  SUBWF  00,W
014E6:  MOVLB  0
014E8:  BTFSC  FD8.2
014EA:  BRA    19A4
014EC:  MOVLB  4
014EE:  MOVF   03,W
014F0:  BNZ   14FE
014F2:  MOVLW  1B
014F4:  SUBWF  00,W
014F6:  MOVLB  0
014F8:  BTFSC  FD8.2
014FA:  BRA    19B2
014FC:  MOVLB  4
014FE:  MOVF   03,W
01500:  BNZ   150E
01502:  MOVLW  1C
01504:  SUBWF  00,W
01506:  MOVLB  0
01508:  BTFSC  FD8.2
0150A:  BRA    19E0
0150C:  MOVLB  4
0150E:  MOVF   03,W
01510:  BNZ   151E
01512:  MOVLW  1D
01514:  SUBWF  00,W
01516:  MOVLB  0
01518:  BTFSC  FD8.2
0151A:  BRA    19FA
0151C:  MOVLB  4
0151E:  MOVF   03,W
01520:  BNZ   152E
01522:  MOVLW  1E
01524:  SUBWF  00,W
01526:  MOVLB  0
01528:  BTFSC  FD8.2
0152A:  BRA    1A08
0152C:  MOVLB  4
0152E:  MOVF   03,W
01530:  BNZ   153E
01532:  MOVLW  1F
01534:  SUBWF  00,W
01536:  MOVLB  0
01538:  BTFSC  FD8.2
0153A:  BRA    1A36
0153C:  MOVLB  4
0153E:  MOVF   03,W
01540:  BNZ   154E
01542:  MOVLW  20
01544:  SUBWF  00,W
01546:  MOVLB  0
01548:  BTFSC  FD8.2
0154A:  BRA    1A50
0154C:  MOVLB  4
0154E:  MOVF   03,W
01550:  BNZ   155E
01552:  MOVLW  21
01554:  SUBWF  00,W
01556:  MOVLB  0
01558:  BTFSC  FD8.2
0155A:  BRA    1A5E
0155C:  MOVLB  4
0155E:  MOVF   03,W
01560:  BNZ   156E
01562:  MOVLW  22
01564:  SUBWF  00,W
01566:  MOVLB  0
01568:  BTFSC  FD8.2
0156A:  BRA    1A8C
0156C:  MOVLB  4
0156E:  MOVF   03,W
01570:  BNZ   157E
01572:  MOVLW  23
01574:  SUBWF  00,W
01576:  MOVLB  0
01578:  BTFSC  FD8.2
0157A:  BRA    1AA6
0157C:  MOVLB  4
0157E:  MOVF   03,W
01580:  BNZ   158E
01582:  MOVLW  24
01584:  SUBWF  00,W
01586:  MOVLB  0
01588:  BTFSC  FD8.2
0158A:  BRA    1AB4
0158C:  MOVLB  4
0158E:  MOVF   03,W
01590:  BNZ   159E
01592:  MOVLW  25
01594:  SUBWF  00,W
01596:  MOVLB  0
01598:  BTFSC  FD8.2
0159A:  BRA    1AE2
0159C:  MOVLB  4
0159E:  MOVF   03,W
015A0:  BNZ   15AE
015A2:  MOVLW  26
015A4:  SUBWF  00,W
015A6:  MOVLB  0
015A8:  BTFSC  FD8.2
015AA:  BRA    1AFC
015AC:  MOVLB  4
015AE:  MOVF   03,W
015B0:  BNZ   15BE
015B2:  MOVLW  27
015B4:  SUBWF  00,W
015B6:  MOVLB  0
015B8:  BTFSC  FD8.2
015BA:  BRA    1B0A
015BC:  MOVLB  4
015BE:  MOVF   03,W
015C0:  BNZ   15CE
015C2:  MOVLW  28
015C4:  SUBWF  00,W
015C6:  MOVLB  0
015C8:  BTFSC  FD8.2
015CA:  BRA    1B38
015CC:  MOVLB  4
015CE:  MOVF   03,W
015D0:  BNZ   15DE
015D2:  MOVLW  29
015D4:  SUBWF  00,W
015D6:  MOVLB  0
015D8:  BTFSC  FD8.2
015DA:  BRA    1B52
015DC:  MOVLB  4
015DE:  MOVF   03,W
015E0:  BNZ   15EE
015E2:  MOVLW  2A
015E4:  SUBWF  00,W
015E6:  MOVLB  0
015E8:  BTFSC  FD8.2
015EA:  BRA    1B60
015EC:  MOVLB  4
015EE:  MOVF   03,W
015F0:  BNZ   15FE
015F2:  MOVLW  2B
015F4:  SUBWF  00,W
015F6:  MOVLB  0
015F8:  BTFSC  FD8.2
015FA:  BRA    1B7A
015FC:  MOVLB  4
015FE:  MOVF   03,W
01600:  BNZ   160E
01602:  MOVLW  2C
01604:  SUBWF  00,W
01606:  MOVLB  0
01608:  BTFSC  FD8.2
0160A:  BRA    1B8A
0160C:  MOVLB  4
0160E:  MOVF   03,W
01610:  BNZ   161E
01612:  MOVLW  2D
01614:  SUBWF  00,W
01616:  MOVLB  0
01618:  BTFSC  FD8.2
0161A:  BRA    1B9A
0161C:  MOVLB  4
0161E:  MOVF   03,W
01620:  BNZ   162E
01622:  MOVLW  2E
01624:  SUBWF  00,W
01626:  MOVLB  0
01628:  BTFSC  FD8.2
0162A:  BRA    1BAA
0162C:  MOVLB  4
0162E:  MOVF   03,W
01630:  BNZ   163E
01632:  MOVLW  2F
01634:  SUBWF  00,W
01636:  MOVLB  0
01638:  BTFSC  FD8.2
0163A:  BRA    1BBA
0163C:  MOVLB  4
0163E:  MOVF   03,W
01640:  BNZ   164E
01642:  MOVLW  30
01644:  SUBWF  00,W
01646:  MOVLB  0
01648:  BTFSC  FD8.2
0164A:  BRA    1BCA
0164C:  MOVLB  4
0164E:  MOVF   03,W
01650:  BNZ   165E
01652:  MOVLW  31
01654:  SUBWF  00,W
01656:  MOVLB  0
01658:  BTFSC  FD8.2
0165A:  BRA    1BDA
0165C:  MOVLB  4
0165E:  MOVF   03,W
01660:  BNZ   166E
01662:  MOVLW  32
01664:  SUBWF  00,W
01666:  MOVLB  0
01668:  BTFSC  FD8.2
0166A:  BRA    1BEA
0166C:  MOVLB  4
0166E:  MOVF   03,W
01670:  BNZ   167E
01672:  MOVLW  33
01674:  SUBWF  00,W
01676:  MOVLB  0
01678:  BTFSC  FD8.2
0167A:  BRA    1BFA
0167C:  MOVLB  4
0167E:  MOVLW  03
01680:  SUBWF  03,W
01682:  BNZ   1690
01684:  MOVLW  E8
01686:  SUBWF  00,W
01688:  MOVLB  0
0168A:  BTFSC  FD8.2
0168C:  BRA    1C0A
0168E:  MOVLB  4
01690:  MOVLW  03
01692:  SUBWF  03,W
01694:  BNZ   16A2
01696:  MOVLW  E9
01698:  SUBWF  00,W
0169A:  MOVLB  0
0169C:  BTFSC  FD8.2
0169E:  BRA    1C1A
016A0:  MOVLB  4
016A2:  MOVLW  03
016A4:  SUBWF  03,W
016A6:  BNZ   16B4
016A8:  MOVLW  EA
016AA:  SUBWF  00,W
016AC:  MOVLB  0
016AE:  BTFSC  FD8.2
016B0:  BRA    1C28
016B2:  MOVLB  4
016B4:  MOVLW  03
016B6:  SUBWF  03,W
016B8:  BNZ   16C6
016BA:  MOVLW  EB
016BC:  SUBWF  00,W
016BE:  MOVLB  0
016C0:  BTFSC  FD8.2
016C2:  BRA    1C36
016C4:  MOVLB  4
016C6:  MOVLW  03
016C8:  SUBWF  03,W
016CA:  BNZ   16D8
016CC:  MOVLW  EC
016CE:  SUBWF  00,W
016D0:  MOVLB  0
016D2:  BTFSC  FD8.2
016D4:  BRA    1C44
016D6:  MOVLB  4
016D8:  MOVLW  03
016DA:  SUBWF  03,W
016DC:  BNZ   16EA
016DE:  MOVLW  ED
016E0:  SUBWF  00,W
016E2:  MOVLB  0
016E4:  BTFSC  FD8.2
016E6:  BRA    1C52
016E8:  MOVLB  4
016EA:  MOVLW  03
016EC:  SUBWF  03,W
016EE:  BNZ   16FC
016F0:  MOVLW  EE
016F2:  SUBWF  00,W
016F4:  MOVLB  0
016F6:  BTFSC  FD8.2
016F8:  BRA    1C60
016FA:  MOVLB  4
016FC:  MOVLW  03
016FE:  SUBWF  03,W
01700:  BNZ   170E
01702:  MOVLW  EF
01704:  SUBWF  00,W
01706:  MOVLB  0
01708:  BTFSC  FD8.2
0170A:  BRA    1C70
0170C:  MOVLB  4
0170E:  MOVLW  03
01710:  SUBWF  03,W
01712:  BNZ   1720
01714:  MOVLW  F0
01716:  SUBWF  00,W
01718:  MOVLB  0
0171A:  BTFSC  FD8.2
0171C:  BRA    1C7E
0171E:  MOVLB  4
01720:  MOVLW  03
01722:  SUBWF  03,W
01724:  BNZ   1732
01726:  MOVLW  F1
01728:  SUBWF  00,W
0172A:  MOVLB  0
0172C:  BTFSC  FD8.2
0172E:  BRA    1C8E
01730:  MOVLB  4
01732:  MOVLW  03
01734:  SUBWF  03,W
01736:  BNZ   1744
01738:  MOVLW  F2
0173A:  SUBWF  00,W
0173C:  MOVLB  0
0173E:  BTFSC  FD8.2
01740:  BRA    1C9C
01742:  MOVLB  4
01744:  MOVLW  03
01746:  SUBWF  03,W
01748:  BNZ   1756
0174A:  MOVLW  F3
0174C:  SUBWF  00,W
0174E:  MOVLB  0
01750:  BTFSC  FD8.2
01752:  BRA    1CAA
01754:  MOVLB  4
01756:  MOVLW  03
01758:  SUBWF  03,W
0175A:  BNZ   1768
0175C:  MOVLW  F4
0175E:  SUBWF  00,W
01760:  MOVLB  0
01762:  BTFSC  FD8.2
01764:  BRA    1CBA
01766:  MOVLB  4
01768:  BRA    1CC8
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
0176A:  MOVFF  60,01
0176E:  MOVFF  61,02
01772:  MOVLB  4
01774:  BRA    1CD0
01776:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01778:  MOVF   4E,W
0177A:  MOVWF  01
0177C:  MOVF   4F,W
0177E:  MOVWF  02
01780:  MOVLB  4
01782:  BRA    1CD0
01784:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01786:  MOVF   54,W
01788:  MOVWF  01
0178A:  MOVF   55,W
0178C:  MOVWF  02
0178E:  MOVLB  4
01790:  BRA    1CD0
01792:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01794:  MOVF   5A,W
01796:  MOVWF  01
01798:  MOVF   5B,W
0179A:  MOVWF  02
0179C:  MOVLB  4
0179E:  BRA    1CD0
017A0:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
017A2:  MOVLB  4
017A4:  CLRF   xE1
017A6:  MOVLB  0
017A8:  RCALL  1202
017AA:  MOVFF  03,4C1
017AE:  MOVFF  02,4C0
017B2:  MOVFF  01,4BF
017B6:  MOVFF  00,4BE
017BA:  MOVLB  4
017BC:  MOVF   xBE,W
017BE:  MOVWF  01
017C0:  MOVF   xBF,W
017C2:  MOVWF  02
017C4:  BRA    1CD0
017C6:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
017C8:  MOVLB  4
017CA:  MOVF   xC0,W
017CC:  MOVWF  01
017CE:  MOVF   xC1,W
017D0:  MOVWF  02
017D2:  BRA    1CD0
017D4:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
017D6:  MOVF   x62,W
017D8:  MOVWF  01
017DA:  MOVF   x63,W
017DC:  MOVWF  02
017DE:  MOVLB  4
017E0:  BRA    1CD0
017E2:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
017E4:  MOVF   50,W
017E6:  MOVWF  01
017E8:  MOVF   51,W
017EA:  MOVWF  02
017EC:  MOVLB  4
017EE:  BRA    1CD0
017F0:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
017F2:  MOVF   56,W
017F4:  MOVWF  01
017F6:  MOVF   57,W
017F8:  MOVWF  02
017FA:  MOVLB  4
017FC:  BRA    1CD0
017FE:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01800:  MOVF   5C,W
01802:  MOVWF  01
01804:  MOVF   5D,W
01806:  MOVWF  02
01808:  MOVLB  4
0180A:  BRA    1CD0
0180C:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
0180E:  MOVLW  01
01810:  MOVLB  4
01812:  MOVWF  xE1
01814:  MOVLB  0
01816:  RCALL  1202
01818:  MOVFF  03,4C1
0181C:  MOVFF  02,4C0
01820:  MOVFF  01,4BF
01824:  MOVFF  00,4BE
01828:  MOVLB  4
0182A:  MOVF   xBE,W
0182C:  MOVWF  01
0182E:  MOVF   xBF,W
01830:  MOVWF  02
01832:  BRA    1CD0
01834:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01836:  MOVLB  4
01838:  MOVF   xC0,W
0183A:  MOVWF  01
0183C:  MOVF   xC1,W
0183E:  MOVWF  02
01840:  BRA    1CD0
01842:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01844:  MOVF   x64,W
01846:  MOVWF  01
01848:  MOVF   x65,W
0184A:  MOVWF  02
0184C:  MOVLB  4
0184E:  BRA    1CD0
01850:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01852:  MOVF   52,W
01854:  MOVWF  01
01856:  MOVF   53,W
01858:  MOVWF  02
0185A:  MOVLB  4
0185C:  BRA    1CD0
0185E:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01860:  MOVF   58,W
01862:  MOVWF  01
01864:  MOVF   59,W
01866:  MOVWF  02
01868:  MOVLB  4
0186A:  BRA    1CD0
0186C:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
0186E:  MOVF   5E,W
01870:  MOVWF  01
01872:  MOVF   5F,W
01874:  MOVWF  02
01876:  MOVLB  4
01878:  BRA    1CD0
0187A:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
0187C:  MOVLW  02
0187E:  MOVLB  4
01880:  MOVWF  xE1
01882:  MOVLB  0
01884:  RCALL  1202
01886:  MOVFF  03,4C1
0188A:  MOVFF  02,4C0
0188E:  MOVFF  01,4BF
01892:  MOVFF  00,4BE
01896:  MOVLB  4
01898:  MOVF   xBE,W
0189A:  MOVWF  01
0189C:  MOVF   xBF,W
0189E:  MOVWF  02
018A0:  BRA    1CD0
018A2:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
018A4:  MOVLB  4
018A6:  MOVF   xC0,W
018A8:  MOVWF  01
018AA:  MOVF   xC1,W
018AC:  MOVWF  02
018AE:  BRA    1CD0
018B0:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
018B2:  CLRF   03
018B4:  MOVLB  1
018B6:  MOVF   x82,W
018B8:  MOVWF  02
018BA:  BCF    FD8.0
018BC:  RLCF   02,F
018BE:  RLCF   03,F
018C0:  MOVF   02,W
018C2:  ADDLW  82
018C4:  MOVWF  FE9
018C6:  MOVLW  00
018C8:  ADDWFC 03,W
018CA:  MOVWF  FEA
018CC:  MOVFF  FEC,03
018D0:  MOVF   FED,F
018D2:  MOVF   FEF,W
018D4:  MOVWF  01
018D6:  MOVF   03,W
018D8:  MOVWF  02
018DA:  MOVLB  4
018DC:  BRA    1CD0
018DE:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
018E0:  MOVLB  4
018E2:  CLRF   xE1
018E4:  MOVLB  0
018E6:  CALL   0E64
018EA:  MOVF   01,W
018EC:  MOVWF  01
018EE:  MOVF   02,W
018F0:  MOVWF  02
018F2:  MOVLB  4
018F4:  BRA    1CD0
018F6:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
018F8:  MOVF   x72,W
018FA:  MOVWF  01
018FC:  MOVF   x73,W
018FE:  MOVWF  02
01900:  MOVLB  4
01902:  BRA    1CD0
01904:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01906:  CLRF   03
01908:  MOVLB  1
0190A:  MOVF   x82,W
0190C:  MOVWF  02
0190E:  BCF    FD8.0
01910:  RLCF   02,F
01912:  RLCF   03,F
01914:  MOVF   02,W
01916:  ADDLW  A2
01918:  MOVWF  FE9
0191A:  MOVLW  00
0191C:  ADDWFC 03,W
0191E:  MOVWF  FEA
01920:  MOVFF  FEC,03
01924:  MOVF   FED,F
01926:  MOVF   FEF,W
01928:  MOVWF  01
0192A:  MOVF   03,W
0192C:  MOVWF  02
0192E:  MOVLB  4
01930:  BRA    1CD0
01932:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01934:  MOVLW  01
01936:  MOVLB  4
01938:  MOVWF  xE1
0193A:  MOVLB  0
0193C:  CALL   0E64
01940:  MOVF   01,W
01942:  MOVWF  01
01944:  MOVF   02,W
01946:  MOVWF  02
01948:  MOVLB  4
0194A:  BRA    1CD0
0194C:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0194E:  MOVF   x74,W
01950:  MOVWF  01
01952:  MOVF   x75,W
01954:  MOVWF  02
01956:  MOVLB  4
01958:  BRA    1CD0
0195A:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0195C:  CLRF   03
0195E:  MOVLB  1
01960:  MOVF   x82,W
01962:  MOVWF  02
01964:  BCF    FD8.0
01966:  RLCF   02,F
01968:  RLCF   03,F
0196A:  MOVF   02,W
0196C:  ADDLW  C2
0196E:  MOVWF  FE9
01970:  MOVLW  00
01972:  ADDWFC 03,W
01974:  MOVWF  FEA
01976:  MOVFF  FEC,03
0197A:  MOVF   FED,F
0197C:  MOVF   FEF,W
0197E:  MOVWF  01
01980:  MOVF   03,W
01982:  MOVWF  02
01984:  MOVLB  4
01986:  BRA    1CD0
01988:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
0198A:  MOVLW  02
0198C:  MOVLB  4
0198E:  MOVWF  xE1
01990:  MOVLB  0
01992:  CALL   0E64
01996:  MOVF   01,W
01998:  MOVWF  01
0199A:  MOVF   02,W
0199C:  MOVWF  02
0199E:  MOVLB  4
019A0:  BRA    1CD0
019A2:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
019A4:  MOVF   x76,W
019A6:  MOVWF  01
019A8:  MOVF   x77,W
019AA:  MOVWF  02
019AC:  MOVLB  4
019AE:  BRA    1CD0
019B0:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
019B2:  CLRF   03
019B4:  MOVLB  1
019B6:  MOVF   x82,W
019B8:  MOVWF  02
019BA:  BCF    FD8.0
019BC:  RLCF   02,F
019BE:  RLCF   03,F
019C0:  MOVF   02,W
019C2:  ADDLW  E2
019C4:  MOVWF  FE9
019C6:  MOVLW  00
019C8:  ADDWFC 03,W
019CA:  MOVWF  FEA
019CC:  MOVFF  FEC,03
019D0:  MOVF   FED,F
019D2:  MOVF   FEF,W
019D4:  MOVWF  01
019D6:  MOVF   03,W
019D8:  MOVWF  02
019DA:  MOVLB  4
019DC:  BRA    1CD0
019DE:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
019E0:  MOVLW  03
019E2:  MOVLB  4
019E4:  MOVWF  xE1
019E6:  MOVLB  0
019E8:  CALL   0E64
019EC:  MOVF   01,W
019EE:  MOVWF  01
019F0:  MOVF   02,W
019F2:  MOVWF  02
019F4:  MOVLB  4
019F6:  BRA    1CD0
019F8:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
019FA:  MOVF   x78,W
019FC:  MOVWF  01
019FE:  MOVF   x79,W
01A00:  MOVWF  02
01A02:  MOVLB  4
01A04:  BRA    1CD0
01A06:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01A08:  CLRF   03
01A0A:  MOVLB  1
01A0C:  MOVF   x82,W
01A0E:  MOVWF  02
01A10:  BCF    FD8.0
01A12:  RLCF   02,F
01A14:  RLCF   03,F
01A16:  MOVF   02,W
01A18:  ADDLW  02
01A1A:  MOVWF  FE9
01A1C:  MOVLW  01
01A1E:  ADDWFC 03,W
01A20:  MOVWF  FEA
01A22:  MOVFF  FEC,03
01A26:  MOVF   FED,F
01A28:  MOVF   FEF,W
01A2A:  MOVWF  01
01A2C:  MOVF   03,W
01A2E:  MOVWF  02
01A30:  MOVLB  4
01A32:  BRA    1CD0
01A34:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01A36:  MOVLW  04
01A38:  MOVLB  4
01A3A:  MOVWF  xE1
01A3C:  MOVLB  0
01A3E:  CALL   0E64
01A42:  MOVF   01,W
01A44:  MOVWF  01
01A46:  MOVF   02,W
01A48:  MOVWF  02
01A4A:  MOVLB  4
01A4C:  BRA    1CD0
01A4E:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01A50:  MOVF   x7A,W
01A52:  MOVWF  01
01A54:  MOVF   x7B,W
01A56:  MOVWF  02
01A58:  MOVLB  4
01A5A:  BRA    1CD0
01A5C:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01A5E:  CLRF   03
01A60:  MOVLB  1
01A62:  MOVF   x82,W
01A64:  MOVWF  02
01A66:  BCF    FD8.0
01A68:  RLCF   02,F
01A6A:  RLCF   03,F
01A6C:  MOVF   02,W
01A6E:  ADDLW  22
01A70:  MOVWF  FE9
01A72:  MOVLW  01
01A74:  ADDWFC 03,W
01A76:  MOVWF  FEA
01A78:  MOVFF  FEC,03
01A7C:  MOVF   FED,F
01A7E:  MOVF   FEF,W
01A80:  MOVWF  01
01A82:  MOVF   03,W
01A84:  MOVWF  02
01A86:  MOVLB  4
01A88:  BRA    1CD0
01A8A:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01A8C:  MOVLW  05
01A8E:  MOVLB  4
01A90:  MOVWF  xE1
01A92:  MOVLB  0
01A94:  CALL   0E64
01A98:  MOVF   01,W
01A9A:  MOVWF  01
01A9C:  MOVF   02,W
01A9E:  MOVWF  02
01AA0:  MOVLB  4
01AA2:  BRA    1CD0
01AA4:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01AA6:  MOVF   x7C,W
01AA8:  MOVWF  01
01AAA:  MOVF   x7D,W
01AAC:  MOVWF  02
01AAE:  MOVLB  4
01AB0:  BRA    1CD0
01AB2:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01AB4:  CLRF   03
01AB6:  MOVLB  1
01AB8:  MOVF   x82,W
01ABA:  MOVWF  02
01ABC:  BCF    FD8.0
01ABE:  RLCF   02,F
01AC0:  RLCF   03,F
01AC2:  MOVF   02,W
01AC4:  ADDLW  42
01AC6:  MOVWF  FE9
01AC8:  MOVLW  01
01ACA:  ADDWFC 03,W
01ACC:  MOVWF  FEA
01ACE:  MOVFF  FEC,03
01AD2:  MOVF   FED,F
01AD4:  MOVF   FEF,W
01AD6:  MOVWF  01
01AD8:  MOVF   03,W
01ADA:  MOVWF  02
01ADC:  MOVLB  4
01ADE:  BRA    1CD0
01AE0:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01AE2:  MOVLW  06
01AE4:  MOVLB  4
01AE6:  MOVWF  xE1
01AE8:  MOVLB  0
01AEA:  CALL   0E64
01AEE:  MOVF   01,W
01AF0:  MOVWF  01
01AF2:  MOVF   02,W
01AF4:  MOVWF  02
01AF6:  MOVLB  4
01AF8:  BRA    1CD0
01AFA:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01AFC:  MOVF   x7E,W
01AFE:  MOVWF  01
01B00:  MOVF   x7F,W
01B02:  MOVWF  02
01B04:  MOVLB  4
01B06:  BRA    1CD0
01B08:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01B0A:  CLRF   03
01B0C:  MOVLB  1
01B0E:  MOVF   x82,W
01B10:  MOVWF  02
01B12:  BCF    FD8.0
01B14:  RLCF   02,F
01B16:  RLCF   03,F
01B18:  MOVF   02,W
01B1A:  ADDLW  62
01B1C:  MOVWF  FE9
01B1E:  MOVLW  01
01B20:  ADDWFC 03,W
01B22:  MOVWF  FEA
01B24:  MOVFF  FEC,03
01B28:  MOVF   FED,F
01B2A:  MOVF   FEF,W
01B2C:  MOVWF  01
01B2E:  MOVF   03,W
01B30:  MOVWF  02
01B32:  MOVLB  4
01B34:  BRA    1CD0
01B36:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01B38:  MOVLW  07
01B3A:  MOVLB  4
01B3C:  MOVWF  xE1
01B3E:  MOVLB  0
01B40:  CALL   0E64
01B44:  MOVF   01,W
01B46:  MOVWF  01
01B48:  MOVF   02,W
01B4A:  MOVWF  02
01B4C:  MOVLB  4
01B4E:  BRA    1CD0
01B50:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01B52:  MOVF   x80,W
01B54:  MOVWF  01
01B56:  MOVF   x81,W
01B58:  MOVWF  02
01B5A:  MOVLB  4
01B5C:  BRA    1CD0
01B5E:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01B60:  MOVLB  1
01B62:  MOVF   x8A,W
01B64:  MOVWF  03
01B66:  MOVF   x89,W
01B68:  INCF   x89,F
01B6A:  BTFSC  FD8.2
01B6C:  INCF   x8A,F
01B6E:  MOVWF  01
01B70:  MOVF   03,W
01B72:  MOVWF  02
01B74:  MOVLB  4
01B76:  BRA    1CD0
01B78:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01B7A:  MOVLB  1
01B7C:  MOVF   x8D,W
01B7E:  MOVWF  01
01B80:  MOVF   x8E,W
01B82:  MOVWF  02
01B84:  MOVLB  4
01B86:  BRA    1CD0
01B88:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01B8A:  MOVLB  1
01B8C:  MOVF   x8B,W
01B8E:  MOVWF  01
01B90:  MOVF   x8C,W
01B92:  MOVWF  02
01B94:  MOVLB  4
01B96:  BRA    1CD0
01B98:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01B9A:  MOVLB  1
01B9C:  MOVF   x91,W
01B9E:  MOVWF  01
01BA0:  MOVF   x92,W
01BA2:  MOVWF  02
01BA4:  MOVLB  4
01BA6:  BRA    1CD0
01BA8:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01BAA:  GOTO   1264
01BAE:  MOVLW  00
01BB0:  MOVWF  01
01BB2:  MOVWF  02
01BB4:  MOVLB  4
01BB6:  BRA    1CD0
01BB8:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01BBA:  GOTO   12A0
01BBE:  MOVLW  00
01BC0:  MOVWF  01
01BC2:  MOVWF  02
01BC4:  MOVLB  4
01BC6:  BRA    1CD0
01BC8:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01BCA:  MOVLB  1
01BCC:  MOVF   x83,W
01BCE:  MOVWF  01
01BD0:  MOVF   x84,W
01BD2:  MOVWF  02
01BD4:  MOVLB  4
01BD6:  BRA    1CD0
01BD8:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01BDA:  MOVLB  1
01BDC:  MOVF   x85,W
01BDE:  MOVWF  01
01BE0:  MOVF   x86,W
01BE2:  MOVWF  02
01BE4:  MOVLB  4
01BE6:  BRA    1CD0
01BE8:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01BEA:  MOVLB  1
01BEC:  MOVF   x87,W
01BEE:  MOVWF  01
01BF0:  MOVF   x88,W
01BF2:  MOVWF  02
01BF4:  MOVLB  4
01BF6:  BRA    1CD0
01BF8:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01BFA:  GOTO   12C8
01BFE:  MOVLW  00
01C00:  MOVWF  01
01C02:  MOVWF  02
01C04:  MOVLB  4
01C06:  BRA    1CD0
01C08:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01C0A:  CLRF   03
01C0C:  MOVF   39,W
01C0E:  MOVWF  01
01C10:  MOVF   03,W
01C12:  MOVWF  02
01C14:  MOVLB  4
01C16:  BRA    1CD0
01C18:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01C1A:  MOVF   3A,W
01C1C:  MOVWF  01
01C1E:  MOVF   3B,W
01C20:  MOVWF  02
01C22:  MOVLB  4
01C24:  BRA    1CD0
01C26:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01C28:  MOVLW  50
01C2A:  MOVWF  01
01C2C:  MOVLW  00
01C2E:  MOVWF  02
01C30:  MOVLB  4
01C32:  BRA    1CD0
01C34:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01C36:  MOVLW  57
01C38:  MOVWF  01
01C3A:  MOVLW  00
01C3C:  MOVWF  02
01C3E:  MOVLB  4
01C40:  BRA    1CD0
01C42:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01C44:  MOVLW  58
01C46:  MOVWF  01
01C48:  MOVLW  00
01C4A:  MOVWF  02
01C4C:  MOVLB  4
01C4E:  BRA    1CD0
01C50:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01C52:  MOVLW  01
01C54:  MOVWF  01
01C56:  MOVLW  00
01C58:  MOVWF  02
01C5A:  MOVLB  4
01C5C:  BRA    1CD0
01C5E:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01C60:  CLRF   03
01C62:  MOVF   36,W
01C64:  MOVWF  01
01C66:  MOVF   03,W
01C68:  MOVWF  02
01C6A:  MOVLB  4
01C6C:  BRA    1CD0
01C6E:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01C70:  MOVF   3C,W
01C72:  MOVWF  01
01C74:  MOVF   3D,W
01C76:  MOVWF  02
01C78:  MOVLB  4
01C7A:  BRA    1CD0
01C7C:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01C7E:  CLRF   03
01C80:  MOVF   3E,W
01C82:  MOVWF  01
01C84:  MOVF   03,W
01C86:  MOVWF  02
01C88:  MOVLB  4
01C8A:  BRA    1CD0
01C8C:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01C8E:  MOVF   3F,W
01C90:  MOVWF  01
01C92:  MOVF   40,W
01C94:  MOVWF  02
01C96:  MOVLB  4
01C98:  BRA    1CD0
01C9A:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01C9C:  MOVF   41,W
01C9E:  MOVWF  01
01CA0:  MOVF   42,W
01CA2:  MOVWF  02
01CA4:  MOVLB  4
01CA6:  BRA    1CD0
01CA8:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01CAA:  CLRF   03
01CAC:  MOVF   43,W
01CAE:  MOVWF  01
01CB0:  MOVF   03,W
01CB2:  MOVWF  02
01CB4:  MOVLB  4
01CB6:  BRA    1CD0
01CB8:  MOVLB  0
.................... 		case 1012: return (int16) config.modbus_bridge; 
01CBA:  CLRF   03
01CBC:  MOVF   38,W
01CBE:  MOVWF  01
01CC0:  MOVF   03,W
01CC2:  MOVWF  02
01CC4:  MOVLB  4
01CC6:  BRA    1CD0
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01CC8:  MOVLW  FF
01CCA:  MOVWF  01
01CCC:  MOVWF  02
01CCE:  BRA    1CD0
.................... 	} 
....................  
.................... } 
01CD0:  MOVLB  0
01CD2:  GOTO   1D24 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
010C8:  MOVLB  4
010CA:  MOVF   xD5,W
010CC:  SUBLW  1F
010CE:  BNZ   10E8
010D0:  MOVF   xD6,W
010D2:  SUBLW  4E
010D4:  BNZ   10E8
010D6:  MOVF   xD7,W
010D8:  SUBLW  20
010DA:  BNZ   10E8
010DC:  MOVF   xD8,W
010DE:  SUBLW  4E
010E0:  BNZ   10E8
.................... 		return 1; 
010E2:  MOVLW  01
010E4:  MOVWF  01
010E6:  BRA    1144
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
010E8:  MOVF   xD6,W
010EA:  SUBLW  02
010EC:  BC    110C
010EE:  XORLW  FF
010F0:  BNZ   10F8
010F2:  MOVF   xD5,W
010F4:  SUBLW  E7
010F6:  BC    110C
010F8:  MOVF   xD8,W
010FA:  SUBLW  03
010FC:  BNC   110C
010FE:  BNZ   1106
01100:  MOVF   xD7,W
01102:  SUBLW  F5
01104:  BNC   110C
.................... 		return 1; 
01106:  MOVLW  01
01108:  MOVWF  01
0110A:  BRA    1144
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
0110C:  MOVF   xD6,W
0110E:  SUBLW  06
01110:  BC    1130
01112:  XORLW  FF
01114:  BNZ   111C
01116:  MOVF   xD5,W
01118:  SUBLW  CF
0111A:  BC    1130
0111C:  MOVF   xD8,W
0111E:  SUBLW  09
01120:  BNC   1130
01122:  BNZ   112A
01124:  MOVF   xD7,W
01126:  SUBLW  D1
01128:  BNC   1130
.................... 		return 1; 
0112A:  MOVLW  01
0112C:  MOVWF  01
0112E:  BRA    1144
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01130:  MOVF   xD8,F
01132:  BNZ   1140
01134:  MOVF   xD7,W
01136:  SUBLW  34
01138:  BNC   1140
.................... 		return 1; 
0113A:  MOVLW  01
0113C:  MOVWF  01
0113E:  BRA    1144
....................  
.................... 	return 0; 
01140:  MOVLW  00
01142:  MOVWF  01
.................... } 
01144:  MOVLB  0
01146:  GOTO   218A (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01CD6:  MOVFF  4D4,4DD
01CDA:  MOVFF  4D3,4DE
01CDE:  CALL   1186
.................... 	modbus_serial_putc(register_count*2); 
01CE2:  BCF    FD8.0
01CE4:  MOVLB  4
01CE6:  RLCF   xD7,W
01CE8:  MOVWF  xDD
01CEA:  RLCF   xD8,W
01CEC:  MOVWF  xDE
01CEE:  MOVFF  4DD,4DF
01CF2:  MOVLB  0
01CF4:  CALL   1152
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01CF8:  MOVLB  4
01CFA:  CLRF   xDA
01CFC:  CLRF   xD9
01CFE:  MOVF   xDA,W
01D00:  SUBWF  xD8,W
01D02:  BNC   1D4E
01D04:  BNZ   1D0C
01D06:  MOVF   xD7,W
01D08:  SUBWF  xD9,W
01D0A:  BC    1D4E
.................... 		l=map_modbus(start_address+i); 
01D0C:  MOVF   xD9,W
01D0E:  ADDWF  xD5,W
01D10:  MOVWF  xDD
01D12:  MOVF   xDA,W
01D14:  ADDWFC xD6,W
01D16:  MOVWF  xDE
01D18:  MOVWF  xE0
01D1A:  MOVFF  4DD,4DF
01D1E:  MOVLB  0
01D20:  GOTO   12DC
01D24:  MOVFF  02,4DC
01D28:  MOVFF  01,4DB
.................... 		modbus_serial_putc(make8(l,1)); 
01D2C:  MOVFF  4DC,4DD
01D30:  MOVFF  4DC,4DF
01D34:  CALL   1152
....................   		modbus_serial_putc(make8(l,0)); 
01D38:  MOVFF  4DB,4DD
01D3C:  MOVFF  4DB,4DF
01D40:  CALL   1152
.................... 	} 
01D44:  MOVLB  4
01D46:  INCF   xD9,F
01D48:  BTFSC  FD8.2
01D4A:  INCF   xDA,F
01D4C:  BRA    1CFE
....................  
.................... 	modbus_serial_send_stop(); 
01D4E:  MOVLB  0
01D50:  CALL   11B4
.................... } 
01D54:  GOTO   21CC (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01D58:  MOVLB  4
01D5A:  MOVF   xDA,W
01D5C:  SUBLW  06
01D5E:  BC    1DD6
01D60:  XORLW  FF
01D62:  BNZ   1D6A
01D64:  MOVF   xD9,W
01D66:  SUBLW  CF
01D68:  BC    1DD6
01D6A:  MOVF   xDA,W
01D6C:  SUBLW  09
01D6E:  BNC   1DD6
01D70:  BNZ   1D78
01D72:  MOVF   xD9,W
01D74:  SUBLW  CF
01D76:  BNC   1DD6
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01D78:  MOVF   xDC,W
01D7A:  SUBLW  00
01D7C:  BC    1D8E
01D7E:  XORLW  FF
01D80:  BNZ   1D88
01D82:  MOVF   xDB,W
01D84:  SUBLW  00
01D86:  BC    1D8E
01D88:  MOVLW  03
01D8A:  MOVWF  01
01D8C:  BRA    1FC2
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
01D8E:  MOVLW  D0
01D90:  SUBWF  xD9,W
01D92:  MOVWF  xDD
01D94:  MOVLW  07
01D96:  SUBWFB xDA,W
01D98:  MOVWF  xDE
01D9A:  MOVLW  02
01D9C:  ADDWF  xDE,F
01D9E:  MOVFF  4DE,FAA
01DA2:  MOVFF  4DD,FA9
01DA6:  MOVFF  4DB,FA8
01DAA:  BCF    FA6.6
01DAC:  BCF    FA6.7
01DAE:  BSF    FA6.2
01DB0:  MOVF   FF2,W
01DB2:  MOVWF  00
01DB4:  BCF    FF2.6
01DB6:  BCF    FF2.7
01DB8:  MOVLB  F
01DBA:  MOVLW  55
01DBC:  MOVWF  FA7
01DBE:  MOVLW  AA
01DC0:  MOVWF  FA7
01DC2:  BSF    FA6.1
01DC4:  BTFSC  FA6.1
01DC6:  BRA    1DC4
01DC8:  BCF    FA6.2
01DCA:  MOVF   00,W
01DCC:  IORWF  FF2,F
.................... 		return 0; 
01DCE:  MOVLW  00
01DD0:  MOVWF  01
01DD2:  MOVLB  4
01DD4:  BRA    1FC2
.................... 	} 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01DD6:  MOVLB  1
01DD8:  MOVF   x8F,F
01DDA:  BZ    1E12
.................... 		if ( 1000 == address ) { 
01DDC:  MOVLB  4
01DDE:  MOVF   xD9,W
01DE0:  SUBLW  E8
01DE2:  BNZ   1DF6
01DE4:  MOVF   xDA,W
01DE6:  SUBLW  03
01DE8:  BNZ   1DF6
.................... 			config.serial_prefix=value; 
01DEA:  MOVFF  4DB,39
.................... 			return 0; 
01DEE:  MOVLW  00
01DF0:  MOVWF  01
01DF2:  BRA    1FC2
.................... 		} else if ( 1001 == address ) { 
01DF4:  BRA    1E10
01DF6:  MOVF   xD9,W
01DF8:  SUBLW  E9
01DFA:  BNZ   1E10
01DFC:  MOVF   xDA,W
01DFE:  SUBLW  03
01E00:  BNZ   1E10
.................... 			config.serial_number=value; 
01E02:  MOVFF  4DC,3B
01E06:  MOVFF  4DB,3A
.................... 			return 0; 
01E0A:  MOVLW  00
01E0C:  MOVWF  01
01E0E:  BRA    1FC2
01E10:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01E12:  MOVLB  4
01E14:  MOVF   xD9,W
01E16:  MOVWF  00
01E18:  MOVF   xDA,W
01E1A:  MOVWF  03
01E1C:  MOVLW  03
01E1E:  SUBWF  03,W
01E20:  BNZ   1E2C
01E22:  MOVLW  EE
01E24:  SUBWF  00,W
01E26:  MOVLB  0
01E28:  BZ    1EC6
01E2A:  MOVLB  4
01E2C:  MOVLW  03
01E2E:  SUBWF  03,W
01E30:  BNZ   1E3C
01E32:  MOVLW  EF
01E34:  SUBWF  00,W
01E36:  MOVLB  0
01E38:  BZ    1EDE
01E3A:  MOVLB  4
01E3C:  MOVLW  03
01E3E:  SUBWF  03,W
01E40:  BNZ   1E4C
01E42:  MOVLW  F0
01E44:  SUBWF  00,W
01E46:  MOVLB  0
01E48:  BZ    1EEE
01E4A:  MOVLB  4
01E4C:  MOVLW  03
01E4E:  SUBWF  03,W
01E50:  BNZ   1E5C
01E52:  MOVLW  F1
01E54:  SUBWF  00,W
01E56:  MOVLB  0
01E58:  BZ    1F06
01E5A:  MOVLB  4
01E5C:  MOVLW  03
01E5E:  SUBWF  03,W
01E60:  BNZ   1E6C
01E62:  MOVLW  F2
01E64:  SUBWF  00,W
01E66:  MOVLB  0
01E68:  BZ    1F12
01E6A:  MOVLB  4
01E6C:  MOVLW  03
01E6E:  SUBWF  03,W
01E70:  BNZ   1E7C
01E72:  MOVLW  F3
01E74:  SUBWF  00,W
01E76:  MOVLB  0
01E78:  BZ    1F2C
01E7A:  MOVLB  4
01E7C:  MOVLW  03
01E7E:  SUBWF  03,W
01E80:  BNZ   1E8E
01E82:  MOVLW  F4
01E84:  SUBWF  00,W
01E86:  MOVLB  0
01E88:  BTFSC  FD8.2
01E8A:  BRA    1F44
01E8C:  MOVLB  4
01E8E:  MOVLW  07
01E90:  SUBWF  03,W
01E92:  BNZ   1EA0
01E94:  MOVLW  CE
01E96:  SUBWF  00,W
01E98:  MOVLB  0
01E9A:  BTFSC  FD8.2
01E9C:  BRA    1F5C
01E9E:  MOVLB  4
01EA0:  MOVLW  07
01EA2:  SUBWF  03,W
01EA4:  BNZ   1EB2
01EA6:  MOVLW  CF
01EA8:  SUBWF  00,W
01EAA:  MOVLB  0
01EAC:  BTFSC  FD8.2
01EAE:  BRA    1F76
01EB0:  MOVLB  4
01EB2:  MOVLW  4E
01EB4:  SUBWF  03,W
01EB6:  BNZ   1EC4
01EB8:  MOVLW  1F
01EBA:  SUBWF  00,W
01EBC:  MOVLB  0
01EBE:  BTFSC  FD8.2
01EC0:  BRA    1F90
01EC2:  MOVLB  4
01EC4:  BRA    1FB8
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
01EC6:  MOVLB  4
01EC8:  MOVF   xDC,F
01ECA:  BNZ   1ED2
01ECC:  MOVF   xDB,W
01ECE:  SUBLW  80
01ED0:  BC    1ED8
01ED2:  MOVLW  03
01ED4:  MOVWF  01
01ED6:  BRA    1FC2
.................... 			config.modbus_address=value; 
01ED8:  MOVFF  4DB,36
.................... 			break; 
01EDC:  BRA    1FBE
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01EDE:  MOVLB  1
01EE0:  BSF    xAE.1
.................... 			config.adc_sample_ticks=value; 
01EE2:  MOVFF  4DC,3D
01EE6:  MOVFF  4DB,3C
.................... 			break; 
01EEA:  MOVLB  4
01EEC:  BRA    1FBE
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01EEE:  MOVLB  4
01EF0:  MOVF   xDC,F
01EF2:  BNZ   1EFA
01EF4:  MOVF   xDB,W
01EF6:  SUBLW  01
01EF8:  BC    1F00
01EFA:  MOVLW  03
01EFC:  MOVWF  01
01EFE:  BRA    1FC2
.................... 			config.allow_bootload_request=value; 
01F00:  MOVFF  4DB,3E
.................... 			break; 
01F04:  BRA    1FBE
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01F06:  MOVFF  4DC,40
01F0A:  MOVFF  4DB,3F
.................... 			break; 
01F0E:  MOVLB  4
01F10:  BRA    1FBE
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01F12:  MOVLB  4
01F14:  MOVF   xDB,F
01F16:  BNZ   1F22
01F18:  MOVF   xDC,F
01F1A:  BNZ   1F22
01F1C:  MOVLW  03
01F1E:  MOVWF  01
01F20:  BRA    1FC2
.................... 			config.pi_offtime_seconds=value; 
01F22:  MOVFF  4DC,42
01F26:  MOVFF  4DB,41
.................... 			break; 
01F2A:  BRA    1FBE
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01F2C:  MOVLB  4
01F2E:  MOVF   xDC,F
01F30:  BNZ   1F38
01F32:  MOVF   xDB,W
01F34:  SUBLW  01
01F36:  BC    1F3E
01F38:  MOVLW  03
01F3A:  MOVWF  01
01F3C:  BRA    1FC2
.................... 			config.power_startup=value; 
01F3E:  MOVFF  4DB,43
.................... 			break; 
01F42:  BRA    1FBE
....................  
.................... 		case 1012: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01F44:  MOVLB  4
01F46:  MOVF   xDC,F
01F48:  BNZ   1F50
01F4A:  MOVF   xDB,W
01F4C:  SUBLW  01
01F4E:  BC    1F56
01F50:  MOVLW  03
01F52:  MOVWF  01
01F54:  BRA    1FC2
.................... 			config.modbus_bridge=value; 
01F56:  MOVFF  4DB,38
.................... 			break; 
01F5A:  BRA    1FBE
.................... 		 
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01F5C:  MOVLB  4
01F5E:  DECFSZ xDB,W
01F60:  BRA    1F66
01F62:  MOVF   xDC,F
01F64:  BZ    1F6C
01F66:  MOVLW  03
01F68:  MOVWF  01
01F6A:  BRA    1FC2
.................... 			write_default_param_file(); 
01F6C:  MOVLB  0
01F6E:  CALL   0C1A
.................... 			break; 
01F72:  MOVLB  4
01F74:  BRA    1FBE
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01F76:  MOVLB  4
01F78:  DECFSZ xDB,W
01F7A:  BRA    1F80
01F7C:  MOVF   xDC,F
01F7E:  BZ    1F86
01F80:  MOVLW  03
01F82:  MOVWF  01
01F84:  BRA    1FC2
.................... 			write_param_file(); 
01F86:  MOVLB  0
01F88:  CALL   0BC6
.................... 			break; 
01F8C:  MOVLB  4
01F8E:  BRA    1FBE
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01F90:  MOVLB  4
01F92:  MOVF   xDB,W
01F94:  SUBLW  0A
01F96:  BNZ   1F9E
01F98:  MOVF   xDC,W
01F9A:  SUBLW  07
01F9C:  BZ    1FAA
.................... 				current.factory_unlocked=0; 
01F9E:  MOVLB  1
01FA0:  CLRF   x8F
.................... 				return ILLEGAL_DATA_VALUE; 
01FA2:  MOVLW  03
01FA4:  MOVWF  01
01FA6:  MOVLB  4
01FA8:  BRA    1FC2
.................... 			} 
.................... 			current.factory_unlocked=1; 
01FAA:  MOVLW  01
01FAC:  MOVLB  1
01FAE:  MOVWF  x8F
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01FB0:  MOVLW  C8
01FB2:  MOVWF  xAB
.................... 			break; 
01FB4:  MOVLB  4
01FB6:  BRA    1FBE
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01FB8:  MOVLW  02
01FBA:  MOVWF  01
01FBC:  BRA    1FC2
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01FBE:  MOVLW  00
01FC0:  MOVWF  01
.................... } 
01FC2:  MOVLB  0
01FC4:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02056:  GOTO   1082
0205A:  MOVF   01,F
0205C:  BTFSC  FD8.2
0205E:  BRA    2342
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( 1==config.modbus_bridge && modbus_rx.address!=config.modbus_address ) { 
02060:  DECFSZ 38,W
02062:  BRA    2116
02064:  MOVF   36,W
02066:  MOVLB  3
02068:  SUBWF  xBB,W
0206A:  BTFSS  FD8.2
0206C:  BRA    2072
0206E:  MOVLB  0
02070:  BRA    2116
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02072:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02074:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02076:  CLRWDT
02078:  MOVLW  02
0207A:  MOVLB  4
0207C:  MOVWF  xD3
0207E:  MOVLW  B5
02080:  MOVWF  xD4
02082:  MOVLB  0
02084:  CALL   10A8
02088:  MOVLB  4
0208A:  DECFSZ xD3,F
0208C:  BRA    207E
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
0208E:  MOVLB  3
02090:  MOVF   xBB,W
02092:  MOVLB  0
02094:  CALL   067E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02098:  CLRWDT
0209A:  MOVLW  67
0209C:  MOVWF  00
0209E:  DECFSZ 00,F
020A0:  BRA    209E
020A2:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
020A4:  MOVLB  3
020A6:  MOVF   xBD,W
020A8:  MOVLB  0
020AA:  CALL   067E
.................... 			delay_us(104); //one stop bit @ 9600 baud 
020AE:  CLRWDT
020B0:  MOVLW  67
020B2:  MOVWF  00
020B4:  DECFSZ 00,F
020B6:  BRA    20B4
020B8:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
020BA:  MOVLB  4
020BC:  CLRF   xD2
020BE:  MOVLW  02
020C0:  MOVLB  3
020C2:  ADDWF  xBC,W
020C4:  MOVLB  4
020C6:  SUBWF  xD2,W
020C8:  BC    20F6
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
020CA:  MOVLW  BF
020CC:  ADDWF  xD2,W
020CE:  MOVWF  FE9
020D0:  MOVLW  03
020D2:  MOVWF  FEA
020D4:  BTFSC  FD8.0
020D6:  INCF   FEA,F
020D8:  MOVFF  FEF,4D3
020DC:  MOVF   xD3,W
020DE:  MOVLB  0
020E0:  CALL   067E
.................... 				delay_us(104); //one stop bit @ 9600 baud 
020E4:  CLRWDT
020E6:  MOVLW  67
020E8:  MOVWF  00
020EA:  DECFSZ 00,F
020EC:  BRA    20EA
020EE:  NOP   
.................... 			} 
020F0:  MOVLB  4
020F2:  INCF   xD2,F
020F4:  BRA    20BE
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
020F6:  BTFSS  F72.1
020F8:  BRA    20F6
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
020FA:  CLRWDT
020FC:  MOVLW  02
020FE:  MOVWF  xD3
02100:  MOVLW  B5
02102:  MOVWF  xD4
02104:  MOVLB  0
02106:  CALL   10A8
0210A:  MOVLB  4
0210C:  DECFSZ xD3,F
0210E:  BRA    2100
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02110:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02112:  BCF    F8C.0
02114:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02116:  MOVF   36,W
02118:  SUBLW  80
0211A:  BZ    2128
0211C:  MOVF   36,W
0211E:  MOVLB  3
02120:  SUBWF  xBB,W
02122:  BTFSS  FD8.2
02124:  BRA    232C
02126:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02128:  MOVLB  1
0212A:  INCFSZ x83,W
0212C:  BRA    2134
0212E:  INCFSZ x84,W
02130:  BRA    2134
02132:  BRA    213A
.................... 				current.modbus_our_packets++; 
02134:  INCF   x83,F
02136:  BTFSC  FD8.2
02138:  INCF   x84,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
0213A:  MOVLW  14
0213C:  MOVWF  xAB
....................  
.................... 			switch(modbus_rx.func) { 
0213E:  MOVLB  3
02140:  MOVF   xBD,W
02142:  XORLW  03
02144:  MOVLB  0
02146:  BZ    2158
02148:  XORLW  07
0214A:  BZ    2158
0214C:  XORLW  02
0214E:  BZ    21D0
02150:  XORLW  16
02152:  BTFSC  FD8.2
02154:  BRA    2242
02156:  BRA    2304
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02158:  MOVFF  3BF,4CE
0215C:  MOVFF  3C0,4CD
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02160:  MOVFF  3C1,4D0
02164:  MOVFF  3C2,4CF
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02168:  MOVLB  4
0216A:  MOVF   xCF,W
0216C:  ADDWF  xCD,W
0216E:  MOVWF  xD3
02170:  MOVF   xD0,W
02172:  ADDWFC xCE,W
02174:  MOVWF  xD4
02176:  MOVFF  4CE,4D6
0217A:  MOVFF  4CD,4D5
0217E:  MOVWF  xD8
02180:  MOVFF  4D3,4D7
02184:  MOVLB  0
02186:  GOTO   10C8
0218A:  MOVF   01,F
0218C:  BNZ   21B2
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0218E:  MOVFF  3BB,4D3
02192:  MOVLB  4
02194:  CLRF   xD5
02196:  MOVFF  3BD,4D4
0219A:  MOVLW  02
0219C:  MOVWF  xD6
0219E:  MOVLB  0
021A0:  CALL   11E2
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
021A4:  MOVLB  1
021A6:  CLRF   x88
021A8:  MOVLW  02
021AA:  MOVWF  x87
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
021AC:  CLRF   xAB
.................... 					} else { 
021AE:  BRA    21CE
021B0:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
021B2:  MOVFF  3BD,4D3
021B6:  MOVFF  3BB,4D4
021BA:  MOVFF  4CE,4D6
021BE:  MOVFF  4CD,4D5
021C2:  MOVFF  4D0,4D8
021C6:  MOVFF  4CF,4D7
021CA:  BRA    1CD6
021CC:  MOVLB  1
.................... 					} 
.................... 					break; 
021CE:  BRA    2324
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
021D0:  MOVFF  3BF,4CE
021D4:  MOVFF  3C0,4CD
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
021D8:  MOVFF  3C1,4D4
021DC:  MOVFF  3C2,4D3
021E0:  MOVFF  4CE,4DA
021E4:  MOVFF  4CD,4D9
021E8:  MOVFF  3C1,4DC
021EC:  MOVFF  3C2,4DB
021F0:  RCALL  1D58
021F2:  MOVFF  01,4D1
....................  
.................... 					if ( result ) { 
021F6:  MOVLB  4
021F8:  MOVF   xD1,F
021FA:  BZ    221E
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
021FC:  MOVFF  3BB,4D3
02200:  CLRF   xD5
02202:  MOVFF  3BD,4D4
02206:  MOVFF  4D1,4D6
0220A:  MOVLB  0
0220C:  CALL   11E2
.................... 						current.modbus_last_error=result; 
02210:  MOVLB  1
02212:  CLRF   x88
02214:  MOVFF  4D1,187
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02218:  CLRF   xAB
.................... 					}  else { 
0221A:  BRA    2240
0221C:  MOVLB  4
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
0221E:  MOVFF  3C1,4D4
02222:  MOVFF  3C2,4D3
02226:  MOVFF  3BB,4D5
0222A:  MOVFF  4CE,4D7
0222E:  MOVFF  4CD,4D6
02232:  MOVFF  3C1,4D9
02236:  MOVFF  3C2,4D8
0223A:  MOVLB  0
0223C:  BRA    1FC6
0223E:  MOVLB  1
.................... 					} 
.................... 					break; 
02240:  BRA    2324
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02242:  MOVFF  3BF,4CE
02246:  MOVFF  3C0,4CD
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
0224A:  MOVFF  3C1,4D0
0224E:  MOVFF  3C2,4CF
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02252:  MOVLB  4
02254:  CLRF   xD2
02256:  MOVF   xD0,F
02258:  BNZ   2260
0225A:  MOVF   xCF,W
0225C:  SUBWF  xD2,W
0225E:  BC    22E4
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02260:  MOVF   xD2,W
02262:  ADDWF  xCD,W
02264:  MOVWF  xD3
02266:  MOVLW  00
02268:  ADDWFC xCE,W
0226A:  MOVWF  xD4
0226C:  BCF    FD8.0
0226E:  RLCF   xD2,W
02270:  ADDLW  05
02272:  ADDLW  BF
02274:  MOVWF  FE9
02276:  MOVLW  03
02278:  MOVWF  FEA
0227A:  BTFSC  FD8.0
0227C:  INCF   FEA,F
0227E:  MOVFF  FEF,4D5
02282:  BCF    FD8.0
02284:  RLCF   xD2,W
02286:  ADDLW  06
02288:  ADDLW  BF
0228A:  MOVWF  FE9
0228C:  MOVLW  03
0228E:  MOVWF  FEA
02290:  BTFSC  FD8.0
02292:  INCF   FEA,F
02294:  MOVFF  FEF,4D6
02298:  MOVFF  4D5,4D8
0229C:  MOVFF  4D6,4D7
022A0:  MOVFF  4D4,4DA
022A4:  MOVFF  4D3,4D9
022A8:  MOVFF  4D5,4DC
022AC:  MOVFF  4D6,4DB
022B0:  MOVLB  0
022B2:  RCALL  1D58
022B4:  MOVFF  01,4D1
....................  
.................... 						if ( result ) { 
022B8:  MOVLB  4
022BA:  MOVF   xD1,F
022BC:  BZ    22E0
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
022BE:  MOVFF  3BB,4D3
022C2:  CLRF   xD5
022C4:  MOVFF  3BD,4D4
022C8:  MOVFF  4D1,4D6
022CC:  MOVLB  0
022CE:  CALL   11E2
.................... 							current.modbus_last_error=result; 
022D2:  MOVLB  1
022D4:  CLRF   x88
022D6:  MOVFF  4D1,187
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
022DA:  CLRF   xAB
.................... 			 
.................... 							break; 
022DC:  MOVLB  4
022DE:  BRA    22E4
.................... 						} 
.................... 					} 
022E0:  INCF   xD2,F
022E2:  BRA    2256
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
022E4:  MOVF   xD1,F
022E6:  BNZ   2300
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
022E8:  MOVFF  3BB,4D3
022EC:  MOVFF  4CE,4D5
022F0:  MOVFF  4CD,4D4
022F4:  MOVFF  4D0,4D7
022F8:  MOVFF  4CF,4D6
022FC:  MOVLB  0
022FE:  BRA    200E
.................... 					} 
....................  
.................... 					break;   
02300:  MOVLB  1
02302:  BRA    2324
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02304:  MOVFF  3BB,4D3
02308:  MOVLB  4
0230A:  CLRF   xD5
0230C:  MOVFF  3BD,4D4
02310:  MOVLW  01
02312:  MOVWF  xD6
02314:  MOVLB  0
02316:  CALL   11E2
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
0231A:  MOVLB  1
0231C:  CLRF   x88
0231E:  MOVLW  01
02320:  MOVWF  x87
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02322:  CLRF   xAB
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02324:  CLRF   x92
02326:  CLRF   x91
....................  
.................... 		} else { 
02328:  BRA    2342
0232A:  MOVLB  3
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
0232C:  MOVLB  1
0232E:  INCFSZ x85,W
02330:  BRA    2338
02332:  INCFSZ x86,W
02334:  BRA    2338
02336:  BRA    233E
.................... 				current.modbus_other_packets++; 
02338:  INCF   x85,F
0233A:  BTFSC  FD8.2
0233C:  INCF   x86,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
0233E:  MOVLW  0A
02340:  MOVWF  xAB
02342:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02344:  GOTO   263C (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
003E2:  MOVLB  5
003E4:  BTFSS  xD4.0
003E6:  BRA    0400
003E8:  MOVLB  1
003EA:  INCFSZ x9A,W
003EC:  BRA    03F8
003EE:  INCFSZ x9B,W
003F0:  BRA    03F8
003F2:  MOVLB  5
003F4:  BRA    0400
003F6:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
003F8:  INCF   x9A,F
003FA:  BTFSC  FD8.2
003FC:  INCF   x9B,F
003FE:  MOVLB  5
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
00400:  BTFSS  xD4.2
00402:  BRA    041C
00404:  MOVLB  1
00406:  INCFSZ x9C,W
00408:  BRA    0414
0040A:  INCFSZ x9D,W
0040C:  BRA    0414
0040E:  MOVLB  5
00410:  BRA    041C
00412:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00414:  INCF   x9C,F
00416:  BTFSC  FD8.2
00418:  INCF   x9D,F
0041A:  MOVLB  5
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0041C:  BTFSS  xD4.4
0041E:  BRA    0438
00420:  MOVLB  1
00422:  INCFSZ x9E,W
00424:  BRA    0430
00426:  INCFSZ x9F,W
00428:  BRA    0430
0042A:  MOVLB  5
0042C:  BRA    0438
0042E:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
00430:  INCF   x9E,F
00432:  BTFSC  FD8.2
00434:  INCF   x9F,F
00436:  MOVLB  5
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
00438:  BCF    xD4.1
0043A:  BTFSC  F81.0
0043C:  BSF    xD4.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
0043E:  BTFSC  xD4.1
00440:  BRA    04C2
00442:  MOVLB  3
00444:  BTFSC  xB7.1
00446:  BRA    044C
00448:  MOVLB  5
0044A:  BRA    04C2
.................... 		current.pulse_count[0]++; 
0044C:  MOVLB  0
0044E:  INCF   x60,F
00450:  BTFSC  FD8.2
00452:  INCF   x61,F
.................... 		current.pulse_sum[0]++; 
00454:  MOVLW  01
00456:  ADDWF  x66,F
00458:  BTFSC  FD8.0
0045A:  INCF   x67,F
0045C:  BTFSC  FD8.2
0045E:  INCF   x68,F
00460:  BTFSC  FD8.2
00462:  INCF   x69,F
.................... 		if ( 1 == ext0_state ) { 
00464:  MOVLB  3
00466:  BTFSS  xB7.2
00468:  BRA    04B0
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0046A:  MOVLB  5
0046C:  BCF    xD4.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
0046E:  MOVFF  19B,4F
00472:  MOVFF  19A,4E
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
00476:  MOVF   4F,W
00478:  SUBWF  55,W
0047A:  BNC   048C
0047C:  BNZ   0484
0047E:  MOVF   54,W
00480:  SUBWF  4E,W
00482:  BC    048C
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00484:  MOVFF  4F,55
00488:  MOVFF  4E,54
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0048C:  MOVF   5B,W
0048E:  SUBWF  4F,W
00490:  BNC   04AC
00492:  BNZ   049A
00494:  MOVF   4E,W
00496:  SUBWF  5A,W
00498:  BC    04AC
0049A:  INCFSZ 4E,W
0049C:  BRA    04A4
0049E:  INCFSZ 4F,W
004A0:  BRA    04A4
004A2:  BRA    04AC
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
004A4:  MOVFF  4F,5B
004A8:  MOVFF  4E,5A
.................... 			} 
.................... 			ext0_state=0; 
004AC:  MOVLB  3
004AE:  BCF    xB7.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
004B0:  BTFSC  xB7.2
004B2:  BRA    04C2
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
004B4:  MOVLB  1
004B6:  CLRF   x9B
004B8:  CLRF   x9A
.................... 			ext0_count=1; 
004BA:  MOVLB  5
004BC:  BSF    xD4.0
.................... 			ext0_state=1; 
004BE:  MOVLB  3
004C0:  BSF    xB7.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
004C2:  MOVLB  3
004C4:  BCF    xB7.1
004C6:  MOVLB  5
004C8:  BTFSS  xD4.1
004CA:  BRA    04D2
004CC:  MOVLB  3
004CE:  BSF    xB7.1
004D0:  MOVLB  5
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
004D2:  BCF    xD4.3
004D4:  BTFSC  F81.1
004D6:  BSF    xD4.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
004D8:  BTFSC  xD4.3
004DA:  BRA    055C
004DC:  MOVLB  3
004DE:  BTFSC  xB7.3
004E0:  BRA    04E6
004E2:  MOVLB  5
004E4:  BRA    055C
.................... 		current.pulse_count[1]++; 
004E6:  MOVLB  0
004E8:  INCF   x62,F
004EA:  BTFSC  FD8.2
004EC:  INCF   x63,F
.................... 		current.pulse_sum[1]++; 
004EE:  MOVLW  01
004F0:  ADDWF  x6A,F
004F2:  BTFSC  FD8.0
004F4:  INCF   x6B,F
004F6:  BTFSC  FD8.2
004F8:  INCF   x6C,F
004FA:  BTFSC  FD8.2
004FC:  INCF   x6D,F
.................... 		if ( 1 == ext1_state ) { 
004FE:  MOVLB  3
00500:  BTFSS  xB7.4
00502:  BRA    054A
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00504:  MOVLB  5
00506:  BCF    xD4.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00508:  MOVFF  19D,51
0050C:  MOVFF  19C,50
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00510:  MOVF   51,W
00512:  SUBWF  57,W
00514:  BNC   0526
00516:  BNZ   051E
00518:  MOVF   56,W
0051A:  SUBWF  50,W
0051C:  BC    0526
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
0051E:  MOVFF  51,57
00522:  MOVFF  50,56
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
00526:  MOVF   5D,W
00528:  SUBWF  51,W
0052A:  BNC   0546
0052C:  BNZ   0534
0052E:  MOVF   50,W
00530:  SUBWF  5C,W
00532:  BC    0546
00534:  INCFSZ 50,W
00536:  BRA    053E
00538:  INCFSZ 51,W
0053A:  BRA    053E
0053C:  BRA    0546
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
0053E:  MOVFF  51,5D
00542:  MOVFF  50,5C
.................... 			} 
.................... 			ext1_state=0; 
00546:  MOVLB  3
00548:  BCF    xB7.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
0054A:  BTFSC  xB7.4
0054C:  BRA    055C
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
0054E:  MOVLB  1
00550:  CLRF   x9D
00552:  CLRF   x9C
.................... 			ext1_count=1; 
00554:  MOVLB  5
00556:  BSF    xD4.2
.................... 			ext1_state=1; 
00558:  MOVLB  3
0055A:  BSF    xB7.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
0055C:  MOVLB  3
0055E:  BCF    xB7.3
00560:  MOVLB  5
00562:  BTFSS  xD4.3
00564:  BRA    056C
00566:  MOVLB  3
00568:  BSF    xB7.3
0056A:  MOVLB  5
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0056C:  BCF    xD4.5
0056E:  BTFSC  F81.2
00570:  BSF    xD4.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00572:  BTFSC  xD4.5
00574:  BRA    05F6
00576:  MOVLB  3
00578:  BTFSC  xB7.5
0057A:  BRA    0580
0057C:  MOVLB  5
0057E:  BRA    05F6
.................... 		current.pulse_count[2]++; 
00580:  MOVLB  0
00582:  INCF   x64,F
00584:  BTFSC  FD8.2
00586:  INCF   x65,F
.................... 		current.pulse_sum[2]++; 
00588:  MOVLW  01
0058A:  ADDWF  x6E,F
0058C:  BTFSC  FD8.0
0058E:  INCF   x6F,F
00590:  BTFSC  FD8.2
00592:  INCF   x70,F
00594:  BTFSC  FD8.2
00596:  INCF   x71,F
.................... 		if ( 1 == ext2_state ) { 
00598:  MOVLB  3
0059A:  BTFSS  xB7.6
0059C:  BRA    05E4
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0059E:  MOVLB  5
005A0:  BCF    xD4.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
005A2:  MOVFF  19F,53
005A6:  MOVFF  19E,52
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
005AA:  MOVF   53,W
005AC:  SUBWF  59,W
005AE:  BNC   05C0
005B0:  BNZ   05B8
005B2:  MOVF   58,W
005B4:  SUBWF  52,W
005B6:  BC    05C0
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
005B8:  MOVFF  53,59
005BC:  MOVFF  52,58
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
005C0:  MOVF   5F,W
005C2:  SUBWF  53,W
005C4:  BNC   05E0
005C6:  BNZ   05CE
005C8:  MOVF   52,W
005CA:  SUBWF  5E,W
005CC:  BC    05E0
005CE:  INCFSZ 52,W
005D0:  BRA    05D8
005D2:  INCFSZ 53,W
005D4:  BRA    05D8
005D6:  BRA    05E0
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
005D8:  MOVFF  53,5F
005DC:  MOVFF  52,5E
.................... 			} 
.................... 			ext2_state=0; 
005E0:  MOVLB  3
005E2:  BCF    xB7.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
005E4:  BTFSC  xB7.6
005E6:  BRA    05F6
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
005E8:  MOVLB  1
005EA:  CLRF   x9F
005EC:  CLRF   x9E
.................... 			ext2_count=1; 
005EE:  MOVLB  5
005F0:  BSF    xD4.4
.................... 			ext2_state=1; 
005F2:  MOVLB  3
005F4:  BSF    xB7.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
005F6:  MOVLB  3
005F8:  BCF    xB7.5
005FA:  MOVLB  5
005FC:  BTFSS  xD4.5
005FE:  BRA    0606
00600:  MOVLB  3
00602:  BSF    xB7.5
00604:  MOVLB  5
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
00606:  MOVLB  4
00608:  INCF   xC2,F
.................... 	if ( 10 == tick ) { 
0060A:  MOVF   xC2,W
0060C:  SUBLW  0A
0060E:  BNZ   0618
.................... 		tick=0; 
00610:  CLRF   xC2
.................... 		timers.now_millisecond=1; 
00612:  MOVLB  1
00614:  BSF    xAE.2
00616:  MOVLB  4
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
00618:  BCF    F9E.1
0061A:  MOVLB  0
0061C:  GOTO   012E
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
00638:  BRA    0620
0063A:  MOVFF  01,5D1
....................  
.................... 	if ( config.modbus_bridge) { 
0063E:  MOVF   38,F
00640:  BZ    0662
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
00642:  MOVLB  3
00644:  CLRF   xB6
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
00646:  INCFSZ xB5,W
00648:  BRA    064C
0064A:  BRA    0660
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
0064C:  MOVLW  B5
0064E:  ADDWF  xB5,W
00650:  MOVWF  FE9
00652:  MOVLW  02
00654:  MOVWF  FEA
00656:  BTFSC  FD8.0
00658:  INCF   FEA,F
0065A:  MOVFF  5D1,FEF
.................... 			timers.rda2_buff_pos++; 
0065E:  INCF   xB5,F
00660:  MOVLB  0
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00662:  BCF    FA4.5
00664:  GOTO   0088
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
006B2:  RCALL  0668
006B4:  MOVFF  01,5D1
....................  
.................... 	if ( current.bridged_uarts ) { 
006B8:  MOVLB  1
006BA:  BTFSS  x90.0
006BC:  BRA    06C8
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,STREAM_RS485); 
006BE:  MOVLB  5
006C0:  MOVF   xD1,W
006C2:  MOVLB  0
006C4:  RCALL  067E
.................... 		return; 
006C6:  BRA    0722
.................... 	} 
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
006C8:  MOVLB  3
006CA:  BTFSC  xB7.0
006CC:  BRA    0724
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
006CE:  MOVF   xB8,F
006D0:  BNZ   06E2
.................... 			modbus_serial_crc.d = 0xFFFF; 
006D2:  SETF   xBA
006D4:  SETF   xB9
.................... 			modbus_rx.address = c; 
006D6:  MOVFF  5D1,3BB
.................... 			modbus_serial_state++; 
006DA:  INCF   xB8,F
.................... 			modbus_rx.len = 0; 
006DC:  CLRF   xBC
.................... 			modbus_rx.error=0; 
006DE:  CLRF   xBE
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
006E0:  BRA    0710
006E2:  DECFSZ xB8,W
006E4:  BRA    06EE
.................... 			modbus_rx.func = c; 
006E6:  MOVFF  5D1,3BD
.................... 			modbus_serial_state++; 
006EA:  INCF   xB8,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
006EC:  BRA    0710
006EE:  MOVF   xB8,W
006F0:  SUBLW  02
006F2:  BNZ   0710
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
006F4:  INCFSZ xBC,W
006F6:  BRA    06FC
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
006F8:  MOVLW  FE
006FA:  MOVWF  xBC
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
006FC:  MOVLW  BF
006FE:  ADDWF  xBC,W
00700:  MOVWF  FE9
00702:  MOVLW  03
00704:  MOVWF  FEA
00706:  BTFSC  FD8.0
00708:  INCF   FEA,F
0070A:  MOVFF  5D1,FEF
.................... 			modbus_rx.len++; 
0070E:  INCF   xBC,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00710:  MOVFF  5D1,5D2
00714:  MOVLB  0
00716:  RCALL  0686
.................... 		modbus_enable_timeout(TRUE); 
00718:  MOVLW  01
0071A:  MOVLB  5
0071C:  MOVWF  xD2
0071E:  MOVLB  0
00720:  RCALL  039C
00722:  MOVLB  3
.................... 	} 
.................... } 
....................  
....................  
....................  
00724:  BCF    F9E.5
00726:  MOVLB  0
00728:  GOTO   0088
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
00848:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
0084A:  MOVLW  08
0084C:  MOVWF  F61
0084E:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
00850:  MOVLW  00
00852:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
00854:  MOVLW  FF
00856:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00858:  MOVLW  92
0085A:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
0085C:  MOVLW  80
0085E:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00860:  BCF    F96.0
00862:  BCF    F96.1
00864:  BCF    F96.2
00866:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00868:  MOVLB  1
0086A:  CLRF   xAB
.................... 	timers.load_off_seconds=2; 
0086C:  CLRF   xAD
0086E:  MOVLW  02
00870:  MOVWF  xAC
.................... 	timers.now_adc_sample=0; 
00872:  BCF    xAE.0
.................... 	timers.now_adc_reset_count=0; 
00874:  BCF    xAE.1
.................... 	timers.now_millisecond=0; 
00876:  BCF    xAE.2
.................... 	timers.port_b=0b11111111; 
00878:  SETF   xAF
.................... 	timers.port_c=0b11111111; 
0087A:  SETF   xB0
....................  
.................... 	timers.rda_buff_pos=0; 
0087C:  MOVLB  2
0087E:  CLRF   xB2
.................... 	timers.rda_buff_gap=255; 
00880:  SETF   xB3
.................... 	timers.now_parse_rda=0; 
00882:  MOVLB  1
00884:  BCF    xB1.0
....................  
.................... 	timers.rda2_buff_pos=0; 
00886:  MOVLB  3
00888:  CLRF   xB5
.................... 	timers.rda2_buff_gap=255; 
0088A:  SETF   xB6
.................... 	timers.now_parse_rda2=0; 
0088C:  MOVLB  2
0088E:  BCF    xB4.0
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
00890:  MOVLB  4
00892:  CLRF   xCD
00894:  MOVF   xCD,W
00896:  SUBLW  02
00898:  BNC   0946
.................... 		current.pulse_period[i]=0; 
0089A:  CLRF   03
0089C:  MOVFF  4CD,02
008A0:  BCF    FD8.0
008A2:  RLCF   02,F
008A4:  RLCF   03,F
008A6:  MOVF   02,W
008A8:  ADDLW  4E
008AA:  MOVWF  FE9
008AC:  MOVLW  00
008AE:  ADDWFC 03,W
008B0:  MOVWF  FEA
008B2:  CLRF   FEC
008B4:  MOVF   FED,F
008B6:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
008B8:  CLRF   03
008BA:  MOVFF  4CD,02
008BE:  BCF    FD8.0
008C0:  RLCF   02,F
008C2:  RLCF   03,F
008C4:  MOVF   02,W
008C6:  ADDLW  54
008C8:  MOVWF  FE9
008CA:  MOVLW  00
008CC:  ADDWFC 03,W
008CE:  MOVWF  FEA
008D0:  SETF   FEC
008D2:  MOVF   FED,F
008D4:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
008D6:  CLRF   03
008D8:  MOVFF  4CD,02
008DC:  BCF    FD8.0
008DE:  RLCF   02,F
008E0:  RLCF   03,F
008E2:  MOVF   02,W
008E4:  ADDLW  5A
008E6:  MOVWF  FE9
008E8:  MOVLW  00
008EA:  ADDWFC 03,W
008EC:  MOVWF  FEA
008EE:  CLRF   FEC
008F0:  MOVF   FED,F
008F2:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
008F4:  CLRF   03
008F6:  MOVFF  4CD,02
008FA:  BCF    FD8.0
008FC:  RLCF   02,F
008FE:  RLCF   03,F
00900:  MOVF   02,W
00902:  ADDLW  60
00904:  MOVWF  FE9
00906:  MOVLW  00
00908:  ADDWFC 03,W
0090A:  MOVWF  FEA
0090C:  CLRF   FEC
0090E:  MOVF   FED,F
00910:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00912:  CLRF   xE8
00914:  MOVFF  4CD,4E7
00918:  CLRF   xEA
0091A:  MOVLW  04
0091C:  MOVWF  xE9
0091E:  MOVLB  0
00920:  RCALL  0826
00922:  MOVF   01,W
00924:  ADDLW  66
00926:  MOVWF  FE9
00928:  MOVLW  00
0092A:  ADDWFC 02,W
0092C:  MOVWF  FEA
0092E:  MOVF   FEE,F
00930:  MOVF   FEE,F
00932:  CLRF   FEC
00934:  MOVF   FED,F
00936:  CLRF   FEF
00938:  MOVF   FED,F
0093A:  CLRF   FEF
0093C:  MOVF   FED,F
0093E:  CLRF   FEF
.................... 	} 
00940:  MOVLB  4
00942:  INCF   xCD,F
00944:  BRA    0894
....................  
.................... 	current.modbus_our_packets=0; 
00946:  MOVLB  1
00948:  CLRF   x84
0094A:  CLRF   x83
.................... 	current.modbus_other_packets=0; 
0094C:  CLRF   x86
0094E:  CLRF   x85
.................... 	current.modbus_last_error=0; 
00950:  CLRF   x88
00952:  CLRF   x87
.................... 	current.sequence_number=0; 
00954:  CLRF   x8A
00956:  CLRF   x89
.................... 	current.uptime_minutes=0; 
00958:  CLRF   x8C
0095A:  CLRF   x8B
.................... 	current.interval_milliseconds=0; 
0095C:  CLRF   x8E
0095E:  CLRF   x8D
.................... 	current.adc_buffer_index=0; 
00960:  CLRF   x82
.................... 	current.factory_unlocked=0; 
00962:  CLRF   x8F
.................... 	current.bridged_uarts=0; 
00964:  BCF    x90.0
.................... 	current.watchdog_seconds=0; 
00966:  CLRF   x92
00968:  CLRF   x91
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
0096A:  MOVFF  4B,195
0096E:  MOVFF  4A,194
.................... 	current.power_off_delay=config.power_off_below_delay; 
00972:  MOVFF  47,197
00976:  MOVFF  46,196
.................... 	current.power_override_timeout=0; 
0097A:  CLRF   x99
0097C:  CLRF   x98
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
0097E:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
00980:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
00982:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00984:  MOVLW  00
00986:  IORLW  05
00988:  MOVWF  FBA
0098A:  MOVLW  4A
0098C:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
0098E:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00990:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00992:  MOVLB  0
00994:  GOTO   2450 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00EEC:  MOVLB  1
00EEE:  BCF    xAE.2
....................  
.................... //	fputc('.',STREAM_RS485); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(STREAM_RS485,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00EF0:  BCF    FD8.0
00EF2:  MOVLB  4
00EF4:  RLCF   xC8,W
00EF6:  MOVWF  xCD
00EF8:  RLCF   xC9,W
00EFA:  MOVWF  xCE
00EFC:  MOVLW  00
00EFE:  MOVLB  1
00F00:  BTFSS  xB0.5
00F02:  MOVLW  01
00F04:  MOVLB  4
00F06:  IORWF  xCD,F
00F08:  MOVFF  4CD,4C8
00F0C:  MOVF   xCE,W
00F0E:  IORLW  E0
00F10:  MOVWF  xC9
.................... 	if ( b2_state==0xf000) { 
00F12:  MOVF   xC8,F
00F14:  BNZ   0F1C
00F16:  MOVF   xC9,W
00F18:  SUBLW  F0
00F1A:  BNZ   0F1C
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00F1C:  MOVLB  1
00F1E:  INCFSZ x9A,W
00F20:  BRA    0F2A
00F22:  INCFSZ x9B,W
00F24:  BRA    0F2A
.................... 				current.pulse_period[0]=0; 
00F26:  CLRF   4F
00F28:  CLRF   4E
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00F2A:  INCFSZ x9C,W
00F2C:  BRA    0F36
00F2E:  INCFSZ x9D,W
00F30:  BRA    0F36
.................... 				current.pulse_period[1]=0; 
00F32:  CLRF   51
00F34:  CLRF   50
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00F36:  INCFSZ x9E,W
00F38:  BRA    0F42
00F3A:  INCFSZ x9F,W
00F3C:  BRA    0F42
.................... 				current.pulse_period[2]=0; 
00F3E:  CLRF   53
00F40:  CLRF   52
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00F42:  MOVFF  F81,1AF
.................... 	timers.port_c=port_c; 
00F46:  MOVFF  F82,1B0
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00F4A:  BTFSS  x90.0
00F4C:  BRA    0F52
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00F4E:  BSF    F89.3
.................... 	} else { 
00F50:  BRA    0F5E
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00F52:  MOVF   xAB,F
00F54:  BNZ   0F5A
.................... 			output_low(LED_GREEN); 
00F56:  BCF    F89.3
.................... 		} else { 
00F58:  BRA    0F5E
.................... 			output_high(LED_GREEN); 
00F5A:  BSF    F89.3
.................... 			timers.led_on_green--; 
00F5C:  DECF   xAB,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00F5E:  INCFSZ x8D,W
00F60:  BRA    0F68
00F62:  INCFSZ x8E,W
00F64:  BRA    0F68
00F66:  BRA    0F6E
.................... 		current.interval_milliseconds++; 
00F68:  INCF   x8D,F
00F6A:  BTFSC  FD8.2
00F6C:  INCF   x8E,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00F6E:  MOVLB  4
00F70:  INCF   xC6,F
00F72:  BTFSC  FD8.2
00F74:  INCF   xC7,F
.................... 	if ( 1000 == ticks ) { 
00F76:  MOVF   xC6,W
00F78:  SUBLW  E8
00F7A:  BNZ   1000
00F7C:  MOVF   xC7,W
00F7E:  SUBLW  03
00F80:  BNZ   1000
.................... 		ticks=0; 
00F82:  CLRF   xC7
00F84:  CLRF   xC6
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00F86:  MOVLB  1
00F88:  INCFSZ x91,W
00F8A:  BRA    0F92
00F8C:  INCFSZ x92,W
00F8E:  BRA    0F92
00F90:  BRA    0F98
.................... 			current.watchdog_seconds++; 
00F92:  INCF   x91,F
00F94:  BTFSC  FD8.2
00F96:  INCF   x92,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
00F98:  MOVF   3F,F
00F9A:  BNZ   0FA0
00F9C:  MOVF   40,F
00F9E:  BZ    0FBE
00FA0:  MOVF   40,W
00FA2:  SUBWF  x92,W
00FA4:  BNC   0FBE
00FA6:  BNZ   0FAE
00FA8:  MOVF   x91,W
00FAA:  SUBWF  3F,W
00FAC:  BC    0FBE
00FAE:  MOVF   xAC,F
00FB0:  BNZ   0FBE
00FB2:  MOVF   xAD,F
00FB4:  BNZ   0FBE
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
00FB6:  MOVFF  42,1AD
00FBA:  MOVFF  41,1AC
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
00FBE:  MOVF   xAC,F
00FC0:  BNZ   0FCA
00FC2:  MOVF   xAD,F
00FC4:  BNZ   0FCA
.................... 			output_high(PI_POWER_EN); 
00FC6:  BSF    F8B.0
.................... 		} else { 
00FC8:  BRA    0FE0
.................... 			output_low(PI_POWER_EN); 
00FCA:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
00FCC:  MOVF   xAC,W
00FCE:  BTFSC  FD8.2
00FD0:  DECF   xAD,F
00FD2:  DECF   xAC,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
00FD4:  MOVF   xAC,F
00FD6:  BNZ   0FE0
00FD8:  MOVF   xAD,F
00FDA:  BNZ   0FE0
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
00FDC:  CLRF   x92
00FDE:  CLRF   x91
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
00FE0:  MOVLB  4
00FE2:  INCF   xC3,F
.................... 		if ( 60 == uptimeTicks ) { 
00FE4:  MOVF   xC3,W
00FE6:  SUBLW  3C
00FE8:  BNZ   1000
.................... 			uptimeTicks=0; 
00FEA:  CLRF   xC3
.................... 			if ( current.uptime_minutes < 65535 )  
00FEC:  MOVLB  1
00FEE:  INCFSZ x8B,W
00FF0:  BRA    0FF8
00FF2:  INCFSZ x8C,W
00FF4:  BRA    0FF8
00FF6:  BRA    0FFE
.................... 				current.uptime_minutes++; 
00FF8:  INCF   x8B,F
00FFA:  BTFSC  FD8.2
00FFC:  INCF   x8C,F
00FFE:  MOVLB  4
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
01000:  INCFSZ xCA,W
01002:  BRA    1016
01004:  INCFSZ xCB,W
01006:  BRA    1016
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
01008:  CLRF   xE1
0100A:  MOVLB  0
0100C:  RCALL  0E64
0100E:  MOVFF  02,4CB
01012:  MOVFF  01,4CA
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
01016:  MOVLB  1
01018:  BTFSS  xAE.1
0101A:  BRA    1024
.................... 		timers.now_adc_reset_count=0; 
0101C:  BCF    xAE.1
.................... 		adcTicks=0; 
0101E:  MOVLB  4
01020:  CLRF   xC5
01022:  CLRF   xC4
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01024:  MOVLB  4
01026:  INCF   xC4,F
01028:  BTFSC  FD8.2
0102A:  INCF   xC5,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
0102C:  MOVF   3C,W
0102E:  SUBWF  xC4,W
01030:  BNZ   1046
01032:  MOVF   3D,W
01034:  SUBWF  xC5,W
01036:  BNZ   1046
.................... 		adcTicks=0; 
01038:  CLRF   xC5
0103A:  CLRF   xC4
.................... 		timers.now_adc_sample=1; 
0103C:  MOVLB  1
0103E:  BSF    xAE.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
01040:  MOVLB  4
01042:  SETF   xCB
01044:  SETF   xCA
.................... 	} 
....................  
.................... 	/* for xbee */		 
.................... 	if ( timers.rda_buff_gap < 255 ) { 
01046:  MOVLB  2
01048:  INCFSZ xB3,W
0104A:  BRA    104E
0104C:  BRA    1050
.................... 		timers.rda_buff_gap++; 
0104E:  INCF   xB3,F
.................... 	} 
.................... 	/* for bluetooth */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01050:  MOVLB  3
01052:  INCFSZ xB6,W
01054:  BRA    1058
01056:  BRA    105A
.................... 		timers.rda2_buff_gap++; 
01058:  INCF   xB6,F
.................... 	} 
....................  
.................... 	/* xbee: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda_buff_gap >= 3 && timers.rda_buff_pos>0 ) { 
0105A:  MOVLB  2
0105C:  MOVF   xB3,W
0105E:  SUBLW  02
01060:  BC    106A
01062:  MOVF   xB2,F
01064:  BZ    106A
.................... 		timers.now_parse_rda=1;	 
01066:  MOVLB  1
01068:  BSF    xB1.0
.................... 	} 
.................... 	/* bluetooth: if we have data and we have >=3 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 3 && timers.rda2_buff_pos>0 ) { 
0106A:  MOVLB  3
0106C:  MOVF   xB6,W
0106E:  SUBLW  02
01070:  BC    107C
01072:  MOVF   xB5,F
01074:  BZ    107C
.................... 		timers.now_parse_rda2=1;	 
01076:  MOVLB  2
01078:  BSF    xB4.0
0107A:  MOVLB  3
.................... 	} 
.................... } 
0107C:  MOVLB  0
0107E:  GOTO   262A (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
*
02348:  MOVFF  3B5,5CD
.................... 	timers.rda2_buff_pos=255; /* stop getting more data for a second */ 
0234C:  MOVLB  3
0234E:  SETF   xB5
.................... 	memcpy(buff,timers.rda2_buff,length); 
02350:  MOVLW  04
02352:  MOVWF  FEA
02354:  MOVLW  CD
02356:  MOVWF  FE9
02358:  MOVLW  02
0235A:  MOVWF  FE2
0235C:  MOVLW  B5
0235E:  MOVWF  FE1
02360:  MOVLB  5
02362:  MOVF   xCD,W
02364:  MOVWF  01
02366:  BZ    2370
02368:  MOVFF  FE6,FEE
0236C:  DECFSZ 01,F
0236E:  BRA    2368
.................... 	timers.rda2_buff_gap=0; 
02370:  MOVLB  3
02372:  CLRF   xB6
.................... 	timers.rda2_buff_pos=0; 
02374:  CLRF   xB5
....................  
.................... 	/* transmit back out to the PI */ 
.................... 	for ( l=0 ; l<length ; l++ ) { 
02376:  MOVLB  5
02378:  CLRF   xCF
0237A:  CLRF   xCE
0237C:  MOVF   xCF,F
0237E:  BNZ   23A8
02380:  MOVF   xCD,W
02382:  SUBWF  xCE,W
02384:  BC    23A8
.................... 		fputc(buff[l],STREAM_PI); 
02386:  MOVLW  CD
02388:  ADDWF  xCE,W
0238A:  MOVWF  FE9
0238C:  MOVLW  04
0238E:  ADDWFC xCF,W
02390:  MOVWF  FEA
02392:  MOVFF  FEF,5D0
02396:  MOVF   xD0,W
02398:  MOVLB  0
0239A:  CALL   114A
.................... 	} 
0239E:  MOVLB  5
023A0:  INCF   xCE,F
023A2:  BTFSC  FD8.2
023A4:  INCF   xCF,F
023A6:  BRA    237C
.................... } 
023A8:  MOVLB  0
023AA:  GOTO   2648 (RETURN)
....................  
....................  
.................... void main(void) { 
023AE:  CLRF   FF8
023B0:  BCF    FF1.2
023B2:  BSF    F9F.1
023B4:  BCF    F9F.5
023B6:  BCF    FA5.5
023B8:  BSF    FD0.7
023BA:  BSF    07.7
023BC:  CLRF   FEA
023BE:  CLRF   FE9
023C0:  CLRF   35
023C2:  BCF    FB8.3
023C4:  MOVLW  0C
023C6:  MOVWF  FAF
023C8:  MOVLW  A6
023CA:  MOVWF  FAC
023CC:  MOVLW  90
023CE:  MOVWF  FAB
023D0:  BCF    F70.3
023D2:  MOVLW  4D
023D4:  MOVWF  F75
023D6:  MOVLW  A6
023D8:  MOVWF  F72
023DA:  MOVLW  90
023DC:  MOVWF  F71
023DE:  MOVLB  3
023E0:  BCF    xB7.0
023E2:  CLRF   xB8
023E4:  MOVLB  4
023E6:  CLRF   xC2
023E8:  MOVLB  3
023EA:  BCF    xB7.1
023EC:  BCF    xB7.2
023EE:  BCF    xB7.3
023F0:  BCF    xB7.4
023F2:  BCF    xB7.5
023F4:  BCF    xB7.6
023F6:  MOVLB  4
023F8:  CLRF   xC3
023FA:  CLRF   xC5
023FC:  CLRF   xC4
023FE:  CLRF   xC7
02400:  CLRF   xC6
02402:  CLRF   xC9
02404:  CLRF   xC8
02406:  MOVF   FC1,W
02408:  ANDLW  F0
0240A:  MOVWF  FC1
0240C:  MOVLW  00
0240E:  MOVLB  F
02410:  MOVWF  x38
02412:  MOVWF  x3C
02414:  MOVWF  x39
02416:  MOVWF  x3A
02418:  MOVWF  x3B
0241A:  MOVLB  1
0241C:  CLRF   x88
0241E:  CLRF   F77
02420:  CLRF   F78
02422:  CLRF   F79
02424:  CLRF   2F
02426:  CLRF   30
02428:  MOVLB  4
0242A:  CLRF   xBE
0242C:  CLRF   xBF
0242E:  CLRF   xC0
02430:  CLRF   xC1
02432:  CLRF   xCA
02434:  CLRF   xCB
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
02436:  MOVF   FD0,W
02438:  ANDLW  0F
0243A:  BTFSS  FD0.4
0243C:  MOVLW  00
0243E:  BSF    FD0.0
02440:  BSF    FD0.1
02442:  BSF    FD0.4
02444:  BSF    FD8.3
02446:  BSF    FD8.4
02448:  MOVWF  xCC
....................  
.................... 	init(); 
0244A:  MOVLB  0
0244C:  GOTO   0848
....................  
....................  
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
02450:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
02452:  BSF    F8C.0
....................  
.................... #if 1 
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
02454:  MOVLW  2C
02456:  MOVWF  FF6
02458:  MOVLW  07
0245A:  MOVWF  FF7
0245C:  MOVLW  07
0245E:  MOVLB  4
02460:  MOVWF  xCD
02462:  MOVLB  0
02464:  CALL   0998
02468:  MOVLW  38
0246A:  MOVWF  FF6
0246C:  MOVLW  07
0246E:  MOVWF  FF7
02470:  CALL   09C2
02474:  MOVLW  0D
02476:  BTFSS  FA4.4
02478:  BRA    2476
0247A:  MOVWF  F73
0247C:  MOVLW  0A
0247E:  BTFSS  FA4.4
02480:  BRA    247E
02482:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
02484:  MOVLW  42
02486:  MOVWF  FF6
02488:  MOVLW  07
0248A:  MOVWF  FF7
0248C:  MOVLW  12
0248E:  MOVLB  4
02490:  MOVWF  xCD
02492:  MOVLB  0
02494:  CALL   0998
02498:  MOVFF  4CC,4CD
0249C:  MOVLW  1B
0249E:  MOVLB  4
024A0:  MOVWF  xCE
024A2:  MOVLB  0
024A4:  CALL   0A10
024A8:  MOVLW  20
024AA:  BTFSS  FA4.4
024AC:  BRA    24AA
024AE:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
024B0:  MOVLB  4
024B2:  MOVF   xCC,W
024B4:  XORLW  07
024B6:  MOVLB  0
024B8:  BZ    24D4
024BA:  XORLW  0C
024BC:  BZ    24E2
024BE:  XORLW  04
024C0:  BZ    24F0
024C2:  XORLW  03
024C4:  BZ    24FE
024C6:  XORLW  02
024C8:  BZ    250C
024CA:  XORLW  0D
024CC:  BZ    251A
024CE:  XORLW  03
024D0:  BZ    2528
024D2:  BRA    2536
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
024D4:  MOVLW  58
024D6:  MOVWF  FF6
024D8:  MOVLW  07
024DA:  MOVWF  FF7
024DC:  CALL   09C2
024E0:  BRA    2542
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
024E2:  MOVLW  64
024E4:  MOVWF  FF6
024E6:  MOVLW  07
024E8:  MOVWF  FF7
024EA:  CALL   09C2
024EE:  BRA    2542
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
024F0:  MOVLW  74
024F2:  MOVWF  FF6
024F4:  MOVLW  07
024F6:  MOVWF  FF7
024F8:  CALL   09C2
024FC:  BRA    2542
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
024FE:  MOVLW  82
02500:  MOVWF  FF6
02502:  MOVLW  07
02504:  MOVWF  FF7
02506:  CALL   09C2
0250A:  BRA    2542
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
0250C:  MOVLW  92
0250E:  MOVWF  FF6
02510:  MOVLW  07
02512:  MOVWF  FF7
02514:  CALL   09C2
02518:  BRA    2542
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
0251A:  MOVLW  A4
0251C:  MOVWF  FF6
0251E:  MOVLW  07
02520:  MOVWF  FF7
02522:  CALL   09C2
02526:  BRA    2542
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
02528:  MOVLW  B4
0252A:  MOVWF  FF6
0252C:  MOVLW  07
0252E:  MOVWF  FF7
02530:  CALL   09C2
02534:  BRA    2542
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
02536:  MOVLW  C6
02538:  MOVWF  FF6
0253A:  MOVLW  07
0253C:  MOVWF  FF7
0253E:  CALL   09C2
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
02542:  MOVLW  D0
02544:  MOVWF  FF6
02546:  MOVLW  07
02548:  MOVWF  FF7
0254A:  CALL   09C2
.................... #endif 
....................  
.................... //	fprintf(STREAM_RS485,"# read_param_file() starting ..."); 
.................... 	read_param_file(); 
0254E:  GOTO   0C52
.................... fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
02552:  MOVLW  D4
02554:  MOVWF  FF6
02556:  MOVLW  07
02558:  MOVWF  FF7
0255A:  MOVLW  18
0255C:  MOVLB  4
0255E:  MOVWF  xCD
02560:  MOVLB  0
02562:  CALL   0998
02566:  MOVFF  36,4CD
0256A:  MOVLW  1B
0256C:  MOVLB  4
0256E:  MOVWF  xCE
02570:  MOVLB  0
02572:  CALL   0A10
02576:  MOVLW  0D
02578:  BTFSS  FA4.4
0257A:  BRA    2578
0257C:  MOVWF  F73
0257E:  MOVLW  0A
02580:  BTFSS  FA4.4
02582:  BRA    2580
02584:  MOVWF  F73
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
02586:  MOVF   36,W
02588:  SUBLW  80
0258A:  BC    2590
.................... //		fprintf(STREAM_RS485,"# write_default_param_file() starting ..."); 
.................... 		write_default_param_file(); 
0258C:  CALL   0C1A
.................... //		fprintf(STREAM_RS485," complete\r\n"); 
.................... 	} 
.................... 	fprintf(STREAM_RS485,"# config.modbus_address=%u\r\n",config.modbus_address); 
02590:  MOVLW  F2
02592:  MOVWF  FF6
02594:  MOVLW  07
02596:  MOVWF  FF7
02598:  MOVLW  18
0259A:  MOVLB  4
0259C:  MOVWF  xCD
0259E:  MOVLB  0
025A0:  CALL   0998
025A4:  MOVFF  36,4CD
025A8:  MOVLW  1B
025AA:  MOVLB  4
025AC:  MOVWF  xCE
025AE:  MOVLB  0
025B0:  CALL   0A10
025B4:  MOVLW  0D
025B6:  BTFSS  FA4.4
025B8:  BRA    25B6
025BA:  MOVWF  F73
025BC:  MOVLW  0A
025BE:  BTFSS  FA4.4
025C0:  BRA    25BE
025C2:  MOVWF  F73
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
025C4:  BSF    FAB.7
025C6:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	fprintf(STREAM_RS485,"# modbus_init() starting ..."); 
.................... 	modbus_init(); 
025C8:  GOTO   0CB0
.................... //	fprintf(STREAM_RS485," complete\r\n"); 
....................  
.................... //	fprintf(STREAM_RS485,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
025CC:  MOVLB  4
025CE:  CLRF   xCC
025D0:  MOVF   xCC,W
025D2:  SUBLW  1D
025D4:  BNC   25E2
.................... 		adc_update(); 
025D6:  MOVLB  0
025D8:  CALL   0D6E
.................... 	} 
025DC:  MOVLB  4
025DE:  INCF   xCC,F
025E0:  BRA    25D0
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
025E2:  MOVFF  43,193
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
025E6:  BTFSS  F72.1
025E8:  BRA    25E6
.................... 	output_low(RS485_DE); 
025EA:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
025EC:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
025EE:  MOVLW  10
025F0:  MOVWF  FF6
025F2:  MOVLW  08
025F4:  MOVWF  FF7
025F6:  MOVLW  07
025F8:  MOVWF  xCD
025FA:  MOVLB  0
025FC:  GOTO   0E14
02600:  MOVLW  1C
02602:  MOVWF  FF6
02604:  MOVLW  08
02606:  MOVWF  FF7
02608:  GOTO   0E40
0260C:  MOVLW  0D
0260E:  BTFSS  F9E.4
02610:  BRA    260E
02612:  MOVWF  FAD
02614:  MOVLW  0A
02616:  BTFSS  F9E.4
02618:  BRA    2616
0261A:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
0261C:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(STREAM_RS485) ) { 
.................... 				fputc(fgetc(STREAM_RS485),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
0261E:  MOVLB  1
02620:  BTFSS  xAE.2
02622:  BRA    262C
.................... 			periodic_millisecond(); 
02624:  MOVLB  0
02626:  GOTO   0EEC
0262A:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
0262C:  BTFSS  xAE.0
0262E:  BRA    2638
.................... 			timers.now_adc_sample=0; 
02630:  BCF    xAE.0
.................... 			adc_update(); 
02632:  MOVLB  0
02634:  CALL   0D6E
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
02638:  MOVLB  0
0263A:  BRA    2056
.................... //		} 
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
0263C:  MOVLB  2
0263E:  BTFSS  xB4.0
02640:  BRA    264A
.................... 			timers.now_parse_rda2=0; 
02642:  BCF    xB4.0
.................... 			rs485_to_host(); 
02644:  MOVLB  0
02646:  BRA    2348
02648:  MOVLB  2
.................... 		} 
....................  
.................... 	} 
0264A:  MOVLB  0
0264C:  BRA    261C
.................... } 
0264E:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
