CCS PCH C Compiler, Version 4.135, 4375               13-Dec-15 13:34

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 13174 bytes (20%)
                         Largest free fragment is 52358
               RAM used: 2300 (59%) at main() level
                         2581 (66%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   3112
*
00008:  GOTO   00E2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   042E
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   07C2
0007C:  BTFSS  F9D.4
0007E:  GOTO   0088
00082:  BTFSC  F9E.4
00084:  GOTO   074C
00088:  BTFSS  FA3.5
0008A:  GOTO   0094
0008E:  BTFSC  FA4.5
00090:  GOTO   06BC
00094:  MOVFF  0E,00
00098:  MOVFF  0F,01
0009C:  MOVFF  10,02
000A0:  MOVFF  11,03
000A4:  MOVFF  0C,FE9
000A8:  MOVFF  07,FEA
000AC:  BSF    07.7
000AE:  MOVFF  08,FE1
000B2:  MOVFF  09,FE2
000B6:  MOVFF  0A,FD9
000BA:  MOVFF  0B,FDA
000BE:  MOVFF  12,FF3
000C2:  MOVFF  13,FF4
000C6:  MOVFF  14,FFA
000CA:  MOVFF  15,FF5
000CE:  MOVFF  16,FF6
000D2:  MOVFF  17,FF7
000D6:  MOVF   04,W
000D8:  MOVFF  06,FE0
000DC:  MOVFF  05,FD8
000E0:  RETFIE 0
000E2:  MOVWF  1A
000E4:  MOVFF  FD8,1B
000E8:  MOVFF  FE0,1C
000EC:  MOVLB  0
000EE:  MOVFF  FE9,22
000F2:  MOVFF  FEA,1D
000F6:  MOVFF  FE1,1E
000FA:  MOVFF  FE2,1F
000FE:  MOVFF  FD9,20
00102:  MOVFF  FDA,21
00106:  MOVFF  FF3,28
0010A:  MOVFF  FF4,29
0010E:  MOVFF  FFA,2A
00112:  MOVFF  FF5,2B
00116:  MOVFF  FF6,2C
0011A:  MOVFF  FF7,2D
0011E:  MOVFF  00,24
00122:  MOVFF  01,25
00126:  MOVFF  02,26
0012A:  MOVFF  03,27
0012E:  BTFSS  F9D.1
00130:  GOTO   013A
00134:  BTFSC  F9E.1
00136:  GOTO   0460
0013A:  MOVFF  24,00
0013E:  MOVFF  25,01
00142:  MOVFF  26,02
00146:  MOVFF  27,03
0014A:  MOVFF  22,FE9
0014E:  MOVFF  1D,FEA
00152:  BSF    1D.7
00154:  MOVFF  1E,FE1
00158:  MOVFF  1F,FE2
0015C:  MOVFF  20,FD9
00160:  MOVFF  21,FDA
00164:  MOVFF  28,FF3
00168:  MOVFF  29,FF4
0016C:  MOVFF  2A,FFA
00170:  MOVFF  2B,FF5
00174:  MOVFF  2C,FF6
00178:  MOVFF  2D,FF7
0017C:  MOVF   1A,W
0017E:  MOVFF  1C,FE0
00182:  MOVFF  1B,FD8
00186:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
02E66:  MOVLB  A
02E68:  MOVF   x06,F
02E6A:  BNZ   2E70
02E6C:  MOVF   x07,F
02E6E:  BZ    2EF4
....................       if (*s1 != *s2) 
02E70:  MOVFF  A02,FE9
02E74:  MOVFF  A03,FEA
02E78:  MOVFF  FEF,A08
02E7C:  MOVFF  A05,03
02E80:  MOVFF  A04,FE9
02E84:  MOVFF  A05,FEA
02E88:  MOVF   FEF,W
02E8A:  SUBWF  x08,W
02E8C:  BZ    2EBC
....................          return((*s1 <*s2) ? -1: 1); 
02E8E:  MOVFF  A03,03
02E92:  MOVFF  A02,FE9
02E96:  MOVFF  A03,FEA
02E9A:  MOVFF  FEF,A08
02E9E:  MOVFF  A05,03
02EA2:  MOVFF  A04,FE9
02EA6:  MOVFF  A05,FEA
02EAA:  MOVF   FEF,W
02EAC:  SUBWF  x08,W
02EAE:  BC    2EB4
02EB0:  MOVLW  FF
02EB2:  BRA    2EB6
02EB4:  MOVLW  01
02EB6:  MOVWF  01
02EB8:  BRA    2EF8
....................       else if (*s1 == '\0') 
02EBA:  BRA    2ED2
02EBC:  MOVFF  A03,03
02EC0:  MOVFF  A02,FE9
02EC4:  MOVFF  A03,FEA
02EC8:  MOVF   FEF,F
02ECA:  BNZ   2ED2
....................          return(0); 
02ECC:  MOVLW  00
02ECE:  MOVWF  01
02ED0:  BRA    2EF8
02ED2:  MOVFF  A03,03
02ED6:  MOVF   x02,W
02ED8:  INCF   x02,F
02EDA:  BTFSC  FD8.2
02EDC:  INCF   x03,F
02EDE:  MOVFF  A05,03
02EE2:  MOVF   x04,W
02EE4:  INCF   x04,F
02EE6:  BTFSC  FD8.2
02EE8:  INCF   x05,F
02EEA:  MOVF   x06,W
02EEC:  BTFSC  FD8.2
02EEE:  DECF   x07,F
02EF0:  DECF   x06,F
02EF2:  BRA    2E68
....................    return(0); 
02EF4:  MOVLW  00
02EF6:  MOVWF  01
.................... } 
02EF8:  MOVLB  0
02EFA:  GOTO   3064 (RETURN)
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
*
012E0:  MOVLW  05
012E2:  MOVLB  9
012E4:  SUBWF  x07,F
012E6:  BNC   12FC
012E8:  MOVLW  09
012EA:  MOVWF  FEA
012EC:  MOVLW  07
012EE:  MOVWF  FE9
012F0:  MOVF   FEF,W
012F2:  BZ    12FC
012F4:  BRA    12F8
012F6:  CLRWDT
012F8:  DECFSZ FEF,F
012FA:  BRA    12F6
012FC:  MOVLB  0
012FE:  RETURN 0
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=STREAM_PI,baud=57600,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
00744:  BTFSS  F9E.4
00746:  BRA    0744
00748:  MOVWF  FAD
0074A:  RETURN 0
*
00780:  BTFSS  F9E.5
00782:  BRA    0780
00784:  MOVFF  FAB,35
00788:  MOVFF  FAE,01
0078C:  BTFSS  35.1
0078E:  BRA    0794
00790:  BCF    FAB.4
00792:  BSF    FAB.4
00794:  RETURN 0
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=STREAM_RS485, baud=9600,errors)	 
*
006A4:  BTFSS  FA4.5
006A6:  BRA    06A4
006A8:  MOVFF  F71,35
006AC:  MOVFF  F74,01
006B0:  BTFSS  35.1
006B2:  BRA    06B8
006B4:  BCF    F71.4
006B6:  BSF    F71.4
006B8:  GOTO   06BE (RETURN)
*
01300:  BTFSS  FA4.4
01302:  BRA    1300
01304:  MOVWF  F73
01306:  RETURN 0
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define _PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... #define RS485_MODE_OFF           0 
.................... #define RS485_MODE_MODBUS_BRIDGE 1 
.................... #define RS485_MODE_NMEA0183_RX   2 
....................  
.................... #define RS485_SPEED_1200  0 
.................... #define RS485_SPEED_2400  1 
.................... #define RS485_SPEED_4800  2 
.................... #define RS485_SPEED_9600  3 
.................... #define RS485_SPEED_19200 4 
.................... #define RS485_SPEED_38400 5 
.................... #define RS485_SPEED_57600 6 
....................  
.................... #define N_NMEA0183_SENTENCES 12 
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 rs485_port_mode; 
.................... 	int8 rs485_port_speed; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* sentences we make available via modbus */ 
.................... 	int8 nmea0183_sentence[N_NMEA0183_SENTENCES][6]; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
....................  
.................... 	/* serial byte counters. Roll over */ 
.................... 	int16 rda_bytes_received; 
.................... 	int16 rda2_bytes_received; 
....................  
.................... 	/* push button on board */ 
.................... 	int8 button_state; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
....................  
.................... 	short now_parse_rda2; 
.................... 	int8 rda2_buff[256]; 
.................... 	int8 rda2_buff_pos; 
.................... 	int8 rda2_buff_gap; 
....................  
.................... 	/* transmit buffer for PIC to PI */ 
.................... 	int8 rda_tx_buff[256]; 
.................... 	int8 rda_tx_length; 
.................... 	int8 rda_tx_pos; 
.................... 	int1 now_rda_tx_ready; 
.................... 	int1 now_rda_tx_done; 
.................... } struct_time_keep; 
....................  
....................  
....................  
.................... #define NMEA_SENTENCE_LENGTH 80 
.................... typedef struct { 
.................... 	int8 sentence[N_NMEA0183_SENTENCES][NMEA_SENTENCE_LENGTH]; 
.................... 	int16 sentence_age[N_NMEA0183_SENTENCES]; 
.................... 	int8 sentence_length[N_NMEA0183_SENTENCES]; 
.................... } struct_nmea; 
....................  
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
.................... struct_nmea nmea; 
....................  
.................... /* declarations */ 
.................... void set_rs485_speed(void); 
....................  
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00FDE:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00F22:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00F24:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00F26:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00F28:  MOVLB  8
00F2A:  MOVF   xFF,F
00F2C:  BNZ   0F38
.................... 		c=0b00011; 
00F2E:  MOVLW  03
00F30:  MOVLB  9
00F32:  MOVWF  x03
.................... 	else if ( 1 == ch )  
00F34:  BRA    0F9A
00F36:  MOVLB  8
00F38:  DECFSZ xFF,W
00F3A:  BRA    0F46
.................... 		c=0b10011; 
00F3C:  MOVLW  13
00F3E:  MOVLB  9
00F40:  MOVWF  x03
.................... 	else if ( 2 == ch )  
00F42:  BRA    0F9A
00F44:  MOVLB  8
00F46:  MOVF   xFF,W
00F48:  SUBLW  02
00F4A:  BNZ   0F56
.................... 		c=0b01011; 
00F4C:  MOVLW  0B
00F4E:  MOVLB  9
00F50:  MOVWF  x03
.................... 	else if ( 3 == ch )  
00F52:  BRA    0F9A
00F54:  MOVLB  8
00F56:  MOVF   xFF,W
00F58:  SUBLW  03
00F5A:  BNZ   0F66
.................... 		c=0b11011; 
00F5C:  MOVLW  1B
00F5E:  MOVLB  9
00F60:  MOVWF  x03
.................... 	else if ( 4 == ch ) 
00F62:  BRA    0F9A
00F64:  MOVLB  8
00F66:  MOVF   xFF,W
00F68:  SUBLW  04
00F6A:  BNZ   0F76
.................... 		c=0b00111; 
00F6C:  MOVLW  07
00F6E:  MOVLB  9
00F70:  MOVWF  x03
.................... 	else if ( 5 == ch )  
00F72:  BRA    0F9A
00F74:  MOVLB  8
00F76:  MOVF   xFF,W
00F78:  SUBLW  05
00F7A:  BNZ   0F86
.................... 		c=0b10111; 
00F7C:  MOVLW  17
00F7E:  MOVLB  9
00F80:  MOVWF  x03
.................... 	else if ( 6 == ch ) 
00F82:  BRA    0F9A
00F84:  MOVLB  8
00F86:  MOVF   xFF,W
00F88:  SUBLW  06
00F8A:  BNZ   0F94
.................... 		c=0b01111; 
00F8C:  MOVLW  0F
00F8E:  MOVLB  9
00F90:  MOVWF  x03
.................... 	else 
00F92:  BRA    0F9A
.................... 		c=0b11111; 
00F94:  MOVLW  1F
00F96:  MOVLB  9
00F98:  MOVWF  x03
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00F9A:  CLRF   x02
00F9C:  MOVF   x02,W
00F9E:  SUBLW  04
00FA0:  BNC   0FB8
.................... 		output_low(MCP3208_CLK); 
00FA2:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00FA4:  BTFSC  x03.0
00FA6:  BRA    0FAC
00FA8:  BCF    F8B.5
00FAA:  BRA    0FAE
00FAC:  BSF    F8B.5
.................... 		c=c>>1; 
00FAE:  BCF    FD8.0
00FB0:  RRCF   x03,F
.................... 		output_high(MCP3208_CLK); 
00FB2:  BSF    F8B.3
.................... 	} 
00FB4:  INCF   x02,F
00FB6:  BRA    0F9C
....................  
....................  
.................... 	value=0; 
00FB8:  CLRF   x01
00FBA:  CLRF   x00
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00FBC:  CLRF   x02
00FBE:  MOVF   x02,W
00FC0:  SUBLW  0D
00FC2:  BNC   0FDA
.................... 		output_low(MCP3208_CLK); 
00FC4:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00FC6:  BTFSC  F82.4
00FC8:  BRA    0FCE
00FCA:  BCF    FD8.0
00FCC:  BRA    0FD0
00FCE:  BSF    FD8.0
00FD0:  RLCF   x00,F
00FD2:  RLCF   x01,F
.................... 		output_high(MCP3208_CLK); 
00FD4:  BSF    F8B.3
.................... 	} 
00FD6:  INCF   x02,F
00FD8:  BRA    0FBE
....................  
.................... 	bit_clear(value,13); 
00FDA:  BCF    x01.5
.................... 	bit_clear(value,12); 
00FDC:  BCF    x01.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00FE0:  MOVFF  900,01
00FE4:  MOVFF  901,02
.................... } 
00FE8:  MOVLB  0
00FEA:  GOTO   105C (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
01514:  MOVLB  A
01516:  CLRF   x01
01518:  MOVFF  918,A00
0151C:  CLRF   x03
0151E:  MOVLW  20
01520:  MOVWF  x02
01522:  MOVLB  0
01524:  CALL   08F4
01528:  MOVFF  02,03
0152C:  MOVF   01,W
0152E:  ADDLW  CB
01530:  MOVWF  01
01532:  MOVLW  00
01534:  ADDWFC 03,F
01536:  MOVFF  01,91C
0153A:  MOVLB  9
0153C:  MOVFF  03,91D
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
01540:  CLRF   x1A
01542:  CLRF   x19
.................... 	for( i = 0; i < 16 ; i++ ) { 
01544:  CLRF   x1B
01546:  MOVF   x1B,W
01548:  SUBLW  0F
0154A:  BNC   156E
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
0154C:  BCF    FD8.0
0154E:  RLCF   x1B,W
01550:  CLRF   03
01552:  ADDWF  x1C,W
01554:  MOVWF  FE9
01556:  MOVF   x1D,W
01558:  ADDWFC 03,W
0155A:  MOVWF  FEA
0155C:  MOVFF  FEC,03
01560:  MOVF   FED,F
01562:  MOVF   FEF,W
01564:  ADDWF  x19,F
01566:  MOVF   03,W
01568:  ADDWFC x1A,F
.................... 	} 
0156A:  INCF   x1B,F
0156C:  BRA    1546
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
0156E:  MOVLW  08
01570:  ADDWF  x19,W
01572:  MOVWF  x1E
01574:  MOVLW  00
01576:  ADDWFC x1A,W
01578:  MOVWF  x1F
0157A:  RRCF   x1F,W
0157C:  MOVWF  03
0157E:  RRCF   x1E,W
01580:  MOVWF  02
01582:  RRCF   03,F
01584:  RRCF   02,F
01586:  RRCF   03,F
01588:  RRCF   02,F
0158A:  RRCF   03,F
0158C:  RRCF   02,F
0158E:  MOVLW  0F
01590:  ANDWF  03,F
01592:  MOVFF  02,01
01596:  MOVFF  03,02
.................... } 
0159A:  MOVLB  0
0159C:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00FEE:  MOVLB  1
00FF0:  INCF   xCB,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00FF2:  MOVF   xCB,W
00FF4:  SUBLW  0F
00FF6:  BC    0FFA
.................... 		current.adc_buffer_index=0; 
00FF8:  CLRF   xCB
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00FFA:  MOVLB  8
00FFC:  CLRF   xFC
00FFE:  MOVF   xFC,W
01000:  SUBLW  07
01002:  BNC   1092
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
01004:  MOVLB  A
01006:  CLRF   x01
01008:  MOVFF  8FC,A00
0100C:  CLRF   x03
0100E:  MOVLW  20
01010:  MOVWF  x02
01012:  MOVLB  0
01014:  RCALL  08F4
01016:  MOVFF  02,03
0101A:  MOVF   01,W
0101C:  ADDLW  34
0101E:  MOVLB  8
01020:  MOVWF  xFD
01022:  MOVLW  00
01024:  ADDWFC 02,W
01026:  MOVWF  xFE
01028:  CLRF   03
0102A:  MOVLB  1
0102C:  MOVFF  1CB,02
01030:  BCF    FD8.0
01032:  RLCF   02,F
01034:  RLCF   03,F
01036:  MOVF   02,W
01038:  MOVLB  8
0103A:  ADDWF  xFD,W
0103C:  MOVWF  01
0103E:  MOVF   xFE,W
01040:  ADDWFC 03,F
01042:  MOVF   01,W
01044:  ADDLW  97
01046:  MOVWF  01
01048:  MOVLW  00
0104A:  ADDWFC 03,F
0104C:  MOVFF  01,8FD
01050:  MOVFF  03,8FE
01054:  MOVFF  8FC,8FF
01058:  MOVLB  0
0105A:  BRA    0F22
0105C:  MOVFF  8FE,FEA
01060:  MOVFF  8FD,FE9
01064:  MOVFF  02,FEC
01068:  MOVF   FED,F
0106A:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
0106E:  CLRF   03
01070:  MOVLB  8
01072:  MOVFF  8FC,02
01076:  BCF    FD8.0
01078:  RLCF   02,F
0107A:  RLCF   03,F
0107C:  MOVF   02,W
0107E:  ADDLW  BB
01080:  MOVWF  FE9
01082:  MOVLW  00
01084:  ADDWFC 03,W
01086:  MOVWF  FEA
01088:  CLRF   FEC
0108A:  MOVF   FED,F
0108C:  CLRF   FEF
....................  
.................... 	} 
0108E:  INCF   xFC,F
01090:  BRA    0FFE
.................... } 
01092:  MOVLB  0
01094:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00CD6:  MOVF   x1D,W
00CD8:  XORWF  x1E,W
00CDA:  MOVWF  01
*
00D28:  MOVF   x1D,W
00D2A:  XORWF  x1E,W
00D2C:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00C56:  MOVLB  9
00C58:  CLRF   x05
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00C5A:  MOVFF  904,03
00C5E:  MOVF   x03,W
00C60:  BTFSC  FD8.2
00C62:  DECF   x04,F
00C64:  DECF   x03,F
00C66:  MOVWF  x06
00C68:  MOVFF  03,907
00C6C:  MOVF   x06,F
00C6E:  BNZ   0C74
00C70:  MOVF   x07,F
00C72:  BZ    0CE8
.................... 		*data = read_eeprom( address++ ); 
00C74:  MOVFF  902,03
00C78:  MOVF   x01,W
00C7A:  MOVWF  FE9
00C7C:  MOVFF  03,FEA
00C80:  MOVF   x00,W
00C82:  MOVWF  03
00C84:  MOVLB  8
00C86:  MOVF   xFF,W
00C88:  INCF   xFF,F
00C8A:  BTFSS  FD8.2
00C8C:  BRA    0C94
00C8E:  MOVLB  9
00C90:  INCF   x00,F
00C92:  MOVLB  8
00C94:  MOVLB  9
00C96:  MOVWF  x08
00C98:  MOVFF  03,909
00C9C:  MOVFF  FF2,90A
00CA0:  BCF    FF2.6
00CA2:  BCF    FF2.7
00CA4:  MOVFF  909,FAA
00CA8:  MOVFF  908,FA9
00CAC:  BCF    FA6.6
00CAE:  BCF    FA6.7
00CB0:  BSF    FA6.0
00CB2:  MOVF   FA8,W
00CB4:  BTFSC  x0A.6
00CB6:  BSF    FF2.6
00CB8:  BTFSC  x0A.7
00CBA:  BSF    FF2.7
00CBC:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00CBE:  MOVFF  902,03
00CC2:  MOVF   x01,W
00CC4:  MOVWF  FE9
00CC6:  MOVFF  03,FEA
00CCA:  MOVFF  FEF,906
00CCE:  MOVFF  905,91D
00CD2:  MOVFF  906,91E
*
00CDC:  MOVFF  01,905
.................... 		data++; 
00CE0:  INCF   x01,F
00CE2:  BTFSC  FD8.2
00CE4:  INCF   x02,F
.................... 	} 
00CE6:  BRA    0C5A
.................... 	return crc; 
00CE8:  MOVFF  905,01
.................... } 
00CEC:  MOVLB  0
00CEE:  GOTO   0ED6 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00CF2:  MOVLB  9
00CF4:  CLRF   x1B
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00CF6:  MOVFF  91A,03
00CFA:  MOVF   x19,W
00CFC:  BTFSC  FD8.2
00CFE:  DECF   x1A,F
00D00:  DECF   x19,F
00D02:  MOVWF  x1C
00D04:  MOVFF  03,91D
00D08:  MOVF   x1C,F
00D0A:  BNZ   0D10
00D0C:  MOVF   x1D,F
00D0E:  BZ    0D8E
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00D10:  MOVFF  918,03
00D14:  MOVF   x17,W
00D16:  MOVWF  FE9
00D18:  MOVFF  03,FEA
00D1C:  MOVFF  FEF,91C
00D20:  MOVFF  91B,91D
00D24:  MOVFF  91C,91E
*
00D2E:  MOVFF  01,91B
.................... 		write_eeprom( address++, *data++ ); 
00D32:  MOVF   x16,W
00D34:  MOVWF  03
00D36:  MOVF   x15,W
00D38:  INCF   x15,F
00D3A:  BTFSC  FD8.2
00D3C:  INCF   x16,F
00D3E:  MOVWF  x1C
00D40:  MOVFF  03,91D
00D44:  MOVF   x18,W
00D46:  MOVWF  03
00D48:  MOVF   x17,W
00D4A:  INCF   x17,F
00D4C:  BTFSC  FD8.2
00D4E:  INCF   x18,F
00D50:  MOVWF  FE9
00D52:  MOVFF  03,FEA
00D56:  MOVFF  FEF,91E
00D5A:  MOVFF  91D,FAA
00D5E:  MOVFF  91C,FA9
00D62:  MOVFF  91E,FA8
00D66:  BCF    FA6.6
00D68:  BCF    FA6.7
00D6A:  BSF    FA6.2
00D6C:  MOVF   FF2,W
00D6E:  MOVWF  00
00D70:  BCF    FF2.6
00D72:  BCF    FF2.7
00D74:  MOVLB  F
00D76:  MOVLW  55
00D78:  MOVWF  FA7
00D7A:  MOVLW  AA
00D7C:  MOVWF  FA7
00D7E:  BSF    FA6.1
00D80:  BTFSC  FA6.1
00D82:  BRA    0D80
00D84:  BCF    FA6.2
00D86:  MOVF   00,W
00D88:  IORWF  FF2,F
.................... 	} 
00D8A:  MOVLB  9
00D8C:  BRA    0CF6
....................  
.................... 	return crc; 
00D8E:  MOVFF  91B,01
.................... } 
00D92:  MOVLB  0
00D94:  GOTO   0DB8 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00D98:  MOVLB  9
00D9A:  CLRF   x14
00D9C:  MOVLW  36
00D9E:  MOVWF  x13
00DA0:  CLRF   x16
00DA2:  MOVLW  02
00DA4:  MOVWF  x15
00DA6:  MOVFF  914,918
00DAA:  MOVFF  913,917
00DAE:  CLRF   x1A
00DB0:  MOVLW  61
00DB2:  MOVWF  x19
00DB4:  MOVLB  0
00DB6:  BRA    0CF2
00DB8:  MOVFF  01,912
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00DBC:  CLRF   FAA
00DBE:  CLRF   FA9
00DC0:  MOVFF  912,FA8
00DC4:  BCF    FA6.6
00DC6:  BCF    FA6.7
00DC8:  BSF    FA6.2
00DCA:  MOVF   FF2,W
00DCC:  MOVWF  00
00DCE:  BCF    FF2.6
00DD0:  BCF    FF2.7
00DD2:  MOVLB  F
00DD4:  MOVLW  55
00DD6:  MOVWF  FA7
00DD8:  MOVLW  AA
00DDA:  MOVWF  FA7
00DDC:  BSF    FA6.1
00DDE:  BTFSC  FA6.1
00DE0:  BRA    0DDE
00DE2:  BCF    FA6.2
00DE4:  MOVF   00,W
00DE6:  IORWF  FF2,F
.................... } 
00DE8:  MOVLB  0
00DEA:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00DEC:  MOVLW  96
00DEE:  MOVLB  1
00DF0:  MOVWF  xF8
....................  
.................... 	config.modbus_address=38; 
00DF2:  MOVLW  26
00DF4:  MOVWF  36
.................... 	config.rs485_port_speed=RS485_SPEED_9600; 
00DF6:  MOVLW  03
00DF8:  MOVWF  39
.................... 	config.rs485_port_mode=RS485_MODE_NMEA0183_RX; // RS485_MODE_MODBUS_BRIDGE; 
00DFA:  MOVLW  02
00DFC:  MOVWF  38
.................... //	config.modbus_address=128; /* use any address */ 
....................  
.................... 	config.serial_prefix='P'; 
00DFE:  MOVLW  50
00E00:  MOVWF  3A
.................... 	config.serial_number=9876; 
00E02:  MOVLW  26
00E04:  MOVWF  3C
00E06:  MOVLW  94
00E08:  MOVWF  3B
....................  
.................... 	config.adc_sample_ticks=20; 
00E0A:  CLRF   3E
00E0C:  MOVLW  14
00E0E:  MOVWF  3D
.................... 	config.allow_bootload_request=0; 
00E10:  CLRF   3F
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00E12:  MOVLW  02
00E14:  MOVWF  41
00E16:  MOVLW  76
00E18:  MOVWF  40
.................... 	config.pi_offtime_seconds=2; 
00E1A:  CLRF   43
00E1C:  MOVLW  02
00E1E:  MOVWF  42
.................... 	config.power_startup=0; 
00E20:  CLRF   44
....................  
.................... 	/* clear NMEA0183 sentence character array */ 
.................... 	memset(config.nmea0183_sentence,0,sizeof(config.nmea0183_sentence)); 
00E22:  CLRF   FEA
00E24:  MOVLW  4F
00E26:  MOVWF  FE9
00E28:  CLRF   00
00E2A:  CLRF   02
00E2C:  MOVLW  48
00E2E:  MOVWF  01
00E30:  MOVLB  0
00E32:  RCALL  0916
.................... 	/* set defaults. Can set the first 11 this way. They are 6 bytes long, not null terminated. 
.................... 	Can use normal string functions (null terminated) to set the first 11 of them in order. 
.................... 	12th would go 1 byte past the end of array */ 
.................... 	strcpy(config.nmea0183_sentence[0],"$GPRMC"); 
00E34:  CLRF   FEA
00E36:  MOVLW  4F
00E38:  MOVWF  FE9
00E3A:  MOVLW  00
00E3C:  CALL   0188
00E40:  TBLRD*-
00E42:  TBLRD*+
00E44:  MOVF   FF5,W
00E46:  MOVWF  FEE
00E48:  IORLW  00
00E4A:  BNZ   0E42
.................... 	strcpy(config.nmea0183_sentence[1],"$GPGGA"); 
00E4C:  CLRF   FEA
00E4E:  MOVLW  55
00E50:  MOVWF  FE9
00E52:  MOVLW  00
00E54:  CALL   01A0
00E58:  TBLRD*-
00E5A:  TBLRD*+
00E5C:  MOVF   FF5,W
00E5E:  MOVWF  FEE
00E60:  IORLW  00
00E62:  BNZ   0E5A
.................... 	strcpy(config.nmea0183_sentence[2],"$GPGSV"); 
00E64:  CLRF   FEA
00E66:  MOVLW  5B
00E68:  MOVWF  FE9
00E6A:  MOVLW  00
00E6C:  CALL   01B8
00E70:  TBLRD*-
00E72:  TBLRD*+
00E74:  MOVF   FF5,W
00E76:  MOVWF  FEE
00E78:  IORLW  00
00E7A:  BNZ   0E72
.................... 	strcpy(config.nmea0183_sentence[3],"$WIMDA"); 
00E7C:  CLRF   FEA
00E7E:  MOVLW  61
00E80:  MOVWF  FE9
00E82:  MOVLW  00
00E84:  CALL   01D0
00E88:  TBLRD*-
00E8A:  TBLRD*+
00E8C:  MOVF   FF5,W
00E8E:  MOVWF  FEE
00E90:  IORLW  00
00E92:  BNZ   0E8A
....................  
.................... 	strcpy(config.nmea0183_sentence[6],"*"); /* put anything in */ 
00E94:  CLRF   FEA
00E96:  MOVLW  73
00E98:  MOVWF  FE9
00E9A:  MOVLW  00
00E9C:  CALL   01E8
00EA0:  TBLRD*-
00EA2:  TBLRD*+
00EA4:  MOVF   FF5,W
00EA6:  MOVWF  FEE
00EA8:  IORLW  00
00EAA:  BNZ   0EA2
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00EAC:  RCALL  0D98
....................  
.................... } 
00EAE:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00EB0:  MOVLB  8
00EB2:  CLRF   xFE
00EB4:  MOVLW  36
00EB6:  MOVWF  xFD
00EB8:  MOVLB  9
00EBA:  CLRF   x00
00EBC:  MOVLW  02
00EBE:  MOVLB  8
00EC0:  MOVWF  xFF
00EC2:  MOVFF  8FE,902
00EC6:  MOVFF  8FD,901
00ECA:  MOVLB  9
00ECC:  CLRF   x04
00ECE:  MOVLW  61
00ED0:  MOVWF  x03
00ED2:  MOVLB  0
00ED4:  BRA    0C56
00ED6:  MOVFF  01,8FC
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00EDA:  MOVFF  FF2,8FD
00EDE:  BCF    FF2.6
00EE0:  BCF    FF2.7
00EE2:  CLRF   FAA
00EE4:  CLRF   FA9
00EE6:  BCF    FA6.6
00EE8:  BCF    FA6.7
00EEA:  BSF    FA6.0
00EEC:  MOVF   FA8,W
00EEE:  MOVLB  8
00EF0:  BTFSC  xFD.6
00EF2:  BSF    FF2.6
00EF4:  BTFSC  xFD.7
00EF6:  BSF    FF2.7
00EF8:  SUBWF  xFC,W
00EFA:  BZ    0F02
.................... 		write_default_param_file(); 
00EFC:  MOVLB  0
00EFE:  RCALL  0DEC
00F00:  MOVLB  8
.................... 	} 
.................... } 
00F02:  MOVLB  0
00F04:  GOTO   32B4 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
.................... } 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(STREAM_PI) ) { 
00F08:  BTFSS  F9E.5
00F0A:  BRA    0F10
.................... 		fgetc(STREAM_PI); 
00F0C:  RCALL  0780
.................... 	} 
00F0E:  BRA    0F08
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00F10:  BSF    F9D.5
.................... } 
00F12:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
00F14:  RCALL  0F08
....................  
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_8 | T0_8_BIT); /* 0.683 ms @ 12 MHz. Use fosc/4 not fosc */ 
00F16:  MOVLW  C2
00F18:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL); 
00F1A:  MOVLW  C0
00F1C:  IORWF  FF2,F
.................... } 
00F1E:  GOTO   32C6 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0041A:  BCF    FF2.5
.................... 	if (enable) { 
0041C:  MOVLB  A
0041E:  MOVF   x12,F
00420:  BZ    042A
.................... 		set_timer0(0); 
00422:  CLRF   FD7
00424:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00426:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00428:  BSF    FF2.5
.................... 	} 
.................... } 
0042A:  MOVLB  0
0042C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0042E:  MOVLB  7
00430:  MOVF   xE9,W
00432:  SUBLW  02
00434:  BNZ   044A
00436:  MOVF   xEA,F
00438:  BNZ   044A
0043A:  MOVF   xEB,F
0043C:  BNZ   044A
0043E:  BTFSC  xE8.0
00440:  BRA    044A
....................    { 
....................       modbus_rx.len-=2; 
00442:  MOVLW  02
00444:  SUBWF  xED,F
....................       modbus_serial_new=TRUE; 
00446:  BSF    xE8.0
....................    } 
....................    else 
00448:  BRA    044C
....................       modbus_serial_new=FALSE; 
0044A:  BCF    xE8.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0044C:  SETF   xEB
0044E:  SETF   xEA
....................    modbus_serial_state=MODBUS_GETADDY; 
00450:  CLRF   xE9
....................    modbus_enable_timeout(FALSE); 
00452:  MOVLB  A
00454:  CLRF   x12
00456:  MOVLB  0
00458:  RCALL  041A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0045A:  BCF    FF2.2
0045C:  GOTO   0094
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00796:  MOVLB  7
00798:  MOVF   xEB,W
0079A:  MOVLB  A
0079C:  XORWF  x12,W
0079E:  MOVWF  x13
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
007A0:  CLRF   03
007A2:  MOVF   x13,W
007A4:  MOVLB  0
007A6:  RCALL  01FA
007A8:  MOVWF  01
007AA:  MOVLB  7
007AC:  MOVF   xEA,W
007AE:  XORWF  01,W
007B0:  MOVWF  xEB
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
007B2:  CLRF   03
007B4:  MOVLB  A
007B6:  MOVF   x13,W
007B8:  MOVLB  0
007BA:  RCALL  030A
007BC:  MOVFF  FE8,7EA
.................... } 
007C0:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	timers.rda_tx_buff[timers.rda_tx_length]=c; 
*
0141A:  MOVLW  01
0141C:  MOVLB  4
0141E:  ADDWF  x01,W
01420:  MOVWF  FE9
01422:  MOVLW  03
01424:  MOVWF  FEA
01426:  BTFSC  FD8.0
01428:  INCF   FEA,F
0142A:  MOVFF  912,FEF
.................... 	timers.rda_tx_length++; 
0142E:  INCF   x01,F
01430:  CLRF   19
01432:  BTFSC  FF2.6
01434:  BSF    19.6
01436:  BCF    FF2.6
01438:  BTFSC  FF2.7
0143A:  BSF    19.7
0143C:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
0143E:  MOVFF  912,A12
01442:  MOVLB  0
01444:  CALL   0796
01448:  BTFSC  19.6
0144A:  BSF    FF2.6
0144C:  BTFSC  19.7
0144E:  BSF    FF2.7
.................... } 
01450:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) { 
.................... 	/* reset out transmit buffer */ 
.................... 	timers.rda_tx_length=0; 
01452:  MOVLB  4
01454:  CLRF   x01
.................... 	timers.rda_tx_pos=0; 
01456:  CLRF   x02
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01458:  MOVLB  7
0145A:  SETF   xEB
0145C:  SETF   xEA
.................... 	modbus_serial_new=FALSE; 
0145E:  BCF    xE8.0
....................  
.................... 	modbus_serial_putc(to); 
01460:  MOVFF  910,912
01464:  MOVLB  0
01466:  RCALL  141A
.................... 	modbus_serial_putc(func); 
01468:  MOVFF  911,912
0146C:  RCALL  141A
.................... } 
0146E:  RETURN 0
....................  
.................... void modbus_serial_send_stop() { 
.................... 	int8 crc_low, crc_high; 
....................  
.................... 	crc_high=modbus_serial_crc.b[1]; 
01470:  MOVFF  7EB,911
.................... 	crc_low=modbus_serial_crc.b[0]; 
01474:  MOVFF  7EA,910
....................  
.................... 	modbus_serial_putc(crc_high); 
01478:  MOVFF  911,912
0147C:  RCALL  141A
.................... 	modbus_serial_putc(crc_low); 
0147E:  MOVFF  910,912
01482:  RCALL  141A
....................  
....................  
.................... 	modbus_serial_crc.d=0xFFFF; 
01484:  MOVLB  7
01486:  SETF   xEB
01488:  SETF   xEA
....................  
.................... 	/* ready to transmit from buffer flag set. Elsewhere we start sending */ 
.................... 	timers.now_rda_tx_ready=1; 
0148A:  MOVLB  4
0148C:  BSF    x03.0
.................... } 
0148E:  MOVLB  0
01490:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
012BA:  MOVLB  7
012BC:  BTFSC  xE8.0
012BE:  BRA    12C8
....................       return FALSE; 
012C0:  MOVLW  00
012C2:  MOVWF  01
012C4:  BRA    12DA
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
012C6:  BRA    12D4
012C8:  BTFSS  xEE.7
012CA:  BRA    12D4
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
012CC:  MOVFF  7F0,7EF
....................       modbus_rx.len = 1; 
012D0:  MOVLW  01
012D2:  MOVWF  xED
....................    } 
....................    modbus_serial_new=FALSE; 
012D4:  BCF    xE8.0
....................    return TRUE; 
012D6:  MOVLW  01
012D8:  MOVWF  01
.................... } 
012DA:  MOVLB  0
012DC:  GOTO   2B60 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
02ACC:  MOVFF  908,910
02AD0:  MOVLW  06
02AD2:  MOVLB  9
02AD4:  MOVWF  x11
02AD6:  MOVLB  0
02AD8:  CALL   1452
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
02ADC:  MOVFF  90A,90D
02AE0:  MOVFF  90A,912
02AE4:  CALL   141A
....................    modbus_serial_putc(make8(reg_address,0)); 
02AE8:  MOVFF  909,90D
02AEC:  MOVFF  909,912
02AF0:  CALL   141A
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
02AF4:  MOVFF  90C,90D
02AF8:  MOVFF  90C,912
02AFC:  CALL   141A
....................    modbus_serial_putc(make8(reg_value,0)); 
02B00:  MOVFF  90B,90D
02B04:  MOVFF  90B,912
02B08:  CALL   141A
....................  
....................    modbus_serial_send_stop(); 
02B0C:  CALL   1470
.................... } 
02B10:  GOTO   2D4C (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
02B14:  MOVFF  906,910
02B18:  MOVLW  10
02B1A:  MOVLB  9
02B1C:  MOVWF  x11
02B1E:  MOVLB  0
02B20:  CALL   1452
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
02B24:  MOVFF  908,90B
02B28:  MOVFF  908,912
02B2C:  CALL   141A
....................    modbus_serial_putc(make8(start_address,0)); 
02B30:  MOVFF  907,90B
02B34:  MOVFF  907,912
02B38:  CALL   141A
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02B3C:  MOVFF  90A,90B
02B40:  MOVFF  90A,912
02B44:  CALL   141A
....................    modbus_serial_putc(make8(quantity,0)); 
02B48:  MOVFF  909,90B
02B4C:  MOVFF  909,912
02B50:  CALL   141A
....................  
....................    modbus_serial_send_stop(); 
02B54:  CALL   1470
.................... } 
02B58:  GOTO   2E1E (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01492:  MOVLB  9
01494:  MOVF   x07,W
01496:  IORLW  80
01498:  MOVWF  x0A
0149A:  MOVFF  908,90B
0149E:  MOVFF  906,910
014A2:  MOVWF  x11
014A4:  MOVLB  0
014A6:  RCALL  1452
....................    modbus_serial_putc(error); 
014A8:  MOVFF  909,912
014AC:  RCALL  141A
....................    modbus_serial_send_stop(); 
014AE:  RCALL  1470
.................... } 
014B0:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER          54 
....................  
.................... #define MIN_CONFIG_REGISTER          1000 
.................... #define MAX_CONFIG_REGISTER          1013 
....................  
.................... #define MIN_NMEA0183_CONFIG_REGISTER 1100 
.................... #define MAX_NMEA0183_CONFIG_REGISTER 1100 + N_NMEA0183_SENTENCES*6 
....................  
.................... #define MIN_EE_REGISTER              2000 
.................... #define MAX_EE_REGISTER              MIN_EE_REGISTER + 512 
....................  
.................... #define MIN_NMEA0183_BYTE_REGISTER   5000 
.................... #define MAX_NMEA0183_BYTE_REGISTER   MIN_NMEA0183_BYTE_REGISTER + N_NMEA0183_SENTENCES*80 
....................  
.................... #define MIN_NMEA0183_WORD_REGISTER   6000 
.................... #define MAX_NMEA0183_WORD_REGISTER   MIN_NMEA0183_WORD_REGISTER + N_NMEA0183_SENTENCES*40 
....................  
.................... #define MIN_NMEA0183_META_REGISTER   6500 
.................... #define MAX_NMEA0183_META_REGISTER   MIN_NMEA0183_META_REGISTER + N_NMEA0183_SENTENCES*2 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
01602:  MOVLB  1
01604:  CLRF   xCD
01606:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
01608:  CLRF   xCF
0160A:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
0160C:  CLRF   xD1
0160E:  CLRF   xD0
.................... } 
01610:  MOVLB  0
01612:  GOTO   2340 (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
0159E:  BCF    FF2.6
015A0:  BCF    FF2.7
015A2:  BTFSC  FF2.7
015A4:  BRA    15A0
....................  
.................... 	current.pulse_count[0]=0; 
015A6:  CLRF   xAA
015A8:  CLRF   xA9
.................... 	current.pulse_count[1]=0; 
015AA:  CLRF   xAC
015AC:  CLRF   xAB
.................... 	current.pulse_count[2]=0; 
015AE:  CLRF   xAE
015B0:  CLRF   xAD
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
015B2:  SETF   x9E
015B4:  SETF   x9D
.................... 	current.pulse_min_period[1]=65535; 
015B6:  SETF   xA0
015B8:  SETF   x9F
.................... 	current.pulse_min_period[2]=65535; 
015BA:  SETF   xA2
015BC:  SETF   xA1
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
015BE:  CLRF   xA4
015C0:  CLRF   xA3
.................... 	current.pulse_max_period[1]=0; 
015C2:  CLRF   xA6
015C4:  CLRF   xA5
.................... 	current.pulse_max_period[2]=0; 
015C6:  CLRF   xA8
015C8:  CLRF   xA7
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
015CA:  MOVLB  1
015CC:  CLRF   xD7
015CE:  CLRF   xD6
....................  
.................... 	enable_interrupts(GLOBAL); 
015D0:  MOVLW  C0
015D2:  IORWF  FF2,F
.................... } 
015D4:  MOVLB  0
015D6:  GOTO   22F0 (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
015DA:  BCF    FF2.6
015DC:  BCF    FF2.7
015DE:  BTFSC  FF2.7
015E0:  BRA    15DC
.................... 	current.pulse_sum[0]=0; 
015E2:  CLRF   xB2
015E4:  CLRF   xB1
015E6:  CLRF   xB0
015E8:  CLRF   xAF
.................... 	current.pulse_sum[1]=0; 
015EA:  CLRF   xB6
015EC:  CLRF   xB5
015EE:  CLRF   xB4
015F0:  CLRF   xB3
.................... 	current.pulse_sum[2]=0; 
015F2:  CLRF   xBA
015F4:  CLRF   xB9
015F6:  CLRF   xB8
015F8:  CLRF   xB7
.................... 	enable_interrupts(GLOBAL); 
015FA:  MOVLW  C0
015FC:  IORWF  FF2,F
.................... } 
015FE:  GOTO   2300 (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
014B2:  BCF    FF2.6
014B4:  BCF    FF2.7
014B6:  BTFSC  FF2.7
014B8:  BRA    14B4
.................... 	l=current.pulse_sum[ch]; 
014BA:  MOVLB  A
014BC:  CLRF   x01
014BE:  MOVFF  918,A00
014C2:  CLRF   x03
014C4:  MOVLW  04
014C6:  MOVWF  x02
014C8:  MOVLB  0
014CA:  CALL   08F4
014CE:  MOVFF  02,03
014D2:  MOVF   01,W
014D4:  ADDLW  AF
014D6:  MOVWF  FE9
014D8:  MOVLW  00
014DA:  ADDWFC 02,W
014DC:  MOVWF  FEA
014DE:  MOVFF  FEF,00
014E2:  MOVFF  FEC,01
014E6:  MOVFF  FEC,02
014EA:  MOVFF  FEC,03
014EE:  MOVFF  03,91C
014F2:  MOVFF  02,91B
014F6:  MOVFF  01,91A
014FA:  MOVFF  00,919
.................... 	enable_interrupts(GLOBAL); 
014FE:  MOVLW  C0
01500:  IORWF  FF2,F
....................  
.................... 	return l; 
01502:  MOVFF  919,00
01506:  MOVFF  91A,01
0150A:  MOVFF  91B,02
0150E:  MOVFF  91C,03
.................... } 
01512:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
.................... 	int8 n,o; 
.................... 	int8 *p; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01616:  MOVLB  9
01618:  MOVF   x13,W
0161A:  SUBLW  06
0161C:  BC    1672
0161E:  XORLW  FF
01620:  BNZ   1628
01622:  MOVF   x12,W
01624:  SUBLW  CF
01626:  BC    1672
01628:  MOVF   x13,W
0162A:  SUBLW  09
0162C:  BNC   1672
0162E:  BNZ   1636
01630:  MOVF   x12,W
01632:  SUBLW  CF
01634:  BNC   1672
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS); 
01636:  MOVLW  D0
01638:  SUBWF  x12,W
0163A:  MOVWF  x18
0163C:  MOVLW  07
0163E:  SUBWFB x13,W
01640:  MOVWF  x19
01642:  MOVLW  02
01644:  ADDWF  x19,F
01646:  MOVFF  FF2,91A
0164A:  BCF    FF2.6
0164C:  BCF    FF2.7
0164E:  MOVFF  919,FAA
01652:  MOVFF  918,FA9
01656:  BCF    FA6.6
01658:  BCF    FA6.7
0165A:  BSF    FA6.0
0165C:  MOVF   FA8,W
0165E:  BTFSC  x1A.6
01660:  BSF    FF2.6
01662:  BTFSC  x1A.7
01664:  BSF    FF2.7
01666:  CLRF   03
01668:  MOVWF  01
0166A:  MOVF   03,W
0166C:  MOVWF  02
0166E:  GOTO   265E
.................... 	} 
....................  
.................... 	if ( addr >= MIN_NMEA0183_CONFIG_REGISTER && addr < MAX_NMEA0183_CONFIG_REGISTER ) { 
01672:  MOVF   x13,W
01674:  SUBLW  03
01676:  BC    16F6
01678:  XORLW  FF
0167A:  BNZ   1682
0167C:  MOVF   x12,W
0167E:  SUBLW  4B
01680:  BC    16F6
01682:  MOVF   x13,W
01684:  SUBLW  04
01686:  BNC   16F6
01688:  BNZ   1690
0168A:  MOVF   x12,W
0168C:  SUBLW  93
0168E:  BNC   16F6
.................... 		/* get rid of our base */ 
.................... 		n = (addr-MIN_NMEA0183_CONFIG_REGISTER); 
01690:  MOVLW  4C
01692:  SUBWF  x12,W
01694:  MOVWF  x14
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
01696:  MOVFF  914,918
0169A:  MOVLW  06
0169C:  MOVWF  x19
0169E:  MOVLB  0
016A0:  CALL   0BA8
016A4:  MOVFF  00,915
.................... 		n = n / 6; /* number of sentence */ 
016A8:  MOVFF  914,918
016AC:  MOVLW  06
016AE:  MOVLB  9
016B0:  MOVWF  x19
016B2:  MOVLB  0
016B4:  CALL   0BA8
016B8:  MOVFF  01,914
....................  
.................... 		return (int16) config.nmea0183_sentence[n][o]; 
016BC:  MOVLB  9
016BE:  MOVF   x14,W
016C0:  MULLW  06
016C2:  MOVF   FF3,W
016C4:  CLRF   03
016C6:  ADDLW  19
016C8:  MOVWF  x18
016CA:  MOVLW  00
016CC:  ADDWFC 03,W
016CE:  MOVWF  x19
016D0:  CLRF   03
016D2:  MOVF   x15,W
016D4:  ADDWF  x18,W
016D6:  MOVWF  01
016D8:  MOVF   x19,W
016DA:  ADDWFC 03,F
016DC:  MOVF   01,W
016DE:  ADDLW  36
016E0:  MOVWF  FE9
016E2:  MOVLW  00
016E4:  ADDWFC 03,W
016E6:  MOVWF  FEA
016E8:  MOVF   FEF,W
016EA:  CLRF   03
016EC:  MOVWF  01
016EE:  MOVFF  03,02
016F2:  GOTO   265E
.................... 	} 
....................  
.................... 	/* one byte per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_BYTE_REGISTER && addr < MAX_NMEA0183_BYTE_REGISTER ) { 
016F6:  MOVF   x13,W
016F8:  SUBLW  12
016FA:  BC    173C
016FC:  XORLW  FF
016FE:  BNZ   1706
01700:  MOVF   x12,W
01702:  SUBLW  87
01704:  BC    173C
01706:  MOVF   x13,W
01708:  SUBLW  17
0170A:  BNC   173C
0170C:  BNZ   1714
0170E:  MOVF   x12,W
01710:  SUBLW  47
01712:  BNC   173C
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_BYTE_REGISTER); 
01714:  MOVLW  88
01716:  SUBWF  x12,F
01718:  MOVLW  13
0171A:  SUBWFB x13,F
....................  
....................  		p  = nmea.sentence[0]; 
0171C:  MOVLW  04
0171E:  MOVWF  x17
01720:  MOVWF  x16
.................... 		return (int16) p[addr]; 
01722:  MOVF   x16,W
01724:  ADDWF  x12,W
01726:  MOVWF  FE9
01728:  MOVF   x17,W
0172A:  ADDWFC x13,W
0172C:  MOVWF  FEA
0172E:  MOVF   FEF,W
01730:  CLRF   03
01732:  MOVWF  01
01734:  MOVFF  03,02
01738:  GOTO   265E
.................... 	} 
....................  
.................... 	/* two bytes per register for NMEA0183 sentences */ 
.................... 	if ( addr >= MIN_NMEA0183_WORD_REGISTER && addr < MAX_NMEA0183_WORD_REGISTER ) { 
0173C:  MOVF   x13,W
0173E:  SUBLW  16
01740:  BC    17AA
01742:  XORLW  FF
01744:  BNZ   174C
01746:  MOVF   x12,W
01748:  SUBLW  6F
0174A:  BC    17AA
0174C:  MOVF   x13,W
0174E:  SUBLW  19
01750:  BNC   17AA
01752:  BNZ   175A
01754:  MOVF   x12,W
01756:  SUBLW  4F
01758:  BNC   17AA
.................... 		/* get rid of our base */ 
.................... 		addr = (addr-MIN_NMEA0183_WORD_REGISTER); 
0175A:  MOVLW  70
0175C:  SUBWF  x12,F
0175E:  MOVLW  17
01760:  SUBWFB x13,F
.................... 		addr = addr * 2; 
01762:  BCF    FD8.0
01764:  RLCF   x12,F
01766:  RLCF   x13,F
....................  
....................  		p  = nmea.sentence[0]; 
01768:  MOVLW  04
0176A:  MOVWF  x17
0176C:  MOVWF  x16
.................... 		return (int16) make16(p[addr],p[addr+1]); 
0176E:  MOVF   x16,W
01770:  ADDWF  x12,W
01772:  MOVWF  FE9
01774:  MOVF   x17,W
01776:  ADDWFC x13,W
01778:  MOVWF  FEA
0177A:  MOVFF  FEF,918
0177E:  MOVLW  01
01780:  ADDWF  x12,W
01782:  MOVWF  x19
01784:  MOVLW  00
01786:  ADDWFC x13,W
01788:  MOVWF  x1A
0178A:  MOVF   x16,W
0178C:  ADDWF  x19,W
0178E:  MOVWF  FE9
01790:  MOVF   x17,W
01792:  ADDWFC x1A,W
01794:  MOVWF  FEA
01796:  MOVFF  FEF,91B
0179A:  MOVFF  918,03
0179E:  MOVFF  91B,01
017A2:  MOVFF  918,02
017A6:  GOTO   265E
.................... 	} 
....................  
....................  
.................... 	switch ( addr ) { 
017AA:  MOVF   x12,W
017AC:  MOVWF  00
017AE:  MOVF   x13,W
017B0:  MOVWF  03
017B2:  MOVF   03,W
017B4:  BNZ   17C2
017B6:  MOVF   00,F
017B8:  MOVLB  0
017BA:  BTFSC  FD8.2
017BC:  GOTO   1E8A
017C0:  MOVLB  9
017C2:  MOVF   03,W
017C4:  BNZ   17D4
017C6:  MOVLW  01
017C8:  SUBWF  00,W
017CA:  MOVLB  0
017CC:  BTFSC  FD8.2
017CE:  GOTO   1E9A
017D2:  MOVLB  9
017D4:  MOVF   03,W
017D6:  BNZ   17E6
017D8:  MOVLW  02
017DA:  SUBWF  00,W
017DC:  MOVLB  0
017DE:  BTFSC  FD8.2
017E0:  GOTO   1EAA
017E4:  MOVLB  9
017E6:  MOVF   03,W
017E8:  BNZ   17F8
017EA:  MOVLW  03
017EC:  SUBWF  00,W
017EE:  MOVLB  0
017F0:  BTFSC  FD8.2
017F2:  GOTO   1EBA
017F6:  MOVLB  9
017F8:  MOVF   03,W
017FA:  BNZ   180A
017FC:  MOVLW  04
017FE:  SUBWF  00,W
01800:  MOVLB  0
01802:  BTFSC  FD8.2
01804:  GOTO   1ECA
01808:  MOVLB  9
0180A:  MOVF   03,W
0180C:  BNZ   181C
0180E:  MOVLW  05
01810:  SUBWF  00,W
01812:  MOVLB  0
01814:  BTFSC  FD8.2
01816:  GOTO   1EF6
0181A:  MOVLB  9
0181C:  MOVF   03,W
0181E:  BNZ   182E
01820:  MOVLW  06
01822:  SUBWF  00,W
01824:  MOVLB  0
01826:  BTFSC  FD8.2
01828:  GOTO   1F08
0182C:  MOVLB  9
0182E:  MOVF   03,W
01830:  BNZ   1840
01832:  MOVLW  07
01834:  SUBWF  00,W
01836:  MOVLB  0
01838:  BTFSC  FD8.2
0183A:  GOTO   1F18
0183E:  MOVLB  9
01840:  MOVF   03,W
01842:  BNZ   1852
01844:  MOVLW  08
01846:  SUBWF  00,W
01848:  MOVLB  0
0184A:  BTFSC  FD8.2
0184C:  GOTO   1F28
01850:  MOVLB  9
01852:  MOVF   03,W
01854:  BNZ   1864
01856:  MOVLW  09
01858:  SUBWF  00,W
0185A:  MOVLB  0
0185C:  BTFSC  FD8.2
0185E:  GOTO   1F36
01862:  MOVLB  9
01864:  MOVF   03,W
01866:  BNZ   1876
01868:  MOVLW  0A
0186A:  SUBWF  00,W
0186C:  MOVLB  0
0186E:  BTFSC  FD8.2
01870:  GOTO   1F44
01874:  MOVLB  9
01876:  MOVF   03,W
01878:  BNZ   1888
0187A:  MOVLW  0B
0187C:  SUBWF  00,W
0187E:  MOVLB  0
01880:  BTFSC  FD8.2
01882:  GOTO   1F70
01886:  MOVLB  9
01888:  MOVF   03,W
0188A:  BNZ   189A
0188C:  MOVLW  0C
0188E:  SUBWF  00,W
01890:  MOVLB  0
01892:  BTFSC  FD8.2
01894:  GOTO   1F80
01898:  MOVLB  9
0189A:  MOVF   03,W
0189C:  BNZ   18AC
0189E:  MOVLW  0D
018A0:  SUBWF  00,W
018A2:  MOVLB  0
018A4:  BTFSC  FD8.2
018A6:  GOTO   1F8E
018AA:  MOVLB  9
018AC:  MOVF   03,W
018AE:  BNZ   18BE
018B0:  MOVLW  0E
018B2:  SUBWF  00,W
018B4:  MOVLB  0
018B6:  BTFSC  FD8.2
018B8:  GOTO   1F9C
018BC:  MOVLB  9
018BE:  MOVF   03,W
018C0:  BNZ   18D0
018C2:  MOVLW  0F
018C4:  SUBWF  00,W
018C6:  MOVLB  0
018C8:  BTFSC  FD8.2
018CA:  GOTO   1FAA
018CE:  MOVLB  9
018D0:  MOVF   03,W
018D2:  BNZ   18E2
018D4:  MOVLW  10
018D6:  SUBWF  00,W
018D8:  MOVLB  0
018DA:  BTFSC  FD8.2
018DC:  GOTO   1FB8
018E0:  MOVLB  9
018E2:  MOVF   03,W
018E4:  BNZ   18F4
018E6:  MOVLW  11
018E8:  SUBWF  00,W
018EA:  MOVLB  0
018EC:  BTFSC  FD8.2
018EE:  GOTO   1FE4
018F2:  MOVLB  9
018F4:  MOVF   03,W
018F6:  BNZ   1906
018F8:  MOVLW  12
018FA:  SUBWF  00,W
018FC:  MOVLB  0
018FE:  BTFSC  FD8.2
01900:  GOTO   1FF4
01904:  MOVLB  9
01906:  MOVF   03,W
01908:  BNZ   1918
0190A:  MOVLW  13
0190C:  SUBWF  00,W
0190E:  MOVLB  0
01910:  BTFSC  FD8.2
01912:  GOTO   2022
01916:  MOVLB  9
01918:  MOVF   03,W
0191A:  BNZ   192A
0191C:  MOVLW  14
0191E:  SUBWF  00,W
01920:  MOVLB  0
01922:  BTFSC  FD8.2
01924:  GOTO   203A
01928:  MOVLB  9
0192A:  MOVF   03,W
0192C:  BNZ   193C
0192E:  MOVLW  15
01930:  SUBWF  00,W
01932:  MOVLB  0
01934:  BTFSC  FD8.2
01936:  GOTO   2048
0193A:  MOVLB  9
0193C:  MOVF   03,W
0193E:  BNZ   194E
01940:  MOVLW  16
01942:  SUBWF  00,W
01944:  MOVLB  0
01946:  BTFSC  FD8.2
01948:  GOTO   2076
0194C:  MOVLB  9
0194E:  MOVF   03,W
01950:  BNZ   1960
01952:  MOVLW  17
01954:  SUBWF  00,W
01956:  MOVLB  0
01958:  BTFSC  FD8.2
0195A:  GOTO   2090
0195E:  MOVLB  9
01960:  MOVF   03,W
01962:  BNZ   1972
01964:  MOVLW  18
01966:  SUBWF  00,W
01968:  MOVLB  0
0196A:  BTFSC  FD8.2
0196C:  GOTO   209E
01970:  MOVLB  9
01972:  MOVF   03,W
01974:  BNZ   1984
01976:  MOVLW  19
01978:  SUBWF  00,W
0197A:  MOVLB  0
0197C:  BTFSC  FD8.2
0197E:  GOTO   20CC
01982:  MOVLB  9
01984:  MOVF   03,W
01986:  BNZ   1996
01988:  MOVLW  1A
0198A:  SUBWF  00,W
0198C:  MOVLB  0
0198E:  BTFSC  FD8.2
01990:  GOTO   20E6
01994:  MOVLB  9
01996:  MOVF   03,W
01998:  BNZ   19A8
0199A:  MOVLW  1B
0199C:  SUBWF  00,W
0199E:  MOVLB  0
019A0:  BTFSC  FD8.2
019A2:  GOTO   20F4
019A6:  MOVLB  9
019A8:  MOVF   03,W
019AA:  BNZ   19BA
019AC:  MOVLW  1C
019AE:  SUBWF  00,W
019B0:  MOVLB  0
019B2:  BTFSC  FD8.2
019B4:  GOTO   2122
019B8:  MOVLB  9
019BA:  MOVF   03,W
019BC:  BNZ   19CC
019BE:  MOVLW  1D
019C0:  SUBWF  00,W
019C2:  MOVLB  0
019C4:  BTFSC  FD8.2
019C6:  GOTO   213C
019CA:  MOVLB  9
019CC:  MOVF   03,W
019CE:  BNZ   19DE
019D0:  MOVLW  1E
019D2:  SUBWF  00,W
019D4:  MOVLB  0
019D6:  BTFSC  FD8.2
019D8:  GOTO   214A
019DC:  MOVLB  9
019DE:  MOVF   03,W
019E0:  BNZ   19F0
019E2:  MOVLW  1F
019E4:  SUBWF  00,W
019E6:  MOVLB  0
019E8:  BTFSC  FD8.2
019EA:  GOTO   2178
019EE:  MOVLB  9
019F0:  MOVF   03,W
019F2:  BNZ   1A02
019F4:  MOVLW  20
019F6:  SUBWF  00,W
019F8:  MOVLB  0
019FA:  BTFSC  FD8.2
019FC:  GOTO   2192
01A00:  MOVLB  9
01A02:  MOVF   03,W
01A04:  BNZ   1A14
01A06:  MOVLW  21
01A08:  SUBWF  00,W
01A0A:  MOVLB  0
01A0C:  BTFSC  FD8.2
01A0E:  GOTO   21A0
01A12:  MOVLB  9
01A14:  MOVF   03,W
01A16:  BNZ   1A26
01A18:  MOVLW  22
01A1A:  SUBWF  00,W
01A1C:  MOVLB  0
01A1E:  BTFSC  FD8.2
01A20:  GOTO   21CE
01A24:  MOVLB  9
01A26:  MOVF   03,W
01A28:  BNZ   1A38
01A2A:  MOVLW  23
01A2C:  SUBWF  00,W
01A2E:  MOVLB  0
01A30:  BTFSC  FD8.2
01A32:  GOTO   21E8
01A36:  MOVLB  9
01A38:  MOVF   03,W
01A3A:  BNZ   1A4A
01A3C:  MOVLW  24
01A3E:  SUBWF  00,W
01A40:  MOVLB  0
01A42:  BTFSC  FD8.2
01A44:  GOTO   21F6
01A48:  MOVLB  9
01A4A:  MOVF   03,W
01A4C:  BNZ   1A5C
01A4E:  MOVLW  25
01A50:  SUBWF  00,W
01A52:  MOVLB  0
01A54:  BTFSC  FD8.2
01A56:  GOTO   2224
01A5A:  MOVLB  9
01A5C:  MOVF   03,W
01A5E:  BNZ   1A6E
01A60:  MOVLW  26
01A62:  SUBWF  00,W
01A64:  MOVLB  0
01A66:  BTFSC  FD8.2
01A68:  GOTO   223E
01A6C:  MOVLB  9
01A6E:  MOVF   03,W
01A70:  BNZ   1A80
01A72:  MOVLW  27
01A74:  SUBWF  00,W
01A76:  MOVLB  0
01A78:  BTFSC  FD8.2
01A7A:  GOTO   224C
01A7E:  MOVLB  9
01A80:  MOVF   03,W
01A82:  BNZ   1A92
01A84:  MOVLW  28
01A86:  SUBWF  00,W
01A88:  MOVLB  0
01A8A:  BTFSC  FD8.2
01A8C:  GOTO   227A
01A90:  MOVLB  9
01A92:  MOVF   03,W
01A94:  BNZ   1AA4
01A96:  MOVLW  29
01A98:  SUBWF  00,W
01A9A:  MOVLB  0
01A9C:  BTFSC  FD8.2
01A9E:  GOTO   2294
01AA2:  MOVLB  9
01AA4:  MOVF   03,W
01AA6:  BNZ   1AB6
01AA8:  MOVLW  2A
01AAA:  SUBWF  00,W
01AAC:  MOVLB  0
01AAE:  BTFSC  FD8.2
01AB0:  GOTO   22A2
01AB4:  MOVLB  9
01AB6:  MOVF   03,W
01AB8:  BNZ   1AC8
01ABA:  MOVLW  2B
01ABC:  SUBWF  00,W
01ABE:  MOVLB  0
01AC0:  BTFSC  FD8.2
01AC2:  GOTO   22BC
01AC6:  MOVLB  9
01AC8:  MOVF   03,W
01ACA:  BNZ   1ADA
01ACC:  MOVLW  2C
01ACE:  SUBWF  00,W
01AD0:  MOVLB  0
01AD2:  BTFSC  FD8.2
01AD4:  GOTO   22CC
01AD8:  MOVLB  9
01ADA:  MOVF   03,W
01ADC:  BNZ   1AEC
01ADE:  MOVLW  2D
01AE0:  SUBWF  00,W
01AE2:  MOVLB  0
01AE4:  BTFSC  FD8.2
01AE6:  GOTO   22DC
01AEA:  MOVLB  9
01AEC:  MOVF   03,W
01AEE:  BNZ   1AFE
01AF0:  MOVLW  2E
01AF2:  SUBWF  00,W
01AF4:  MOVLB  0
01AF6:  BTFSC  FD8.2
01AF8:  GOTO   22EC
01AFC:  MOVLB  9
01AFE:  MOVF   03,W
01B00:  BNZ   1B10
01B02:  MOVLW  2F
01B04:  SUBWF  00,W
01B06:  MOVLB  0
01B08:  BTFSC  FD8.2
01B0A:  GOTO   22FC
01B0E:  MOVLB  9
01B10:  MOVF   03,W
01B12:  BNZ   1B22
01B14:  MOVLW  30
01B16:  SUBWF  00,W
01B18:  MOVLB  0
01B1A:  BTFSC  FD8.2
01B1C:  GOTO   230C
01B20:  MOVLB  9
01B22:  MOVF   03,W
01B24:  BNZ   1B34
01B26:  MOVLW  31
01B28:  SUBWF  00,W
01B2A:  MOVLB  0
01B2C:  BTFSC  FD8.2
01B2E:  GOTO   231C
01B32:  MOVLB  9
01B34:  MOVF   03,W
01B36:  BNZ   1B46
01B38:  MOVLW  32
01B3A:  SUBWF  00,W
01B3C:  MOVLB  0
01B3E:  BTFSC  FD8.2
01B40:  GOTO   232C
01B44:  MOVLB  9
01B46:  MOVF   03,W
01B48:  BNZ   1B58
01B4A:  MOVLW  33
01B4C:  SUBWF  00,W
01B4E:  MOVLB  0
01B50:  BTFSC  FD8.2
01B52:  GOTO   233C
01B56:  MOVLB  9
01B58:  MOVF   03,W
01B5A:  BNZ   1B6A
01B5C:  MOVLW  34
01B5E:  SUBWF  00,W
01B60:  MOVLB  0
01B62:  BTFSC  FD8.2
01B64:  GOTO   234C
01B68:  MOVLB  9
01B6A:  MOVF   03,W
01B6C:  BNZ   1B7C
01B6E:  MOVLW  35
01B70:  SUBWF  00,W
01B72:  MOVLB  0
01B74:  BTFSC  FD8.2
01B76:  GOTO   235C
01B7A:  MOVLB  9
01B7C:  MOVF   03,W
01B7E:  BNZ   1B8E
01B80:  MOVLW  36
01B82:  SUBWF  00,W
01B84:  MOVLB  0
01B86:  BTFSC  FD8.2
01B88:  GOTO   236C
01B8C:  MOVLB  9
01B8E:  MOVLW  03
01B90:  SUBWF  03,W
01B92:  BNZ   1BA2
01B94:  MOVLW  E8
01B96:  SUBWF  00,W
01B98:  MOVLB  0
01B9A:  BTFSC  FD8.2
01B9C:  GOTO   237E
01BA0:  MOVLB  9
01BA2:  MOVLW  03
01BA4:  SUBWF  03,W
01BA6:  BNZ   1BB6
01BA8:  MOVLW  E9
01BAA:  SUBWF  00,W
01BAC:  MOVLB  0
01BAE:  BTFSC  FD8.2
01BB0:  GOTO   238E
01BB4:  MOVLB  9
01BB6:  MOVLW  03
01BB8:  SUBWF  03,W
01BBA:  BNZ   1BCA
01BBC:  MOVLW  EA
01BBE:  SUBWF  00,W
01BC0:  MOVLB  0
01BC2:  BTFSC  FD8.2
01BC4:  GOTO   239C
01BC8:  MOVLB  9
01BCA:  MOVLW  03
01BCC:  SUBWF  03,W
01BCE:  BNZ   1BDE
01BD0:  MOVLW  EB
01BD2:  SUBWF  00,W
01BD4:  MOVLB  0
01BD6:  BTFSC  FD8.2
01BD8:  GOTO   23AA
01BDC:  MOVLB  9
01BDE:  MOVLW  03
01BE0:  SUBWF  03,W
01BE2:  BNZ   1BF2
01BE4:  MOVLW  EC
01BE6:  SUBWF  00,W
01BE8:  MOVLB  0
01BEA:  BTFSC  FD8.2
01BEC:  GOTO   23B8
01BF0:  MOVLB  9
01BF2:  MOVLW  03
01BF4:  SUBWF  03,W
01BF6:  BNZ   1C06
01BF8:  MOVLW  ED
01BFA:  SUBWF  00,W
01BFC:  MOVLB  0
01BFE:  BTFSC  FD8.2
01C00:  GOTO   23C6
01C04:  MOVLB  9
01C06:  MOVLW  03
01C08:  SUBWF  03,W
01C0A:  BNZ   1C1A
01C0C:  MOVLW  EE
01C0E:  SUBWF  00,W
01C10:  MOVLB  0
01C12:  BTFSC  FD8.2
01C14:  GOTO   23D4
01C18:  MOVLB  9
01C1A:  MOVLW  03
01C1C:  SUBWF  03,W
01C1E:  BNZ   1C2E
01C20:  MOVLW  EF
01C22:  SUBWF  00,W
01C24:  MOVLB  0
01C26:  BTFSC  FD8.2
01C28:  GOTO   23E4
01C2C:  MOVLB  9
01C2E:  MOVLW  03
01C30:  SUBWF  03,W
01C32:  BNZ   1C42
01C34:  MOVLW  F0
01C36:  SUBWF  00,W
01C38:  MOVLB  0
01C3A:  BTFSC  FD8.2
01C3C:  GOTO   23F2
01C40:  MOVLB  9
01C42:  MOVLW  03
01C44:  SUBWF  03,W
01C46:  BNZ   1C56
01C48:  MOVLW  F1
01C4A:  SUBWF  00,W
01C4C:  MOVLB  0
01C4E:  BTFSC  FD8.2
01C50:  GOTO   2402
01C54:  MOVLB  9
01C56:  MOVLW  03
01C58:  SUBWF  03,W
01C5A:  BNZ   1C6A
01C5C:  MOVLW  F2
01C5E:  SUBWF  00,W
01C60:  MOVLB  0
01C62:  BTFSC  FD8.2
01C64:  GOTO   2410
01C68:  MOVLB  9
01C6A:  MOVLW  03
01C6C:  SUBWF  03,W
01C6E:  BNZ   1C7E
01C70:  MOVLW  F3
01C72:  SUBWF  00,W
01C74:  MOVLB  0
01C76:  BTFSC  FD8.2
01C78:  GOTO   241E
01C7C:  MOVLB  9
01C7E:  MOVLW  03
01C80:  SUBWF  03,W
01C82:  BNZ   1C92
01C84:  MOVLW  F4
01C86:  SUBWF  00,W
01C88:  MOVLB  0
01C8A:  BTFSC  FD8.2
01C8C:  GOTO   242E
01C90:  MOVLB  9
01C92:  MOVLW  03
01C94:  SUBWF  03,W
01C96:  BNZ   1CA6
01C98:  MOVLW  F5
01C9A:  SUBWF  00,W
01C9C:  MOVLB  0
01C9E:  BTFSC  FD8.2
01CA0:  GOTO   243E
01CA4:  MOVLB  9
01CA6:  MOVLW  19
01CA8:  SUBWF  03,W
01CAA:  BNZ   1CBA
01CAC:  MOVLW  64
01CAE:  SUBWF  00,W
01CB0:  MOVLB  0
01CB2:  BTFSC  FD8.2
01CB4:  GOTO   24C0
01CB8:  MOVLB  9
01CBA:  MOVLW  19
01CBC:  SUBWF  03,W
01CBE:  BNZ   1CCE
01CC0:  MOVLW  65
01CC2:  SUBWF  00,W
01CC4:  MOVLB  0
01CC6:  BTFSC  FD8.2
01CC8:  GOTO   24D0
01CCC:  MOVLB  9
01CCE:  MOVLW  19
01CD0:  SUBWF  03,W
01CD2:  BNZ   1CE2
01CD4:  MOVLW  66
01CD6:  SUBWF  00,W
01CD8:  MOVLB  0
01CDA:  BTFSC  FD8.2
01CDC:  GOTO   24E2
01CE0:  MOVLB  9
01CE2:  MOVLW  19
01CE4:  SUBWF  03,W
01CE6:  BNZ   1CF6
01CE8:  MOVLW  67
01CEA:  SUBWF  00,W
01CEC:  MOVLB  0
01CEE:  BTFSC  FD8.2
01CF0:  GOTO   24F2
01CF4:  MOVLB  9
01CF6:  MOVLW  19
01CF8:  SUBWF  03,W
01CFA:  BNZ   1D0A
01CFC:  MOVLW  68
01CFE:  SUBWF  00,W
01D00:  MOVLB  0
01D02:  BTFSC  FD8.2
01D04:  GOTO   2504
01D08:  MOVLB  9
01D0A:  MOVLW  19
01D0C:  SUBWF  03,W
01D0E:  BNZ   1D1E
01D10:  MOVLW  69
01D12:  SUBWF  00,W
01D14:  MOVLB  0
01D16:  BTFSC  FD8.2
01D18:  GOTO   2514
01D1C:  MOVLB  9
01D1E:  MOVLW  19
01D20:  SUBWF  03,W
01D22:  BNZ   1D32
01D24:  MOVLW  6A
01D26:  SUBWF  00,W
01D28:  MOVLB  0
01D2A:  BTFSC  FD8.2
01D2C:  GOTO   2526
01D30:  MOVLB  9
01D32:  MOVLW  19
01D34:  SUBWF  03,W
01D36:  BNZ   1D46
01D38:  MOVLW  6B
01D3A:  SUBWF  00,W
01D3C:  MOVLB  0
01D3E:  BTFSC  FD8.2
01D40:  GOTO   2536
01D44:  MOVLB  9
01D46:  MOVLW  19
01D48:  SUBWF  03,W
01D4A:  BNZ   1D5A
01D4C:  MOVLW  6C
01D4E:  SUBWF  00,W
01D50:  MOVLB  0
01D52:  BTFSC  FD8.2
01D54:  GOTO   2548
01D58:  MOVLB  9
01D5A:  MOVLW  19
01D5C:  SUBWF  03,W
01D5E:  BNZ   1D6E
01D60:  MOVLW  6D
01D62:  SUBWF  00,W
01D64:  MOVLB  0
01D66:  BTFSC  FD8.2
01D68:  GOTO   2558
01D6C:  MOVLB  9
01D6E:  MOVLW  19
01D70:  SUBWF  03,W
01D72:  BNZ   1D82
01D74:  MOVLW  6E
01D76:  SUBWF  00,W
01D78:  MOVLB  0
01D7A:  BTFSC  FD8.2
01D7C:  GOTO   256A
01D80:  MOVLB  9
01D82:  MOVLW  19
01D84:  SUBWF  03,W
01D86:  BNZ   1D96
01D88:  MOVLW  6F
01D8A:  SUBWF  00,W
01D8C:  MOVLB  0
01D8E:  BTFSC  FD8.2
01D90:  GOTO   257A
01D94:  MOVLB  9
01D96:  MOVLW  19
01D98:  SUBWF  03,W
01D9A:  BNZ   1DAA
01D9C:  MOVLW  70
01D9E:  SUBWF  00,W
01DA0:  MOVLB  0
01DA2:  BTFSC  FD8.2
01DA4:  GOTO   258C
01DA8:  MOVLB  9
01DAA:  MOVLW  19
01DAC:  SUBWF  03,W
01DAE:  BNZ   1DBE
01DB0:  MOVLW  71
01DB2:  SUBWF  00,W
01DB4:  MOVLB  0
01DB6:  BTFSC  FD8.2
01DB8:  GOTO   259C
01DBC:  MOVLB  9
01DBE:  MOVLW  19
01DC0:  SUBWF  03,W
01DC2:  BNZ   1DD2
01DC4:  MOVLW  72
01DC6:  SUBWF  00,W
01DC8:  MOVLB  0
01DCA:  BTFSC  FD8.2
01DCC:  GOTO   25AE
01DD0:  MOVLB  9
01DD2:  MOVLW  19
01DD4:  SUBWF  03,W
01DD6:  BNZ   1DE6
01DD8:  MOVLW  73
01DDA:  SUBWF  00,W
01DDC:  MOVLB  0
01DDE:  BTFSC  FD8.2
01DE0:  GOTO   25BE
01DE4:  MOVLB  9
01DE6:  MOVLW  19
01DE8:  SUBWF  03,W
01DEA:  BNZ   1DFA
01DEC:  MOVLW  74
01DEE:  SUBWF  00,W
01DF0:  MOVLB  0
01DF2:  BTFSC  FD8.2
01DF4:  GOTO   25D0
01DF8:  MOVLB  9
01DFA:  MOVLW  19
01DFC:  SUBWF  03,W
01DFE:  BNZ   1E0E
01E00:  MOVLW  75
01E02:  SUBWF  00,W
01E04:  MOVLB  0
01E06:  BTFSC  FD8.2
01E08:  GOTO   25E0
01E0C:  MOVLB  9
01E0E:  MOVLW  19
01E10:  SUBWF  03,W
01E12:  BNZ   1E22
01E14:  MOVLW  76
01E16:  SUBWF  00,W
01E18:  MOVLB  0
01E1A:  BTFSC  FD8.2
01E1C:  GOTO   25F2
01E20:  MOVLB  9
01E22:  MOVLW  19
01E24:  SUBWF  03,W
01E26:  BNZ   1E36
01E28:  MOVLW  77
01E2A:  SUBWF  00,W
01E2C:  MOVLB  0
01E2E:  BTFSC  FD8.2
01E30:  GOTO   2602
01E34:  MOVLB  9
01E36:  MOVLW  19
01E38:  SUBWF  03,W
01E3A:  BNZ   1E4A
01E3C:  MOVLW  78
01E3E:  SUBWF  00,W
01E40:  MOVLB  0
01E42:  BTFSC  FD8.2
01E44:  GOTO   2614
01E48:  MOVLB  9
01E4A:  MOVLW  19
01E4C:  SUBWF  03,W
01E4E:  BNZ   1E5E
01E50:  MOVLW  79
01E52:  SUBWF  00,W
01E54:  MOVLB  0
01E56:  BTFSC  FD8.2
01E58:  GOTO   2624
01E5C:  MOVLB  9
01E5E:  MOVLW  19
01E60:  SUBWF  03,W
01E62:  BNZ   1E72
01E64:  MOVLW  7A
01E66:  SUBWF  00,W
01E68:  MOVLB  0
01E6A:  BTFSC  FD8.2
01E6C:  GOTO   2636
01E70:  MOVLB  9
01E72:  MOVLW  19
01E74:  SUBWF  03,W
01E76:  BNZ   1E86
01E78:  MOVLW  7B
01E7A:  SUBWF  00,W
01E7C:  MOVLB  0
01E7E:  BTFSC  FD8.2
01E80:  GOTO   2646
01E84:  MOVLB  9
01E86:  GOTO   2656
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01E8A:  MOVFF  A9,01
01E8E:  MOVFF  AA,02
01E92:  MOVLB  9
01E94:  GOTO   265E
01E98:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01E9A:  MOVF   x97,W
01E9C:  MOVWF  01
01E9E:  MOVF   x98,W
01EA0:  MOVWF  02
01EA2:  MOVLB  9
01EA4:  GOTO   265E
01EA8:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01EAA:  MOVF   x9D,W
01EAC:  MOVWF  01
01EAE:  MOVF   x9E,W
01EB0:  MOVWF  02
01EB2:  MOVLB  9
01EB4:  GOTO   265E
01EB8:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
01EBA:  MOVF   xA3,W
01EBC:  MOVWF  01
01EBE:  MOVF   xA4,W
01EC0:  MOVWF  02
01EC2:  MOVLB  9
01EC4:  GOTO   265E
01EC8:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
01ECA:  MOVLB  9
01ECC:  CLRF   x18
01ECE:  MOVLB  0
01ED0:  CALL   14B2
01ED4:  MOVFF  03,8F2
01ED8:  MOVFF  02,8F1
01EDC:  MOVFF  01,8F0
01EE0:  MOVFF  00,8EF
01EE4:  MOVLB  8
01EE6:  MOVF   xEF,W
01EE8:  MOVWF  01
01EEA:  MOVF   xF0,W
01EEC:  MOVWF  02
01EEE:  MOVLB  9
01EF0:  GOTO   265E
01EF4:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
01EF6:  MOVLB  8
01EF8:  MOVF   xF1,W
01EFA:  MOVWF  01
01EFC:  MOVF   xF2,W
01EFE:  MOVWF  02
01F00:  MOVLB  9
01F02:  GOTO   265E
01F06:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
01F08:  MOVF   xAB,W
01F0A:  MOVWF  01
01F0C:  MOVF   xAC,W
01F0E:  MOVWF  02
01F10:  MOVLB  9
01F12:  GOTO   265E
01F16:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
01F18:  MOVF   x99,W
01F1A:  MOVWF  01
01F1C:  MOVF   x9A,W
01F1E:  MOVWF  02
01F20:  MOVLB  9
01F22:  GOTO   265E
01F26:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01F28:  MOVF   x9F,W
01F2A:  MOVWF  01
01F2C:  MOVF   xA0,W
01F2E:  MOVWF  02
01F30:  MOVLB  9
01F32:  BRA    265E
01F34:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
01F36:  MOVF   xA5,W
01F38:  MOVWF  01
01F3A:  MOVF   xA6,W
01F3C:  MOVWF  02
01F3E:  MOVLB  9
01F40:  BRA    265E
01F42:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
01F44:  MOVLW  01
01F46:  MOVLB  9
01F48:  MOVWF  x18
01F4A:  MOVLB  0
01F4C:  CALL   14B2
01F50:  MOVFF  03,8F2
01F54:  MOVFF  02,8F1
01F58:  MOVFF  01,8F0
01F5C:  MOVFF  00,8EF
01F60:  MOVLB  8
01F62:  MOVF   xEF,W
01F64:  MOVWF  01
01F66:  MOVF   xF0,W
01F68:  MOVWF  02
01F6A:  MOVLB  9
01F6C:  BRA    265E
01F6E:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01F70:  MOVLB  8
01F72:  MOVF   xF1,W
01F74:  MOVWF  01
01F76:  MOVF   xF2,W
01F78:  MOVWF  02
01F7A:  MOVLB  9
01F7C:  BRA    265E
01F7E:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01F80:  MOVF   xAD,W
01F82:  MOVWF  01
01F84:  MOVF   xAE,W
01F86:  MOVWF  02
01F88:  MOVLB  9
01F8A:  BRA    265E
01F8C:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01F8E:  MOVF   x9B,W
01F90:  MOVWF  01
01F92:  MOVF   x9C,W
01F94:  MOVWF  02
01F96:  MOVLB  9
01F98:  BRA    265E
01F9A:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
01F9C:  MOVF   xA1,W
01F9E:  MOVWF  01
01FA0:  MOVF   xA2,W
01FA2:  MOVWF  02
01FA4:  MOVLB  9
01FA6:  BRA    265E
01FA8:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
01FAA:  MOVF   xA7,W
01FAC:  MOVWF  01
01FAE:  MOVF   xA8,W
01FB0:  MOVWF  02
01FB2:  MOVLB  9
01FB4:  BRA    265E
01FB6:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
01FB8:  MOVLW  02
01FBA:  MOVLB  9
01FBC:  MOVWF  x18
01FBE:  MOVLB  0
01FC0:  CALL   14B2
01FC4:  MOVFF  03,8F2
01FC8:  MOVFF  02,8F1
01FCC:  MOVFF  01,8F0
01FD0:  MOVFF  00,8EF
01FD4:  MOVLB  8
01FD6:  MOVF   xEF,W
01FD8:  MOVWF  01
01FDA:  MOVF   xF0,W
01FDC:  MOVWF  02
01FDE:  MOVLB  9
01FE0:  BRA    265E
01FE2:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
01FE4:  MOVLB  8
01FE6:  MOVF   xF1,W
01FE8:  MOVWF  01
01FEA:  MOVF   xF2,W
01FEC:  MOVWF  02
01FEE:  MOVLB  9
01FF0:  BRA    265E
01FF2:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
01FF4:  CLRF   03
01FF6:  MOVLB  1
01FF8:  MOVF   xCB,W
01FFA:  MOVWF  02
01FFC:  BCF    FD8.0
01FFE:  RLCF   02,F
02000:  RLCF   03,F
02002:  MOVF   02,W
02004:  ADDLW  CB
02006:  MOVWF  FE9
02008:  MOVLW  00
0200A:  ADDWFC 03,W
0200C:  MOVWF  FEA
0200E:  MOVFF  FEC,03
02012:  MOVF   FED,F
02014:  MOVF   FEF,W
02016:  MOVWF  01
02018:  MOVF   03,W
0201A:  MOVWF  02
0201C:  MOVLB  9
0201E:  BRA    265E
02020:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
02022:  MOVLB  9
02024:  CLRF   x18
02026:  MOVLB  0
02028:  CALL   1514
0202C:  MOVF   01,W
0202E:  MOVWF  01
02030:  MOVF   02,W
02032:  MOVWF  02
02034:  MOVLB  9
02036:  BRA    265E
02038:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
0203A:  MOVF   xBB,W
0203C:  MOVWF  01
0203E:  MOVF   xBC,W
02040:  MOVWF  02
02042:  MOVLB  9
02044:  BRA    265E
02046:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
02048:  CLRF   03
0204A:  MOVLB  1
0204C:  MOVF   xCB,W
0204E:  MOVWF  02
02050:  BCF    FD8.0
02052:  RLCF   02,F
02054:  RLCF   03,F
02056:  MOVF   02,W
02058:  ADDLW  EB
0205A:  MOVWF  FE9
0205C:  MOVLW  00
0205E:  ADDWFC 03,W
02060:  MOVWF  FEA
02062:  MOVFF  FEC,03
02066:  MOVF   FED,F
02068:  MOVF   FEF,W
0206A:  MOVWF  01
0206C:  MOVF   03,W
0206E:  MOVWF  02
02070:  MOVLB  9
02072:  BRA    265E
02074:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
02076:  MOVLW  01
02078:  MOVLB  9
0207A:  MOVWF  x18
0207C:  MOVLB  0
0207E:  CALL   1514
02082:  MOVF   01,W
02084:  MOVWF  01
02086:  MOVF   02,W
02088:  MOVWF  02
0208A:  MOVLB  9
0208C:  BRA    265E
0208E:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
02090:  MOVF   xBD,W
02092:  MOVWF  01
02094:  MOVF   xBE,W
02096:  MOVWF  02
02098:  MOVLB  9
0209A:  BRA    265E
0209C:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0209E:  CLRF   03
020A0:  MOVLB  1
020A2:  MOVF   xCB,W
020A4:  MOVWF  02
020A6:  BCF    FD8.0
020A8:  RLCF   02,F
020AA:  RLCF   03,F
020AC:  MOVF   02,W
020AE:  ADDLW  0B
020B0:  MOVWF  FE9
020B2:  MOVLW  01
020B4:  ADDWFC 03,W
020B6:  MOVWF  FEA
020B8:  MOVFF  FEC,03
020BC:  MOVF   FED,F
020BE:  MOVF   FEF,W
020C0:  MOVWF  01
020C2:  MOVF   03,W
020C4:  MOVWF  02
020C6:  MOVLB  9
020C8:  BRA    265E
020CA:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
020CC:  MOVLW  02
020CE:  MOVLB  9
020D0:  MOVWF  x18
020D2:  MOVLB  0
020D4:  CALL   1514
020D8:  MOVF   01,W
020DA:  MOVWF  01
020DC:  MOVF   02,W
020DE:  MOVWF  02
020E0:  MOVLB  9
020E2:  BRA    265E
020E4:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
020E6:  MOVF   xBF,W
020E8:  MOVWF  01
020EA:  MOVF   xC0,W
020EC:  MOVWF  02
020EE:  MOVLB  9
020F0:  BRA    265E
020F2:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
020F4:  CLRF   03
020F6:  MOVLB  1
020F8:  MOVF   xCB,W
020FA:  MOVWF  02
020FC:  BCF    FD8.0
020FE:  RLCF   02,F
02100:  RLCF   03,F
02102:  MOVF   02,W
02104:  ADDLW  2B
02106:  MOVWF  FE9
02108:  MOVLW  01
0210A:  ADDWFC 03,W
0210C:  MOVWF  FEA
0210E:  MOVFF  FEC,03
02112:  MOVF   FED,F
02114:  MOVF   FEF,W
02116:  MOVWF  01
02118:  MOVF   03,W
0211A:  MOVWF  02
0211C:  MOVLB  9
0211E:  BRA    265E
02120:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
02122:  MOVLW  03
02124:  MOVLB  9
02126:  MOVWF  x18
02128:  MOVLB  0
0212A:  CALL   1514
0212E:  MOVF   01,W
02130:  MOVWF  01
02132:  MOVF   02,W
02134:  MOVWF  02
02136:  MOVLB  9
02138:  BRA    265E
0213A:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
0213C:  MOVF   xC1,W
0213E:  MOVWF  01
02140:  MOVF   xC2,W
02142:  MOVWF  02
02144:  MOVLB  9
02146:  BRA    265E
02148:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
0214A:  CLRF   03
0214C:  MOVLB  1
0214E:  MOVF   xCB,W
02150:  MOVWF  02
02152:  BCF    FD8.0
02154:  RLCF   02,F
02156:  RLCF   03,F
02158:  MOVF   02,W
0215A:  ADDLW  4B
0215C:  MOVWF  FE9
0215E:  MOVLW  01
02160:  ADDWFC 03,W
02162:  MOVWF  FEA
02164:  MOVFF  FEC,03
02168:  MOVF   FED,F
0216A:  MOVF   FEF,W
0216C:  MOVWF  01
0216E:  MOVF   03,W
02170:  MOVWF  02
02172:  MOVLB  9
02174:  BRA    265E
02176:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
02178:  MOVLW  04
0217A:  MOVLB  9
0217C:  MOVWF  x18
0217E:  MOVLB  0
02180:  CALL   1514
02184:  MOVF   01,W
02186:  MOVWF  01
02188:  MOVF   02,W
0218A:  MOVWF  02
0218C:  MOVLB  9
0218E:  BRA    265E
02190:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
02192:  MOVF   xC3,W
02194:  MOVWF  01
02196:  MOVF   xC4,W
02198:  MOVWF  02
0219A:  MOVLB  9
0219C:  BRA    265E
0219E:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
021A0:  CLRF   03
021A2:  MOVLB  1
021A4:  MOVF   xCB,W
021A6:  MOVWF  02
021A8:  BCF    FD8.0
021AA:  RLCF   02,F
021AC:  RLCF   03,F
021AE:  MOVF   02,W
021B0:  ADDLW  6B
021B2:  MOVWF  FE9
021B4:  MOVLW  01
021B6:  ADDWFC 03,W
021B8:  MOVWF  FEA
021BA:  MOVFF  FEC,03
021BE:  MOVF   FED,F
021C0:  MOVF   FEF,W
021C2:  MOVWF  01
021C4:  MOVF   03,W
021C6:  MOVWF  02
021C8:  MOVLB  9
021CA:  BRA    265E
021CC:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
021CE:  MOVLW  05
021D0:  MOVLB  9
021D2:  MOVWF  x18
021D4:  MOVLB  0
021D6:  CALL   1514
021DA:  MOVF   01,W
021DC:  MOVWF  01
021DE:  MOVF   02,W
021E0:  MOVWF  02
021E2:  MOVLB  9
021E4:  BRA    265E
021E6:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
021E8:  MOVF   xC5,W
021EA:  MOVWF  01
021EC:  MOVF   xC6,W
021EE:  MOVWF  02
021F0:  MOVLB  9
021F2:  BRA    265E
021F4:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
021F6:  CLRF   03
021F8:  MOVLB  1
021FA:  MOVF   xCB,W
021FC:  MOVWF  02
021FE:  BCF    FD8.0
02200:  RLCF   02,F
02202:  RLCF   03,F
02204:  MOVF   02,W
02206:  ADDLW  8B
02208:  MOVWF  FE9
0220A:  MOVLW  01
0220C:  ADDWFC 03,W
0220E:  MOVWF  FEA
02210:  MOVFF  FEC,03
02214:  MOVF   FED,F
02216:  MOVF   FEF,W
02218:  MOVWF  01
0221A:  MOVF   03,W
0221C:  MOVWF  02
0221E:  MOVLB  9
02220:  BRA    265E
02222:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
02224:  MOVLW  06
02226:  MOVLB  9
02228:  MOVWF  x18
0222A:  MOVLB  0
0222C:  CALL   1514
02230:  MOVF   01,W
02232:  MOVWF  01
02234:  MOVF   02,W
02236:  MOVWF  02
02238:  MOVLB  9
0223A:  BRA    265E
0223C:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
0223E:  MOVF   xC7,W
02240:  MOVWF  01
02242:  MOVF   xC8,W
02244:  MOVWF  02
02246:  MOVLB  9
02248:  BRA    265E
0224A:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
0224C:  CLRF   03
0224E:  MOVLB  1
02250:  MOVF   xCB,W
02252:  MOVWF  02
02254:  BCF    FD8.0
02256:  RLCF   02,F
02258:  RLCF   03,F
0225A:  MOVF   02,W
0225C:  ADDLW  AB
0225E:  MOVWF  FE9
02260:  MOVLW  01
02262:  ADDWFC 03,W
02264:  MOVWF  FEA
02266:  MOVFF  FEC,03
0226A:  MOVF   FED,F
0226C:  MOVF   FEF,W
0226E:  MOVWF  01
02270:  MOVF   03,W
02272:  MOVWF  02
02274:  MOVLB  9
02276:  BRA    265E
02278:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
0227A:  MOVLW  07
0227C:  MOVLB  9
0227E:  MOVWF  x18
02280:  MOVLB  0
02282:  CALL   1514
02286:  MOVF   01,W
02288:  MOVWF  01
0228A:  MOVF   02,W
0228C:  MOVWF  02
0228E:  MOVLB  9
02290:  BRA    265E
02292:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
02294:  MOVF   xC9,W
02296:  MOVWF  01
02298:  MOVF   xCA,W
0229A:  MOVWF  02
0229C:  MOVLB  9
0229E:  BRA    265E
022A0:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
022A2:  MOVLB  1
022A4:  MOVF   xD3,W
022A6:  MOVWF  03
022A8:  MOVF   xD2,W
022AA:  INCF   xD2,F
022AC:  BTFSC  FD8.2
022AE:  INCF   xD3,F
022B0:  MOVWF  01
022B2:  MOVF   03,W
022B4:  MOVWF  02
022B6:  MOVLB  9
022B8:  BRA    265E
022BA:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
022BC:  MOVLB  1
022BE:  MOVF   xD6,W
022C0:  MOVWF  01
022C2:  MOVF   xD7,W
022C4:  MOVWF  02
022C6:  MOVLB  9
022C8:  BRA    265E
022CA:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
022CC:  MOVLB  1
022CE:  MOVF   xD4,W
022D0:  MOVWF  01
022D2:  MOVF   xD5,W
022D4:  MOVWF  02
022D6:  MOVLB  9
022D8:  BRA    265E
022DA:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
022DC:  MOVLB  1
022DE:  MOVF   xD9,W
022E0:  MOVWF  01
022E2:  MOVF   xDA,W
022E4:  MOVWF  02
022E6:  MOVLB  9
022E8:  BRA    265E
022EA:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
022EC:  GOTO   159E
022F0:  MOVLW  00
022F2:  MOVWF  01
022F4:  MOVWF  02
022F6:  MOVLB  9
022F8:  BRA    265E
022FA:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
022FC:  GOTO   15DA
02300:  MOVLW  00
02302:  MOVWF  01
02304:  MOVWF  02
02306:  MOVLB  9
02308:  BRA    265E
0230A:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
0230C:  MOVLB  1
0230E:  MOVF   xCC,W
02310:  MOVWF  01
02312:  MOVF   xCD,W
02314:  MOVWF  02
02316:  MOVLB  9
02318:  BRA    265E
0231A:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
0231C:  MOVLB  1
0231E:  MOVF   xCE,W
02320:  MOVWF  01
02322:  MOVF   xCF,W
02324:  MOVWF  02
02326:  MOVLB  9
02328:  BRA    265E
0232A:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
0232C:  MOVLB  1
0232E:  MOVF   xD0,W
02330:  MOVWF  01
02332:  MOVF   xD1,W
02334:  MOVWF  02
02336:  MOVLB  9
02338:  BRA    265E
0233A:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
0233C:  GOTO   1602
02340:  MOVLW  00
02342:  MOVWF  01
02344:  MOVWF  02
02346:  MOVLB  9
02348:  BRA    265E
0234A:  MOVLB  0
.................... 		 
.................... 		/* meta */ 
.................... 		case 52: return (int16) current.rda_bytes_received; 
0234C:  MOVLB  1
0234E:  MOVF   xE2,W
02350:  MOVWF  01
02352:  MOVF   xE3,W
02354:  MOVWF  02
02356:  MOVLB  9
02358:  BRA    265E
0235A:  MOVLB  0
.................... 		case 53: return (int16) current.rda2_bytes_received; 
0235C:  MOVLB  1
0235E:  MOVF   xE4,W
02360:  MOVWF  01
02362:  MOVF   xE5,W
02364:  MOVWF  02
02366:  MOVLB  9
02368:  BRA    265E
0236A:  MOVLB  0
.................... 		case 54: return (int16) current.button_state; 
0236C:  CLRF   03
0236E:  MOVLB  1
02370:  MOVF   xE6,W
02372:  MOVWF  01
02374:  MOVF   03,W
02376:  MOVWF  02
02378:  MOVLB  9
0237A:  BRA    265E
0237C:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return (int16) config.serial_prefix; 
0237E:  CLRF   03
02380:  MOVF   3A,W
02382:  MOVWF  01
02384:  MOVF   03,W
02386:  MOVWF  02
02388:  MOVLB  9
0238A:  BRA    265E
0238C:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
0238E:  MOVF   3B,W
02390:  MOVWF  01
02392:  MOVF   3C,W
02394:  MOVWF  02
02396:  MOVLB  9
02398:  BRA    265E
0239A:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
0239C:  MOVLW  50
0239E:  MOVWF  01
023A0:  MOVLW  00
023A2:  MOVWF  02
023A4:  MOVLB  9
023A6:  BRA    265E
023A8:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
023AA:  MOVLW  57
023AC:  MOVWF  01
023AE:  MOVLW  00
023B0:  MOVWF  02
023B2:  MOVLB  9
023B4:  BRA    265E
023B6:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
023B8:  MOVLW  58
023BA:  MOVWF  01
023BC:  MOVLW  00
023BE:  MOVWF  02
023C0:  MOVLB  9
023C2:  BRA    265E
023C4:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
023C6:  MOVLW  01
023C8:  MOVWF  01
023CA:  MOVLW  00
023CC:  MOVWF  02
023CE:  MOVLB  9
023D0:  BRA    265E
023D2:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
023D4:  CLRF   03
023D6:  MOVF   36,W
023D8:  MOVWF  01
023DA:  MOVF   03,W
023DC:  MOVWF  02
023DE:  MOVLB  9
023E0:  BRA    265E
023E2:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
023E4:  MOVF   3D,W
023E6:  MOVWF  01
023E8:  MOVF   3E,W
023EA:  MOVWF  02
023EC:  MOVLB  9
023EE:  BRA    265E
023F0:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
023F2:  CLRF   03
023F4:  MOVF   3F,W
023F6:  MOVWF  01
023F8:  MOVF   03,W
023FA:  MOVWF  02
023FC:  MOVLB  9
023FE:  BRA    265E
02400:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
02402:  MOVF   40,W
02404:  MOVWF  01
02406:  MOVF   41,W
02408:  MOVWF  02
0240A:  MOVLB  9
0240C:  BRA    265E
0240E:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
02410:  MOVF   42,W
02412:  MOVWF  01
02414:  MOVF   43,W
02416:  MOVWF  02
02418:  MOVLB  9
0241A:  BRA    265E
0241C:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
0241E:  CLRF   03
02420:  MOVF   44,W
02422:  MOVWF  01
02424:  MOVF   03,W
02426:  MOVWF  02
02428:  MOVLB  9
0242A:  BRA    265E
0242C:  MOVLB  0
.................... 		case 1012: return (int16) config.rs485_port_mode; 
0242E:  CLRF   03
02430:  MOVF   38,W
02432:  MOVWF  01
02434:  MOVF   03,W
02436:  MOVWF  02
02438:  MOVLB  9
0243A:  BRA    265E
0243C:  MOVLB  0
.................... 		case 1013:  
.................... 			if ( RS485_SPEED_1200 == config.rs485_port_speed )  return (int16) 1200; 
0243E:  MOVF   39,F
02440:  BNZ   2450
02442:  MOVLW  B0
02444:  MOVWF  01
02446:  MOVLW  04
02448:  MOVWF  02
0244A:  MOVLB  9
0244C:  BRA    265E
0244E:  MOVLB  0
.................... 			if ( RS485_SPEED_2400 == config.rs485_port_speed )  return (int16) 2400; 
02450:  DECFSZ 39,W
02452:  BRA    2462
02454:  MOVLW  60
02456:  MOVWF  01
02458:  MOVLW  09
0245A:  MOVWF  02
0245C:  MOVLB  9
0245E:  BRA    265E
02460:  MOVLB  0
.................... 			if ( RS485_SPEED_4800 == config.rs485_port_speed )  return (int16) 4800; 
02462:  MOVF   39,W
02464:  SUBLW  02
02466:  BNZ   2476
02468:  MOVLW  C0
0246A:  MOVWF  01
0246C:  MOVLW  12
0246E:  MOVWF  02
02470:  MOVLB  9
02472:  BRA    265E
02474:  MOVLB  0
.................... 			if ( RS485_SPEED_19200 == config.rs485_port_speed ) return (int16) 19200; 
02476:  MOVF   39,W
02478:  SUBLW  04
0247A:  BNZ   248A
0247C:  MOVLW  00
0247E:  MOVWF  01
02480:  MOVLW  4B
02482:  MOVWF  02
02484:  MOVLB  9
02486:  BRA    265E
02488:  MOVLB  0
.................... 			if ( RS485_SPEED_38400 == config.rs485_port_speed ) return (int16) 38400; 
0248A:  MOVF   39,W
0248C:  SUBLW  05
0248E:  BNZ   249E
02490:  MOVLW  00
02492:  MOVWF  01
02494:  MOVLW  96
02496:  MOVWF  02
02498:  MOVLB  9
0249A:  BRA    265E
0249C:  MOVLB  0
.................... 			if ( RS485_SPEED_57600 == config.rs485_port_speed ) return (int16) 57600; 
0249E:  MOVF   39,W
024A0:  SUBLW  06
024A2:  BNZ   24B2
024A4:  MOVLW  00
024A6:  MOVWF  01
024A8:  MOVLW  E1
024AA:  MOVWF  02
024AC:  MOVLB  9
024AE:  BRA    265E
024B0:  MOVLB  0
....................  
.................... 			return (int16) 9600; 
024B2:  MOVLW  80
024B4:  MOVWF  01
024B6:  MOVLW  25
024B8:  MOVWF  02
024BA:  MOVLB  9
024BC:  BRA    265E
024BE:  MOVLB  0
....................  
.................... 		/* NMEA sentence age and length */ 
.................... 		case 6500: return (int16) nmea.sentence_age[0]; 
024C0:  MOVLB  7
024C2:  MOVF   xC4,W
024C4:  MOVWF  01
024C6:  MOVF   xC5,W
024C8:  MOVWF  02
024CA:  MOVLB  9
024CC:  BRA    265E
024CE:  MOVLB  0
.................... 		case 6501: return (int16) nmea.sentence_length[0]; 
024D0:  CLRF   03
024D2:  MOVLB  7
024D4:  MOVF   xDC,W
024D6:  MOVWF  01
024D8:  MOVF   03,W
024DA:  MOVWF  02
024DC:  MOVLB  9
024DE:  BRA    265E
024E0:  MOVLB  0
.................... 		case 6502: return (int16) nmea.sentence_age[1]; 
024E2:  MOVLB  7
024E4:  MOVF   xC6,W
024E6:  MOVWF  01
024E8:  MOVF   xC7,W
024EA:  MOVWF  02
024EC:  MOVLB  9
024EE:  BRA    265E
024F0:  MOVLB  0
.................... 		case 6503: return (int16) nmea.sentence_length[1]; 
024F2:  CLRF   03
024F4:  MOVLB  7
024F6:  MOVF   xDD,W
024F8:  MOVWF  01
024FA:  MOVF   03,W
024FC:  MOVWF  02
024FE:  MOVLB  9
02500:  BRA    265E
02502:  MOVLB  0
.................... 		case 6504: return (int16) nmea.sentence_age[2]; 
02504:  MOVLB  7
02506:  MOVF   xC8,W
02508:  MOVWF  01
0250A:  MOVF   xC9,W
0250C:  MOVWF  02
0250E:  MOVLB  9
02510:  BRA    265E
02512:  MOVLB  0
.................... 		case 6505: return (int16) nmea.sentence_length[2]; 
02514:  CLRF   03
02516:  MOVLB  7
02518:  MOVF   xDE,W
0251A:  MOVWF  01
0251C:  MOVF   03,W
0251E:  MOVWF  02
02520:  MOVLB  9
02522:  BRA    265E
02524:  MOVLB  0
.................... 		case 6506: return (int16) nmea.sentence_age[3]; 
02526:  MOVLB  7
02528:  MOVF   xCA,W
0252A:  MOVWF  01
0252C:  MOVF   xCB,W
0252E:  MOVWF  02
02530:  MOVLB  9
02532:  BRA    265E
02534:  MOVLB  0
.................... 		case 6507: return (int16) nmea.sentence_length[3]; 
02536:  CLRF   03
02538:  MOVLB  7
0253A:  MOVF   xDF,W
0253C:  MOVWF  01
0253E:  MOVF   03,W
02540:  MOVWF  02
02542:  MOVLB  9
02544:  BRA    265E
02546:  MOVLB  0
.................... 		case 6508: return (int16) nmea.sentence_age[4]; 
02548:  MOVLB  7
0254A:  MOVF   xCC,W
0254C:  MOVWF  01
0254E:  MOVF   xCD,W
02550:  MOVWF  02
02552:  MOVLB  9
02554:  BRA    265E
02556:  MOVLB  0
.................... 		case 6509: return (int16) nmea.sentence_length[4]; 
02558:  CLRF   03
0255A:  MOVLB  7
0255C:  MOVF   xE0,W
0255E:  MOVWF  01
02560:  MOVF   03,W
02562:  MOVWF  02
02564:  MOVLB  9
02566:  BRA    265E
02568:  MOVLB  0
.................... 		case 6510: return (int16) nmea.sentence_age[5]; 
0256A:  MOVLB  7
0256C:  MOVF   xCE,W
0256E:  MOVWF  01
02570:  MOVF   xCF,W
02572:  MOVWF  02
02574:  MOVLB  9
02576:  BRA    265E
02578:  MOVLB  0
.................... 		case 6511: return (int16) nmea.sentence_length[5]; 
0257A:  CLRF   03
0257C:  MOVLB  7
0257E:  MOVF   xE1,W
02580:  MOVWF  01
02582:  MOVF   03,W
02584:  MOVWF  02
02586:  MOVLB  9
02588:  BRA    265E
0258A:  MOVLB  0
.................... 		case 6512: return (int16) nmea.sentence_age[6]; 
0258C:  MOVLB  7
0258E:  MOVF   xD0,W
02590:  MOVWF  01
02592:  MOVF   xD1,W
02594:  MOVWF  02
02596:  MOVLB  9
02598:  BRA    265E
0259A:  MOVLB  0
.................... 		case 6513: return (int16) nmea.sentence_length[6]; 
0259C:  CLRF   03
0259E:  MOVLB  7
025A0:  MOVF   xE2,W
025A2:  MOVWF  01
025A4:  MOVF   03,W
025A6:  MOVWF  02
025A8:  MOVLB  9
025AA:  BRA    265E
025AC:  MOVLB  0
.................... 		case 6514: return (int16) nmea.sentence_age[7]; 
025AE:  MOVLB  7
025B0:  MOVF   xD2,W
025B2:  MOVWF  01
025B4:  MOVF   xD3,W
025B6:  MOVWF  02
025B8:  MOVLB  9
025BA:  BRA    265E
025BC:  MOVLB  0
.................... 		case 6515: return (int16) nmea.sentence_length[7]; 
025BE:  CLRF   03
025C0:  MOVLB  7
025C2:  MOVF   xE3,W
025C4:  MOVWF  01
025C6:  MOVF   03,W
025C8:  MOVWF  02
025CA:  MOVLB  9
025CC:  BRA    265E
025CE:  MOVLB  0
.................... 		case 6516: return (int16) nmea.sentence_age[8]; 
025D0:  MOVLB  7
025D2:  MOVF   xD4,W
025D4:  MOVWF  01
025D6:  MOVF   xD5,W
025D8:  MOVWF  02
025DA:  MOVLB  9
025DC:  BRA    265E
025DE:  MOVLB  0
.................... 		case 6517: return (int16) nmea.sentence_length[8]; 
025E0:  CLRF   03
025E2:  MOVLB  7
025E4:  MOVF   xE4,W
025E6:  MOVWF  01
025E8:  MOVF   03,W
025EA:  MOVWF  02
025EC:  MOVLB  9
025EE:  BRA    265E
025F0:  MOVLB  0
.................... 		case 6518: return (int16) nmea.sentence_age[9]; 
025F2:  MOVLB  7
025F4:  MOVF   xD6,W
025F6:  MOVWF  01
025F8:  MOVF   xD7,W
025FA:  MOVWF  02
025FC:  MOVLB  9
025FE:  BRA    265E
02600:  MOVLB  0
.................... 		case 6519: return (int16) nmea.sentence_length[9]; 
02602:  CLRF   03
02604:  MOVLB  7
02606:  MOVF   xE5,W
02608:  MOVWF  01
0260A:  MOVF   03,W
0260C:  MOVWF  02
0260E:  MOVLB  9
02610:  BRA    265E
02612:  MOVLB  0
.................... 		case 6520: return (int16) nmea.sentence_age[10]; 
02614:  MOVLB  7
02616:  MOVF   xD8,W
02618:  MOVWF  01
0261A:  MOVF   xD9,W
0261C:  MOVWF  02
0261E:  MOVLB  9
02620:  BRA    265E
02622:  MOVLB  0
.................... 		case 6521: return (int16) nmea.sentence_length[10]; 
02624:  CLRF   03
02626:  MOVLB  7
02628:  MOVF   xE6,W
0262A:  MOVWF  01
0262C:  MOVF   03,W
0262E:  MOVWF  02
02630:  MOVLB  9
02632:  BRA    265E
02634:  MOVLB  0
.................... 		case 6522: return (int16) nmea.sentence_age[11]; 
02636:  MOVLB  7
02638:  MOVF   xDA,W
0263A:  MOVWF  01
0263C:  MOVF   xDB,W
0263E:  MOVWF  02
02640:  MOVLB  9
02642:  BRA    265E
02644:  MOVLB  0
.................... 		case 6523: return (int16) nmea.sentence_length[11]; 
02646:  CLRF   03
02648:  MOVLB  7
0264A:  MOVF   xE7,W
0264C:  MOVWF  01
0264E:  MOVF   03,W
02650:  MOVWF  02
02652:  MOVLB  9
02654:  BRA    265E
....................  
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
02656:  MOVLW  FF
02658:  MOVWF  01
0265A:  MOVWF  02
0265C:  BRA    265E
.................... 	} 
....................  
.................... } 
0265E:  MOVLB  0
02660:  GOTO   26B2 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
01308:  MOVLB  9
0130A:  MOVF   x08,W
0130C:  SUBLW  1F
0130E:  BNZ   1328
01310:  MOVF   x09,W
01312:  SUBLW  4E
01314:  BNZ   1328
01316:  MOVF   x0A,W
01318:  SUBLW  20
0131A:  BNZ   1328
0131C:  MOVF   x0B,W
0131E:  SUBLW  4E
01320:  BNZ   1328
.................... 		return 1; 
01322:  MOVLW  01
01324:  MOVWF  01
01326:  BRA    1414
....................  
.................... 	if ( start >= MIN_NMEA0183_META_REGISTER && end <= MAX_NMEA0183_META_REGISTER )  
01328:  MOVF   x09,W
0132A:  SUBLW  18
0132C:  BC    134C
0132E:  XORLW  FF
01330:  BNZ   1338
01332:  MOVF   x08,W
01334:  SUBLW  63
01336:  BC    134C
01338:  MOVF   x0B,W
0133A:  SUBLW  19
0133C:  BNC   134C
0133E:  BNZ   1346
01340:  MOVF   x0A,W
01342:  SUBLW  7C
01344:  BNC   134C
.................... 		return 1; 
01346:  MOVLW  01
01348:  MOVWF  01
0134A:  BRA    1414
....................  
.................... 	if ( start >= MIN_NMEA0183_WORD_REGISTER && end <= MAX_NMEA0183_WORD_REGISTER )  
0134C:  MOVF   x09,W
0134E:  SUBLW  16
01350:  BC    1370
01352:  XORLW  FF
01354:  BNZ   135C
01356:  MOVF   x08,W
01358:  SUBLW  6F
0135A:  BC    1370
0135C:  MOVF   x0B,W
0135E:  SUBLW  19
01360:  BNC   1370
01362:  BNZ   136A
01364:  MOVF   x0A,W
01366:  SUBLW  50
01368:  BNC   1370
.................... 		return 1; 
0136A:  MOVLW  01
0136C:  MOVWF  01
0136E:  BRA    1414
....................  
.................... 	if ( start >= MIN_NMEA0183_BYTE_REGISTER && end <= MAX_NMEA0183_BYTE_REGISTER )  
01370:  MOVF   x09,W
01372:  SUBLW  12
01374:  BC    1394
01376:  XORLW  FF
01378:  BNZ   1380
0137A:  MOVF   x08,W
0137C:  SUBLW  87
0137E:  BC    1394
01380:  MOVF   x0B,W
01382:  SUBLW  17
01384:  BNC   1394
01386:  BNZ   138E
01388:  MOVF   x0A,W
0138A:  SUBLW  48
0138C:  BNC   1394
.................... 		return 1; 
0138E:  MOVLW  01
01390:  MOVWF  01
01392:  BRA    1414
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER ) 
01394:  MOVF   x09,W
01396:  SUBLW  03
01398:  BC    13B8
0139A:  XORLW  FF
0139C:  BNZ   13A4
0139E:  MOVF   x08,W
013A0:  SUBLW  4B
013A2:  BC    13B8
013A4:  MOVF   x0B,W
013A6:  SUBLW  04
013A8:  BNC   13B8
013AA:  BNZ   13B2
013AC:  MOVF   x0A,W
013AE:  SUBLW  94
013B0:  BNC   13B8
.................... 		return 1; 
013B2:  MOVLW  01
013B4:  MOVWF  01
013B6:  BRA    1414
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
013B8:  MOVF   x09,W
013BA:  SUBLW  02
013BC:  BC    13DC
013BE:  XORLW  FF
013C0:  BNZ   13C8
013C2:  MOVF   x08,W
013C4:  SUBLW  E7
013C6:  BC    13DC
013C8:  MOVF   x0B,W
013CA:  SUBLW  03
013CC:  BNC   13DC
013CE:  BNZ   13D6
013D0:  MOVF   x0A,W
013D2:  SUBLW  F6
013D4:  BNC   13DC
.................... 		return 1; 
013D6:  MOVLW  01
013D8:  MOVWF  01
013DA:  BRA    1414
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
013DC:  MOVF   x09,W
013DE:  SUBLW  06
013E0:  BC    1400
013E2:  XORLW  FF
013E4:  BNZ   13EC
013E6:  MOVF   x08,W
013E8:  SUBLW  CF
013EA:  BC    1400
013EC:  MOVF   x0B,W
013EE:  SUBLW  09
013F0:  BNC   1400
013F2:  BNZ   13FA
013F4:  MOVF   x0A,W
013F6:  SUBLW  D1
013F8:  BNC   1400
.................... 		return 1; 
013FA:  MOVLW  01
013FC:  MOVWF  01
013FE:  BRA    1414
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01400:  MOVF   x0B,F
01402:  BNZ   1410
01404:  MOVF   x0A,W
01406:  SUBLW  37
01408:  BNC   1410
.................... 		return 1; 
0140A:  MOVLW  01
0140C:  MOVWF  01
0140E:  BRA    1414
....................  
.................... 	return 0; 
01410:  MOVLW  00
01412:  MOVWF  01
.................... } 
01414:  MOVLB  0
01416:  GOTO   2C98 (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_NMEA0183_CONFIG_REGISTER && end <= MAX_NMEA0183_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
02664:  MOVFF  907,910
02668:  MOVFF  906,911
0266C:  CALL   1452
.................... 	modbus_serial_putc(register_count*2); 
02670:  BCF    FD8.0
02672:  MOVLB  9
02674:  RLCF   x0A,W
02676:  MOVWF  x10
02678:  RLCF   x0B,W
0267A:  MOVWF  x11
0267C:  MOVFF  910,912
02680:  MOVLB  0
02682:  CALL   141A
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
02686:  MOVLB  9
02688:  CLRF   x0D
0268A:  CLRF   x0C
0268C:  MOVF   x0D,W
0268E:  SUBWF  x0B,W
02690:  BNC   26DC
02692:  BNZ   269A
02694:  MOVF   x0A,W
02696:  SUBWF  x0C,W
02698:  BC    26DC
.................... 		l=map_modbus(start_address+i); 
0269A:  MOVF   x0C,W
0269C:  ADDWF  x08,W
0269E:  MOVWF  x10
026A0:  MOVF   x0D,W
026A2:  ADDWFC x09,W
026A4:  MOVWF  x11
026A6:  MOVWF  x13
026A8:  MOVFF  910,912
026AC:  MOVLB  0
026AE:  GOTO   1616
026B2:  MOVFF  02,90F
026B6:  MOVFF  01,90E
.................... 		modbus_serial_putc(make8(l,1)); 
026BA:  MOVFF  90F,910
026BE:  MOVFF  90F,912
026C2:  CALL   141A
....................   		modbus_serial_putc(make8(l,0)); 
026C6:  MOVFF  90E,910
026CA:  MOVFF  90E,912
026CE:  CALL   141A
.................... 	} 
026D2:  MOVLB  9
026D4:  INCF   x0C,F
026D6:  BTFSC  FD8.2
026D8:  INCF   x0D,F
026DA:  BRA    268C
....................  
.................... 	modbus_serial_send_stop(); 
026DC:  MOVLB  0
026DE:  CALL   1470
.................... } 
026E2:  GOTO   2CDA (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
.................... 	int8 n,o; 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
026E6:  MOVLB  9
026E8:  MOVF   x0D,W
026EA:  SUBLW  06
026EC:  BC    2764
026EE:  XORLW  FF
026F0:  BNZ   26F8
026F2:  MOVF   x0C,W
026F4:  SUBLW  CF
026F6:  BC    2764
026F8:  MOVF   x0D,W
026FA:  SUBLW  09
026FC:  BNC   2764
026FE:  BNZ   2706
02700:  MOVF   x0C,W
02702:  SUBLW  CF
02704:  BNC   2764
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02706:  MOVF   x0F,W
02708:  SUBLW  00
0270A:  BC    271C
0270C:  XORLW  FF
0270E:  BNZ   2716
02710:  MOVF   x0E,W
02712:  SUBLW  00
02714:  BC    271C
02716:  MOVLW  03
02718:  MOVWF  01
0271A:  BRA    2AC8
.................... 		write_eeprom(address - MIN_EE_REGISTER + EE_FOR_HOST_ADDRESS,(int8) value); 
0271C:  MOVLW  D0
0271E:  SUBWF  x0C,W
02720:  MOVWF  x12
02722:  MOVLW  07
02724:  SUBWFB x0D,W
02726:  MOVWF  x13
02728:  MOVLW  02
0272A:  ADDWF  x13,F
0272C:  MOVFF  913,FAA
02730:  MOVFF  912,FA9
02734:  MOVFF  90E,FA8
02738:  BCF    FA6.6
0273A:  BCF    FA6.7
0273C:  BSF    FA6.2
0273E:  MOVF   FF2,W
02740:  MOVWF  00
02742:  BCF    FF2.6
02744:  BCF    FF2.7
02746:  MOVLB  F
02748:  MOVLW  55
0274A:  MOVWF  FA7
0274C:  MOVLW  AA
0274E:  MOVWF  FA7
02750:  BSF    FA6.1
02752:  BTFSC  FA6.1
02754:  BRA    2752
02756:  BCF    FA6.2
02758:  MOVF   00,W
0275A:  IORWF  FF2,F
.................... 		return 0; 
0275C:  MOVLW  00
0275E:  MOVWF  01
02760:  MOVLB  9
02762:  BRA    2AC8
.................... 	} 
....................  
.................... 	if ( address >= MIN_NMEA0183_CONFIG_REGISTER && address < MAX_NMEA0183_CONFIG_REGISTER ) { 
02764:  MOVF   x0D,W
02766:  SUBLW  03
02768:  BC    27FA
0276A:  XORLW  FF
0276C:  BNZ   2774
0276E:  MOVF   x0C,W
02770:  SUBLW  4B
02772:  BC    27FA
02774:  MOVF   x0D,W
02776:  SUBLW  04
02778:  BNC   27FA
0277A:  BNZ   2782
0277C:  MOVF   x0C,W
0277E:  SUBLW  93
02780:  BNC   27FA
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
02782:  MOVF   x0F,W
02784:  SUBLW  00
02786:  BC    2798
02788:  XORLW  FF
0278A:  BNZ   2792
0278C:  MOVF   x0E,W
0278E:  SUBLW  00
02790:  BC    2798
02792:  MOVLW  03
02794:  MOVWF  01
02796:  BRA    2AC8
....................  
.................... 		/* get rid of our base */ 
.................... 		n = (address-MIN_NMEA0183_CONFIG_REGISTER); 
02798:  MOVLW  4C
0279A:  SUBWF  x0C,W
0279C:  MOVWF  x10
....................  
.................... 		/* configurable sentence parts are the first 6 characters */ 
.................... 		o = n % 6; /* offset into sentence */ 
0279E:  MOVFF  910,918
027A2:  MOVLW  06
027A4:  MOVWF  x19
027A6:  MOVLB  0
027A8:  CALL   0BA8
027AC:  MOVFF  00,911
.................... 		n = n / 6; /* number of sentence */ 
027B0:  MOVFF  910,918
027B4:  MOVLW  06
027B6:  MOVLB  9
027B8:  MOVWF  x19
027BA:  MOVLB  0
027BC:  CALL   0BA8
027C0:  MOVFF  01,910
....................  
.................... 		config.nmea0183_sentence[n][o]=(int8) value; 
027C4:  MOVLB  9
027C6:  MOVF   x10,W
027C8:  MULLW  06
027CA:  MOVF   FF3,W
027CC:  CLRF   03
027CE:  ADDLW  19
027D0:  MOVWF  x12
027D2:  MOVLW  00
027D4:  ADDWFC 03,W
027D6:  MOVWF  x13
027D8:  CLRF   03
027DA:  MOVF   x11,W
027DC:  ADDWF  x12,W
027DE:  MOVWF  01
027E0:  MOVF   x13,W
027E2:  ADDWFC 03,F
027E4:  MOVF   01,W
027E6:  ADDLW  36
027E8:  MOVWF  FE9
027EA:  MOVLW  00
027EC:  ADDWFC 03,W
027EE:  MOVWF  FEA
027F0:  MOVFF  90E,FEF
.................... 		 
.................... 		return 0; 
027F4:  MOVLW  00
027F6:  MOVWF  01
027F8:  BRA    2AC8
.................... 	} 
....................  
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
027FA:  MOVLB  1
027FC:  MOVF   xD8,F
027FE:  BZ    2836
.................... 		if ( 1000 == address ) { 
02800:  MOVLB  9
02802:  MOVF   x0C,W
02804:  SUBLW  E8
02806:  BNZ   281A
02808:  MOVF   x0D,W
0280A:  SUBLW  03
0280C:  BNZ   281A
.................... 			config.serial_prefix=value; 
0280E:  MOVFF  90E,3A
.................... 			return 0; 
02812:  MOVLW  00
02814:  MOVWF  01
02816:  BRA    2AC8
.................... 		} else if ( 1001 == address ) { 
02818:  BRA    2834
0281A:  MOVF   x0C,W
0281C:  SUBLW  E9
0281E:  BNZ   2834
02820:  MOVF   x0D,W
02822:  SUBLW  03
02824:  BNZ   2834
.................... 			config.serial_number=value; 
02826:  MOVFF  90F,3C
0282A:  MOVFF  90E,3B
.................... 			return 0; 
0282E:  MOVLW  00
02830:  MOVWF  01
02832:  BRA    2AC8
02834:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
02836:  MOVLB  9
02838:  MOVF   x0C,W
0283A:  MOVWF  00
0283C:  MOVF   x0D,W
0283E:  MOVWF  03
02840:  MOVLW  03
02842:  SUBWF  03,W
02844:  BNZ   2852
02846:  MOVLW  EE
02848:  SUBWF  00,W
0284A:  MOVLB  0
0284C:  BTFSC  FD8.2
0284E:  BRA    291A
02850:  MOVLB  9
02852:  MOVLW  03
02854:  SUBWF  03,W
02856:  BNZ   2864
02858:  MOVLW  EF
0285A:  SUBWF  00,W
0285C:  MOVLB  0
0285E:  BTFSC  FD8.2
02860:  BRA    2932
02862:  MOVLB  9
02864:  MOVLW  03
02866:  SUBWF  03,W
02868:  BNZ   2876
0286A:  MOVLW  F0
0286C:  SUBWF  00,W
0286E:  MOVLB  0
02870:  BTFSC  FD8.2
02872:  BRA    2942
02874:  MOVLB  9
02876:  MOVLW  03
02878:  SUBWF  03,W
0287A:  BNZ   2888
0287C:  MOVLW  F1
0287E:  SUBWF  00,W
02880:  MOVLB  0
02882:  BTFSC  FD8.2
02884:  BRA    295A
02886:  MOVLB  9
02888:  MOVLW  03
0288A:  SUBWF  03,W
0288C:  BNZ   289A
0288E:  MOVLW  F2
02890:  SUBWF  00,W
02892:  MOVLB  0
02894:  BTFSC  FD8.2
02896:  BRA    2966
02898:  MOVLB  9
0289A:  MOVLW  03
0289C:  SUBWF  03,W
0289E:  BNZ   28AC
028A0:  MOVLW  F3
028A2:  SUBWF  00,W
028A4:  MOVLB  0
028A6:  BTFSC  FD8.2
028A8:  BRA    2980
028AA:  MOVLB  9
028AC:  MOVLW  03
028AE:  SUBWF  03,W
028B0:  BNZ   28BE
028B2:  MOVLW  F4
028B4:  SUBWF  00,W
028B6:  MOVLB  0
028B8:  BTFSC  FD8.2
028BA:  BRA    2998
028BC:  MOVLB  9
028BE:  MOVLW  03
028C0:  SUBWF  03,W
028C2:  BNZ   28D0
028C4:  MOVLW  F5
028C6:  SUBWF  00,W
028C8:  MOVLB  0
028CA:  BTFSC  FD8.2
028CC:  BRA    29B0
028CE:  MOVLB  9
028D0:  MOVLW  07
028D2:  SUBWF  03,W
028D4:  BNZ   28E2
028D6:  MOVLW  CD
028D8:  SUBWF  00,W
028DA:  MOVLB  0
028DC:  BTFSC  FD8.2
028DE:  BRA    2A4E
028E0:  MOVLB  9
028E2:  MOVLW  07
028E4:  SUBWF  03,W
028E6:  BNZ   28F4
028E8:  MOVLW  CE
028EA:  SUBWF  00,W
028EC:  MOVLB  0
028EE:  BTFSC  FD8.2
028F0:  BRA    2A62
028F2:  MOVLB  9
028F4:  MOVLW  07
028F6:  SUBWF  03,W
028F8:  BNZ   2906
028FA:  MOVLW  CF
028FC:  SUBWF  00,W
028FE:  MOVLB  0
02900:  BTFSC  FD8.2
02902:  BRA    2A7C
02904:  MOVLB  9
02906:  MOVLW  4E
02908:  SUBWF  03,W
0290A:  BNZ   2918
0290C:  MOVLW  1F
0290E:  SUBWF  00,W
02910:  MOVLB  0
02912:  BTFSC  FD8.2
02914:  BRA    2A96
02916:  MOVLB  9
02918:  BRA    2ABE
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127 or 128 for respond to any} */ 
.................... 			if ( value > 128 ) return ILLEGAL_DATA_VALUE; 
0291A:  MOVLB  9
0291C:  MOVF   x0F,F
0291E:  BNZ   2926
02920:  MOVF   x0E,W
02922:  SUBLW  80
02924:  BC    292C
02926:  MOVLW  03
02928:  MOVWF  01
0292A:  BRA    2AC8
.................... 			config.modbus_address=value; 
0292C:  MOVFF  90E,36
.................... 			break; 
02930:  BRA    2AC4
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
02932:  MOVLB  1
02934:  BSF    xFB.1
.................... 			config.adc_sample_ticks=value; 
02936:  MOVFF  90F,3E
0293A:  MOVFF  90E,3D
.................... 			break; 
0293E:  MOVLB  9
02940:  BRA    2AC4
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02942:  MOVLB  9
02944:  MOVF   x0F,F
02946:  BNZ   294E
02948:  MOVF   x0E,W
0294A:  SUBLW  01
0294C:  BC    2954
0294E:  MOVLW  03
02950:  MOVWF  01
02952:  BRA    2AC8
.................... 			config.allow_bootload_request=value; 
02954:  MOVFF  90E,3F
.................... 			break; 
02958:  BRA    2AC4
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
0295A:  MOVFF  90F,41
0295E:  MOVFF  90E,40
.................... 			break; 
02962:  MOVLB  9
02964:  BRA    2AC4
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
02966:  MOVLB  9
02968:  MOVF   x0E,F
0296A:  BNZ   2976
0296C:  MOVF   x0F,F
0296E:  BNZ   2976
02970:  MOVLW  03
02972:  MOVWF  01
02974:  BRA    2AC8
.................... 			config.pi_offtime_seconds=value; 
02976:  MOVFF  90F,43
0297A:  MOVFF  90E,42
.................... 			break; 
0297E:  BRA    2AC4
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
02980:  MOVLB  9
02982:  MOVF   x0F,F
02984:  BNZ   298C
02986:  MOVF   x0E,W
02988:  SUBLW  01
0298A:  BC    2992
0298C:  MOVLW  03
0298E:  MOVWF  01
02990:  BRA    2AC8
.................... 			config.power_startup=value; 
02992:  MOVFF  90E,44
.................... 			break; 
02996:  BRA    2AC4
.................... 		 
.................... 		case 1012: 
.................... 			if ( value > 2 ) return ILLEGAL_DATA_VALUE; 
02998:  MOVLB  9
0299A:  MOVF   x0F,F
0299C:  BNZ   29A4
0299E:  MOVF   x0E,W
029A0:  SUBLW  02
029A2:  BC    29AA
029A4:  MOVLW  03
029A6:  MOVWF  01
029A8:  BRA    2AC8
.................... 			config.rs485_port_mode=value; 
029AA:  MOVFF  90E,38
.................... 			break; 
029AE:  BRA    2AC4
.................... 		 
.................... 		case 1013: 
....................  
.................... 			n=0; 
029B0:  MOVLB  9
029B2:  CLRF   x10
.................... 			if ( 1200 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_1200; } 
029B4:  MOVF   x0E,W
029B6:  SUBLW  B0
029B8:  BNZ   29C6
029BA:  MOVF   x0F,W
029BC:  SUBLW  04
029BE:  BNZ   29C6
029C0:  MOVLW  01
029C2:  MOVWF  x10
029C4:  CLRF   39
.................... 			if ( 2400 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_2400; } 
029C6:  MOVF   x0E,W
029C8:  SUBLW  60
029CA:  BNZ   29D8
029CC:  MOVF   x0F,W
029CE:  SUBLW  09
029D0:  BNZ   29D8
029D2:  MOVLW  01
029D4:  MOVWF  x10
029D6:  MOVWF  39
.................... 			if ( 4800 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_4800; } 
029D8:  MOVF   x0E,W
029DA:  SUBLW  C0
029DC:  BNZ   29EC
029DE:  MOVF   x0F,W
029E0:  SUBLW  12
029E2:  BNZ   29EC
029E4:  MOVLW  01
029E6:  MOVWF  x10
029E8:  MOVLW  02
029EA:  MOVWF  39
.................... 			if ( 9600 == value )  { n=1; config.rs485_port_speed=RS485_SPEED_9600; } 
029EC:  MOVF   x0E,W
029EE:  SUBLW  80
029F0:  BNZ   2A00
029F2:  MOVF   x0F,W
029F4:  SUBLW  25
029F6:  BNZ   2A00
029F8:  MOVLW  01
029FA:  MOVWF  x10
029FC:  MOVLW  03
029FE:  MOVWF  39
.................... 			if ( 19200 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_19200; } 
02A00:  MOVF   x0E,F
02A02:  BNZ   2A12
02A04:  MOVF   x0F,W
02A06:  SUBLW  4B
02A08:  BNZ   2A12
02A0A:  MOVLW  01
02A0C:  MOVWF  x10
02A0E:  MOVLW  04
02A10:  MOVWF  39
.................... 			if ( 38400 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_38400; } 
02A12:  MOVF   x0E,F
02A14:  BNZ   2A24
02A16:  MOVF   x0F,W
02A18:  SUBLW  96
02A1A:  BNZ   2A24
02A1C:  MOVLW  01
02A1E:  MOVWF  x10
02A20:  MOVLW  05
02A22:  MOVWF  39
.................... 			if ( 57600 == value ) { n=1; config.rs485_port_speed=RS485_SPEED_57600; } 
02A24:  MOVF   x0E,F
02A26:  BNZ   2A36
02A28:  MOVF   x0F,W
02A2A:  SUBLW  E1
02A2C:  BNZ   2A36
02A2E:  MOVLW  01
02A30:  MOVWF  x10
02A32:  MOVLW  06
02A34:  MOVWF  39
....................  
.................... 			if (  1==n ) { 
02A36:  DECFSZ x10,W
02A38:  BRA    2A44
.................... 				set_rs485_speed(); 
02A3A:  MOVLB  0
02A3C:  CALL   0930
.................... 			}  else { 
02A40:  BRA    2A4A
02A42:  MOVLB  9
.................... 				return ILLEGAL_DATA_VALUE; 
02A44:  MOVLW  03
02A46:  MOVWF  01
02A48:  BRA    2AC8
.................... 			} 
.................... 			break; 
02A4A:  MOVLB  9
02A4C:  BRA    2AC4
....................  
.................... 		case 1997: 
.................... 			/* reset CPU */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A4E:  MOVLB  9
02A50:  DECFSZ x0E,W
02A52:  BRA    2A58
02A54:  MOVF   x0F,F
02A56:  BZ    2A5E
02A58:  MOVLW  03
02A5A:  MOVWF  01
02A5C:  BRA    2AC8
.................... 			reset_cpu(); 
02A5E:  RESET
02A60:  MOVLB  0
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A62:  MOVLB  9
02A64:  DECFSZ x0E,W
02A66:  BRA    2A6C
02A68:  MOVF   x0F,F
02A6A:  BZ    2A72
02A6C:  MOVLW  03
02A6E:  MOVWF  01
02A70:  BRA    2AC8
.................... 			write_default_param_file(); 
02A72:  MOVLB  0
02A74:  CALL   0DEC
.................... 			break; 
02A78:  MOVLB  9
02A7A:  BRA    2AC4
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
02A7C:  MOVLB  9
02A7E:  DECFSZ x0E,W
02A80:  BRA    2A86
02A82:  MOVF   x0F,F
02A84:  BZ    2A8C
02A86:  MOVLW  03
02A88:  MOVWF  01
02A8A:  BRA    2AC8
.................... 			write_param_file(); 
02A8C:  MOVLB  0
02A8E:  CALL   0D98
.................... 			break; 
02A92:  MOVLB  9
02A94:  BRA    2AC4
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
02A96:  MOVLB  9
02A98:  MOVF   x0E,W
02A9A:  SUBLW  0A
02A9C:  BNZ   2AA4
02A9E:  MOVF   x0F,W
02AA0:  SUBLW  07
02AA2:  BZ    2AB0
.................... 				current.factory_unlocked=0; 
02AA4:  MOVLB  1
02AA6:  CLRF   xD8
.................... 				return ILLEGAL_DATA_VALUE; 
02AA8:  MOVLW  03
02AAA:  MOVWF  01
02AAC:  MOVLB  9
02AAE:  BRA    2AC8
.................... 			} 
.................... 			current.factory_unlocked=1; 
02AB0:  MOVLW  01
02AB2:  MOVLB  1
02AB4:  MOVWF  xD8
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
02AB6:  MOVLW  C8
02AB8:  MOVWF  xF8
.................... 			break; 
02ABA:  MOVLB  9
02ABC:  BRA    2AC4
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
02ABE:  MOVLW  02
02AC0:  MOVWF  01
02AC2:  BRA    2AC8
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
02AC4:  MOVLW  00
02AC6:  MOVWF  01
.................... } 
02AC8:  MOVLB  0
02ACA:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02B5C:  GOTO   12BA
02B60:  MOVF   01,F
02B62:  BTFSC  FD8.2
02B64:  BRA    2E60
.................... output_low(_PIC_TO_PI); 
02B66:  BCF    F8C.3
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode && modbus_rx.address!=config.modbus_address ) { 
02B68:  DECFSZ 38,W
02B6A:  BRA    2C1E
02B6C:  MOVF   36,W
02B6E:  MOVLB  7
02B70:  SUBWF  xEC,W
02B72:  BTFSS  FD8.2
02B74:  BRA    2B7A
02B76:  MOVLB  0
02B78:  BRA    2C1E
.................... 			/* rebuld modbus packet and send to RS-485 port */ 
....................  
.................... 			/* start transmitting */ 
.................... 			output_high(RS485_DE); 
02B7A:  BSF    F8C.1
.................... 			output_high(RS485_NRE); 
02B7C:  BSF    F8C.0
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02B7E:  CLRWDT
02B80:  MOVLW  02
02B82:  MOVLB  9
02B84:  MOVWF  x02
02B86:  MOVLW  B5
02B88:  MOVWF  x07
02B8A:  MOVLB  0
02B8C:  CALL   12E0
02B90:  MOVLB  9
02B92:  DECFSZ x02,F
02B94:  BRA    2B86
....................  
.................... 			/* address */ 
.................... 			fputc(modbus_rx.address,STREAM_RS485); 
02B96:  MOVLB  7
02B98:  MOVF   xEC,W
02B9A:  MOVLB  0
02B9C:  CALL   1300
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02BA0:  CLRWDT
02BA2:  MOVLW  67
02BA4:  MOVWF  00
02BA6:  DECFSZ 00,F
02BA8:  BRA    2BA6
02BAA:  NOP   
....................  
.................... 			/* function */ 
.................... 			fputc(modbus_rx.func,STREAM_RS485); 
02BAC:  MOVLB  7
02BAE:  MOVF   xEE,W
02BB0:  MOVLB  0
02BB2:  CALL   1300
.................... 			delay_us(104); //one stop bit @ 9600 baud 
02BB6:  CLRWDT
02BB8:  MOVLW  67
02BBA:  MOVWF  00
02BBC:  DECFSZ 00,F
02BBE:  BRA    2BBC
02BC0:  NOP   
....................  
.................... 			/* data and (hopefully) CRC */ 
.................... 			for ( i=0 ; i<modbus_rx.len+2 ; i++ ) { 
02BC2:  MOVLB  9
02BC4:  CLRF   x01
02BC6:  MOVLW  02
02BC8:  MOVLB  7
02BCA:  ADDWF  xED,W
02BCC:  MOVLB  9
02BCE:  SUBWF  x01,W
02BD0:  BC    2BFE
.................... 				fputc(modbus_rx.data[i],STREAM_RS485); 
02BD2:  MOVLW  F0
02BD4:  ADDWF  x01,W
02BD6:  MOVWF  FE9
02BD8:  MOVLW  07
02BDA:  MOVWF  FEA
02BDC:  BTFSC  FD8.0
02BDE:  INCF   FEA,F
02BE0:  MOVFF  FEF,902
02BE4:  MOVF   x02,W
02BE6:  MOVLB  0
02BE8:  CALL   1300
.................... 				delay_us(104); //one stop bit @ 9600 baud 
02BEC:  CLRWDT
02BEE:  MOVLW  67
02BF0:  MOVWF  00
02BF2:  DECFSZ 00,F
02BF4:  BRA    2BF2
02BF6:  NOP   
.................... 			} 
02BF8:  MOVLB  9
02BFA:  INCF   x01,F
02BFC:  BRA    2BC6
....................  
.................... 			/* wait for transmitter buffer to empty */ 
.................... 			while ( ! TRMT2 ) 
.................... 				; 
02BFE:  BTFSS  F72.1
02C00:  BRA    2BFE
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(365); /* 9600 */ 
02C02:  CLRWDT
02C04:  MOVLW  02
02C06:  MOVWF  x02
02C08:  MOVLW  B5
02C0A:  MOVWF  x07
02C0C:  MOVLB  0
02C0E:  CALL   12E0
02C12:  MOVLB  9
02C14:  DECFSZ x02,F
02C16:  BRA    2C08
.................... 			/* shut off transmitter */ 
.................... 			output_low(RS485_DE); 
02C18:  BCF    F8C.1
.................... 			output_low(RS485_NRE); 
02C1A:  BCF    F8C.0
02C1C:  MOVLB  0
....................  
.................... 		} 
....................  
.................... 		if ( 128==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
02C1E:  MOVF   36,W
02C20:  SUBLW  80
02C22:  BZ    2C30
02C24:  MOVF   36,W
02C26:  MOVLB  7
02C28:  SUBWF  xEC,W
02C2A:  BTFSS  FD8.2
02C2C:  BRA    2E4A
02C2E:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
02C30:  MOVLB  1
02C32:  INCFSZ xCC,W
02C34:  BRA    2C3C
02C36:  INCFSZ xCD,W
02C38:  BRA    2C3C
02C3A:  BRA    2C42
.................... 				current.modbus_our_packets++; 
02C3C:  INCF   xCC,F
02C3E:  BTFSC  FD8.2
02C40:  INCF   xCD,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
02C42:  MOVLW  14
02C44:  MOVWF  xF8
....................  
.................... 			switch(modbus_rx.func) { 
02C46:  MOVLB  7
02C48:  MOVF   xEE,W
02C4A:  XORLW  03
02C4C:  MOVLB  0
02C4E:  BZ    2C60
02C50:  XORLW  07
02C52:  BZ    2C60
02C54:  XORLW  02
02C56:  BZ    2CDE
02C58:  XORLW  16
02C5A:  BTFSC  FD8.2
02C5C:  BRA    2D50
02C5E:  BRA    2E22
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02C60:  MOVFF  7F0,8FD
02C64:  MOVFF  7F1,8FC
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02C68:  MOVFF  7F2,8FF
02C6C:  MOVFF  7F3,8FE
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
02C70:  MOVLB  8
02C72:  MOVF   xFE,W
02C74:  ADDWF  xFC,W
02C76:  MOVLB  9
02C78:  MOVWF  x02
02C7A:  MOVLB  8
02C7C:  MOVF   xFF,W
02C7E:  ADDWFC xFD,W
02C80:  MOVLB  9
02C82:  MOVWF  x03
02C84:  MOVFF  8FD,909
02C88:  MOVFF  8FC,908
02C8C:  MOVWF  x0B
02C8E:  MOVFF  902,90A
02C92:  MOVLB  0
02C94:  GOTO   1308
02C98:  MOVF   01,F
02C9A:  BNZ   2CC0
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
02C9C:  MOVFF  7EC,906
02CA0:  MOVLB  9
02CA2:  CLRF   x08
02CA4:  MOVFF  7EE,907
02CA8:  MOVLW  02
02CAA:  MOVWF  x09
02CAC:  MOVLB  0
02CAE:  CALL   1492
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
02CB2:  MOVLB  1
02CB4:  CLRF   xD1
02CB6:  MOVLW  02
02CB8:  MOVWF  xD0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02CBA:  CLRF   xF8
.................... 					} else { 
02CBC:  BRA    2CDC
02CBE:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
02CC0:  MOVFF  7EE,906
02CC4:  MOVFF  7EC,907
02CC8:  MOVFF  8FD,909
02CCC:  MOVFF  8FC,908
02CD0:  MOVFF  8FF,90B
02CD4:  MOVFF  8FE,90A
02CD8:  BRA    2664
02CDA:  MOVLB  1
.................... 					} 
.................... 					break; 
02CDC:  BRA    2E42
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02CDE:  MOVFF  7F0,8FD
02CE2:  MOVFF  7F1,8FC
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
02CE6:  MOVFF  7F2,903
02CEA:  MOVFF  7F3,902
02CEE:  MOVFF  8FD,90D
02CF2:  MOVFF  8FC,90C
02CF6:  MOVFF  7F2,90F
02CFA:  MOVFF  7F3,90E
02CFE:  RCALL  26E6
02D00:  MOVFF  01,900
....................  
.................... 					if ( result ) { 
02D04:  MOVLB  9
02D06:  MOVF   x00,F
02D08:  BZ    2D2C
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02D0A:  MOVFF  7EC,906
02D0E:  CLRF   x08
02D10:  MOVFF  7EE,907
02D14:  MOVFF  900,909
02D18:  MOVLB  0
02D1A:  CALL   1492
.................... 						current.modbus_last_error=result; 
02D1E:  MOVLB  1
02D20:  CLRF   xD1
02D22:  MOVFF  900,1D0
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
02D26:  CLRF   xF8
.................... 					}  else { 
02D28:  BRA    2D4E
02D2A:  MOVLB  9
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02D2C:  MOVFF  7F2,903
02D30:  MOVFF  7F3,902
02D34:  MOVFF  7EC,908
02D38:  MOVFF  8FD,90A
02D3C:  MOVFF  8FC,909
02D40:  MOVFF  7F2,90C
02D44:  MOVFF  7F3,90B
02D48:  MOVLB  0
02D4A:  BRA    2ACC
02D4C:  MOVLB  1
.................... 					} 
.................... 					break; 
02D4E:  BRA    2E42
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02D50:  MOVFF  7F0,8FD
02D54:  MOVFF  7F1,8FC
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02D58:  MOVFF  7F2,8FF
02D5C:  MOVFF  7F3,8FE
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02D60:  MOVLB  9
02D62:  CLRF   x01
02D64:  MOVLB  8
02D66:  MOVF   xFF,F
02D68:  BNZ   2D74
02D6A:  MOVF   xFE,W
02D6C:  MOVLB  9
02D6E:  SUBWF  x01,W
02D70:  BC    2E02
02D72:  MOVLB  8
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02D74:  MOVLB  9
02D76:  MOVF   x01,W
02D78:  MOVLB  8
02D7A:  ADDWF  xFC,W
02D7C:  MOVLB  9
02D7E:  MOVWF  x02
02D80:  MOVLW  00
02D82:  MOVLB  8
02D84:  ADDWFC xFD,W
02D86:  MOVLB  9
02D88:  MOVWF  x03
02D8A:  BCF    FD8.0
02D8C:  RLCF   x01,W
02D8E:  ADDLW  05
02D90:  ADDLW  F0
02D92:  MOVWF  FE9
02D94:  MOVLW  07
02D96:  MOVWF  FEA
02D98:  BTFSC  FD8.0
02D9A:  INCF   FEA,F
02D9C:  MOVFF  FEF,904
02DA0:  BCF    FD8.0
02DA2:  RLCF   x01,W
02DA4:  ADDLW  06
02DA6:  ADDLW  F0
02DA8:  MOVWF  FE9
02DAA:  MOVLW  07
02DAC:  MOVWF  FEA
02DAE:  BTFSC  FD8.0
02DB0:  INCF   FEA,F
02DB2:  MOVFF  FEF,905
02DB6:  MOVFF  904,907
02DBA:  MOVFF  905,906
02DBE:  MOVFF  903,90D
02DC2:  MOVFF  902,90C
02DC6:  MOVFF  904,90F
02DCA:  MOVFF  905,90E
02DCE:  MOVLB  0
02DD0:  RCALL  26E6
02DD2:  MOVFF  01,900
....................  
.................... 						if ( result ) { 
02DD6:  MOVLB  9
02DD8:  MOVF   x00,F
02DDA:  BZ    2DFE
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
02DDC:  MOVFF  7EC,906
02DE0:  CLRF   x08
02DE2:  MOVFF  7EE,907
02DE6:  MOVFF  900,909
02DEA:  MOVLB  0
02DEC:  CALL   1492
.................... 							current.modbus_last_error=result; 
02DF0:  MOVLB  1
02DF2:  CLRF   xD1
02DF4:  MOVFF  900,1D0
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
02DF8:  CLRF   xF8
.................... 			 
.................... 							break; 
02DFA:  MOVLB  9
02DFC:  BRA    2E02
.................... 						} 
.................... 					} 
02DFE:  INCF   x01,F
02E00:  BRA    2D64
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
02E02:  MOVF   x00,F
02E04:  BNZ   2E1E
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
02E06:  MOVFF  7EC,906
02E0A:  MOVFF  8FD,908
02E0E:  MOVFF  8FC,907
02E12:  MOVFF  8FF,90A
02E16:  MOVFF  8FE,909
02E1A:  MOVLB  0
02E1C:  BRA    2B14
.................... 					} 
....................  
.................... 					break;   
02E1E:  MOVLB  1
02E20:  BRA    2E42
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02E22:  MOVFF  7EC,906
02E26:  MOVLB  9
02E28:  CLRF   x08
02E2A:  MOVFF  7EE,907
02E2E:  MOVLW  01
02E30:  MOVWF  x09
02E32:  MOVLB  0
02E34:  CALL   1492
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
02E38:  MOVLB  1
02E3A:  CLRF   xD1
02E3C:  MOVLW  01
02E3E:  MOVWF  xD0
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02E40:  CLRF   xF8
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02E42:  CLRF   xDA
02E44:  CLRF   xD9
....................  
.................... 		} else { 
02E46:  BRA    2E60
02E48:  MOVLB  7
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
02E4A:  MOVLB  1
02E4C:  INCFSZ xCE,W
02E4E:  BRA    2E56
02E50:  INCFSZ xCF,W
02E52:  BRA    2E56
02E54:  BRA    2E5C
.................... 				current.modbus_other_packets++; 
02E56:  INCF   xCE,F
02E58:  BTFSC  FD8.2
02E5A:  INCF   xCF,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=10; 
02E5C:  MOVLW  0A
02E5E:  MOVWF  xF8
02E60:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02E62:  GOTO   3336 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00460:  MOVLB  A
00462:  BTFSS  x14.0
00464:  BRA    047E
00466:  MOVLB  1
00468:  INCFSZ xE7,W
0046A:  BRA    0476
0046C:  INCFSZ xE8,W
0046E:  BRA    0476
00470:  MOVLB  A
00472:  BRA    047E
00474:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00476:  INCF   xE7,F
00478:  BTFSC  FD8.2
0047A:  INCF   xE8,F
0047C:  MOVLB  A
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0047E:  BTFSS  x14.2
00480:  BRA    049A
00482:  MOVLB  1
00484:  INCFSZ xE9,W
00486:  BRA    0492
00488:  INCFSZ xEA,W
0048A:  BRA    0492
0048C:  MOVLB  A
0048E:  BRA    049A
00490:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
00492:  INCF   xE9,F
00494:  BTFSC  FD8.2
00496:  INCF   xEA,F
00498:  MOVLB  A
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
0049A:  BTFSS  x14.4
0049C:  BRA    04B6
0049E:  MOVLB  1
004A0:  INCFSZ xEB,W
004A2:  BRA    04AE
004A4:  INCFSZ xEC,W
004A6:  BRA    04AE
004A8:  MOVLB  A
004AA:  BRA    04B6
004AC:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
004AE:  INCF   xEB,F
004B0:  BTFSC  FD8.2
004B2:  INCF   xEC,F
004B4:  MOVLB  A
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
004B6:  BCF    x14.1
004B8:  BTFSC  F81.0
004BA:  BSF    x14.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
004BC:  BTFSC  x14.1
004BE:  BRA    0542
004C0:  MOVLB  7
004C2:  BTFSC  xE8.1
004C4:  BRA    04CA
004C6:  MOVLB  A
004C8:  BRA    0542
.................... 		current.pulse_count[0]++; 
004CA:  MOVLB  0
004CC:  INCF   xA9,F
004CE:  BTFSC  FD8.2
004D0:  INCF   xAA,F
.................... 		current.pulse_sum[0]++; 
004D2:  MOVLW  01
004D4:  ADDWF  xAF,F
004D6:  BTFSC  FD8.0
004D8:  INCF   xB0,F
004DA:  BTFSC  FD8.2
004DC:  INCF   xB1,F
004DE:  BTFSC  FD8.2
004E0:  INCF   xB2,F
.................... 		if ( 1 == ext0_state ) { 
004E2:  MOVLB  7
004E4:  BTFSS  xE8.2
004E6:  BRA    0530
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
004E8:  MOVLB  A
004EA:  BCF    x14.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
004EC:  MOVFF  1E8,98
004F0:  MOVFF  1E7,97
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
004F4:  MOVLB  0
004F6:  MOVF   x98,W
004F8:  SUBWF  x9E,W
004FA:  BNC   050C
004FC:  BNZ   0504
004FE:  MOVF   x9D,W
00500:  SUBWF  x97,W
00502:  BC    050C
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00504:  MOVFF  98,9E
00508:  MOVFF  97,9D
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
0050C:  MOVF   xA4,W
0050E:  SUBWF  x98,W
00510:  BNC   052C
00512:  BNZ   051A
00514:  MOVF   x97,W
00516:  SUBWF  xA3,W
00518:  BC    052C
0051A:  INCFSZ x97,W
0051C:  BRA    0524
0051E:  INCFSZ x98,W
00520:  BRA    0524
00522:  BRA    052C
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00524:  MOVFF  98,A4
00528:  MOVFF  97,A3
.................... 			} 
.................... 			ext0_state=0; 
0052C:  MOVLB  7
0052E:  BCF    xE8.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00530:  BTFSC  xE8.2
00532:  BRA    0542
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00534:  MOVLB  1
00536:  CLRF   xE8
00538:  CLRF   xE7
.................... 			ext0_count=1; 
0053A:  MOVLB  A
0053C:  BSF    x14.0
.................... 			ext0_state=1; 
0053E:  MOVLB  7
00540:  BSF    xE8.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00542:  MOVLB  7
00544:  BCF    xE8.1
00546:  MOVLB  A
00548:  BTFSS  x14.1
0054A:  BRA    0552
0054C:  MOVLB  7
0054E:  BSF    xE8.1
00550:  MOVLB  A
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00552:  BCF    x14.3
00554:  BTFSC  F81.1
00556:  BSF    x14.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
00558:  BTFSC  x14.3
0055A:  BRA    05DE
0055C:  MOVLB  7
0055E:  BTFSC  xE8.3
00560:  BRA    0566
00562:  MOVLB  A
00564:  BRA    05DE
.................... 		current.pulse_count[1]++; 
00566:  MOVLB  0
00568:  INCF   xAB,F
0056A:  BTFSC  FD8.2
0056C:  INCF   xAC,F
.................... 		current.pulse_sum[1]++; 
0056E:  MOVLW  01
00570:  ADDWF  xB3,F
00572:  BTFSC  FD8.0
00574:  INCF   xB4,F
00576:  BTFSC  FD8.2
00578:  INCF   xB5,F
0057A:  BTFSC  FD8.2
0057C:  INCF   xB6,F
.................... 		if ( 1 == ext1_state ) { 
0057E:  MOVLB  7
00580:  BTFSS  xE8.4
00582:  BRA    05CC
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
00584:  MOVLB  A
00586:  BCF    x14.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
00588:  MOVFF  1EA,9A
0058C:  MOVFF  1E9,99
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
00590:  MOVLB  0
00592:  MOVF   x9A,W
00594:  SUBWF  xA0,W
00596:  BNC   05A8
00598:  BNZ   05A0
0059A:  MOVF   x9F,W
0059C:  SUBWF  x99,W
0059E:  BC    05A8
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
005A0:  MOVFF  9A,A0
005A4:  MOVFF  99,9F
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
005A8:  MOVF   xA6,W
005AA:  SUBWF  x9A,W
005AC:  BNC   05C8
005AE:  BNZ   05B6
005B0:  MOVF   x99,W
005B2:  SUBWF  xA5,W
005B4:  BC    05C8
005B6:  INCFSZ x99,W
005B8:  BRA    05C0
005BA:  INCFSZ x9A,W
005BC:  BRA    05C0
005BE:  BRA    05C8
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005C0:  MOVFF  9A,A6
005C4:  MOVFF  99,A5
.................... 			} 
.................... 			ext1_state=0; 
005C8:  MOVLB  7
005CA:  BCF    xE8.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005CC:  BTFSC  xE8.4
005CE:  BRA    05DE
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005D0:  MOVLB  1
005D2:  CLRF   xEA
005D4:  CLRF   xE9
.................... 			ext1_count=1; 
005D6:  MOVLB  A
005D8:  BSF    x14.2
.................... 			ext1_state=1; 
005DA:  MOVLB  7
005DC:  BSF    xE8.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005DE:  MOVLB  7
005E0:  BCF    xE8.3
005E2:  MOVLB  A
005E4:  BTFSS  x14.3
005E6:  BRA    05EE
005E8:  MOVLB  7
005EA:  BSF    xE8.3
005EC:  MOVLB  A
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
005EE:  BCF    x14.5
005F0:  BTFSC  F81.2
005F2:  BSF    x14.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
005F4:  BTFSC  x14.5
005F6:  BRA    067A
005F8:  MOVLB  7
005FA:  BTFSC  xE8.5
005FC:  BRA    0602
005FE:  MOVLB  A
00600:  BRA    067A
.................... 		current.pulse_count[2]++; 
00602:  MOVLB  0
00604:  INCF   xAD,F
00606:  BTFSC  FD8.2
00608:  INCF   xAE,F
.................... 		current.pulse_sum[2]++; 
0060A:  MOVLW  01
0060C:  ADDWF  xB7,F
0060E:  BTFSC  FD8.0
00610:  INCF   xB8,F
00612:  BTFSC  FD8.2
00614:  INCF   xB9,F
00616:  BTFSC  FD8.2
00618:  INCF   xBA,F
.................... 		if ( 1 == ext2_state ) { 
0061A:  MOVLB  7
0061C:  BTFSS  xE8.6
0061E:  BRA    0668
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
00620:  MOVLB  A
00622:  BCF    x14.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00624:  MOVFF  1EC,9C
00628:  MOVFF  1EB,9B
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0062C:  MOVLB  0
0062E:  MOVF   x9C,W
00630:  SUBWF  xA2,W
00632:  BNC   0644
00634:  BNZ   063C
00636:  MOVF   xA1,W
00638:  SUBWF  x9B,W
0063A:  BC    0644
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
0063C:  MOVFF  9C,A2
00640:  MOVFF  9B,A1
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00644:  MOVF   xA8,W
00646:  SUBWF  x9C,W
00648:  BNC   0664
0064A:  BNZ   0652
0064C:  MOVF   x9B,W
0064E:  SUBWF  xA7,W
00650:  BC    0664
00652:  INCFSZ x9B,W
00654:  BRA    065C
00656:  INCFSZ x9C,W
00658:  BRA    065C
0065A:  BRA    0664
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
0065C:  MOVFF  9C,A8
00660:  MOVFF  9B,A7
.................... 			} 
.................... 			ext2_state=0; 
00664:  MOVLB  7
00666:  BCF    xE8.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
00668:  BTFSC  xE8.6
0066A:  BRA    067A
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
0066C:  MOVLB  1
0066E:  CLRF   xEC
00670:  CLRF   xEB
.................... 			ext2_count=1; 
00672:  MOVLB  A
00674:  BSF    x14.4
.................... 			ext2_state=1; 
00676:  MOVLB  7
00678:  BSF    xE8.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
0067A:  MOVLB  7
0067C:  BCF    xE8.5
0067E:  MOVLB  A
00680:  BTFSS  x14.5
00682:  BRA    068A
00684:  MOVLB  7
00686:  BSF    xE8.5
00688:  MOVLB  A
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
0068A:  MOVLB  8
0068C:  INCF   xF3,F
.................... 	if ( 10 == tick ) { 
0068E:  MOVF   xF3,W
00690:  SUBLW  0A
00692:  BNZ   069C
.................... 		tick=0; 
00694:  CLRF   xF3
.................... 		timers.now_millisecond=1; 
00696:  MOVLB  1
00698:  BSF    xFB.2
0069A:  MOVLB  8
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
0069C:  BCF    F9E.1
0069E:  MOVLB  0
006A0:  GOTO   013A
.................... #int_rda2 
.................... void isr_rda2() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_RS485); 
*
006BC:  BRA    06A4
006BE:  MOVFF  01,A11
.................... 	current.rda2_bytes_received++; 
006C2:  MOVLB  1
006C4:  INCF   xE4,F
006C6:  BTFSC  FD8.2
006C8:  INCF   xE5,F
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE == config.rs485_port_mode ) { 
006CA:  DECFSZ 38,W
006CC:  BRA    06F2
.................... 		/* add to buffer to send to PI */ 
....................  
.................... 		timers.rda2_buff_gap=0; 
006CE:  MOVLB  3
006D0:  CLRF   x00
....................  
.................... 		if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
006D2:  MOVLB  2
006D4:  INCFSZ xFF,W
006D6:  BRA    06DA
006D8:  BRA    06EE
.................... 			timers.rda2_buff[timers.rda2_buff_pos]=c; 
006DA:  MOVLW  FF
006DC:  ADDWF  xFF,W
006DE:  MOVWF  FE9
006E0:  MOVLW  01
006E2:  MOVWF  FEA
006E4:  BTFSC  FD8.0
006E6:  INCF   FEA,F
006E8:  MOVFF  A11,FEF
.................... 			timers.rda2_buff_pos++; 
006EC:  INCF   xFF,F
.................... 		} 
.................... 	} else if ( RS485_MODE_NMEA0183_RX == config.rs485_port_mode ) { 
006EE:  BRA    073A
006F0:  MOVLB  1
006F2:  MOVF   38,W
006F4:  SUBLW  02
006F6:  BNZ   073C
.................... 		/* if we are in NMEA mode, we can also recognize \n or \r as the end of a sentence */ 
.................... 		if ( '\n' == c || '\r' == c  ) { 
006F8:  MOVLB  A
006FA:  MOVF   x11,W
006FC:  SUBLW  0A
006FE:  BZ    0706
00700:  MOVF   x11,W
00702:  SUBLW  0D
00704:  BNZ   071A
.................... 			if  ( timers.rda2_buff_pos > 0 ) { 
00706:  MOVLB  2
00708:  MOVF   xFF,F
0070A:  BZ    0716
.................... 				/* mark new packet by a fake gap */ 
.................... 				timers.rda2_buff_gap=20; 
0070C:  MOVLW  14
0070E:  MOVLB  3
00710:  MOVWF  x00
.................... 			}  else { 
00712:  BRA    0714
00714:  MOVLB  2
.................... 				/* do nothing if we are at beginning of next packet */ 
.................... 			} 
.................... 		} else { 
00716:  BRA    073A
00718:  MOVLB  A
.................... 			/* add to buffer */ 
.................... 			timers.rda2_buff_gap=0; 
0071A:  MOVLB  3
0071C:  CLRF   x00
....................  
.................... 			if ( timers.rda2_buff_pos < sizeof(timers.rda2_buff)-1 ) { 
0071E:  MOVLB  2
00720:  INCFSZ xFF,W
00722:  BRA    0726
00724:  BRA    073A
.................... 				timers.rda2_buff[timers.rda2_buff_pos]=c; 
00726:  MOVLW  FF
00728:  ADDWF  xFF,W
0072A:  MOVWF  FE9
0072C:  MOVLW  01
0072E:  MOVWF  FEA
00730:  BTFSC  FD8.0
00732:  INCF   FEA,F
00734:  MOVFF  A11,FEF
.................... 				timers.rda2_buff_pos++; 
00738:  INCF   xFF,F
0073A:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /* transmit buffer empty for Modbus to raspberry pi buffer */ 
0073C:  BCF    FA4.5
0073E:  MOVLB  0
00740:  GOTO   0094
.................... #int_tbe 
.................... void isr_uart1_tbe() { 
.................... 	if ( timers.rda_tx_pos >= timers.rda_tx_length ) { 
*
0074C:  MOVLB  4
0074E:  MOVF   x01,W
00750:  SUBWF  x02,W
00752:  BNC   075A
.................... 		/* done transmitting */ 
.................... 		timers.now_rda_tx_done=1; 
00754:  BSF    x03.1
.................... 		disable_interrupts(INT_TBE); 
00756:  BCF    F9D.4
.................... 	} else { 
00758:  BRA    0778
.................... 		/* put another character into TX buffer */ 
.................... 		fputc(timers.rda_tx_buff[timers.rda_tx_pos], STREAM_PI); 
0075A:  MOVLW  01
0075C:  ADDWF  x02,W
0075E:  MOVWF  FE9
00760:  MOVLW  03
00762:  MOVWF  FEA
00764:  BTFSC  FD8.0
00766:  INCF   FEA,F
00768:  MOVFF  FEF,A11
0076C:  MOVLB  A
0076E:  MOVF   x11,W
00770:  MOVLB  0
00772:  RCALL  0744
.................... 		timers.rda_tx_pos++; 
00774:  MOVLB  4
00776:  INCF   x02,F
.................... 	} 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
00778:  BCF    F9E.4
0077A:  MOVLB  0
0077C:  GOTO   0094
.................... #int_rda 
.................... void isr_uart1_rx() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(STREAM_PI); 
*
007C2:  RCALL  0780
007C4:  MOVFF  01,A11
....................  
.................... 	current.rda_bytes_received++; 
007C8:  MOVLB  1
007CA:  INCF   xE2,F
007CC:  BTFSC  FD8.2
007CE:  INCF   xE3,F
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
007D0:  MOVLB  7
007D2:  BTFSC  xE8.0
007D4:  BRA    082E
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
007D6:  MOVF   xE9,F
007D8:  BNZ   07EC
.................... output_high(_PIC_TO_PI); 
007DA:  BSF    F8C.3
.................... 			modbus_serial_crc.d = 0xFFFF; 
007DC:  SETF   xEB
007DE:  SETF   xEA
.................... 			modbus_rx.address = c; 
007E0:  MOVFF  A11,7EC
.................... 			modbus_serial_state++; 
007E4:  INCF   xE9,F
.................... 			modbus_rx.len = 0; 
007E6:  CLRF   xED
.................... 			modbus_rx.error=0; 
007E8:  CLRF   xEF
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
007EA:  BRA    081A
007EC:  DECFSZ xE9,W
007EE:  BRA    07F8
.................... 			modbus_rx.func = c; 
007F0:  MOVFF  A11,7EE
.................... 			modbus_serial_state++; 
007F4:  INCF   xE9,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
007F6:  BRA    081A
007F8:  MOVF   xE9,W
007FA:  SUBLW  02
007FC:  BNZ   081A
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
007FE:  INCFSZ xED,W
00800:  BRA    0806
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00802:  MOVLW  FE
00804:  MOVWF  xED
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
00806:  MOVLW  F0
00808:  ADDWF  xED,W
0080A:  MOVWF  FE9
0080C:  MOVLW  07
0080E:  MOVWF  FEA
00810:  BTFSC  FD8.0
00812:  INCF   FEA,F
00814:  MOVFF  A11,FEF
.................... 			modbus_rx.len++; 
00818:  INCF   xED,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
0081A:  MOVFF  A11,A12
0081E:  MOVLB  0
00820:  RCALL  0796
.................... 		modbus_enable_timeout(TRUE); 
00822:  MOVLW  01
00824:  MOVLB  A
00826:  MOVWF  x12
00828:  MOVLB  0
0082A:  RCALL  041A
0082C:  MOVLB  7
.................... 	} 
.................... } 
....................  
....................  
0082E:  BCF    F9E.5
00830:  MOVLB  0
00832:  GOTO   0094
.................... void set_rs485_speed(void) { 
.................... 	switch ( config.rs485_port_speed ) { 
*
00930:  MOVF   39,W
00932:  XORLW  00
00934:  BZ    094C
00936:  XORLW  01
00938:  BZ    095C
0093A:  XORLW  03
0093C:  BZ    096C
0093E:  XORLW  06
00940:  BZ    097C
00942:  XORLW  01
00944:  BZ    0988
00946:  XORLW  03
00948:  BZ    0998
0094A:  BRA    09A4
.................... 		case RS485_SPEED_1200:  set_uart_speed(1200,STREAM_RS485); break; 
0094C:  BSF    F70.3
0094E:  MOVLW  C3
00950:  MOVWF  F75
00952:  MOVLW  09
00954:  MOVWF  F76
00956:  MOVLW  A6
00958:  MOVWF  F72
0095A:  BRA    09B0
.................... 		case RS485_SPEED_2400:  set_uart_speed(2400,STREAM_RS485); break; 
0095C:  BSF    F70.3
0095E:  MOVLW  E1
00960:  MOVWF  F75
00962:  MOVLW  04
00964:  MOVWF  F76
00966:  MOVLW  A6
00968:  MOVWF  F72
0096A:  BRA    09B0
.................... 		case RS485_SPEED_4800:  set_uart_speed(4800,STREAM_RS485); break; 
0096C:  BSF    F70.3
0096E:  MOVLW  70
00970:  MOVWF  F75
00972:  MOVLW  02
00974:  MOVWF  F76
00976:  MOVLW  A6
00978:  MOVWF  F72
0097A:  BRA    09B0
.................... 		case RS485_SPEED_19200: set_uart_speed(19200,STREAM_RS485); break; 
0097C:  BCF    F70.3
0097E:  MOVLW  26
00980:  MOVWF  F75
00982:  MOVLW  A6
00984:  MOVWF  F72
00986:  BRA    09B0
.................... 		case RS485_SPEED_38400: set_uart_speed(38400,STREAM_RS485); break; 
00988:  BSF    F70.3
0098A:  MOVLW  4D
0098C:  MOVWF  F75
0098E:  MOVLW  00
00990:  MOVWF  F76
00992:  MOVLW  A6
00994:  MOVWF  F72
00996:  BRA    09B0
.................... 		case RS485_SPEED_57600: set_uart_speed(57600,STREAM_RS485); break;	 
00998:  BCF    F70.3
0099A:  MOVLW  0C
0099C:  MOVWF  F75
0099E:  MOVLW  A6
009A0:  MOVWF  F72
009A2:  BRA    09B0
.................... 		default: set_uart_speed(9600, STREAM_RS485); break; 
009A4:  BCF    F70.3
009A6:  MOVLW  4D
009A8:  MOVWF  F75
009AA:  MOVLW  A6
009AC:  MOVWF  F72
009AE:  BRA    09B0
.................... 	} 
.................... } 
009B0:  RETURN 0
....................  
.................... void init() { 
.................... 	int8 i; 
....................  
.................... 	setup_adc(ADC_OFF); 
009B2:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
009B4:  MOVLW  08
009B6:  MOVWF  F61
009B8:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
009BA:  MOVLW  00
009BC:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
009BE:  MOVLW  FF
009C0:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
009C2:  MOVLW  92
009C4:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
009C6:  MOVLW  80
009C8:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
009CA:  BCF    F96.0
009CC:  BCF    F96.1
009CE:  BCF    F96.2
009D0:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
009D2:  MOVLB  1
009D4:  CLRF   xF8
.................... 	timers.load_off_seconds=2; 
009D6:  CLRF   xFA
009D8:  MOVLW  02
009DA:  MOVWF  xF9
.................... 	timers.now_adc_sample=0; 
009DC:  BCF    xFB.0
.................... 	timers.now_adc_reset_count=0; 
009DE:  BCF    xFB.1
.................... 	timers.now_millisecond=0; 
009E0:  BCF    xFB.2
.................... 	timers.port_b=0b11111111; 
009E2:  SETF   xFC
.................... 	timers.port_c=0b11111111; 
009E4:  SETF   xFD
....................  
.................... 	timers.rda2_buff_pos=0; 
009E6:  MOVLB  2
009E8:  CLRF   xFF
.................... 	timers.rda2_buff_gap=255; 
009EA:  MOVLB  3
009EC:  SETF   x00
.................... 	timers.now_parse_rda2=0; 
009EE:  MOVLB  1
009F0:  BCF    xFE.0
....................  
.................... 	timers.rda_tx_length=0; 
009F2:  MOVLB  4
009F4:  CLRF   x01
.................... 	timers.rda_tx_pos=0; 
009F6:  CLRF   x02
.................... 	timers.now_rda_tx_ready=0; 
009F8:  BCF    x03.0
.................... 	timers.now_rda_tx_done=0; 
009FA:  BCF    x03.1
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
009FC:  MOVLB  8
009FE:  CLRF   xFC
00A00:  MOVF   xFC,W
00A02:  SUBLW  02
00A04:  BNC   0AB4
.................... 		current.pulse_period[i]=0; 
00A06:  CLRF   03
00A08:  MOVFF  8FC,02
00A0C:  BCF    FD8.0
00A0E:  RLCF   02,F
00A10:  RLCF   03,F
00A12:  MOVF   02,W
00A14:  ADDLW  97
00A16:  MOVWF  FE9
00A18:  MOVLW  00
00A1A:  ADDWFC 03,W
00A1C:  MOVWF  FEA
00A1E:  CLRF   FEC
00A20:  MOVF   FED,F
00A22:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
00A24:  CLRF   03
00A26:  MOVFF  8FC,02
00A2A:  BCF    FD8.0
00A2C:  RLCF   02,F
00A2E:  RLCF   03,F
00A30:  MOVF   02,W
00A32:  ADDLW  9D
00A34:  MOVWF  FE9
00A36:  MOVLW  00
00A38:  ADDWFC 03,W
00A3A:  MOVWF  FEA
00A3C:  SETF   FEC
00A3E:  MOVF   FED,F
00A40:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
00A42:  CLRF   03
00A44:  MOVFF  8FC,02
00A48:  BCF    FD8.0
00A4A:  RLCF   02,F
00A4C:  RLCF   03,F
00A4E:  MOVF   02,W
00A50:  ADDLW  A3
00A52:  MOVWF  FE9
00A54:  MOVLW  00
00A56:  ADDWFC 03,W
00A58:  MOVWF  FEA
00A5A:  CLRF   FEC
00A5C:  MOVF   FED,F
00A5E:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00A60:  CLRF   03
00A62:  MOVFF  8FC,02
00A66:  BCF    FD8.0
00A68:  RLCF   02,F
00A6A:  RLCF   03,F
00A6C:  MOVF   02,W
00A6E:  ADDLW  A9
00A70:  MOVWF  FE9
00A72:  MOVLW  00
00A74:  ADDWFC 03,W
00A76:  MOVWF  FEA
00A78:  CLRF   FEC
00A7A:  MOVF   FED,F
00A7C:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
00A7E:  MOVLB  A
00A80:  CLRF   x01
00A82:  MOVFF  8FC,A00
00A86:  CLRF   x03
00A88:  MOVLW  04
00A8A:  MOVWF  x02
00A8C:  MOVLB  0
00A8E:  RCALL  08F4
00A90:  MOVF   01,W
00A92:  ADDLW  AF
00A94:  MOVWF  FE9
00A96:  MOVLW  00
00A98:  ADDWFC 02,W
00A9A:  MOVWF  FEA
00A9C:  MOVF   FEE,F
00A9E:  MOVF   FEE,F
00AA0:  CLRF   FEC
00AA2:  MOVF   FED,F
00AA4:  CLRF   FEF
00AA6:  MOVF   FED,F
00AA8:  CLRF   FEF
00AAA:  MOVF   FED,F
00AAC:  CLRF   FEF
.................... 	} 
00AAE:  MOVLB  8
00AB0:  INCF   xFC,F
00AB2:  BRA    0A00
....................  
.................... 	current.modbus_our_packets=0; 
00AB4:  MOVLB  1
00AB6:  CLRF   xCD
00AB8:  CLRF   xCC
.................... 	current.modbus_other_packets=0; 
00ABA:  CLRF   xCF
00ABC:  CLRF   xCE
.................... 	current.modbus_last_error=0; 
00ABE:  CLRF   xD1
00AC0:  CLRF   xD0
.................... 	current.sequence_number=0; 
00AC2:  CLRF   xD3
00AC4:  CLRF   xD2
.................... 	current.uptime_minutes=0; 
00AC6:  CLRF   xD5
00AC8:  CLRF   xD4
.................... 	current.interval_milliseconds=0; 
00ACA:  CLRF   xD7
00ACC:  CLRF   xD6
.................... 	current.adc_buffer_index=0; 
00ACE:  CLRF   xCB
.................... 	current.factory_unlocked=0; 
00AD0:  CLRF   xD8
.................... 	current.watchdog_seconds=0; 
00AD2:  CLRF   xDA
00AD4:  CLRF   xD9
.................... 	current.rda_bytes_received=0; 
00AD6:  CLRF   xE3
00AD8:  CLRF   xE2
.................... 	current.rda2_bytes_received=0; 
00ADA:  CLRF   xE5
00ADC:  CLRF   xE4
.................... 	current.button_state=0; 
00ADE:  CLRF   xE6
....................  
.................... 	/* zero out NMEA structure */ 
.................... 	memset(&nmea,0,sizeof(nmea)); 
00AE0:  MOVLW  04
00AE2:  MOVWF  FEA
00AE4:  MOVWF  FE9
00AE6:  CLRF   00
00AE8:  MOVLW  03
00AEA:  MOVWF  02
00AEC:  MOVLW  E4
00AEE:  MOVWF  01
00AF0:  MOVLB  0
00AF2:  RCALL  0916
.................... 	for ( i=0 ; i < N_NMEA0183_SENTENCES ; i++ ) { 
00AF4:  MOVLB  8
00AF6:  CLRF   xFC
00AF8:  MOVF   xFC,W
00AFA:  SUBLW  0B
00AFC:  BNC   0B30
.................... 		nmea.sentence_age[i]=0xffff; 
00AFE:  CLRF   03
00B00:  MOVFF  8FC,02
00B04:  BCF    FD8.0
00B06:  RLCF   02,F
00B08:  RLCF   03,F
00B0A:  MOVF   02,W
00B0C:  ADDLW  C4
00B0E:  MOVWF  FE9
00B10:  MOVLW  07
00B12:  ADDWFC 03,W
00B14:  MOVWF  FEA
00B16:  SETF   FEC
00B18:  MOVF   FED,F
00B1A:  SETF   FEF
.................... 		nmea.sentence_length[i]=0; 
00B1C:  MOVLW  DC
00B1E:  ADDWF  xFC,W
00B20:  MOVWF  FE9
00B22:  MOVLW  07
00B24:  MOVWF  FEA
00B26:  BTFSC  FD8.0
00B28:  INCF   FEA,F
00B2A:  CLRF   FEF
.................... 	} 
00B2C:  INCF   xFC,F
00B2E:  BRA    0AF8
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
00B30:  MOVFF  4C,1DD
00B34:  MOVFF  4B,1DC
.................... 	current.power_off_delay=config.power_off_below_delay; 
00B38:  MOVFF  48,1DF
00B3C:  MOVFF  47,1DE
.................... 	current.power_override_timeout=0; 
00B40:  MOVLB  1
00B42:  CLRF   xE1
00B44:  CLRF   xE0
....................  
.................... 	/* UART2 - RS-485 port */ 
.................... 	set_rs485_speed(); 
00B46:  MOVLB  0
00B48:  RCALL  0930
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00B4A:  MOVLW  00
00B4C:  IORLW  05
00B4E:  MOVWF  FBA
00B50:  MOVLW  4A
00B52:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00B54:  BSF    F9D.1
.................... 	enable_interrupts(INT_RDA2); /* debug cable */ 
00B56:  BSF    FA3.5
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00B58:  GOTO   31B2 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... 	static int16 b0_state=0; /* push button */ 
.................... 	/* power control */ 
.................... 	int8 i; 
....................  
....................  
.................... 	timers.now_millisecond=0; 
*
010E6:  MOVLB  1
010E8:  BCF    xFB.2
....................  
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
010EA:  BCF    FD8.0
010EC:  MOVLB  8
010EE:  RLCF   xF9,W
010F0:  MOVWF  xFD
010F2:  RLCF   xFA,W
010F4:  MOVWF  xFE
010F6:  MOVLW  00
010F8:  MOVLB  1
010FA:  BTFSS  xFC.3
010FC:  MOVLW  01
010FE:  MOVLB  8
01100:  IORWF  xFD,F
01102:  MOVFF  8FD,8F9
01106:  MOVF   xFE,W
01108:  IORLW  E0
0110A:  MOVWF  xFA
.................... 	if ( b0_state==0xf000) { 
0110C:  MOVF   xF9,F
0110E:  BNZ   1120
01110:  MOVF   xFA,W
01112:  SUBLW  F0
01114:  BNZ   1120
.................... 		/* button pressed */ 
.................... 		current.button_state=1; 
01116:  MOVLW  01
01118:  MOVLB  1
0111A:  MOVWF  xE6
.................... 	} else { 
0111C:  BRA    1124
0111E:  MOVLB  8
.................... 		current.button_State=0; 
01120:  MOVLB  1
01122:  CLRF   xE6
.................... 	} 
....................  
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
01124:  INCFSZ xE7,W
01126:  BRA    1134
01128:  INCFSZ xE8,W
0112A:  BRA    1134
.................... 				current.pulse_period[0]=0; 
0112C:  MOVLB  0
0112E:  CLRF   x98
01130:  CLRF   x97
01132:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
01134:  INCFSZ xE9,W
01136:  BRA    1144
01138:  INCFSZ xEA,W
0113A:  BRA    1144
.................... 				current.pulse_period[1]=0; 
0113C:  MOVLB  0
0113E:  CLRF   x9A
01140:  CLRF   x99
01142:  MOVLB  1
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
01144:  INCFSZ xEB,W
01146:  BRA    1154
01148:  INCFSZ xEC,W
0114A:  BRA    1154
.................... 				current.pulse_period[2]=0; 
0114C:  MOVLB  0
0114E:  CLRF   x9C
01150:  CLRF   x9B
01152:  MOVLB  1
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
01154:  MOVFF  F81,1FC
.................... 	timers.port_c=port_c; 
01158:  MOVFF  F82,1FD
....................  
.................... 	/* green LED control */ 
.................... 	if ( 0==timers.led_on_green ) { 
0115C:  MOVF   xF8,F
0115E:  BNZ   1164
.................... 		output_low(LED_GREEN); 
01160:  BCF    F89.3
.................... 	} else { 
01162:  BRA    1168
.................... 		output_high(LED_GREEN); 
01164:  BSF    F89.3
.................... 		timers.led_on_green--; 
01166:  DECF   xF8,F
.................... 	} 
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
01168:  INCFSZ xD6,W
0116A:  BRA    1172
0116C:  INCFSZ xD7,W
0116E:  BRA    1172
01170:  BRA    1178
.................... 		current.interval_milliseconds++; 
01172:  INCF   xD6,F
01174:  BTFSC  FD8.2
01176:  INCF   xD7,F
.................... 	} 
....................  
.................... 	if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
01178:  MOVF   38,W
0117A:  SUBLW  02
0117C:  BNZ   11D6
.................... 		/* NMEA sentence age */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
0117E:  MOVLB  8
01180:  CLRF   xFC
01182:  MOVF   xFC,W
01184:  SUBLW  0B
01186:  BNC   11D6
.................... 			if ( 0xffff != nmea.sentence_age[i] ) 
01188:  CLRF   03
0118A:  MOVFF  8FC,02
0118E:  BCF    FD8.0
01190:  RLCF   02,F
01192:  RLCF   03,F
01194:  MOVF   02,W
01196:  ADDLW  C4
01198:  MOVWF  FE9
0119A:  MOVLW  07
0119C:  ADDWFC 03,W
0119E:  MOVWF  FEA
011A0:  MOVFF  FEC,03
011A4:  MOVF   FED,F
011A6:  MOVF   FEF,W
011A8:  SUBLW  FF
011AA:  BNZ   11B2
011AC:  INCFSZ 03,W
011AE:  BRA    11B2
011B0:  BRA    11D2
.................... 				nmea.sentence_age[i]++; 
011B2:  CLRF   03
011B4:  MOVFF  8FC,02
011B8:  BCF    FD8.0
011BA:  RLCF   02,F
011BC:  RLCF   03,F
011BE:  MOVF   02,W
011C0:  ADDLW  C4
011C2:  MOVWF  FE9
011C4:  MOVLW  07
011C6:  ADDWFC 03,W
011C8:  MOVWF  FEA
011CA:  MOVLW  01
011CC:  ADDWF  FEE,F
011CE:  BNC   11D2
011D0:  INCF   FEF,F
.................... 		} 
011D2:  INCF   xFC,F
011D4:  BRA    1182
.................... 	} 
....................  
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
011D6:  MOVLB  8
011D8:  INCF   xF7,F
011DA:  BTFSC  FD8.2
011DC:  INCF   xF8,F
.................... 	if ( 1000 == ticks ) { 
011DE:  MOVF   xF7,W
011E0:  SUBLW  E8
011E2:  BNZ   1268
011E4:  MOVF   xF8,W
011E6:  SUBLW  03
011E8:  BNZ   1268
.................... 		ticks=0; 
011EA:  CLRF   xF8
011EC:  CLRF   xF7
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
011EE:  MOVLB  1
011F0:  INCFSZ xD9,W
011F2:  BRA    11FA
011F4:  INCFSZ xDA,W
011F6:  BRA    11FA
011F8:  BRA    1200
.................... 			current.watchdog_seconds++; 
011FA:  INCF   xD9,F
011FC:  BTFSC  FD8.2
011FE:  INCF   xDA,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
01200:  MOVF   40,F
01202:  BNZ   1208
01204:  MOVF   41,F
01206:  BZ    1226
01208:  MOVF   41,W
0120A:  SUBWF  xDA,W
0120C:  BNC   1226
0120E:  BNZ   1216
01210:  MOVF   xD9,W
01212:  SUBWF  40,W
01214:  BC    1226
01216:  MOVF   xF9,F
01218:  BNZ   1226
0121A:  MOVF   xFA,F
0121C:  BNZ   1226
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
0121E:  MOVFF  43,1FA
01222:  MOVFF  42,1F9
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
01226:  MOVF   xF9,F
01228:  BNZ   1232
0122A:  MOVF   xFA,F
0122C:  BNZ   1232
.................... 			output_high(PI_POWER_EN); 
0122E:  BSF    F8B.0
.................... 		} else { 
01230:  BRA    1248
.................... 			output_low(PI_POWER_EN); 
01232:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01234:  MOVF   xF9,W
01236:  BTFSC  FD8.2
01238:  DECF   xFA,F
0123A:  DECF   xF9,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
0123C:  MOVF   xF9,F
0123E:  BNZ   1248
01240:  MOVF   xFA,F
01242:  BNZ   1248
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01244:  CLRF   xDA
01246:  CLRF   xD9
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
01248:  MOVLB  8
0124A:  INCF   xF4,F
.................... 		if ( 60 == uptimeTicks ) { 
0124C:  MOVF   xF4,W
0124E:  SUBLW  3C
01250:  BNZ   1268
.................... 			uptimeTicks=0; 
01252:  CLRF   xF4
.................... 			if ( current.uptime_minutes < 65535 )  
01254:  MOVLB  1
01256:  INCFSZ xD4,W
01258:  BRA    1260
0125A:  INCFSZ xD5,W
0125C:  BRA    1260
0125E:  BRA    1266
.................... 				current.uptime_minutes++; 
01260:  INCF   xD4,F
01262:  BTFSC  FD8.2
01264:  INCF   xD5,F
01266:  MOVLB  8
.................... 		} 
.................... 	} 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
01268:  MOVLB  1
0126A:  BTFSS  xFB.1
0126C:  BRA    1276
.................... 		timers.now_adc_reset_count=0; 
0126E:  BCF    xFB.1
.................... 		adcTicks=0; 
01270:  MOVLB  8
01272:  CLRF   xF6
01274:  CLRF   xF5
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
01276:  MOVLB  8
01278:  INCF   xF5,F
0127A:  BTFSC  FD8.2
0127C:  INCF   xF6,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
0127E:  MOVF   3D,W
01280:  SUBWF  xF5,W
01282:  BNZ   1292
01284:  MOVF   3E,W
01286:  SUBWF  xF6,W
01288:  BNZ   1292
.................... 		adcTicks=0; 
0128A:  CLRF   xF6
0128C:  CLRF   xF5
.................... 		timers.now_adc_sample=1; 
0128E:  MOVLB  1
01290:  BSF    xFB.0
.................... 	} 
....................  
.................... 	/* for RS-485 port */ 
.................... 	if ( timers.rda2_buff_gap < 255 ) { 
01292:  MOVLB  3
01294:  INCFSZ x00,W
01296:  BRA    129A
01298:  BRA    129C
.................... 		timers.rda2_buff_gap++; 
0129A:  INCF   x00,F
.................... 	} 
....................  
.................... 	/* RS-485: if we have data and we have >=10 miliseconds gap, we parse */ 
.................... 	if ( timers.rda2_buff_gap >= 10 && timers.rda2_buff_pos>0 ) { 
0129C:  MOVF   x00,W
0129E:  SUBLW  09
012A0:  BC    12B4
012A2:  MOVLB  2
012A4:  MOVF   xFF,F
012A6:  BTFSS  FD8.2
012A8:  BRA    12AE
012AA:  MOVLB  3
012AC:  BRA    12B4
.................... 		timers.now_parse_rda2=1;	 
012AE:  MOVLB  1
012B0:  BSF    xFE.0
012B2:  MOVLB  3
.................... 	} 
.................... } 
012B4:  MOVLB  0
012B6:  GOTO   3324 (RETURN)
....................  
.................... /* copy up to n characters, stopping at \0 or \n or \r. Due to int8s, we are limited to < 255 characters */ 
.................... void strncpy_terminate_trim(int8 *dest, int8 *src, int8 validLength, int8 maxLength) { 
.................... 	int8 i; 
....................  
.................... 	/* copy until we get to \0 or \n or \r */ 
.................... 	for (i = 0 ; i < validLength && i < maxLength && src[i] != '\0' && src[i] != '\n' && src[i] != '\r' ; i++) { 
*
02EFE:  MOVLB  A
02F00:  CLRF   x08
02F02:  MOVF   x06,W
02F04:  SUBWF  x08,W
02F06:  BC    2F7A
02F08:  MOVF   x07,W
02F0A:  SUBWF  x08,W
02F0C:  BC    2F7A
02F0E:  CLRF   03
02F10:  MOVF   x08,W
02F12:  ADDWF  x04,W
02F14:  MOVWF  FE9
02F16:  MOVF   x05,W
02F18:  ADDWFC 03,W
02F1A:  MOVWF  FEA
02F1C:  MOVF   FEF,F
02F1E:  BZ    2F7A
02F20:  CLRF   03
02F22:  MOVF   x08,W
02F24:  ADDWF  x04,W
02F26:  MOVWF  FE9
02F28:  MOVF   x05,W
02F2A:  ADDWFC 03,W
02F2C:  MOVWF  FEA
02F2E:  MOVF   FEF,W
02F30:  SUBLW  0A
02F32:  BZ    2F7A
02F34:  CLRF   03
02F36:  MOVF   x08,W
02F38:  ADDWF  x04,W
02F3A:  MOVWF  FE9
02F3C:  MOVF   x05,W
02F3E:  ADDWFC 03,W
02F40:  MOVWF  FEA
02F42:  MOVF   FEF,W
02F44:  SUBLW  0D
02F46:  BZ    2F7A
.................... 		dest[i] = src[i]; 
02F48:  CLRF   03
02F4A:  MOVF   x08,W
02F4C:  ADDWF  x02,W
02F4E:  MOVWF  01
02F50:  MOVF   x03,W
02F52:  ADDWFC 03,F
02F54:  MOVFF  03,A0A
02F58:  CLRF   03
02F5A:  MOVF   x08,W
02F5C:  ADDWF  x04,W
02F5E:  MOVWF  FE9
02F60:  MOVF   x05,W
02F62:  ADDWFC 03,W
02F64:  MOVWF  FEA
02F66:  MOVFF  FEF,A0B
02F6A:  MOVFF  A0A,FEA
02F6E:  MOVFF  01,FE9
02F72:  MOVFF  A0B,FEF
.................... 	} 
02F76:  INCF   x08,F
02F78:  BRA    2F02
....................  
.................... 	/* pad remaining space with \0 */ 
.................... 	for ( ; i < maxLength ; i++) { 
02F7A:  MOVF   x07,W
02F7C:  SUBWF  x08,W
02F7E:  BC    2F94
.................... 		dest[i] = '\0'; 
02F80:  CLRF   03
02F82:  MOVF   x08,W
02F84:  ADDWF  x02,W
02F86:  MOVWF  FE9
02F88:  MOVF   x03,W
02F8A:  ADDWFC 03,W
02F8C:  MOVWF  FEA
02F8E:  CLRF   FEF
.................... 	} 
02F90:  INCF   x08,F
02F92:  BRA    2F7A
....................  
.................... 	/* always null terminate */ 
.................... 	dest[maxLength-1]='\0'; 
02F94:  MOVLW  01
02F96:  SUBWF  x07,W
02F98:  CLRF   03
02F9A:  ADDWF  x02,W
02F9C:  MOVWF  FE9
02F9E:  MOVF   x03,W
02FA0:  ADDWFC 03,W
02FA2:  MOVWF  FEA
02FA4:  CLRF   FEF
.................... } 
02FA6:  MOVLB  0
02FA8:  GOTO   30D2 (RETURN)
....................  
....................  
.................... void rs485_to_host(void) { 
.................... 	int8 buff[sizeof(timers.rda2_buff)]; 
.................... 	int8 length; 
.................... 	int16 l; 
.................... 	int8 i; 
....................  
.................... 	/* get a local copy of our data */ 
.................... 	length=timers.rda2_buff_pos; 
02FAC:  MOVFF  2FF,9FC
.................... 	timers.rda2_buff_pos=255; /* stop getting data briefly */ 
02FB0:  MOVLB  2
02FB2:  SETF   xFF
.................... 	memcpy(buff,timers.rda2_buff,length); 
02FB4:  MOVLW  08
02FB6:  MOVWF  FEA
02FB8:  MOVLW  FC
02FBA:  MOVWF  FE9
02FBC:  MOVLW  01
02FBE:  MOVWF  FE2
02FC0:  SETF   FE1
02FC2:  MOVLB  9
02FC4:  MOVF   xFC,W
02FC6:  MOVWF  01
02FC8:  BZ    2FD2
02FCA:  MOVFF  FE6,FEE
02FCE:  DECFSZ 01,F
02FD0:  BRA    2FCA
.................... 	timers.rda2_buff_gap=0; 
02FD2:  MOVLB  3
02FD4:  CLRF   x00
.................... 	timers.rda2_buff_pos=0; 
02FD6:  MOVLB  2
02FD8:  CLRF   xFF
....................  
....................  
.................... 	if ( RS485_MODE_MODBUS_BRIDGE==config.rs485_port_mode ) { 
02FDA:  DECFSZ 38,W
02FDC:  BRA    3016
.................... 		/* transmit MODBUS received data back out to the PI */ 
.................... 		for ( l=0 ; l<length ; l++ ) { 
02FDE:  MOVLB  9
02FE0:  CLRF   xFE
02FE2:  CLRF   xFD
02FE4:  MOVF   xFE,F
02FE6:  BNZ   3012
02FE8:  MOVF   xFC,W
02FEA:  SUBWF  xFD,W
02FEC:  BC    3012
.................... 			fputc(buff[l],STREAM_PI); 
02FEE:  MOVLW  FC
02FF0:  ADDWF  xFD,W
02FF2:  MOVWF  FE9
02FF4:  MOVLW  08
02FF6:  ADDWFC xFE,W
02FF8:  MOVWF  FEA
02FFA:  MOVFF  FEF,A00
02FFE:  MOVLB  A
03000:  MOVF   x00,W
03002:  MOVLB  0
03004:  CALL   0744
.................... 		} 
03008:  MOVLB  9
0300A:  INCF   xFD,F
0300C:  BTFSC  FD8.2
0300E:  INCF   xFE,F
03010:  BRA    2FE4
.................... 	} else if ( RS485_MODE_NMEA0183_RX==config.rs485_port_mode ) { 
03012:  BRA    310A
03014:  MOVLB  2
03016:  MOVF   38,W
03018:  SUBLW  02
0301A:  BTFSS  FD8.2
0301C:  BRA    310C
.................... 		/* process NMEA0183 sentence */ 
.................... 		/* too short to be a NMEA0183 sentence */ 
.................... 		if ( length < 6 ) { 
0301E:  MOVLB  9
03020:  MOVF   xFC,W
03022:  SUBLW  05
03024:  BNC   3028
.................... 			return; 
03026:  BRA    310A
.................... 		} 
....................  
.................... 		/* search through list of sentences to record and see if we exist */ 
.................... 		for ( i=0 ; i<N_NMEA0183_SENTENCES ; i++ ) { 
03028:  CLRF   xFF
0302A:  MOVF   xFF,W
0302C:  SUBLW  0B
0302E:  BNC   310A
.................... 			/* compare first six characters or look for wild card */ 
.................... 			if ( 0 != strncmp(buff,config.nmea0183_sentence[i],6) && '*' != config.nmea0183_sentence[i][0] ) { 
03030:  MOVF   xFF,W
03032:  MULLW  06
03034:  MOVF   FF3,W
03036:  CLRF   03
03038:  ADDLW  4F
0303A:  MOVWF  01
0303C:  MOVLW  00
0303E:  ADDWFC 03,F
03040:  MOVFF  01,A00
03044:  MOVLB  A
03046:  MOVFF  03,A01
0304A:  MOVLW  08
0304C:  MOVWF  x03
0304E:  MOVLW  FC
03050:  MOVWF  x02
03052:  MOVFF  03,A05
03056:  MOVFF  01,A04
0305A:  CLRF   x07
0305C:  MOVLW  06
0305E:  MOVWF  x06
03060:  MOVLB  0
03062:  BRA    2E66
03064:  MOVF   01,F
03066:  BZ    308A
03068:  MOVLB  9
0306A:  MOVF   xFF,W
0306C:  MULLW  06
0306E:  MOVF   FF3,W
03070:  CLRF   03
03072:  ADDLW  4F
03074:  MOVWF  FE9
03076:  MOVLW  00
03078:  ADDWFC 03,W
0307A:  MOVWF  FEA
0307C:  MOVF   FEF,W
0307E:  SUBLW  2A
03080:  BTFSS  FD8.2
03082:  BRA    3088
03084:  MOVLB  0
03086:  BRA    308A
.................... 				/* no match */ 
.................... 				continue; 
03088:  BRA    3106
.................... 			} 
....................  
.................... 			/* copy to appropriate slot */ 
.................... 			strncpy_terminate_trim(nmea.sentence[i],buff,length,NMEA_SENTENCE_LENGTH); 
0308A:  MOVLB  A
0308C:  CLRF   x01
0308E:  MOVFF  9FF,A00
03092:  CLRF   x03
03094:  MOVLW  50
03096:  MOVWF  x02
03098:  MOVLB  0
0309A:  CALL   08F4
0309E:  MOVFF  02,03
030A2:  MOVF   01,W
030A4:  ADDLW  04
030A6:  MOVWF  01
030A8:  MOVLW  04
030AA:  ADDWFC 03,F
030AC:  MOVFF  01,A00
030B0:  MOVLB  A
030B2:  MOVFF  03,A01
030B6:  MOVFF  03,A03
030BA:  MOVFF  01,A02
030BE:  MOVLW  08
030C0:  MOVWF  x05
030C2:  MOVLW  FC
030C4:  MOVWF  x04
030C6:  MOVFF  9FC,A06
030CA:  MOVLW  50
030CC:  MOVWF  x07
030CE:  MOVLB  0
030D0:  BRA    2EFE
.................... 			nmea.sentence_age[i]=0; 
030D2:  CLRF   03
030D4:  MOVLB  9
030D6:  MOVFF  9FF,02
030DA:  BCF    FD8.0
030DC:  RLCF   02,F
030DE:  RLCF   03,F
030E0:  MOVF   02,W
030E2:  ADDLW  C4
030E4:  MOVWF  FE9
030E6:  MOVLW  07
030E8:  ADDWFC 03,W
030EA:  MOVWF  FEA
030EC:  CLRF   FEC
030EE:  MOVF   FED,F
030F0:  CLRF   FEF
.................... 			nmea.sentence_length[i]=length; 
030F2:  MOVLW  DC
030F4:  ADDWF  xFF,W
030F6:  MOVWF  FE9
030F8:  MOVLW  07
030FA:  MOVWF  FEA
030FC:  BTFSC  FD8.0
030FE:  INCF   FEA,F
03100:  MOVFF  9FC,FEF
....................  
.................... 			/* only fill in our first match */ 
.................... 			break; 
03104:  BRA    310A
.................... 		} 
03106:  INCF   xFF,F
03108:  BRA    302A
0310A:  MOVLB  2
.................... 	} 
.................... } 
0310C:  MOVLB  0
0310E:  GOTO   3372 (RETURN)
....................  
....................  
.................... void main(void) { 
03112:  CLRF   FF8
03114:  BCF    FF1.2
03116:  BSF    F9F.1
03118:  BCF    F9F.5
0311A:  BCF    F9F.4
0311C:  BCF    FA5.5
0311E:  BSF    FD0.7
03120:  BSF    07.7
03122:  CLRF   FEA
03124:  CLRF   FE9
03126:  CLRF   35
03128:  BCF    FB8.3
0312A:  MOVLW  0C
0312C:  MOVWF  FAF
0312E:  MOVLW  A6
03130:  MOVWF  FAC
03132:  MOVLW  90
03134:  MOVWF  FAB
03136:  BCF    F70.3
03138:  MOVLW  4D
0313A:  MOVWF  F75
0313C:  MOVLW  A6
0313E:  MOVWF  F72
03140:  MOVLW  90
03142:  MOVWF  F71
03144:  MOVLB  7
03146:  BCF    xE8.0
03148:  CLRF   xE9
0314A:  MOVLB  8
0314C:  CLRF   xF3
0314E:  MOVLB  7
03150:  BCF    xE8.1
03152:  BCF    xE8.2
03154:  BCF    xE8.3
03156:  BCF    xE8.4
03158:  BCF    xE8.5
0315A:  BCF    xE8.6
0315C:  MOVLB  8
0315E:  CLRF   xF4
03160:  CLRF   xF6
03162:  CLRF   xF5
03164:  CLRF   xF8
03166:  CLRF   xF7
03168:  CLRF   xFA
0316A:  CLRF   xF9
0316C:  MOVF   FC1,W
0316E:  ANDLW  F0
03170:  MOVWF  FC1
03172:  MOVLW  00
03174:  MOVLB  F
03176:  MOVWF  x38
03178:  MOVWF  x3C
0317A:  MOVWF  x39
0317C:  MOVWF  x3A
0317E:  MOVWF  x3B
03180:  MOVLB  1
03182:  CLRF   x88
03184:  CLRF   F77
03186:  CLRF   F78
03188:  CLRF   F79
0318A:  CLRF   2F
0318C:  CLRF   30
0318E:  MOVLB  8
03190:  CLRF   xEF
03192:  CLRF   xF0
03194:  CLRF   xF1
03196:  CLRF   xF2
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
03198:  MOVF   FD0,W
0319A:  ANDLW  0F
0319C:  BTFSS  FD0.4
0319E:  MOVLW  00
031A0:  BSF    FD0.0
031A2:  BSF    FD0.1
031A4:  BSF    FD0.4
031A6:  BSF    FD8.3
031A8:  BSF    FD8.4
031AA:  MOVWF  xFB
....................  
.................... 	init(); 
031AC:  MOVLB  0
031AE:  GOTO   09B2
....................  
....................  
.................... #if 1 
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
031B2:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
031B4:  BSF    F8C.0
....................  
....................  
.................... 	fprintf(STREAM_RS485,"# pcwx %s\r\n",__DATE__); 
031B6:  MOVLW  36
031B8:  MOVWF  FF6
031BA:  MOVLW  08
031BC:  MOVWF  FF7
031BE:  MOVLW  07
031C0:  MOVLB  8
031C2:  MOVWF  xFC
031C4:  MOVLB  0
031C6:  CALL   0B5C
031CA:  MOVLW  42
031CC:  MOVWF  FF6
031CE:  MOVLW  08
031D0:  MOVWF  FF7
031D2:  CALL   0B86
031D6:  MOVLW  0D
031D8:  BTFSS  FA4.4
031DA:  BRA    31D8
031DC:  MOVWF  F73
031DE:  MOVLW  0A
031E0:  BTFSS  FA4.4
031E2:  BRA    31E0
031E4:  MOVWF  F73
.................... 	fprintf(STREAM_RS485,"# restart_cause()=%u ",i); 
031E6:  MOVLW  4C
031E8:  MOVWF  FF6
031EA:  MOVLW  08
031EC:  MOVWF  FF7
031EE:  MOVLW  12
031F0:  MOVLB  8
031F2:  MOVWF  xFC
031F4:  MOVLB  0
031F6:  CALL   0B5C
031FA:  MOVFF  8FB,8FC
031FE:  MOVLW  1B
03200:  MOVLB  8
03202:  MOVWF  xFD
03204:  MOVLB  0
03206:  GOTO   0BD4
0320A:  MOVLW  20
0320C:  BTFSS  FA4.4
0320E:  BRA    320C
03210:  MOVWF  F73
....................  
.................... 	switch ( i ) { 
03212:  MOVLB  8
03214:  MOVF   xFB,W
03216:  XORLW  07
03218:  MOVLB  0
0321A:  BZ    3236
0321C:  XORLW  0C
0321E:  BZ    3244
03220:  XORLW  04
03222:  BZ    3252
03224:  XORLW  03
03226:  BZ    3260
03228:  XORLW  02
0322A:  BZ    326E
0322C:  XORLW  0D
0322E:  BZ    327C
03230:  XORLW  03
03232:  BZ    328A
03234:  BRA    3298
.................... 		case WDT_TIMEOUT: fprintf(STREAM_RS485,"WDT_TIMEOUT"); break; 
03236:  MOVLW  62
03238:  MOVWF  FF6
0323A:  MOVLW  08
0323C:  MOVWF  FF7
0323E:  CALL   0B86
03242:  BRA    32A4
.................... 		case MCLR_FROM_SLEEP: fprintf(STREAM_RS485,"MCLR_FROM_SLEEP"); break; 
03244:  MOVLW  6E
03246:  MOVWF  FF6
03248:  MOVLW  08
0324A:  MOVWF  FF7
0324C:  CALL   0B86
03250:  BRA    32A4
.................... 		case MCLR_FROM_RUN: fprintf(STREAM_RS485,"MCLR_FROM_RUN"); break; 
03252:  MOVLW  7E
03254:  MOVWF  FF6
03256:  MOVLW  08
03258:  MOVWF  FF7
0325A:  CALL   0B86
0325E:  BRA    32A4
.................... 		case NORMAL_POWER_UP: fprintf(STREAM_RS485,"NORMAL_POWER_UP"); break; 
03260:  MOVLW  8C
03262:  MOVWF  FF6
03264:  MOVLW  08
03266:  MOVWF  FF7
03268:  CALL   0B86
0326C:  BRA    32A4
.................... 		case BROWNOUT_RESTART: fprintf(STREAM_RS485,"BROWNOUT_RESTART"); break; 
0326E:  MOVLW  9C
03270:  MOVWF  FF6
03272:  MOVLW  08
03274:  MOVWF  FF7
03276:  CALL   0B86
0327A:  BRA    32A4
.................... 		case WDT_FROM_SLEEP: fprintf(STREAM_RS485,"WDT_FROM_SLEEP"); break; 
0327C:  MOVLW  AE
0327E:  MOVWF  FF6
03280:  MOVLW  08
03282:  MOVWF  FF7
03284:  CALL   0B86
03288:  BRA    32A4
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_RS485,"RESET_INSTRUCTION"); break; 
0328A:  MOVLW  BE
0328C:  MOVWF  FF6
0328E:  MOVLW  08
03290:  MOVWF  FF7
03292:  CALL   0B86
03296:  BRA    32A4
.................... 		default: fprintf(STREAM_RS485,"unknown!"); 
03298:  MOVLW  D0
0329A:  MOVWF  FF6
0329C:  MOVLW  08
0329E:  MOVWF  FF7
032A0:  CALL   0B86
.................... 	} 
.................... 	fprintf(STREAM_RS485,"\r\n"); 
032A4:  MOVLW  DA
032A6:  MOVWF  FF6
032A8:  MOVLW  08
032AA:  MOVWF  FF7
032AC:  CALL   0B86
.................... #endif 
....................  
....................  
.................... 	read_param_file(); 
032B0:  GOTO   0EB0
....................  
....................  
.................... 	if ( config.modbus_address > 128 ) { 
032B4:  MOVF   36,W
032B6:  SUBLW  80
032B8:  BC    32BE
.................... 		write_default_param_file(); 
032BA:  CALL   0DEC
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
032BE:  BSF    FAB.7
032C0:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	modbus_init(); 
032C2:  GOTO   0F14
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
032C6:  MOVLB  8
032C8:  CLRF   xFB
032CA:  MOVF   xFB,W
032CC:  SUBLW  1D
032CE:  BNC   32DC
.................... 		adc_update(); 
032D0:  MOVLB  0
032D2:  CALL   0FEE
.................... 	} 
032D6:  MOVLB  8
032D8:  INCF   xFB,F
032DA:  BRA    32CA
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
032DC:  MOVFF  44,1DB
....................  
....................  
.................... #if 1 
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
032E0:  BTFSS  F72.1
032E2:  BRA    32E0
.................... 	output_low(RS485_DE); 
032E4:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
032E6:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
.................... #endif 
....................  
.................... 	fprintf(STREAM_PI,"# pcwx %s\r\n",__DATE__); 
032E8:  MOVLW  DE
032EA:  MOVWF  FF6
032EC:  MOVLW  08
032EE:  MOVWF  FF7
032F0:  MOVLW  07
032F2:  MOVWF  xFC
032F4:  MOVLB  0
032F6:  GOTO   1096
032FA:  MOVLW  EA
032FC:  MOVWF  FF6
032FE:  MOVLW  08
03300:  MOVWF  FF7
03302:  GOTO   10C2
03306:  MOVLW  0D
03308:  BTFSS  F9E.4
0330A:  BRA    3308
0330C:  MOVWF  FAD
0330E:  MOVLW  0A
03310:  BTFSS  F9E.4
03312:  BRA    3310
03314:  MOVWF  FAD
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
03316:  CLRWDT
....................  
....................  
.................... 		if ( timers.now_millisecond ) { 
03318:  MOVLB  1
0331A:  BTFSS  xFB.2
0331C:  BRA    3326
.................... 			periodic_millisecond(); 
0331E:  MOVLB  0
03320:  GOTO   10E6
03324:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
03326:  BTFSS  xFB.0
03328:  BRA    3332
.................... 			timers.now_adc_sample=0; 
0332A:  BCF    xFB.0
.................... 			adc_update(); 
0332C:  MOVLB  0
0332E:  CALL   0FEE
.................... 		} 
....................  
.................... 		modbus_process(); 
03332:  MOVLB  0
03334:  BRA    2B5C
....................  
....................  
.................... 		/* buffered modbus transmit */ 
....................  
.................... 		/* start transmitting */ 
.................... 		if ( timers.now_rda_tx_ready ) { 
03336:  MOVLB  4
03338:  BTFSS  x03.0
0333A:  BRA    334E
.................... 			timers.now_rda_tx_ready=0; 
0333C:  BCF    x03.0
....................  
.................... //			output_high(_PIC_TO_PI); 
....................  
.................... 			RCV_OFF(); 
0333E:  BCF    F9D.5
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
03340:  CLRWDT
03342:  MOVLW  3C
03344:  MOVWF  00
03346:  DECFSZ 00,F
03348:  BRA    3346
0334A:  NOP   
....................  
.................... 			/* enable transmit buffer empty interrupt. It will feed itself */ 
.................... 			enable_interrupts(INT_TBE); 
0334C:  BSF    F9D.4
.................... 		} 
....................  
.................... 		/* done transmitting */ 
.................... 		if ( timers.now_rda_tx_done ) { 
0334E:  BTFSS  x03.1
03350:  BRA    3366
.................... 			timers.now_rda_tx_done=0; 
03352:  BCF    x03.1
....................  
.................... 			/* 3.5 character delay (3500000/baud) */ 
.................... 			delay_us(61); /* 57600 */ 
03354:  CLRWDT
03356:  MOVLW  3C
03358:  MOVWF  00
0335A:  DECFSZ 00,F
0335C:  BRA    335A
0335E:  NOP   
....................    			RCV_ON(); 
03360:  MOVLB  0
03362:  CALL   0F08
....................  
.................... //			output_low(_PIC_TO_PI); 
.................... 		} 
....................  
....................  
....................  
.................... 		if ( timers.now_parse_rda2 ) { 
03366:  MOVLB  1
03368:  BTFSS  xFE.0
0336A:  BRA    3374
.................... 			timers.now_parse_rda2=0; 
0336C:  BCF    xFE.0
.................... 			rs485_to_host(); 
0336E:  MOVLB  0
03370:  BRA    2FAC
03372:  MOVLB  1
.................... 		} 
....................  
.................... 	} 
03374:  MOVLB  0
03376:  BRA    3316
.................... } 
03378:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
