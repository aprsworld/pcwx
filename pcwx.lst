CCS PCH C Compiler, Version 4.135, 4375               12-Oct-15 16:59

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\pcwx\pcwx.lst

               ROM used: 9434 bytes (14%)
                         Largest free fragment is 56098
               RAM used: 711 (18%) at main() level
                         745 (19%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
00000:  GOTO   2256
*
00008:  GOTO   00CA
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FF2.5
00066:  GOTO   0070
0006A:  BTFSC  FF2.2
0006C:  GOTO   044E
00070:  BTFSS  F9D.5
00072:  GOTO   007C
00076:  BTFSC  F9E.5
00078:  GOTO   0708
0007C:  MOVFF  0E,00
00080:  MOVFF  0F,01
00084:  MOVFF  10,02
00088:  MOVFF  11,03
0008C:  MOVFF  0C,FE9
00090:  MOVFF  07,FEA
00094:  BSF    07.7
00096:  MOVFF  08,FE1
0009A:  MOVFF  09,FE2
0009E:  MOVFF  0A,FD9
000A2:  MOVFF  0B,FDA
000A6:  MOVFF  12,FF3
000AA:  MOVFF  13,FF4
000AE:  MOVFF  14,FFA
000B2:  MOVFF  15,FF5
000B6:  MOVFF  16,FF6
000BA:  MOVFF  17,FF7
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
000CA:  MOVWF  1A
000CC:  MOVFF  FD8,1B
000D0:  MOVFF  FE0,1C
000D4:  MOVLB  0
000D6:  MOVFF  FE9,22
000DA:  MOVFF  FEA,1D
000DE:  MOVFF  FE1,1E
000E2:  MOVFF  FE2,1F
000E6:  MOVFF  FD9,20
000EA:  MOVFF  FDA,21
000EE:  MOVFF  FF3,28
000F2:  MOVFF  FF4,29
000F6:  MOVFF  FFA,2A
000FA:  MOVFF  FF5,2B
000FE:  MOVFF  FF6,2C
00102:  MOVFF  FF7,2D
00106:  MOVFF  00,24
0010A:  MOVFF  01,25
0010E:  MOVFF  02,26
00112:  MOVFF  03,27
00116:  BTFSS  F9D.1
00118:  GOTO   0122
0011C:  BTFSC  F9E.1
0011E:  GOTO   0480
00122:  MOVFF  24,00
00126:  MOVFF  25,01
0012A:  MOVFF  26,02
0012E:  MOVFF  27,03
00132:  MOVFF  22,FE9
00136:  MOVFF  1D,FEA
0013A:  BSF    1D.7
0013C:  MOVFF  1E,FE1
00140:  MOVFF  1F,FE2
00144:  MOVFF  20,FD9
00148:  MOVFF  21,FDA
0014C:  MOVFF  28,FF3
00150:  MOVFF  29,FF4
00154:  MOVFF  2A,FFA
00158:  MOVFF  2B,FF5
0015C:  MOVFF  2C,FF6
00160:  MOVFF  2D,FF7
00164:  MOVF   1A,W
00166:  MOVFF  1C,FE0
0016A:  MOVFF  1B,FD8
0016E:  RETFIE 0
.................... #include "pcwx.h" 
.................... #include <18F46K22.h> 
.................... //////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... #device PIC18F46K22 
.................... #list 
....................  
.................... #device ADC=12 
.................... #device *=16 
.................... #device HIGH_INTS=TRUE /* allow high priority "FAST" interrutps */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES HSM,NOPROTECT,PUT,NOLVP,BROWNOUT,NOMCLR,WDT32768  
.................... #FUSES NOPLLEN, NOFCMEN, NOIESO, NOXINST, NODEBUG, NOPROTECT 
.................... #use delay(clock=12000000, restart_wdt) 
....................  
.................... /*  
.................... Parameters are stored in EEPROM 
.................... */ 
.................... #define PARAM_CRC_ADDRESS  0x000 
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2 
....................  
.................... #define EE_FOR_HOST_ADDRESS 512 
....................  
....................  
.................... #define WEATHER_X_BAUD 57600 
....................  
....................  
.................... /* UART1 - async serial connection connection to Pi */ 
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=WEATHER_X_BAUD,xmit=PIN_C6,rcv=PIN_C7,errors)	 
*
006BC:  BTFSS  F9E.5
006BE:  BRA    06BC
006C0:  MOVFF  FAB,35
006C4:  MOVFF  FAE,01
006C8:  BTFSS  35.1
006CA:  BRA    06D0
006CC:  BCF    FAB.4
006CE:  BSF    FAB.4
006D0:  RETURN 0
*
0116C:  BTFSS  F9E.4
0116E:  BRA    116C
01170:  MOVWF  FAD
01172:  GOTO   117E (RETURN)
....................  
....................  
.................... #byte TXSTA=GETENV("SFR:txsta1") 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #byte TXSTA2=GETENV("SFR:txsta2") 
.................... #bit  TRMT2=TXSTA2.1 
....................  
.................... #byte PORTB=GETENV("SFR:portb") 
.................... #byte INTCON2=GETENV("SFR:intcon2") 
.................... #bit RBPU=INTCON2.7 
....................  
.................... /* UART2 - RS-485 network */ 
.................... #use rs232(UART2, stream=DEBUG, baud=9600,errors)	 
*
006D2:  BTFSS  FA4.4
006D4:  BRA    06D2
006D6:  MOVWF  F73
006D8:  GOTO   071C (RETURN)
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #define LED_GREEN                PIN_A3 
.................... #define BUTTON                   PIN_B3 
.................... #define BUTTON_BIT               3 
.................... #define PI_POWER_EN              PIN_C0 
.................... #define PIC_BOOTLOAD_REQUEST     PIN_B4 
.................... #define PIC_BOOTLOAD_REQUEST_BIT 4 
.................... #define WATCHDOG_FROM_PI         PIN_B5 
.................... #define WATCHDOG_FROM_PI_BIT     5 
.................... #define SYNC_OUT                 PIN_D4 
.................... #define SER_TO_NET               PIN_D6 
.................... #define SER_FROM_NET             PIN_D7 
.................... #define PI_POWER_FLAG            PIN_C1 
....................  
.................... #define ADC_CLK                  PIN_C3 
.................... #define ADC_DOUT                 PIN_C4 
.................... #define ADC_DIN                  PIN_C5 
.................... #define ADC_NCS                  PIN_D2 
....................  
.................... #define RS485_NRE                PIN_D0 
.................... #define RS485_DE                 PIN_D1 
.................... #define PIC_TO_PI                PIN_D3 
.................... #define SER_TO_PI                PIN_C6 
.................... #define SER_FROM_PI              PIN_C7 
....................  
.................... typedef union { 
.................... 	int16 l[2]; 
....................     int8 b[4]; 
....................     int32 word; 
.................... } u_lblock; 
....................  
.................... #byte port_b=GETENV("SFR:portb") 
.................... #byte port_c=GETENV("SFR:portc") 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 modbus_address; 
.................... 	int8 modbus_mode; 
....................  
.................... 	int8 serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int16 adc_sample_ticks; 
....................  
.................... 	int8 allow_bootload_request; 
.................... 	int16 watchdog_seconds_max; 
.................... 	int16 pi_offtime_seconds; 
....................  
....................  
.................... 	/* power control switch settings */ 
.................... 	int8 power_startup; /* 0==start with PI off, 1==start with PI on */ 
.................... 	int16 power_off_below_adc; 
.................... 	int16 power_off_below_delay; 
.................... 	int16 power_on_above_adc; 
.................... 	int16 power_on_above_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_config; 
....................  
....................  
....................  
.................... typedef struct { 
.................... 	/* most recent valid */ 
.................... 	int16 pulse_period[3]; 
.................... 	int16 pulse_min_period[3]; 
.................... 	int16 pulse_max_period[3]; 
.................... 	int16 pulse_count[3]; 
.................... 	int32 pulse_sum[3]; 
....................  
.................... 	int16 adc_std_dev[8]; 
....................  
.................... 	/* circular buffer for ADC readings */ 
.................... 	int16 adc_buffer[8][16]; 
.................... 	int8  adc_buffer_index; 
....................  
.................... 	int16 modbus_our_packets; 
.................... 	int16 modbus_other_packets; 
.................... 	int16 modbus_last_error; 
....................  
.................... 	int16 sequence_number; 
.................... 	int16 uptime_minutes; 
.................... 	int16 interval_milliseconds; 
....................  
.................... 	int8 factory_unlocked; 
.................... 	int1 bridged_uarts; 
....................  
.................... 	int16 watchdog_seconds; 
....................  
.................... 	/* power control switch */ 
.................... 	int8 p_on; 
.................... 	int16 power_on_delay; 
.................... 	int16 power_off_delay; 
.................... 	int16 power_override_timeout; 
.................... } struct_current; 
....................  
.................... typedef struct { 
.................... 	int16 pulse_period[4]; 
.................... 	int16 pulse_count[4]; 
.................... 	int8 pulse_ch_en; 
....................  
.................... 	int8 led_on_green; 
.................... 	int16 load_off_seconds; 
....................  
.................... 	int1 now_adc_sample; 
.................... 	int1 now_adc_reset_count; 
....................  
.................... 	int1 now_millisecond; 
....................  
.................... 	int8 port_b; 
.................... 	int8 port_c; 
.................... } struct_time_keep; 
....................  
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_current current; 
.................... struct_time_keep timers; 
....................  
.................... #include "mcp3208_pcwx.c" 
.................... #define MCP3208_CLK  ADC_CLK 
.................... #define MCP3208_DOUT ADC_DOUT 
.................... #define MCP3208_DIN  ADC_DIN 
....................  
.................... #inline 
.................... void mcp3208_init(void) { 
.................... 	output_high(ADC_NCS); 
*
00E26:  BSF    F8C.2
.................... } 
....................  
.................... int16 mcp3208_read(int8 ch) { 
.................... 	int16 value; 
.................... 	int8 i; 
.................... 	int8 c; 
....................  
....................  
....................  
.................... 	output_low(MCP3208_CLK); 
*
00D86:  BCF    F8B.3
.................... 	output_high(MCP3208_DIN); 
00D88:  BSF    F8B.5
....................  
.................... 	output_low(ADC_NCS); 
00D8A:  BCF    F8C.2
....................  
.................... 	/* d0, d1, d2, single / !differential, start */	 
.................... 	if ( 0 == ch )  
00D8C:  MOVLB  2
00D8E:  MOVF   xC9,F
00D90:  BNZ   0D98
.................... 		c=0b00011; 
00D92:  MOVLW  03
00D94:  MOVWF  xCD
.................... 	else if ( 1 == ch )  
00D96:  BRA    0DE2
00D98:  DECFSZ xC9,W
00D9A:  BRA    0DA2
.................... 		c=0b10011; 
00D9C:  MOVLW  13
00D9E:  MOVWF  xCD
.................... 	else if ( 2 == ch )  
00DA0:  BRA    0DE2
00DA2:  MOVF   xC9,W
00DA4:  SUBLW  02
00DA6:  BNZ   0DAE
.................... 		c=0b01011; 
00DA8:  MOVLW  0B
00DAA:  MOVWF  xCD
.................... 	else if ( 3 == ch )  
00DAC:  BRA    0DE2
00DAE:  MOVF   xC9,W
00DB0:  SUBLW  03
00DB2:  BNZ   0DBA
.................... 		c=0b11011; 
00DB4:  MOVLW  1B
00DB6:  MOVWF  xCD
.................... 	else if ( 4 == ch ) 
00DB8:  BRA    0DE2
00DBA:  MOVF   xC9,W
00DBC:  SUBLW  04
00DBE:  BNZ   0DC6
.................... 		c=0b00111; 
00DC0:  MOVLW  07
00DC2:  MOVWF  xCD
.................... 	else if ( 5 == ch )  
00DC4:  BRA    0DE2
00DC6:  MOVF   xC9,W
00DC8:  SUBLW  05
00DCA:  BNZ   0DD2
.................... 		c=0b10111; 
00DCC:  MOVLW  17
00DCE:  MOVWF  xCD
.................... 	else if ( 6 == ch ) 
00DD0:  BRA    0DE2
00DD2:  MOVF   xC9,W
00DD4:  SUBLW  06
00DD6:  BNZ   0DDE
.................... 		c=0b01111; 
00DD8:  MOVLW  0F
00DDA:  MOVWF  xCD
.................... 	else 
00DDC:  BRA    0DE2
.................... 		c=0b11111; 
00DDE:  MOVLW  1F
00DE0:  MOVWF  xCD
....................  
.................... 	/* select out channel and start the conversion */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
00DE2:  CLRF   xCC
00DE4:  MOVF   xCC,W
00DE6:  SUBLW  04
00DE8:  BNC   0E00
.................... 		output_low(MCP3208_CLK); 
00DEA:  BCF    F8B.3
.................... 		output_bit(MCP3208_DIN,c&1); 
00DEC:  BTFSC  xCD.0
00DEE:  BRA    0DF4
00DF0:  BCF    F8B.5
00DF2:  BRA    0DF6
00DF4:  BSF    F8B.5
.................... 		c=c>>1; 
00DF6:  BCF    FD8.0
00DF8:  RRCF   xCD,F
.................... 		output_high(MCP3208_CLK); 
00DFA:  BSF    F8B.3
.................... 	} 
00DFC:  INCF   xCC,F
00DFE:  BRA    0DE4
....................  
....................  
.................... 	value=0; 
00E00:  CLRF   xCB
00E02:  CLRF   xCA
.................... 	for ( i=0 ; i<14 ; i++ ) { 
00E04:  CLRF   xCC
00E06:  MOVF   xCC,W
00E08:  SUBLW  0D
00E0A:  BNC   0E22
.................... 		output_low(MCP3208_CLK); 
00E0C:  BCF    F8B.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT)); 
00E0E:  BTFSC  F82.4
00E10:  BRA    0E16
00E12:  BCF    FD8.0
00E14:  BRA    0E18
00E16:  BSF    FD8.0
00E18:  RLCF   xCA,F
00E1A:  RLCF   xCB,F
.................... 		output_high(MCP3208_CLK); 
00E1C:  BSF    F8B.3
.................... 	} 
00E1E:  INCF   xCC,F
00E20:  BRA    0E06
....................  
.................... 	bit_clear(value,13); 
00E22:  BCF    xCB.5
.................... 	bit_clear(value,12); 
00E24:  BCF    xCB.4
....................  
.................... 	/* de-select ADCs */ 
.................... 	mcp3208_init(); 
....................  
.................... 	return value; 
*
00E28:  MOVFF  2CA,01
00E2C:  MOVFF  2CB,02
.................... } 
00E30:  MOVLB  0
00E32:  GOTO   0EA2 (RETURN)
....................  
.................... #include "adc_pcwx.c" 
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3}; 
....................  
.................... int16 adc_get(int8 ch) { 
.................... 	int16 sum; 
.................... 	int8 i; 
....................  
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */ 
.................... 	int16 *p; 
.................... 	p = current.adc_buffer[ch]; 
*
00EDC:  MOVLB  2
00EDE:  CLRF   xE1
00EE0:  MOVFF  2DA,2E0
00EE4:  CLRF   xE3
00EE6:  MOVLW  20
00EE8:  MOVWF  xE2
00EEA:  MOVLB  0
00EEC:  RCALL  08CE
00EEE:  MOVFF  02,03
00EF2:  MOVF   01,W
00EF4:  ADDLW  81
00EF6:  MOVWF  01
00EF8:  MOVLW  00
00EFA:  ADDWFC 03,F
00EFC:  MOVFF  01,2DE
00F00:  MOVLB  2
00F02:  MOVFF  03,2DF
....................  
.................... 	// Calculate the mean.  This is done by summing up the 
.................... 	// values and dividing by the number of elements. 
.................... 	sum = 0; 
00F06:  CLRF   xDC
00F08:  CLRF   xDB
.................... 	for( i = 0; i < 16 ; i++ ) { 
00F0A:  CLRF   xDD
00F0C:  MOVF   xDD,W
00F0E:  SUBLW  0F
00F10:  BNC   0F34
.................... //		sum += current.adc_buffer[ch][i]; 
.................... 		sum += p[i]; 
00F12:  BCF    FD8.0
00F14:  RLCF   xDD,W
00F16:  CLRF   03
00F18:  ADDWF  xDE,W
00F1A:  MOVWF  FE9
00F1C:  MOVF   xDF,W
00F1E:  ADDWFC 03,W
00F20:  MOVWF  FEA
00F22:  MOVFF  FEC,03
00F26:  MOVF   FED,F
00F28:  MOVF   FEF,W
00F2A:  ADDWF  xDB,F
00F2C:  MOVF   03,W
00F2E:  ADDWFC xDC,F
.................... 	} 
00F30:  INCF   xDD,F
00F32:  BRA    0F0C
....................  
.................... 	/* divide sum by our 16 samples and round by adding 8 */ 
.................... 	return ( (sum+8) >> 4 ); 
00F34:  MOVLW  08
00F36:  ADDWF  xDB,W
00F38:  MOVWF  xE0
00F3A:  MOVLW  00
00F3C:  ADDWFC xDC,W
00F3E:  MOVWF  xE1
00F40:  RRCF   xE1,W
00F42:  MOVWF  03
00F44:  RRCF   xE0,W
00F46:  MOVWF  02
00F48:  RRCF   03,F
00F4A:  RRCF   02,F
00F4C:  RRCF   03,F
00F4E:  RRCF   02,F
00F50:  RRCF   03,F
00F52:  RRCF   02,F
00F54:  MOVLW  0F
00F56:  ANDWF  03,F
00F58:  MOVFF  02,01
00F5C:  MOVFF  03,02
.................... } 
00F60:  MOVLB  0
00F62:  RETURN 0
....................  
....................  
.................... void adc_update(void) { 
.................... 	int8 i; 
....................  
.................... 	/* wrap buffer around */ 
.................... 	current.adc_buffer_index++; 
*
00E36:  MOVLB  1
00E38:  INCF   x81,F
.................... 	if ( current.adc_buffer_index >= 16 ) 
00E3A:  MOVF   x81,W
00E3C:  SUBLW  0F
00E3E:  BC    0E42
.................... 		current.adc_buffer_index=0; 
00E40:  CLRF   x81
....................  
....................  
.................... 	for ( i=0 ; i<8 ; i++ ) { 
00E42:  MOVLB  2
00E44:  CLRF   xC6
00E46:  MOVF   xC6,W
00E48:  SUBLW  07
00E4A:  BNC   0ED8
.................... 		current.adc_buffer[i][current.adc_buffer_index] = mcp3208_read(i); 
00E4C:  CLRF   xE1
00E4E:  MOVFF  2C6,2E0
00E52:  CLRF   xE3
00E54:  MOVLW  20
00E56:  MOVWF  xE2
00E58:  MOVLB  0
00E5A:  RCALL  08CE
00E5C:  MOVFF  02,03
00E60:  MOVF   01,W
00E62:  ADDLW  34
00E64:  MOVLB  2
00E66:  MOVWF  xC7
00E68:  MOVLW  00
00E6A:  ADDWFC 02,W
00E6C:  MOVWF  xC8
00E6E:  CLRF   03
00E70:  MOVLB  1
00E72:  MOVFF  181,02
00E76:  BCF    FD8.0
00E78:  RLCF   02,F
00E7A:  RLCF   03,F
00E7C:  MOVF   02,W
00E7E:  MOVLB  2
00E80:  ADDWF  xC7,W
00E82:  MOVWF  01
00E84:  MOVF   xC8,W
00E86:  ADDWFC 03,F
00E88:  MOVF   01,W
00E8A:  ADDLW  4D
00E8C:  MOVWF  01
00E8E:  MOVLW  00
00E90:  ADDWFC 03,F
00E92:  MOVFF  01,2C7
00E96:  MOVFF  03,2C8
00E9A:  MOVFF  2C6,2C9
00E9E:  MOVLB  0
00EA0:  BRA    0D86
00EA2:  MOVFF  2C8,FEA
00EA6:  MOVFF  2C7,FE9
00EAA:  MOVFF  02,FEC
00EAE:  MOVF   FED,F
00EB0:  MOVFF  01,FEF
.................... 		current.adc_std_dev[i]=0; 
00EB4:  CLRF   03
00EB6:  MOVLB  2
00EB8:  MOVFF  2C6,02
00EBC:  BCF    FD8.0
00EBE:  RLCF   02,F
00EC0:  RLCF   03,F
00EC2:  MOVF   02,W
00EC4:  ADDLW  71
00EC6:  MOVWF  FE9
00EC8:  MOVLW  00
00ECA:  ADDWFC 03,W
00ECC:  MOVWF  FEA
00ECE:  CLRF   FEC
00ED0:  MOVF   FED,F
00ED2:  CLRF   FEF
....................  
.................... 	} 
00ED4:  INCF   xC6,F
00ED6:  BRA    0E46
.................... } 
00ED8:  MOVLB  0
00EDA:  RETURN 0
....................  
.................... #include "param_pcwx.c" 
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00B96:  MOVF   xE1,W
00B98:  XORWF  xE2,W
00B9A:  MOVWF  01
*
00BE8:  MOVF   xE1,W
00BEA:  XORWF  xE2,W
00BEC:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00B20:  MOVLB  2
00B22:  CLRF   xCF
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00B24:  MOVFF  2CE,03
00B28:  MOVF   xCD,W
00B2A:  BTFSC  FD8.2
00B2C:  DECF   xCE,F
00B2E:  DECF   xCD,F
00B30:  MOVWF  xD0
00B32:  MOVFF  03,2D1
00B36:  MOVF   xD0,F
00B38:  BNZ   0B3E
00B3A:  MOVF   xD1,F
00B3C:  BZ    0BA8
.................... 		*data = read_eeprom( address++ ); 
00B3E:  MOVFF  2CC,03
00B42:  MOVF   xCB,W
00B44:  MOVWF  FE9
00B46:  MOVFF  03,FEA
00B4A:  MOVF   xCA,W
00B4C:  MOVWF  03
00B4E:  MOVF   xC9,W
00B50:  INCF   xC9,F
00B52:  BTFSC  FD8.2
00B54:  INCF   xCA,F
00B56:  MOVWF  xD2
00B58:  MOVFF  03,2D3
00B5C:  MOVFF  FF2,2D4
00B60:  BCF    FF2.6
00B62:  BCF    FF2.7
00B64:  MOVFF  2D3,FAA
00B68:  MOVFF  2D2,FA9
00B6C:  BCF    FA6.6
00B6E:  BCF    FA6.7
00B70:  BSF    FA6.0
00B72:  MOVF   FA8,W
00B74:  BTFSC  xD4.6
00B76:  BSF    FF2.6
00B78:  BTFSC  xD4.7
00B7A:  BSF    FF2.7
00B7C:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00B7E:  MOVFF  2CC,03
00B82:  MOVF   xCB,W
00B84:  MOVWF  FE9
00B86:  MOVFF  03,FEA
00B8A:  MOVFF  FEF,2D0
00B8E:  MOVFF  2CF,2E1
00B92:  MOVFF  2D0,2E2
*
00B9C:  MOVFF  01,2CF
.................... 		data++; 
00BA0:  INCF   xCB,F
00BA2:  BTFSC  FD8.2
00BA4:  INCF   xCC,F
.................... 	} 
00BA6:  BRA    0B24
.................... 	return crc; 
00BA8:  MOVFF  2CF,01
.................... } 
00BAC:  MOVLB  0
00BAE:  GOTO   0CFE (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00BB2:  MOVLB  2
00BB4:  CLRF   xDF
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00BB6:  MOVFF  2DE,03
00BBA:  MOVF   xDD,W
00BBC:  BTFSC  FD8.2
00BBE:  DECF   xDE,F
00BC0:  DECF   xDD,F
00BC2:  MOVWF  xE0
00BC4:  MOVFF  03,2E1
00BC8:  MOVF   xE0,F
00BCA:  BNZ   0BD0
00BCC:  MOVF   xE1,F
00BCE:  BZ    0C4E
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00BD0:  MOVFF  2DC,03
00BD4:  MOVF   xDB,W
00BD6:  MOVWF  FE9
00BD8:  MOVFF  03,FEA
00BDC:  MOVFF  FEF,2E0
00BE0:  MOVFF  2DF,2E1
00BE4:  MOVFF  2E0,2E2
*
00BEE:  MOVFF  01,2DF
.................... 		write_eeprom( address++, *data++ ); 
00BF2:  MOVF   xDA,W
00BF4:  MOVWF  03
00BF6:  MOVF   xD9,W
00BF8:  INCF   xD9,F
00BFA:  BTFSC  FD8.2
00BFC:  INCF   xDA,F
00BFE:  MOVWF  xE0
00C00:  MOVFF  03,2E1
00C04:  MOVF   xDC,W
00C06:  MOVWF  03
00C08:  MOVF   xDB,W
00C0A:  INCF   xDB,F
00C0C:  BTFSC  FD8.2
00C0E:  INCF   xDC,F
00C10:  MOVWF  FE9
00C12:  MOVFF  03,FEA
00C16:  MOVFF  FEF,2E2
00C1A:  MOVFF  2E1,FAA
00C1E:  MOVFF  2E0,FA9
00C22:  MOVFF  2E2,FA8
00C26:  BCF    FA6.6
00C28:  BCF    FA6.7
00C2A:  BSF    FA6.2
00C2C:  MOVF   FF2,W
00C2E:  MOVWF  00
00C30:  BCF    FF2.6
00C32:  BCF    FF2.7
00C34:  MOVLB  F
00C36:  MOVLW  55
00C38:  MOVWF  FA7
00C3A:  MOVLW  AA
00C3C:  MOVWF  FA7
00C3E:  BSF    FA6.1
00C40:  BTFSC  FA6.1
00C42:  BRA    0C40
00C44:  BCF    FA6.2
00C46:  MOVF   00,W
00C48:  IORWF  FF2,F
.................... 	} 
00C4A:  MOVLB  2
00C4C:  BRA    0BB6
....................  
.................... 	return crc; 
00C4E:  MOVFF  2DF,01
.................... } 
00C52:  MOVLB  0
00C54:  GOTO   0C78 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00C58:  MOVLB  2
00C5A:  CLRF   xD8
00C5C:  MOVLW  36
00C5E:  MOVWF  xD7
00C60:  CLRF   xDA
00C62:  MOVLW  02
00C64:  MOVWF  xD9
00C66:  MOVFF  2D8,2DC
00C6A:  MOVFF  2D7,2DB
00C6E:  CLRF   xDE
00C70:  MOVLW  17
00C72:  MOVWF  xDD
00C74:  MOVLB  0
00C76:  BRA    0BB2
00C78:  MOVFF  01,2D6
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00C7C:  CLRF   FAA
00C7E:  CLRF   FA9
00C80:  MOVFF  2D6,FA8
00C84:  BCF    FA6.6
00C86:  BCF    FA6.7
00C88:  BSF    FA6.2
00C8A:  MOVF   FF2,W
00C8C:  MOVWF  00
00C8E:  BCF    FF2.6
00C90:  BCF    FF2.7
00C92:  MOVLB  F
00C94:  MOVLW  55
00C96:  MOVWF  FA7
00C98:  MOVLW  AA
00C9A:  MOVWF  FA7
00C9C:  BSF    FA6.1
00C9E:  BTFSC  FA6.1
00CA0:  BRA    0C9E
00CA2:  BCF    FA6.2
00CA4:  MOVF   00,W
00CA6:  IORWF  FF2,F
.................... } 
00CA8:  MOVLB  0
00CAA:  RETURN 0
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timers.led_on_green=150; 
00CAC:  MOVLW  96
00CAE:  MOVLB  1
00CB0:  MOVWF  xAA
....................  
.................... //	config.modbus_address=38; 
.................... 	config.modbus_address=255; /* use any address */ 
00CB2:  SETF   36
....................  
.................... 	config.serial_prefix='P'; 
00CB4:  MOVLW  50
00CB6:  MOVWF  38
.................... 	config.serial_number=9876; 
00CB8:  MOVLW  26
00CBA:  MOVWF  3A
00CBC:  MOVLW  94
00CBE:  MOVWF  39
....................  
.................... 	config.adc_sample_ticks=20; 
00CC0:  CLRF   3C
00CC2:  MOVLW  14
00CC4:  MOVWF  3B
.................... 	config.allow_bootload_request=0; 
00CC6:  CLRF   3D
....................  
.................... 	config.watchdog_seconds_max=630; /* 10 minutes & 30 seconds */ 
00CC8:  MOVLW  02
00CCA:  MOVWF  3F
00CCC:  MOVLW  76
00CCE:  MOVWF  3E
.................... 	config.pi_offtime_seconds=2; 
00CD0:  CLRF   41
00CD2:  MOVLW  02
00CD4:  MOVWF  40
.................... 	config.power_startup=0; 
00CD6:  CLRF   42
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00CD8:  MOVLB  0
00CDA:  RCALL  0C58
....................  
.................... } 
00CDC:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00CDE:  MOVLB  2
00CE0:  CLRF   xC8
00CE2:  MOVLW  36
00CE4:  MOVWF  xC7
00CE6:  CLRF   xCA
00CE8:  MOVLW  02
00CEA:  MOVWF  xC9
00CEC:  MOVFF  2C8,2CC
00CF0:  MOVFF  2C7,2CB
00CF4:  CLRF   xCE
00CF6:  MOVLW  17
00CF8:  MOVWF  xCD
00CFA:  MOVLB  0
00CFC:  BRA    0B20
00CFE:  MOVFF  01,2C6
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) { 
00D02:  MOVFF  FF2,2C7
00D06:  BCF    FF2.6
00D08:  BCF    FF2.7
00D0A:  CLRF   FAA
00D0C:  CLRF   FA9
00D0E:  BCF    FA6.6
00D10:  BCF    FA6.7
00D12:  BSF    FA6.0
00D14:  MOVF   FA8,W
00D16:  MOVLB  2
00D18:  BTFSC  xC7.6
00D1A:  BSF    FF2.6
00D1C:  BTFSC  xC7.7
00D1E:  BSF    FF2.7
00D20:  SUBWF  xC6,W
00D22:  BZ    0D2A
.................... 		write_default_param_file(); 
00D24:  MOVLB  0
00D26:  RCALL  0CAC
00D28:  MOVLB  2
.................... 	} 
.................... } 
00D2A:  MOVLB  0
00D2C:  GOTO   2404 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "modbus_slave_pcwx.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);} 
....................  
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
.................... void wait_for_hw_buffer() { 
....................   while(!TRMT); 
*
011D0:  BTFSS  FAC.1
011D2:  BRA    11D0
.................... } 
011D4:  GOTO   11EE (RETURN)
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while ( kbhit(MODBUS_SERIAL) ) { 
*
00D30:  BTFSS  F9E.5
00D32:  BRA    0D4C
.................... 		fprintf(DEBUG,"# reading starting ..."); 
00D34:  MOVLW  90
00D36:  MOVWF  FF6
00D38:  MOVLW  03
00D3A:  MOVWF  FF7
00D3C:  RCALL  0A54
.................... 		fgetc(MODBUS_SERIAL); 
00D3E:  RCALL  06BC
.................... 		fprintf(DEBUG," complete"); 
00D40:  MOVLW  A8
00D42:  MOVWF  FF6
00D44:  MOVLW  03
00D46:  MOVWF  FF7
00D48:  RCALL  0A54
.................... 	} 
00D4A:  BRA    0D30
....................  
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
00D4C:  BSF    F9D.5
.................... } 
00D4E:  RETURN 0
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... //	fprintf(DEBUG,"# rcv_on() starting ...\r\n"); 
.................... 	RCV_ON(); 
00D50:  RCALL  0D30
.................... //	fprintf(DEBUG,"# rcv_on() complete\r\n"); 
....................  
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
.................... //	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); /* ~1.024 ms @ 8 MHz ... 0.686 ms @ 12 MHz */ 
....................  
.................... 	fprintf(DEBUG,"# setup_timer_0 starting ...\r\n"); 
00D52:  MOVLW  B2
00D54:  MOVWF  FF6
00D56:  MOVLW  03
00D58:  MOVWF  FF7
00D5A:  RCALL  0A54
.................... 	setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); /* ~4.096 ms @ 8 MHz ... 2.73 ms @ 12 MHz */ 
00D5C:  MOVLW  C6
00D5E:  MOVWF  FD5
.................... 	fprintf(DEBUG,"# setup_timer_0 complete\r\n"); 
00D60:  MOVLW  D2
00D62:  MOVWF  FF6
00D64:  MOVLW  03
00D66:  MOVWF  FF7
00D68:  RCALL  0A54
....................  
.................... 	fprintf(DEBUG,"# enable_interrupts(GLOBAL) starting ...\r\n"); 
00D6A:  MOVLW  EE
00D6C:  MOVWF  FF6
00D6E:  MOVLW  03
00D70:  MOVWF  FF7
00D72:  RCALL  0A54
.................... 	enable_interrupts(GLOBAL); 
00D74:  MOVLW  C0
00D76:  IORWF  FF2,F
.................... 	fprintf(DEBUG,"# enable interrupts complete\r\n"); 
00D78:  MOVLW  1A
00D7A:  MOVWF  FF6
00D7C:  MOVLW  04
00D7E:  MOVWF  FF7
00D80:  RCALL  0A54
.................... } 
00D82:  GOTO   244C (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0043A:  BCF    FF2.5
.................... 	if (enable) { 
0043C:  MOVLB  2
0043E:  MOVF   xE6,F
00440:  BZ    044A
.................... 		set_timer0(0); 
00442:  CLRF   FD7
00444:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00446:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00448:  BSF    FF2.5
.................... 	} 
.................... } 
0044A:  MOVLB  0
0044C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0044E:  MOVLB  1
00450:  MOVF   xB1,W
00452:  SUBLW  02
00454:  BNZ   046A
00456:  MOVF   xB2,F
00458:  BNZ   046A
0045A:  MOVF   xB3,F
0045C:  BNZ   046A
0045E:  BTFSC  xB0.0
00460:  BRA    046A
....................    { 
....................       modbus_rx.len-=2; 
00462:  MOVLW  02
00464:  SUBWF  xB5,F
....................       modbus_serial_new=TRUE; 
00466:  BSF    xB0.0
....................    } 
....................    else 
00468:  BRA    046C
....................       modbus_serial_new=FALSE; 
0046A:  BCF    xB0.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0046C:  SETF   xB3
0046E:  SETF   xB2
....................    modbus_serial_state=MODBUS_GETADDY; 
00470:  CLRF   xB1
....................    modbus_enable_timeout(FALSE); 
00472:  MOVLB  2
00474:  CLRF   xE6
00476:  MOVLB  0
00478:  RCALL  043A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0047A:  BCF    FF2.2
0047C:  GOTO   007C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
006DC:  MOVLB  1
006DE:  MOVF   xB3,W
006E0:  MOVLB  2
006E2:  XORWF  xE6,W
006E4:  MOVWF  xE7
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
006E6:  CLRF   03
006E8:  MOVF   xE7,W
006EA:  MOVLB  0
006EC:  RCALL  0170
006EE:  MOVWF  01
006F0:  MOVLB  1
006F2:  MOVF   xB2,W
006F4:  XORWF  01,W
006F6:  MOVWF  xB3
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
006F8:  CLRF   03
006FA:  MOVLB  2
006FC:  MOVF   xE7,W
006FE:  MOVLB  0
00700:  RCALL  0280
00702:  MOVFF  FE8,1B2
.................... } 
00706:  RETURN 0
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, MODBUS_SERIAL); 
*
01176:  MOVLB  2
01178:  MOVF   xD8,W
0117A:  MOVLB  0
0117C:  BRA    116C
0117E:  CLRF   19
01180:  BTFSC  FF2.6
01182:  BSF    19.6
01184:  BCF    FF2.6
01186:  BTFSC  FF2.7
01188:  BSF    19.7
0118A:  BCF    FF2.7
.................... 	modbus_calc_crc(c); 
0118C:  MOVFF  2D8,2E6
01190:  CALL   06DC
01194:  BTFSC  19.6
01196:  BSF    FF2.6
01198:  BTFSC  19.7
0119A:  BSF    FF2.7
....................  
.................... 	/* one stop bit delay */ 
.................... 	delay_us(9); 
0119C:  CLRWDT
0119E:  MOVLW  08
011A0:  MOVWF  00
011A2:  DECFSZ 00,F
011A4:  BRA    11A2
011A6:  NOP   
....................  
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
.................... } 
011A8:  RETURN 0
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
011AA:  MOVLB  1
011AC:  SETF   xB3
011AE:  SETF   xB2
....................    modbus_serial_new=FALSE; 
011B0:  BCF    xB0.0
....................  
....................    RCV_OFF(); 
011B2:  BCF    F9D.5
....................     
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  //  output_high(MODBUS_SERIAL_ENABLE_PIN); 
....................  
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
011B4:  CLRWDT
011B6:  MOVLW  1E
011B8:  MOVWF  00
011BA:  DECFSZ 00,F
011BC:  BRA    11BA
011BE:  NOP   
....................  
....................    modbus_serial_putc(to); 
011C0:  MOVFF  2D6,2D8
011C4:  MOVLB  0
011C6:  RCALL  1176
....................    modbus_serial_putc(func); 
011C8:  MOVFF  2D7,2D8
011CC:  RCALL  1176
.................... } 
011CE:  RETURN 0
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
011D8:  MOVFF  1B3,2D7
....................    crc_low=modbus_serial_crc.b[0]; 
011DC:  MOVFF  1B2,2D6
....................  
....................    modbus_serial_putc(crc_high); 
011E0:  MOVFF  2D7,2D8
011E4:  RCALL  1176
....................    modbus_serial_putc(crc_low); 
011E6:  MOVFF  2D6,2D8
011EA:  RCALL  1176
....................  
....................    WAIT_FOR_HW_BUFFER(); 
011EC:  BRA    11D0
....................      
.................... 	/* 3.5 character delay (3500000/baud) */ 
.................... 	delay_us(31); /* 115200 */ 
011EE:  CLRWDT
011F0:  MOVLW  1E
011F2:  MOVWF  00
011F4:  DECFSZ 00,F
011F6:  BRA    11F4
011F8:  NOP   
....................  
....................  
....................    RCV_ON(); 
011FA:  RCALL  0D30
....................  
.................... //   output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE); // JJJ 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
011FC:  MOVLB  1
011FE:  SETF   xB3
01200:  SETF   xB2
.................... } 
01202:  MOVLB  0
01204:  RETURN 0
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
010C4:  MOVLB  1
010C6:  BTFSC  xB0.0
010C8:  BRA    10D2
....................       return FALSE; 
010CA:  MOVLW  00
010CC:  MOVWF  01
010CE:  BRA    10E4
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
010D0:  BRA    10DE
010D2:  BTFSS  xB6.7
010D4:  BRA    10DE
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
010D6:  MOVFF  1B8,1B7
....................       modbus_rx.len = 1; 
010DA:  MOVLW  01
010DC:  MOVWF  xB5
....................    } 
....................    modbus_serial_new=FALSE; 
010DE:  BCF    xB0.0
....................    return TRUE; 
010E0:  MOVLW  01
010E2:  MOVWF  01
.................... } 
010E4:  MOVLB  0
010E6:  GOTO   2024 (RETURN)
....................  
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
01F90:  MOVFF  2CE,2D6
01F94:  MOVLW  06
01F96:  MOVLB  2
01F98:  MOVWF  xD7
01F9A:  MOVLB  0
01F9C:  CALL   11AA
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
01FA0:  MOVFF  2D0,2D3
01FA4:  MOVFF  2D0,2D8
01FA8:  CALL   1176
....................    modbus_serial_putc(make8(reg_address,0)); 
01FAC:  MOVFF  2CF,2D3
01FB0:  MOVFF  2CF,2D8
01FB4:  CALL   1176
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
01FB8:  MOVFF  2D2,2D3
01FBC:  MOVFF  2D2,2D8
01FC0:  CALL   1176
....................    modbus_serial_putc(make8(reg_value,0)); 
01FC4:  MOVFF  2D1,2D3
01FC8:  MOVFF  2D1,2D8
01FCC:  CALL   1176
....................  
....................    modbus_serial_send_stop(); 
01FD0:  CALL   11D8
.................... } 
01FD4:  GOTO   2150 (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
01FD8:  MOVFF  2CC,2D6
01FDC:  MOVLW  10
01FDE:  MOVLB  2
01FE0:  MOVWF  xD7
01FE2:  MOVLB  0
01FE4:  CALL   11AA
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01FE8:  MOVFF  2CE,2D1
01FEC:  MOVFF  2CE,2D8
01FF0:  CALL   1176
....................    modbus_serial_putc(make8(start_address,0)); 
01FF4:  MOVFF  2CD,2D1
01FF8:  MOVFF  2CD,2D8
01FFC:  CALL   1176
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
02000:  MOVFF  2D0,2D1
02004:  MOVFF  2D0,2D8
02008:  CALL   1176
....................    modbus_serial_putc(make8(quantity,0)); 
0200C:  MOVFF  2CF,2D1
02010:  MOVFF  2CF,2D8
02014:  CALL   1176
....................  
....................    modbus_serial_send_stop(); 
02018:  CALL   11D8
.................... } 
0201C:  GOTO   2212 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
01206:  MOVLB  2
01208:  MOVF   xCD,W
0120A:  IORLW  80
0120C:  MOVWF  xD0
0120E:  MOVFF  2CE,2D1
01212:  MOVFF  2CC,2D6
01216:  MOVWF  xD7
01218:  MOVLB  0
0121A:  RCALL  11AA
....................    modbus_serial_putc(error); 
0121C:  MOVFF  2CF,2D8
01220:  RCALL  1176
....................    modbus_serial_send_stop(); 
01222:  RCALL  11D8
.................... } 
01224:  RETURN 0
....................  
....................  
.................... #include "modbus_handler_pcwx.c" 
.................... #define MAX_STATUS_REGISTER  51 
....................  
.................... #define MIN_CONFIG_REGISTER  1000 
.................... #define MAX_CONFIG_REGISTER  1011 
....................  
.................... #define MIN_EE_REGISTER      2000 
.................... #define MAX_EE_REGISTER      MIN_EE_REGISTER + 512 
....................  
....................  
.................... /* This function may come in handy for you since MODBUS uses MSB first. */ 
.................... int8 swap_bits(int8 c) { 
.................... 	return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)|((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void reset_modbus_stats(void) { 
.................... 	current.modbus_our_packets=0; 
*
012EC:  MOVLB  1
012EE:  CLRF   x83
012F0:  CLRF   x82
.................... 	current.modbus_other_packets=0; 
012F2:  CLRF   x85
012F4:  CLRF   x84
.................... 	current.modbus_last_error=0; 
012F6:  CLRF   x87
012F8:  CLRF   x86
.................... } 
012FA:  MOVLB  0
012FC:  GOTO   1C0C (RETURN)
....................  
.................... void reset_counters(void) { 
.................... 	disable_interrupts(GLOBAL); 
*
01288:  BCF    FF2.6
0128A:  BCF    FF2.7
0128C:  BTFSC  FF2.7
0128E:  BRA    128A
....................  
.................... 	current.pulse_count[0]=0; 
01290:  CLRF   x60
01292:  CLRF   5F
.................... 	current.pulse_count[1]=0; 
01294:  CLRF   x62
01296:  CLRF   x61
.................... 	current.pulse_count[2]=0; 
01298:  CLRF   x64
0129A:  CLRF   x63
....................  
.................... 	/* pulse period is reset in interrupt */ 
.................... 	current.pulse_min_period[0]=65535; 
0129C:  SETF   54
0129E:  SETF   53
.................... 	current.pulse_min_period[1]=65535; 
012A0:  SETF   56
012A2:  SETF   55
.................... 	current.pulse_min_period[2]=65535; 
012A4:  SETF   58
012A6:  SETF   57
.................... 	 
.................... 	current.pulse_max_period[0]=0; 
012A8:  CLRF   5A
012AA:  CLRF   59
.................... 	current.pulse_max_period[1]=0; 
012AC:  CLRF   5C
012AE:  CLRF   5B
.................... 	current.pulse_max_period[2]=0; 
012B0:  CLRF   5E
012B2:  CLRF   5D
.................... 	 
....................  
.................... 	current.interval_milliseconds=0; 
012B4:  MOVLB  1
012B6:  CLRF   x8D
012B8:  CLRF   x8C
....................  
.................... 	enable_interrupts(GLOBAL); 
012BA:  MOVLW  C0
012BC:  IORWF  FF2,F
.................... } 
012BE:  MOVLB  0
012C0:  GOTO   1BBC (RETURN)
....................  
.................... void reset_pulse_sum(void) { 
.................... 	disable_interrupts(GLOBAL); 
012C4:  BCF    FF2.6
012C6:  BCF    FF2.7
012C8:  BTFSC  FF2.7
012CA:  BRA    12C6
.................... 	current.pulse_sum[0]=0; 
012CC:  CLRF   x68
012CE:  CLRF   x67
012D0:  CLRF   x66
012D2:  CLRF   x65
.................... 	current.pulse_sum[1]=0; 
012D4:  CLRF   x6C
012D6:  CLRF   x6B
012D8:  CLRF   x6A
012DA:  CLRF   x69
.................... 	current.pulse_sum[2]=0; 
012DC:  CLRF   x70
012DE:  CLRF   x6F
012E0:  CLRF   x6E
012E2:  CLRF   x6D
.................... 	enable_interrupts(GLOBAL); 
012E4:  MOVLW  C0
012E6:  IORWF  FF2,F
.................... } 
012E8:  GOTO   1BCC (RETURN)
....................  
.................... int32 get_pulse_sum(int8 ch) { 
.................... 	int32 l; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
01226:  BCF    FF2.6
01228:  BCF    FF2.7
0122A:  BTFSC  FF2.7
0122C:  BRA    1228
.................... 	l=current.pulse_sum[ch]; 
0122E:  MOVLB  2
01230:  CLRF   xE1
01232:  MOVFF  2DA,2E0
01236:  CLRF   xE3
01238:  MOVLW  04
0123A:  MOVWF  xE2
0123C:  MOVLB  0
0123E:  CALL   08CE
01242:  MOVFF  02,03
01246:  MOVF   01,W
01248:  ADDLW  65
0124A:  MOVWF  FE9
0124C:  MOVLW  00
0124E:  ADDWFC 02,W
01250:  MOVWF  FEA
01252:  MOVFF  FEF,00
01256:  MOVFF  FEC,01
0125A:  MOVFF  FEC,02
0125E:  MOVFF  FEC,03
01262:  MOVFF  03,2DE
01266:  MOVFF  02,2DD
0126A:  MOVFF  01,2DC
0126E:  MOVFF  00,2DB
.................... 	enable_interrupts(GLOBAL); 
01272:  MOVLW  C0
01274:  IORWF  FF2,F
....................  
.................... 	return l; 
01276:  MOVFF  2DB,00
0127A:  MOVFF  2DC,01
0127E:  MOVFF  2DD,02
01282:  MOVFF  2DE,03
.................... } 
01286:  RETURN 0
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	static u_lblock ps; 
....................  
.................... 	if ( addr >= MIN_EE_REGISTER && addr < MAX_EE_REGISTER ) { 
*
01300:  MOVLB  2
01302:  MOVF   xD9,W
01304:  SUBLW  06
01306:  BC    1358
01308:  XORLW  FF
0130A:  BNZ   1312
0130C:  MOVF   xD8,W
0130E:  SUBLW  CF
01310:  BC    1358
01312:  MOVF   xD9,W
01314:  SUBLW  09
01316:  BNC   1358
01318:  BNZ   1320
0131A:  MOVF   xD8,W
0131C:  SUBLW  CF
0131E:  BNC   1358
.................... 		return (int16) read_eeprom(addr - MIN_EE_REGISTER); 
01320:  MOVLW  D0
01322:  SUBWF  xD8,W
01324:  MOVWF  xDA
01326:  MOVLW  07
01328:  SUBWFB xD9,W
0132A:  MOVWF  xDB
0132C:  MOVFF  FF2,2DC
01330:  BCF    FF2.6
01332:  BCF    FF2.7
01334:  MOVFF  2DB,FAA
01338:  MOVFF  2DA,FA9
0133C:  BCF    FA6.6
0133E:  BCF    FA6.7
01340:  BSF    FA6.0
01342:  MOVF   FA8,W
01344:  BTFSC  xDC.6
01346:  BSF    FF2.6
01348:  BTFSC  xDC.7
0134A:  BSF    FF2.7
0134C:  CLRF   03
0134E:  MOVWF  01
01350:  MOVF   03,W
01352:  MOVWF  02
01354:  GOTO   1CCE
.................... 	} 
....................  
.................... 	switch ( addr ) { 
01358:  MOVF   xD8,W
0135A:  MOVWF  00
0135C:  MOVF   xD9,W
0135E:  MOVWF  03
01360:  MOVF   03,W
01362:  BNZ   136E
01364:  MOVF   00,F
01366:  MOVLB  0
01368:  BTFSC  FD8.2
0136A:  BRA    1778
0136C:  MOVLB  2
0136E:  MOVF   03,W
01370:  BNZ   137E
01372:  MOVLW  01
01374:  SUBWF  00,W
01376:  MOVLB  0
01378:  BTFSC  FD8.2
0137A:  BRA    1786
0137C:  MOVLB  2
0137E:  MOVF   03,W
01380:  BNZ   138E
01382:  MOVLW  02
01384:  SUBWF  00,W
01386:  MOVLB  0
01388:  BTFSC  FD8.2
0138A:  BRA    1794
0138C:  MOVLB  2
0138E:  MOVF   03,W
01390:  BNZ   139E
01392:  MOVLW  03
01394:  SUBWF  00,W
01396:  MOVLB  0
01398:  BTFSC  FD8.2
0139A:  BRA    17A2
0139C:  MOVLB  2
0139E:  MOVF   03,W
013A0:  BNZ   13AE
013A2:  MOVLW  04
013A4:  SUBWF  00,W
013A6:  MOVLB  0
013A8:  BTFSC  FD8.2
013AA:  BRA    17B0
013AC:  MOVLB  2
013AE:  MOVF   03,W
013B0:  BNZ   13BE
013B2:  MOVLW  05
013B4:  SUBWF  00,W
013B6:  MOVLB  0
013B8:  BTFSC  FD8.2
013BA:  BRA    17D6
013BC:  MOVLB  2
013BE:  MOVF   03,W
013C0:  BNZ   13CE
013C2:  MOVLW  06
013C4:  SUBWF  00,W
013C6:  MOVLB  0
013C8:  BTFSC  FD8.2
013CA:  BRA    17E4
013CC:  MOVLB  2
013CE:  MOVF   03,W
013D0:  BNZ   13DE
013D2:  MOVLW  07
013D4:  SUBWF  00,W
013D6:  MOVLB  0
013D8:  BTFSC  FD8.2
013DA:  BRA    17F2
013DC:  MOVLB  2
013DE:  MOVF   03,W
013E0:  BNZ   13EE
013E2:  MOVLW  08
013E4:  SUBWF  00,W
013E6:  MOVLB  0
013E8:  BTFSC  FD8.2
013EA:  BRA    1800
013EC:  MOVLB  2
013EE:  MOVF   03,W
013F0:  BNZ   13FE
013F2:  MOVLW  09
013F4:  SUBWF  00,W
013F6:  MOVLB  0
013F8:  BTFSC  FD8.2
013FA:  BRA    180E
013FC:  MOVLB  2
013FE:  MOVF   03,W
01400:  BNZ   140E
01402:  MOVLW  0A
01404:  SUBWF  00,W
01406:  MOVLB  0
01408:  BTFSC  FD8.2
0140A:  BRA    181C
0140C:  MOVLB  2
0140E:  MOVF   03,W
01410:  BNZ   141E
01412:  MOVLW  0B
01414:  SUBWF  00,W
01416:  MOVLB  0
01418:  BTFSC  FD8.2
0141A:  BRA    1844
0141C:  MOVLB  2
0141E:  MOVF   03,W
01420:  BNZ   142E
01422:  MOVLW  0C
01424:  SUBWF  00,W
01426:  MOVLB  0
01428:  BTFSC  FD8.2
0142A:  BRA    1852
0142C:  MOVLB  2
0142E:  MOVF   03,W
01430:  BNZ   143E
01432:  MOVLW  0D
01434:  SUBWF  00,W
01436:  MOVLB  0
01438:  BTFSC  FD8.2
0143A:  BRA    1860
0143C:  MOVLB  2
0143E:  MOVF   03,W
01440:  BNZ   144E
01442:  MOVLW  0E
01444:  SUBWF  00,W
01446:  MOVLB  0
01448:  BTFSC  FD8.2
0144A:  BRA    186E
0144C:  MOVLB  2
0144E:  MOVF   03,W
01450:  BNZ   145E
01452:  MOVLW  0F
01454:  SUBWF  00,W
01456:  MOVLB  0
01458:  BTFSC  FD8.2
0145A:  BRA    187C
0145C:  MOVLB  2
0145E:  MOVF   03,W
01460:  BNZ   146E
01462:  MOVLW  10
01464:  SUBWF  00,W
01466:  MOVLB  0
01468:  BTFSC  FD8.2
0146A:  BRA    188A
0146C:  MOVLB  2
0146E:  MOVF   03,W
01470:  BNZ   147E
01472:  MOVLW  11
01474:  SUBWF  00,W
01476:  MOVLB  0
01478:  BTFSC  FD8.2
0147A:  BRA    18B2
0147C:  MOVLB  2
0147E:  MOVF   03,W
01480:  BNZ   148E
01482:  MOVLW  12
01484:  SUBWF  00,W
01486:  MOVLB  0
01488:  BTFSC  FD8.2
0148A:  BRA    18C0
0148C:  MOVLB  2
0148E:  MOVF   03,W
01490:  BNZ   149E
01492:  MOVLW  13
01494:  SUBWF  00,W
01496:  MOVLB  0
01498:  BTFSC  FD8.2
0149A:  BRA    18EE
0149C:  MOVLB  2
0149E:  MOVF   03,W
014A0:  BNZ   14AE
014A2:  MOVLW  14
014A4:  SUBWF  00,W
014A6:  MOVLB  0
014A8:  BTFSC  FD8.2
014AA:  BRA    1906
014AC:  MOVLB  2
014AE:  MOVF   03,W
014B0:  BNZ   14BE
014B2:  MOVLW  15
014B4:  SUBWF  00,W
014B6:  MOVLB  0
014B8:  BTFSC  FD8.2
014BA:  BRA    1914
014BC:  MOVLB  2
014BE:  MOVF   03,W
014C0:  BNZ   14CE
014C2:  MOVLW  16
014C4:  SUBWF  00,W
014C6:  MOVLB  0
014C8:  BTFSC  FD8.2
014CA:  BRA    1942
014CC:  MOVLB  2
014CE:  MOVF   03,W
014D0:  BNZ   14DE
014D2:  MOVLW  17
014D4:  SUBWF  00,W
014D6:  MOVLB  0
014D8:  BTFSC  FD8.2
014DA:  BRA    195C
014DC:  MOVLB  2
014DE:  MOVF   03,W
014E0:  BNZ   14EE
014E2:  MOVLW  18
014E4:  SUBWF  00,W
014E6:  MOVLB  0
014E8:  BTFSC  FD8.2
014EA:  BRA    196A
014EC:  MOVLB  2
014EE:  MOVF   03,W
014F0:  BNZ   14FE
014F2:  MOVLW  19
014F4:  SUBWF  00,W
014F6:  MOVLB  0
014F8:  BTFSC  FD8.2
014FA:  BRA    1998
014FC:  MOVLB  2
014FE:  MOVF   03,W
01500:  BNZ   150E
01502:  MOVLW  1A
01504:  SUBWF  00,W
01506:  MOVLB  0
01508:  BTFSC  FD8.2
0150A:  BRA    19B2
0150C:  MOVLB  2
0150E:  MOVF   03,W
01510:  BNZ   151E
01512:  MOVLW  1B
01514:  SUBWF  00,W
01516:  MOVLB  0
01518:  BTFSC  FD8.2
0151A:  BRA    19C0
0151C:  MOVLB  2
0151E:  MOVF   03,W
01520:  BNZ   152E
01522:  MOVLW  1C
01524:  SUBWF  00,W
01526:  MOVLB  0
01528:  BTFSC  FD8.2
0152A:  BRA    19EE
0152C:  MOVLB  2
0152E:  MOVF   03,W
01530:  BNZ   153E
01532:  MOVLW  1D
01534:  SUBWF  00,W
01536:  MOVLB  0
01538:  BTFSC  FD8.2
0153A:  BRA    1A08
0153C:  MOVLB  2
0153E:  MOVF   03,W
01540:  BNZ   154E
01542:  MOVLW  1E
01544:  SUBWF  00,W
01546:  MOVLB  0
01548:  BTFSC  FD8.2
0154A:  BRA    1A16
0154C:  MOVLB  2
0154E:  MOVF   03,W
01550:  BNZ   155E
01552:  MOVLW  1F
01554:  SUBWF  00,W
01556:  MOVLB  0
01558:  BTFSC  FD8.2
0155A:  BRA    1A44
0155C:  MOVLB  2
0155E:  MOVF   03,W
01560:  BNZ   156E
01562:  MOVLW  20
01564:  SUBWF  00,W
01566:  MOVLB  0
01568:  BTFSC  FD8.2
0156A:  BRA    1A5E
0156C:  MOVLB  2
0156E:  MOVF   03,W
01570:  BNZ   157E
01572:  MOVLW  21
01574:  SUBWF  00,W
01576:  MOVLB  0
01578:  BTFSC  FD8.2
0157A:  BRA    1A6C
0157C:  MOVLB  2
0157E:  MOVF   03,W
01580:  BNZ   158E
01582:  MOVLW  22
01584:  SUBWF  00,W
01586:  MOVLB  0
01588:  BTFSC  FD8.2
0158A:  BRA    1A9A
0158C:  MOVLB  2
0158E:  MOVF   03,W
01590:  BNZ   159E
01592:  MOVLW  23
01594:  SUBWF  00,W
01596:  MOVLB  0
01598:  BTFSC  FD8.2
0159A:  BRA    1AB4
0159C:  MOVLB  2
0159E:  MOVF   03,W
015A0:  BNZ   15AE
015A2:  MOVLW  24
015A4:  SUBWF  00,W
015A6:  MOVLB  0
015A8:  BTFSC  FD8.2
015AA:  BRA    1AC2
015AC:  MOVLB  2
015AE:  MOVF   03,W
015B0:  BNZ   15BE
015B2:  MOVLW  25
015B4:  SUBWF  00,W
015B6:  MOVLB  0
015B8:  BTFSC  FD8.2
015BA:  BRA    1AF0
015BC:  MOVLB  2
015BE:  MOVF   03,W
015C0:  BNZ   15CE
015C2:  MOVLW  26
015C4:  SUBWF  00,W
015C6:  MOVLB  0
015C8:  BTFSC  FD8.2
015CA:  BRA    1B0A
015CC:  MOVLB  2
015CE:  MOVF   03,W
015D0:  BNZ   15DE
015D2:  MOVLW  27
015D4:  SUBWF  00,W
015D6:  MOVLB  0
015D8:  BTFSC  FD8.2
015DA:  BRA    1B18
015DC:  MOVLB  2
015DE:  MOVF   03,W
015E0:  BNZ   15EE
015E2:  MOVLW  28
015E4:  SUBWF  00,W
015E6:  MOVLB  0
015E8:  BTFSC  FD8.2
015EA:  BRA    1B46
015EC:  MOVLB  2
015EE:  MOVF   03,W
015F0:  BNZ   15FE
015F2:  MOVLW  29
015F4:  SUBWF  00,W
015F6:  MOVLB  0
015F8:  BTFSC  FD8.2
015FA:  BRA    1B60
015FC:  MOVLB  2
015FE:  MOVF   03,W
01600:  BNZ   160E
01602:  MOVLW  2A
01604:  SUBWF  00,W
01606:  MOVLB  0
01608:  BTFSC  FD8.2
0160A:  BRA    1B6E
0160C:  MOVLB  2
0160E:  MOVF   03,W
01610:  BNZ   161E
01612:  MOVLW  2B
01614:  SUBWF  00,W
01616:  MOVLB  0
01618:  BTFSC  FD8.2
0161A:  BRA    1B88
0161C:  MOVLB  2
0161E:  MOVF   03,W
01620:  BNZ   162E
01622:  MOVLW  2C
01624:  SUBWF  00,W
01626:  MOVLB  0
01628:  BTFSC  FD8.2
0162A:  BRA    1B98
0162C:  MOVLB  2
0162E:  MOVF   03,W
01630:  BNZ   163E
01632:  MOVLW  2D
01634:  SUBWF  00,W
01636:  MOVLB  0
01638:  BTFSC  FD8.2
0163A:  BRA    1BA8
0163C:  MOVLB  2
0163E:  MOVF   03,W
01640:  BNZ   164E
01642:  MOVLW  2E
01644:  SUBWF  00,W
01646:  MOVLB  0
01648:  BTFSC  FD8.2
0164A:  BRA    1BB8
0164C:  MOVLB  2
0164E:  MOVF   03,W
01650:  BNZ   165E
01652:  MOVLW  2F
01654:  SUBWF  00,W
01656:  MOVLB  0
01658:  BTFSC  FD8.2
0165A:  BRA    1BC8
0165C:  MOVLB  2
0165E:  MOVF   03,W
01660:  BNZ   166E
01662:  MOVLW  30
01664:  SUBWF  00,W
01666:  MOVLB  0
01668:  BTFSC  FD8.2
0166A:  BRA    1BD8
0166C:  MOVLB  2
0166E:  MOVF   03,W
01670:  BNZ   167E
01672:  MOVLW  31
01674:  SUBWF  00,W
01676:  MOVLB  0
01678:  BTFSC  FD8.2
0167A:  BRA    1BE8
0167C:  MOVLB  2
0167E:  MOVF   03,W
01680:  BNZ   168E
01682:  MOVLW  32
01684:  SUBWF  00,W
01686:  MOVLB  0
01688:  BTFSC  FD8.2
0168A:  BRA    1BF8
0168C:  MOVLB  2
0168E:  MOVF   03,W
01690:  BNZ   169E
01692:  MOVLW  33
01694:  SUBWF  00,W
01696:  MOVLB  0
01698:  BTFSC  FD8.2
0169A:  BRA    1C08
0169C:  MOVLB  2
0169E:  MOVLW  03
016A0:  SUBWF  03,W
016A2:  BNZ   16B0
016A4:  MOVLW  E8
016A6:  SUBWF  00,W
016A8:  MOVLB  0
016AA:  BTFSC  FD8.2
016AC:  BRA    1C18
016AE:  MOVLB  2
016B0:  MOVLW  03
016B2:  SUBWF  03,W
016B4:  BNZ   16C2
016B6:  MOVLW  E9
016B8:  SUBWF  00,W
016BA:  MOVLB  0
016BC:  BTFSC  FD8.2
016BE:  BRA    1C28
016C0:  MOVLB  2
016C2:  MOVLW  03
016C4:  SUBWF  03,W
016C6:  BNZ   16D4
016C8:  MOVLW  EA
016CA:  SUBWF  00,W
016CC:  MOVLB  0
016CE:  BTFSC  FD8.2
016D0:  BRA    1C36
016D2:  MOVLB  2
016D4:  MOVLW  03
016D6:  SUBWF  03,W
016D8:  BNZ   16E6
016DA:  MOVLW  EB
016DC:  SUBWF  00,W
016DE:  MOVLB  0
016E0:  BTFSC  FD8.2
016E2:  BRA    1C44
016E4:  MOVLB  2
016E6:  MOVLW  03
016E8:  SUBWF  03,W
016EA:  BNZ   16F8
016EC:  MOVLW  EC
016EE:  SUBWF  00,W
016F0:  MOVLB  0
016F2:  BTFSC  FD8.2
016F4:  BRA    1C52
016F6:  MOVLB  2
016F8:  MOVLW  03
016FA:  SUBWF  03,W
016FC:  BNZ   170A
016FE:  MOVLW  ED
01700:  SUBWF  00,W
01702:  MOVLB  0
01704:  BTFSC  FD8.2
01706:  BRA    1C60
01708:  MOVLB  2
0170A:  MOVLW  03
0170C:  SUBWF  03,W
0170E:  BNZ   171C
01710:  MOVLW  EE
01712:  SUBWF  00,W
01714:  MOVLB  0
01716:  BTFSC  FD8.2
01718:  BRA    1C6E
0171A:  MOVLB  2
0171C:  MOVLW  03
0171E:  SUBWF  03,W
01720:  BNZ   172E
01722:  MOVLW  EF
01724:  SUBWF  00,W
01726:  MOVLB  0
01728:  BTFSC  FD8.2
0172A:  BRA    1C7E
0172C:  MOVLB  2
0172E:  MOVLW  03
01730:  SUBWF  03,W
01732:  BNZ   1740
01734:  MOVLW  F0
01736:  SUBWF  00,W
01738:  MOVLB  0
0173A:  BTFSC  FD8.2
0173C:  BRA    1C8C
0173E:  MOVLB  2
01740:  MOVLW  03
01742:  SUBWF  03,W
01744:  BNZ   1752
01746:  MOVLW  F1
01748:  SUBWF  00,W
0174A:  MOVLB  0
0174C:  BTFSC  FD8.2
0174E:  BRA    1C9C
01750:  MOVLB  2
01752:  MOVLW  03
01754:  SUBWF  03,W
01756:  BNZ   1764
01758:  MOVLW  F2
0175A:  SUBWF  00,W
0175C:  MOVLB  0
0175E:  BTFSC  FD8.2
01760:  BRA    1CAA
01762:  MOVLB  2
01764:  MOVLW  03
01766:  SUBWF  03,W
01768:  BNZ   1776
0176A:  MOVLW  F3
0176C:  SUBWF  00,W
0176E:  MOVLB  0
01770:  BTFSC  FD8.2
01772:  BRA    1CB8
01774:  MOVLB  2
01776:  BRA    1CC6
.................... 		/* counters */ 
.................... 		case 0:  return (int16) current.pulse_count[0]; 
01778:  MOVFF  5F,01
0177C:  MOVFF  60,02
01780:  MOVLB  2
01782:  BRA    1CCE
01784:  MOVLB  0
.................... 		case 1:  return (int16) current.pulse_period[0]; 
01786:  MOVF   4D,W
01788:  MOVWF  01
0178A:  MOVF   4E,W
0178C:  MOVWF  02
0178E:  MOVLB  2
01790:  BRA    1CCE
01792:  MOVLB  0
.................... 		case 2:  return (int16) current.pulse_min_period[0]; 
01794:  MOVF   53,W
01796:  MOVWF  01
01798:  MOVF   54,W
0179A:  MOVWF  02
0179C:  MOVLB  2
0179E:  BRA    1CCE
017A0:  MOVLB  0
.................... 		case 3:  return (int16) current.pulse_max_period[0]; 
017A2:  MOVF   59,W
017A4:  MOVWF  01
017A6:  MOVF   5A,W
017A8:  MOVWF  02
017AA:  MOVLB  2
017AC:  BRA    1CCE
017AE:  MOVLB  0
.................... 		case 4:  ps.word=get_pulse_sum(0); return (int16) ps.l[0]; 
017B0:  MOVLB  2
017B2:  CLRF   xDA
017B4:  MOVLB  0
017B6:  RCALL  1226
017B8:  MOVFF  03,2BA
017BC:  MOVFF  02,2B9
017C0:  MOVFF  01,2B8
017C4:  MOVFF  00,2B7
017C8:  MOVLB  2
017CA:  MOVF   xB7,W
017CC:  MOVWF  01
017CE:  MOVF   xB8,W
017D0:  MOVWF  02
017D2:  BRA    1CCE
017D4:  MOVLB  0
.................... 		case 5:  return (int16) ps.l[1]; 
017D6:  MOVLB  2
017D8:  MOVF   xB9,W
017DA:  MOVWF  01
017DC:  MOVF   xBA,W
017DE:  MOVWF  02
017E0:  BRA    1CCE
017E2:  MOVLB  0
....................  
.................... 		case 6:  return (int16) current.pulse_count[1]; 
017E4:  MOVF   x61,W
017E6:  MOVWF  01
017E8:  MOVF   x62,W
017EA:  MOVWF  02
017EC:  MOVLB  2
017EE:  BRA    1CCE
017F0:  MOVLB  0
.................... 		case 7:  return (int16) current.pulse_period[1]; 
017F2:  MOVF   4F,W
017F4:  MOVWF  01
017F6:  MOVF   50,W
017F8:  MOVWF  02
017FA:  MOVLB  2
017FC:  BRA    1CCE
017FE:  MOVLB  0
.................... 		case 8:  return (int16) current.pulse_min_period[1]; 
01800:  MOVF   55,W
01802:  MOVWF  01
01804:  MOVF   56,W
01806:  MOVWF  02
01808:  MOVLB  2
0180A:  BRA    1CCE
0180C:  MOVLB  0
.................... 		case 9:  return (int16) current.pulse_max_period[1]; 
0180E:  MOVF   5B,W
01810:  MOVWF  01
01812:  MOVF   5C,W
01814:  MOVWF  02
01816:  MOVLB  2
01818:  BRA    1CCE
0181A:  MOVLB  0
.................... 		case 10: ps.word=get_pulse_sum(1); return (int16) ps.l[0]; 
0181C:  MOVLW  01
0181E:  MOVLB  2
01820:  MOVWF  xDA
01822:  MOVLB  0
01824:  RCALL  1226
01826:  MOVFF  03,2BA
0182A:  MOVFF  02,2B9
0182E:  MOVFF  01,2B8
01832:  MOVFF  00,2B7
01836:  MOVLB  2
01838:  MOVF   xB7,W
0183A:  MOVWF  01
0183C:  MOVF   xB8,W
0183E:  MOVWF  02
01840:  BRA    1CCE
01842:  MOVLB  0
.................... 		case 11: return (int16) ps.l[1]; 
01844:  MOVLB  2
01846:  MOVF   xB9,W
01848:  MOVWF  01
0184A:  MOVF   xBA,W
0184C:  MOVWF  02
0184E:  BRA    1CCE
01850:  MOVLB  0
....................  
....................  
.................... 		case 12: return (int16) current.pulse_count[2]; 
01852:  MOVF   x63,W
01854:  MOVWF  01
01856:  MOVF   x64,W
01858:  MOVWF  02
0185A:  MOVLB  2
0185C:  BRA    1CCE
0185E:  MOVLB  0
.................... 		case 13: return (int16) current.pulse_period[2]; 
01860:  MOVF   51,W
01862:  MOVWF  01
01864:  MOVF   52,W
01866:  MOVWF  02
01868:  MOVLB  2
0186A:  BRA    1CCE
0186C:  MOVLB  0
.................... 		case 14: return (int16) current.pulse_min_period[2]; 
0186E:  MOVF   57,W
01870:  MOVWF  01
01872:  MOVF   58,W
01874:  MOVWF  02
01876:  MOVLB  2
01878:  BRA    1CCE
0187A:  MOVLB  0
.................... 		case 15: return (int16) current.pulse_max_period[2]; 
0187C:  MOVF   5D,W
0187E:  MOVWF  01
01880:  MOVF   5E,W
01882:  MOVWF  02
01884:  MOVLB  2
01886:  BRA    1CCE
01888:  MOVLB  0
.................... 		case 16: ps.word=get_pulse_sum(2); return (int16) ps.l[0]; 
0188A:  MOVLW  02
0188C:  MOVLB  2
0188E:  MOVWF  xDA
01890:  MOVLB  0
01892:  RCALL  1226
01894:  MOVFF  03,2BA
01898:  MOVFF  02,2B9
0189C:  MOVFF  01,2B8
018A0:  MOVFF  00,2B7
018A4:  MOVLB  2
018A6:  MOVF   xB7,W
018A8:  MOVWF  01
018AA:  MOVF   xB8,W
018AC:  MOVWF  02
018AE:  BRA    1CCE
018B0:  MOVLB  0
.................... 		case 17: return (int16) ps.l[1]; 
018B2:  MOVLB  2
018B4:  MOVF   xB9,W
018B6:  MOVWF  01
018B8:  MOVF   xBA,W
018BA:  MOVWF  02
018BC:  BRA    1CCE
018BE:  MOVLB  0
....................  
....................  
.................... 		/* analog channels */ 
.................... 		/* input voltage */ 
.................... 		case 18: return (int16) current.adc_buffer[0][current.adc_buffer_index]; 
018C0:  CLRF   03
018C2:  MOVLB  1
018C4:  MOVF   x81,W
018C6:  MOVWF  02
018C8:  BCF    FD8.0
018CA:  RLCF   02,F
018CC:  RLCF   03,F
018CE:  MOVF   02,W
018D0:  ADDLW  81
018D2:  MOVWF  FE9
018D4:  MOVLW  00
018D6:  ADDWFC 03,W
018D8:  MOVWF  FEA
018DA:  MOVFF  FEC,03
018DE:  MOVF   FED,F
018E0:  MOVF   FEF,W
018E2:  MOVWF  01
018E4:  MOVF   03,W
018E6:  MOVWF  02
018E8:  MOVLB  2
018EA:  BRA    1CCE
018EC:  MOVLB  0
.................... 		case 19: return (int16) adc_get(0); 
018EE:  MOVLB  2
018F0:  CLRF   xDA
018F2:  MOVLB  0
018F4:  CALL   0EDC
018F8:  MOVF   01,W
018FA:  MOVWF  01
018FC:  MOVF   02,W
018FE:  MOVWF  02
01900:  MOVLB  2
01902:  BRA    1CCE
01904:  MOVLB  0
.................... 		case 20: return (int16) current.adc_std_dev[0]; 
01906:  MOVF   x71,W
01908:  MOVWF  01
0190A:  MOVF   x72,W
0190C:  MOVWF  02
0190E:  MOVLB  2
01910:  BRA    1CCE
01912:  MOVLB  0
.................... 		/* wind dir 0 */ 
.................... 		case 21: return (int16) current.adc_buffer[1][current.adc_buffer_index]; 
01914:  CLRF   03
01916:  MOVLB  1
01918:  MOVF   x81,W
0191A:  MOVWF  02
0191C:  BCF    FD8.0
0191E:  RLCF   02,F
01920:  RLCF   03,F
01922:  MOVF   02,W
01924:  ADDLW  A1
01926:  MOVWF  FE9
01928:  MOVLW  00
0192A:  ADDWFC 03,W
0192C:  MOVWF  FEA
0192E:  MOVFF  FEC,03
01932:  MOVF   FED,F
01934:  MOVF   FEF,W
01936:  MOVWF  01
01938:  MOVF   03,W
0193A:  MOVWF  02
0193C:  MOVLB  2
0193E:  BRA    1CCE
01940:  MOVLB  0
.................... 		case 22: return (int16) adc_get(1); 
01942:  MOVLW  01
01944:  MOVLB  2
01946:  MOVWF  xDA
01948:  MOVLB  0
0194A:  CALL   0EDC
0194E:  MOVF   01,W
01950:  MOVWF  01
01952:  MOVF   02,W
01954:  MOVWF  02
01956:  MOVLB  2
01958:  BRA    1CCE
0195A:  MOVLB  0
.................... 		case 23: return (int16) current.adc_std_dev[1]; 
0195C:  MOVF   x73,W
0195E:  MOVWF  01
01960:  MOVF   x74,W
01962:  MOVWF  02
01964:  MOVLB  2
01966:  BRA    1CCE
01968:  MOVLB  0
.................... 		/* wind dir 1 */ 
.................... 		case 24: return (int16) current.adc_buffer[2][current.adc_buffer_index]; 
0196A:  CLRF   03
0196C:  MOVLB  1
0196E:  MOVF   x81,W
01970:  MOVWF  02
01972:  BCF    FD8.0
01974:  RLCF   02,F
01976:  RLCF   03,F
01978:  MOVF   02,W
0197A:  ADDLW  C1
0197C:  MOVWF  FE9
0197E:  MOVLW  00
01980:  ADDWFC 03,W
01982:  MOVWF  FEA
01984:  MOVFF  FEC,03
01988:  MOVF   FED,F
0198A:  MOVF   FEF,W
0198C:  MOVWF  01
0198E:  MOVF   03,W
01990:  MOVWF  02
01992:  MOVLB  2
01994:  BRA    1CCE
01996:  MOVLB  0
.................... 		case 25: return (int16) adc_get(2); 
01998:  MOVLW  02
0199A:  MOVLB  2
0199C:  MOVWF  xDA
0199E:  MOVLB  0
019A0:  CALL   0EDC
019A4:  MOVF   01,W
019A6:  MOVWF  01
019A8:  MOVF   02,W
019AA:  MOVWF  02
019AC:  MOVLB  2
019AE:  BRA    1CCE
019B0:  MOVLB  0
.................... 		case 26: return (int16) current.adc_std_dev[2]; 
019B2:  MOVF   x75,W
019B4:  MOVWF  01
019B6:  MOVF   x76,W
019B8:  MOVWF  02
019BA:  MOVLB  2
019BC:  BRA    1CCE
019BE:  MOVLB  0
.................... 		/* temperature */ 
.................... 		case 27: return (int16) current.adc_buffer[3][current.adc_buffer_index]; 
019C0:  CLRF   03
019C2:  MOVLB  1
019C4:  MOVF   x81,W
019C6:  MOVWF  02
019C8:  BCF    FD8.0
019CA:  RLCF   02,F
019CC:  RLCF   03,F
019CE:  MOVF   02,W
019D0:  ADDLW  E1
019D2:  MOVWF  FE9
019D4:  MOVLW  00
019D6:  ADDWFC 03,W
019D8:  MOVWF  FEA
019DA:  MOVFF  FEC,03
019DE:  MOVF   FED,F
019E0:  MOVF   FEF,W
019E2:  MOVWF  01
019E4:  MOVF   03,W
019E6:  MOVWF  02
019E8:  MOVLB  2
019EA:  BRA    1CCE
019EC:  MOVLB  0
.................... 		case 28: return (int16) adc_get(3); 
019EE:  MOVLW  03
019F0:  MOVLB  2
019F2:  MOVWF  xDA
019F4:  MOVLB  0
019F6:  CALL   0EDC
019FA:  MOVF   01,W
019FC:  MOVWF  01
019FE:  MOVF   02,W
01A00:  MOVWF  02
01A02:  MOVLB  2
01A04:  BRA    1CCE
01A06:  MOVLB  0
.................... 		case 29: return (int16) current.adc_std_dev[3]; 
01A08:  MOVF   x77,W
01A0A:  MOVWF  01
01A0C:  MOVF   x78,W
01A0E:  MOVWF  02
01A10:  MOVLB  2
01A12:  BRA    1CCE
01A14:  MOVLB  0
.................... 		/* user ADC 0 to 3 */ 
.................... 		case 30: return (int16) current.adc_buffer[4][current.adc_buffer_index]; 
01A16:  CLRF   03
01A18:  MOVLB  1
01A1A:  MOVF   x81,W
01A1C:  MOVWF  02
01A1E:  BCF    FD8.0
01A20:  RLCF   02,F
01A22:  RLCF   03,F
01A24:  MOVF   02,W
01A26:  ADDLW  01
01A28:  MOVWF  FE9
01A2A:  MOVLW  01
01A2C:  ADDWFC 03,W
01A2E:  MOVWF  FEA
01A30:  MOVFF  FEC,03
01A34:  MOVF   FED,F
01A36:  MOVF   FEF,W
01A38:  MOVWF  01
01A3A:  MOVF   03,W
01A3C:  MOVWF  02
01A3E:  MOVLB  2
01A40:  BRA    1CCE
01A42:  MOVLB  0
.................... 		case 31: return (int16) adc_get(4); 
01A44:  MOVLW  04
01A46:  MOVLB  2
01A48:  MOVWF  xDA
01A4A:  MOVLB  0
01A4C:  CALL   0EDC
01A50:  MOVF   01,W
01A52:  MOVWF  01
01A54:  MOVF   02,W
01A56:  MOVWF  02
01A58:  MOVLB  2
01A5A:  BRA    1CCE
01A5C:  MOVLB  0
.................... 		case 32: return (int16) current.adc_std_dev[4]; 
01A5E:  MOVF   x79,W
01A60:  MOVWF  01
01A62:  MOVF   x7A,W
01A64:  MOVWF  02
01A66:  MOVLB  2
01A68:  BRA    1CCE
01A6A:  MOVLB  0
....................  
.................... 		case 33: return (int16) current.adc_buffer[5][current.adc_buffer_index]; 
01A6C:  CLRF   03
01A6E:  MOVLB  1
01A70:  MOVF   x81,W
01A72:  MOVWF  02
01A74:  BCF    FD8.0
01A76:  RLCF   02,F
01A78:  RLCF   03,F
01A7A:  MOVF   02,W
01A7C:  ADDLW  21
01A7E:  MOVWF  FE9
01A80:  MOVLW  01
01A82:  ADDWFC 03,W
01A84:  MOVWF  FEA
01A86:  MOVFF  FEC,03
01A8A:  MOVF   FED,F
01A8C:  MOVF   FEF,W
01A8E:  MOVWF  01
01A90:  MOVF   03,W
01A92:  MOVWF  02
01A94:  MOVLB  2
01A96:  BRA    1CCE
01A98:  MOVLB  0
.................... 		case 34: return (int16) adc_get(5); 
01A9A:  MOVLW  05
01A9C:  MOVLB  2
01A9E:  MOVWF  xDA
01AA0:  MOVLB  0
01AA2:  CALL   0EDC
01AA6:  MOVF   01,W
01AA8:  MOVWF  01
01AAA:  MOVF   02,W
01AAC:  MOVWF  02
01AAE:  MOVLB  2
01AB0:  BRA    1CCE
01AB2:  MOVLB  0
.................... 		case 35: return (int16) current.adc_std_dev[5]; 
01AB4:  MOVF   x7B,W
01AB6:  MOVWF  01
01AB8:  MOVF   x7C,W
01ABA:  MOVWF  02
01ABC:  MOVLB  2
01ABE:  BRA    1CCE
01AC0:  MOVLB  0
....................  
.................... 		case 36: return (int16) current.adc_buffer[6][current.adc_buffer_index]; 
01AC2:  CLRF   03
01AC4:  MOVLB  1
01AC6:  MOVF   x81,W
01AC8:  MOVWF  02
01ACA:  BCF    FD8.0
01ACC:  RLCF   02,F
01ACE:  RLCF   03,F
01AD0:  MOVF   02,W
01AD2:  ADDLW  41
01AD4:  MOVWF  FE9
01AD6:  MOVLW  01
01AD8:  ADDWFC 03,W
01ADA:  MOVWF  FEA
01ADC:  MOVFF  FEC,03
01AE0:  MOVF   FED,F
01AE2:  MOVF   FEF,W
01AE4:  MOVWF  01
01AE6:  MOVF   03,W
01AE8:  MOVWF  02
01AEA:  MOVLB  2
01AEC:  BRA    1CCE
01AEE:  MOVLB  0
.................... 		case 37: return (int16) adc_get(6); 
01AF0:  MOVLW  06
01AF2:  MOVLB  2
01AF4:  MOVWF  xDA
01AF6:  MOVLB  0
01AF8:  CALL   0EDC
01AFC:  MOVF   01,W
01AFE:  MOVWF  01
01B00:  MOVF   02,W
01B02:  MOVWF  02
01B04:  MOVLB  2
01B06:  BRA    1CCE
01B08:  MOVLB  0
.................... 		case 38: return (int16) current.adc_std_dev[6]; 
01B0A:  MOVF   x7D,W
01B0C:  MOVWF  01
01B0E:  MOVF   x7E,W
01B10:  MOVWF  02
01B12:  MOVLB  2
01B14:  BRA    1CCE
01B16:  MOVLB  0
....................  
.................... 		case 39: return (int16) current.adc_buffer[7][current.adc_buffer_index]; 
01B18:  CLRF   03
01B1A:  MOVLB  1
01B1C:  MOVF   x81,W
01B1E:  MOVWF  02
01B20:  BCF    FD8.0
01B22:  RLCF   02,F
01B24:  RLCF   03,F
01B26:  MOVF   02,W
01B28:  ADDLW  61
01B2A:  MOVWF  FE9
01B2C:  MOVLW  01
01B2E:  ADDWFC 03,W
01B30:  MOVWF  FEA
01B32:  MOVFF  FEC,03
01B36:  MOVF   FED,F
01B38:  MOVF   FEF,W
01B3A:  MOVWF  01
01B3C:  MOVF   03,W
01B3E:  MOVWF  02
01B40:  MOVLB  2
01B42:  BRA    1CCE
01B44:  MOVLB  0
.................... 		case 40: return (int16) adc_get(7); 
01B46:  MOVLW  07
01B48:  MOVLB  2
01B4A:  MOVWF  xDA
01B4C:  MOVLB  0
01B4E:  CALL   0EDC
01B52:  MOVF   01,W
01B54:  MOVWF  01
01B56:  MOVF   02,W
01B58:  MOVWF  02
01B5A:  MOVLB  2
01B5C:  BRA    1CCE
01B5E:  MOVLB  0
.................... 		case 41: return (int16) current.adc_std_dev[7]; 
01B60:  MOVF   x7F,W
01B62:  MOVWF  01
01B64:  MOVF   x80,W
01B66:  MOVWF  02
01B68:  MOVLB  2
01B6A:  BRA    1CCE
01B6C:  MOVLB  0
....................  
.................... 		/* status */ 
.................... 		case 42: return (int16) current.sequence_number++; 
01B6E:  MOVLB  1
01B70:  MOVF   x89,W
01B72:  MOVWF  03
01B74:  MOVF   x88,W
01B76:  INCF   x88,F
01B78:  BTFSC  FD8.2
01B7A:  INCF   x89,F
01B7C:  MOVWF  01
01B7E:  MOVF   03,W
01B80:  MOVWF  02
01B82:  MOVLB  2
01B84:  BRA    1CCE
01B86:  MOVLB  0
.................... 		case 43: return (int16) current.interval_milliseconds; /* milliseconds since last query */ 
01B88:  MOVLB  1
01B8A:  MOVF   x8C,W
01B8C:  MOVWF  01
01B8E:  MOVF   x8D,W
01B90:  MOVWF  02
01B92:  MOVLB  2
01B94:  BRA    1CCE
01B96:  MOVLB  0
.................... 		case 44: return (int16) current.uptime_minutes;  
01B98:  MOVLB  1
01B9A:  MOVF   x8A,W
01B9C:  MOVWF  01
01B9E:  MOVF   x8B,W
01BA0:  MOVWF  02
01BA2:  MOVLB  2
01BA4:  BRA    1CCE
01BA6:  MOVLB  0
.................... 		case 45: return (int16) current.watchdog_seconds;  
01BA8:  MOVLB  1
01BAA:  MOVF   x90,W
01BAC:  MOVWF  01
01BAE:  MOVF   x91,W
01BB0:  MOVWF  02
01BB2:  MOVLB  2
01BB4:  BRA    1CCE
01BB6:  MOVLB  0
....................  
.................... 		/* triggers a new measurement */ 
.................... 		case 46: reset_counters(); return (int16) 0; 
01BB8:  GOTO   1288
01BBC:  MOVLW  00
01BBE:  MOVWF  01
01BC0:  MOVWF  02
01BC2:  MOVLB  2
01BC4:  BRA    1CCE
01BC6:  MOVLB  0
.................... 		/* triggers a reset of pulse sum */ 
.................... 		case 47: reset_pulse_sum(); return (int16) 0; 
01BC8:  GOTO   12C4
01BCC:  MOVLW  00
01BCE:  MOVWF  01
01BD0:  MOVWF  02
01BD2:  MOVLB  2
01BD4:  BRA    1CCE
01BD6:  MOVLB  0
.................... 		/* modbus statistics */ 
.................... 		case 48: return (int16) current.modbus_our_packets; 
01BD8:  MOVLB  1
01BDA:  MOVF   x82,W
01BDC:  MOVWF  01
01BDE:  MOVF   x83,W
01BE0:  MOVWF  02
01BE2:  MOVLB  2
01BE4:  BRA    1CCE
01BE6:  MOVLB  0
.................... 		case 49: return (int16) current.modbus_other_packets; 
01BE8:  MOVLB  1
01BEA:  MOVF   x84,W
01BEC:  MOVWF  01
01BEE:  MOVF   x85,W
01BF0:  MOVWF  02
01BF2:  MOVLB  2
01BF4:  BRA    1CCE
01BF6:  MOVLB  0
.................... 		case 50: return (int16) current.modbus_last_error; 
01BF8:  MOVLB  1
01BFA:  MOVF   x86,W
01BFC:  MOVWF  01
01BFE:  MOVF   x87,W
01C00:  MOVWF  02
01C02:  MOVLB  2
01C04:  BRA    1CCE
01C06:  MOVLB  0
.................... 		/* triggers a modbus statistics reset */ 
.................... 		case 51: reset_modbus_stats(); return (int16) 0; 
01C08:  GOTO   12EC
01C0C:  MOVLW  00
01C0E:  MOVWF  01
01C10:  MOVWF  02
01C12:  MOVLB  2
01C14:  BRA    1CCE
01C16:  MOVLB  0
....................  
.................... 		/* configuration */ 
.................... //		case 1000: return (int16) input(BUTTON); 
.................... //		case 1000: return (int16) modbus_rx.len; 
.................... 		case 1000: return (int16) config.serial_prefix; 
01C18:  CLRF   03
01C1A:  MOVF   38,W
01C1C:  MOVWF  01
01C1E:  MOVF   03,W
01C20:  MOVWF  02
01C22:  MOVLB  2
01C24:  BRA    1CCE
01C26:  MOVLB  0
.................... 		case 1001: return (int16) config.serial_number; 
01C28:  MOVF   39,W
01C2A:  MOVWF  01
01C2C:  MOVF   3A,W
01C2E:  MOVWF  02
01C30:  MOVLB  2
01C32:  BRA    1CCE
01C34:  MOVLB  0
.................... 		case 1002: return (int16) 'P'; 
01C36:  MOVLW  50
01C38:  MOVWF  01
01C3A:  MOVLW  00
01C3C:  MOVWF  02
01C3E:  MOVLB  2
01C40:  BRA    1CCE
01C42:  MOVLB  0
.................... 		case 1003: return (int16) 'W'; 
01C44:  MOVLW  57
01C46:  MOVWF  01
01C48:  MOVLW  00
01C4A:  MOVWF  02
01C4C:  MOVLB  2
01C4E:  BRA    1CCE
01C50:  MOVLB  0
.................... 		case 1004: return (int16) 'X'; 
01C52:  MOVLW  58
01C54:  MOVWF  01
01C56:  MOVLW  00
01C58:  MOVWF  02
01C5A:  MOVLB  2
01C5C:  BRA    1CCE
01C5E:  MOVLB  0
.................... 		case 1005: return (int16) 1; 
01C60:  MOVLW  01
01C62:  MOVWF  01
01C64:  MOVLW  00
01C66:  MOVWF  02
01C68:  MOVLB  2
01C6A:  BRA    1CCE
01C6C:  MOVLB  0
.................... 		case 1006: return (int16) config.modbus_address; 
01C6E:  CLRF   03
01C70:  MOVF   36,W
01C72:  MOVWF  01
01C74:  MOVF   03,W
01C76:  MOVWF  02
01C78:  MOVLB  2
01C7A:  BRA    1CCE
01C7C:  MOVLB  0
.................... 		case 1007: return (int16) config.adc_sample_ticks; 
01C7E:  MOVF   3B,W
01C80:  MOVWF  01
01C82:  MOVF   3C,W
01C84:  MOVWF  02
01C86:  MOVLB  2
01C88:  BRA    1CCE
01C8A:  MOVLB  0
.................... 		case 1008: return (int16) config.allow_bootload_request; 
01C8C:  CLRF   03
01C8E:  MOVF   3D,W
01C90:  MOVWF  01
01C92:  MOVF   03,W
01C94:  MOVWF  02
01C96:  MOVLB  2
01C98:  BRA    1CCE
01C9A:  MOVLB  0
.................... 		case 1009: return (int16) config.watchdog_seconds_max; 
01C9C:  MOVF   3E,W
01C9E:  MOVWF  01
01CA0:  MOVF   3F,W
01CA2:  MOVWF  02
01CA4:  MOVLB  2
01CA6:  BRA    1CCE
01CA8:  MOVLB  0
.................... 		case 1010: return (int16) config.pi_offtime_seconds; 
01CAA:  MOVF   40,W
01CAC:  MOVWF  01
01CAE:  MOVF   41,W
01CB0:  MOVWF  02
01CB2:  MOVLB  2
01CB4:  BRA    1CCE
01CB6:  MOVLB  0
.................... 		case 1011: return (int16) config.power_startup; 
01CB8:  CLRF   03
01CBA:  MOVF   42,W
01CBC:  MOVWF  01
01CBE:  MOVF   03,W
01CC0:  MOVWF  02
01CC2:  MOVLB  2
01CC4:  BRA    1CCE
....................  
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return (int16) 65535; 
01CC6:  MOVLW  FF
01CC8:  MOVWF  01
01CCA:  MOVWF  02
01CCC:  BRA    1CCE
.................... 	} 
....................  
.................... } 
01CCE:  MOVLB  0
01CD0:  GOTO   1D22 (RETURN)
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
*
010EA:  MOVLB  2
010EC:  MOVF   xCE,W
010EE:  SUBLW  1F
010F0:  BNZ   110A
010F2:  MOVF   xCF,W
010F4:  SUBLW  4E
010F6:  BNZ   110A
010F8:  MOVF   xD0,W
010FA:  SUBLW  20
010FC:  BNZ   110A
010FE:  MOVF   xD1,W
01100:  SUBLW  4E
01102:  BNZ   110A
.................... 		return 1; 
01104:  MOVLW  01
01106:  MOVWF  01
01108:  BRA    1166
....................  
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
0110A:  MOVF   xCF,W
0110C:  SUBLW  02
0110E:  BC    112E
01110:  XORLW  FF
01112:  BNZ   111A
01114:  MOVF   xCE,W
01116:  SUBLW  E7
01118:  BC    112E
0111A:  MOVF   xD1,W
0111C:  SUBLW  03
0111E:  BNC   112E
01120:  BNZ   1128
01122:  MOVF   xD0,W
01124:  SUBLW  F4
01126:  BNC   112E
.................... 		return 1; 
01128:  MOVLW  01
0112A:  MOVWF  01
0112C:  BRA    1166
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
0112E:  MOVF   xCF,W
01130:  SUBLW  06
01132:  BC    1152
01134:  XORLW  FF
01136:  BNZ   113E
01138:  MOVF   xCE,W
0113A:  SUBLW  CF
0113C:  BC    1152
0113E:  MOVF   xD1,W
01140:  SUBLW  09
01142:  BNC   1152
01144:  BNZ   114C
01146:  MOVF   xD0,W
01148:  SUBLW  D1
0114A:  BNC   1152
.................... 		return 1; 
0114C:  MOVLW  01
0114E:  MOVWF  01
01150:  BRA    1166
.................... 	 
....................  
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
01152:  MOVF   xD1,F
01154:  BNZ   1162
01156:  MOVF   xD0,W
01158:  SUBLW  34
0115A:  BNC   1162
.................... 		return 1; 
0115C:  MOVLW  01
0115E:  MOVWF  01
01160:  BRA    1166
....................  
.................... 	return 0; 
01162:  MOVLW  00
01164:  MOVWF  01
.................... } 
01166:  MOVLB  0
01168:  GOTO   209C (RETURN)
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_EE_REGISTER && end <= MAX_EE_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */ 
.................... 	if ( end <= MAX_STATUS_REGISTER+1) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(function func, int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, func); // FUNC_READ_HOLDING_REGISTERS); 
*
01CD4:  MOVFF  2CD,2D6
01CD8:  MOVFF  2CC,2D7
01CDC:  CALL   11AA
.................... 	modbus_serial_putc(register_count*2); 
01CE0:  BCF    FD8.0
01CE2:  MOVLB  2
01CE4:  RLCF   xD0,W
01CE6:  MOVWF  xD6
01CE8:  RLCF   xD1,W
01CEA:  MOVWF  xD7
01CEC:  MOVFF  2D6,2D8
01CF0:  MOVLB  0
01CF2:  CALL   1176
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
01CF6:  MOVLB  2
01CF8:  CLRF   xD3
01CFA:  CLRF   xD2
01CFC:  MOVF   xD3,W
01CFE:  SUBWF  xD1,W
01D00:  BNC   1D4C
01D02:  BNZ   1D0A
01D04:  MOVF   xD0,W
01D06:  SUBWF  xD2,W
01D08:  BC    1D4C
.................... 		l=map_modbus(start_address+i); 
01D0A:  MOVF   xD2,W
01D0C:  ADDWF  xCE,W
01D0E:  MOVWF  xD6
01D10:  MOVF   xD3,W
01D12:  ADDWFC xCF,W
01D14:  MOVWF  xD7
01D16:  MOVWF  xD9
01D18:  MOVFF  2D6,2D8
01D1C:  MOVLB  0
01D1E:  GOTO   1300
01D22:  MOVFF  02,2D5
01D26:  MOVFF  01,2D4
.................... 		modbus_serial_putc(make8(l,1)); 
01D2A:  MOVFF  2D5,2D6
01D2E:  MOVFF  2D5,2D8
01D32:  CALL   1176
....................   		modbus_serial_putc(make8(l,0)); 
01D36:  MOVFF  2D4,2D6
01D3A:  MOVFF  2D4,2D8
01D3E:  CALL   1176
.................... 	} 
01D42:  MOVLB  2
01D44:  INCF   xD2,F
01D46:  BTFSC  FD8.2
01D48:  INCF   xD3,F
01D4A:  BRA    1CFC
....................  
.................... 	modbus_serial_send_stop(); 
01D4C:  MOVLB  0
01D4E:  CALL   11D8
.................... } 
01D52:  GOTO   20DE (RETURN)
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	if ( address >= MIN_EE_REGISTER && address < MAX_EE_REGISTER ) { 
01D56:  MOVLB  2
01D58:  MOVF   xD3,W
01D5A:  SUBLW  06
01D5C:  BC    1DC4
01D5E:  XORLW  FF
01D60:  BNZ   1D68
01D62:  MOVF   xD2,W
01D64:  SUBLW  CF
01D66:  BC    1DC4
01D68:  MOVF   xD3,W
01D6A:  SUBLW  09
01D6C:  BNC   1DC4
01D6E:  BNZ   1D76
01D70:  MOVF   xD2,W
01D72:  SUBLW  CF
01D74:  BNC   1DC4
.................... 		if ( value > 256 ) return ILLEGAL_DATA_VALUE; 
01D76:  MOVF   xD5,W
01D78:  SUBLW  00
01D7A:  BC    1D8C
01D7C:  XORLW  FF
01D7E:  BNZ   1D86
01D80:  MOVF   xD4,W
01D82:  SUBLW  00
01D84:  BC    1D8C
01D86:  MOVLW  03
01D88:  MOVWF  01
01D8A:  BRA    1F8C
.................... 		write_eeprom(address,(int8) value); 
01D8C:  MOVFF  2D3,FAA
01D90:  MOVFF  2D2,FA9
01D94:  MOVFF  2D4,FA8
01D98:  BCF    FA6.6
01D9A:  BCF    FA6.7
01D9C:  BSF    FA6.2
01D9E:  MOVF   FF2,W
01DA0:  MOVWF  00
01DA2:  BCF    FF2.6
01DA4:  BCF    FF2.7
01DA6:  MOVLB  F
01DA8:  MOVLW  55
01DAA:  MOVWF  FA7
01DAC:  MOVLW  AA
01DAE:  MOVWF  FA7
01DB0:  BSF    FA6.1
01DB2:  BTFSC  FA6.1
01DB4:  BRA    1DB2
01DB6:  BCF    FA6.2
01DB8:  MOVF   00,W
01DBA:  IORWF  FF2,F
.................... 		return 0; 
01DBC:  MOVLW  00
01DBE:  MOVWF  01
01DC0:  MOVLB  2
01DC2:  BRA    1F8C
.................... 	} 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( current.factory_unlocked ) { 
01DC4:  MOVLB  1
01DC6:  MOVF   x8E,F
01DC8:  BZ    1E00
.................... 		if ( 1000 == address ) { 
01DCA:  MOVLB  2
01DCC:  MOVF   xD2,W
01DCE:  SUBLW  E8
01DD0:  BNZ   1DE4
01DD2:  MOVF   xD3,W
01DD4:  SUBLW  03
01DD6:  BNZ   1DE4
.................... 			config.serial_prefix=value; 
01DD8:  MOVFF  2D4,38
.................... 			return 0; 
01DDC:  MOVLW  00
01DDE:  MOVWF  01
01DE0:  BRA    1F8C
.................... 		} else if ( 1001 == address ) { 
01DE2:  BRA    1DFE
01DE4:  MOVF   xD2,W
01DE6:  SUBLW  E9
01DE8:  BNZ   1DFE
01DEA:  MOVF   xD3,W
01DEC:  SUBLW  03
01DEE:  BNZ   1DFE
.................... 			config.serial_number=value; 
01DF0:  MOVFF  2D5,3A
01DF4:  MOVFF  2D4,39
.................... 			return 0; 
01DF8:  MOVLW  00
01DFA:  MOVWF  01
01DFC:  BRA    1F8C
01DFE:  MOVLB  1
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
01E00:  MOVLB  2
01E02:  MOVF   xD2,W
01E04:  MOVWF  00
01E06:  MOVF   xD3,W
01E08:  MOVWF  03
01E0A:  MOVLW  03
01E0C:  SUBWF  03,W
01E0E:  BNZ   1E1A
01E10:  MOVLW  EE
01E12:  SUBWF  00,W
01E14:  MOVLB  0
01E16:  BZ    1EA0
01E18:  MOVLB  2
01E1A:  MOVLW  03
01E1C:  SUBWF  03,W
01E1E:  BNZ   1E2A
01E20:  MOVLW  EF
01E22:  SUBWF  00,W
01E24:  MOVLB  0
01E26:  BZ    1EC0
01E28:  MOVLB  2
01E2A:  MOVLW  03
01E2C:  SUBWF  03,W
01E2E:  BNZ   1E3A
01E30:  MOVLW  F0
01E32:  SUBWF  00,W
01E34:  MOVLB  0
01E36:  BZ    1ED0
01E38:  MOVLB  2
01E3A:  MOVLW  03
01E3C:  SUBWF  03,W
01E3E:  BNZ   1E4A
01E40:  MOVLW  F1
01E42:  SUBWF  00,W
01E44:  MOVLB  0
01E46:  BZ    1EE8
01E48:  MOVLB  2
01E4A:  MOVLW  03
01E4C:  SUBWF  03,W
01E4E:  BNZ   1E5A
01E50:  MOVLW  F2
01E52:  SUBWF  00,W
01E54:  MOVLB  0
01E56:  BZ    1EF4
01E58:  MOVLB  2
01E5A:  MOVLW  03
01E5C:  SUBWF  03,W
01E5E:  BNZ   1E6A
01E60:  MOVLW  F3
01E62:  SUBWF  00,W
01E64:  MOVLB  0
01E66:  BZ    1F0E
01E68:  MOVLB  2
01E6A:  MOVLW  07
01E6C:  SUBWF  03,W
01E6E:  BNZ   1E7A
01E70:  MOVLW  CE
01E72:  SUBWF  00,W
01E74:  MOVLB  0
01E76:  BZ    1F26
01E78:  MOVLB  2
01E7A:  MOVLW  07
01E7C:  SUBWF  03,W
01E7E:  BNZ   1E8C
01E80:  MOVLW  CF
01E82:  SUBWF  00,W
01E84:  MOVLB  0
01E86:  BTFSC  FD8.2
01E88:  BRA    1F40
01E8A:  MOVLB  2
01E8C:  MOVLW  4E
01E8E:  SUBWF  03,W
01E90:  BNZ   1E9E
01E92:  MOVLW  1F
01E94:  SUBWF  00,W
01E96:  MOVLB  0
01E98:  BTFSC  FD8.2
01E9A:  BRA    1F5A
01E9C:  MOVLB  2
01E9E:  BRA    1F82
.................... 			 
....................  
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127} */ 
.................... 			if ( value != 255 && value > 127 ) return ILLEGAL_DATA_VALUE; 
01EA0:  MOVLB  2
01EA2:  INCFSZ xD4,W
01EA4:  BRA    1EAA
01EA6:  MOVF   xD5,F
01EA8:  BZ    1EBA
01EAA:  MOVF   xD5,F
01EAC:  BNZ   1EB4
01EAE:  MOVF   xD4,W
01EB0:  SUBLW  7F
01EB2:  BC    1EBA
01EB4:  MOVLW  03
01EB6:  MOVWF  01
01EB8:  BRA    1F8C
.................... 			config.modbus_address=value; 
01EBA:  MOVFF  2D4,36
.................... 			break; 
01EBE:  BRA    1F88
....................  
.................... 		case 1007: 
.................... 			/* ADC sample interval */ 
.................... 			timers.now_adc_reset_count=1; 
01EC0:  MOVLB  1
01EC2:  BSF    xAD.1
.................... 			config.adc_sample_ticks=value; 
01EC4:  MOVFF  2D5,3C
01EC8:  MOVFF  2D4,3B
.................... 			break; 
01ECC:  MOVLB  2
01ECE:  BRA    1F88
....................  
.................... 		case 1008: 
.................... 			/* allow this processor to follow requests of the PIC BOOTLOAD REQUEST line to reset ourselves */ 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01ED0:  MOVLB  2
01ED2:  MOVF   xD5,F
01ED4:  BNZ   1EDC
01ED6:  MOVF   xD4,W
01ED8:  SUBLW  01
01EDA:  BC    1EE2
01EDC:  MOVLW  03
01EDE:  MOVWF  01
01EE0:  BRA    1F8C
.................... 			config.allow_bootload_request=value; 
01EE2:  MOVFF  2D4,3D
.................... 			break; 
01EE6:  BRA    1F88
....................  
.................... 		case 1009: 
.................... 			config.watchdog_seconds_max=value; 
01EE8:  MOVFF  2D5,3F
01EEC:  MOVFF  2D4,3E
.................... 			break; 
01EF0:  MOVLB  2
01EF2:  BRA    1F88
....................  
.................... 		case 1010: 
.................... 			if ( value < 1 ) return ILLEGAL_DATA_VALUE; 
01EF4:  MOVLB  2
01EF6:  MOVF   xD4,F
01EF8:  BNZ   1F04
01EFA:  MOVF   xD5,F
01EFC:  BNZ   1F04
01EFE:  MOVLW  03
01F00:  MOVWF  01
01F02:  BRA    1F8C
.................... 			config.pi_offtime_seconds=value; 
01F04:  MOVFF  2D5,41
01F08:  MOVFF  2D4,40
.................... 			break; 
01F0C:  BRA    1F88
.................... 		 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
01F0E:  MOVLB  2
01F10:  MOVF   xD5,F
01F12:  BNZ   1F1A
01F14:  MOVF   xD4,W
01F16:  SUBLW  01
01F18:  BC    1F20
01F1A:  MOVLW  03
01F1C:  MOVWF  01
01F1E:  BRA    1F8C
.................... 			config.power_startup=value; 
01F20:  MOVFF  2D4,42
.................... 			break; 
01F24:  BRA    1F88
.................... 		 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01F26:  MOVLB  2
01F28:  DECFSZ xD4,W
01F2A:  BRA    1F30
01F2C:  MOVF   xD5,F
01F2E:  BZ    1F36
01F30:  MOVLW  03
01F32:  MOVWF  01
01F34:  BRA    1F8C
.................... 			write_default_param_file(); 
01F36:  MOVLB  0
01F38:  CALL   0CAC
.................... 			break; 
01F3C:  MOVLB  2
01F3E:  BRA    1F88
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
01F40:  MOVLB  2
01F42:  DECFSZ xD4,W
01F44:  BRA    1F4A
01F46:  MOVF   xD5,F
01F48:  BZ    1F50
01F4A:  MOVLW  03
01F4C:  MOVWF  01
01F4E:  BRA    1F8C
.................... 			write_param_file(); 
01F50:  MOVLB  0
01F52:  CALL   0C58
.................... 			break; 
01F56:  MOVLB  2
01F58:  BRA    1F88
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
01F5A:  MOVLB  2
01F5C:  MOVF   xD4,W
01F5E:  SUBLW  0A
01F60:  BNZ   1F68
01F62:  MOVF   xD5,W
01F64:  SUBLW  07
01F66:  BZ    1F74
.................... 				current.factory_unlocked=0; 
01F68:  MOVLB  1
01F6A:  CLRF   x8E
.................... 				return ILLEGAL_DATA_VALUE; 
01F6C:  MOVLW  03
01F6E:  MOVWF  01
01F70:  MOVLB  2
01F72:  BRA    1F8C
.................... 			} 
.................... 			current.factory_unlocked=1; 
01F74:  MOVLW  01
01F76:  MOVLB  1
01F78:  MOVWF  x8E
.................... 			/* green LED for 2 seconds */ 
.................... 			timers.led_on_green=200; 
01F7A:  MOVLW  C8
01F7C:  MOVWF  xAA
.................... 			break; 
01F7E:  MOVLB  2
01F80:  BRA    1F88
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
01F82:  MOVLW  02
01F84:  MOVWF  01
01F86:  BRA    1F8C
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
01F88:  MOVLW  00
01F8A:  MOVWF  01
.................... } 
01F8C:  MOVLB  0
01F8E:  RETURN 0
....................  
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
*
02020:  GOTO   10C4
02024:  MOVF   01,F
02026:  BTFSC  FD8.2
02028:  BRA    2250
.................... //		output_high(TP_RED); 
....................  
.................... 		if ( 255==config.modbus_address || modbus_rx.address==config.modbus_address ) { 
0202A:  INCFSZ 36,W
0202C:  BRA    2030
0202E:  BRA    203C
02030:  MOVF   36,W
02032:  MOVLB  1
02034:  SUBWF  xB4,W
02036:  BTFSS  FD8.2
02038:  BRA    223C
0203A:  MOVLB  0
.................... 			/* Modbus statistics */ 
.................... 			if ( current.modbus_our_packets < 65535 ) 
0203C:  MOVLB  1
0203E:  INCFSZ x82,W
02040:  BRA    2048
02042:  INCFSZ x83,W
02044:  BRA    2048
02046:  BRA    204E
.................... 				current.modbus_our_packets++; 
02048:  INCF   x82,F
0204A:  BTFSC  FD8.2
0204C:  INCF   x83,F
.................... 	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
0204E:  MOVLW  14
02050:  MOVWF  xAA
....................  
.................... 			switch(modbus_rx.func) { 
02052:  MOVF   xB6,W
02054:  XORLW  03
02056:  MOVLB  0
02058:  BZ    206A
0205A:  XORLW  07
0205C:  BZ    206A
0205E:  XORLW  02
02060:  BZ    20E2
02062:  XORLW  16
02064:  BTFSC  FD8.2
02066:  BRA    2154
02068:  BRA    2216
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
0206A:  MOVFF  1B8,2C7
0206E:  MOVFF  1B9,2C6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
02072:  MOVFF  1BA,2C9
02076:  MOVFF  1BB,2C8
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
0207A:  MOVLB  2
0207C:  MOVF   xC8,W
0207E:  ADDWF  xC6,W
02080:  MOVWF  xCC
02082:  MOVF   xC9,W
02084:  ADDWFC xC7,W
02086:  MOVWF  xCD
02088:  MOVFF  2C7,2CF
0208C:  MOVFF  2C6,2CE
02090:  MOVWF  xD1
02092:  MOVFF  2CC,2D0
02096:  MOVLB  0
02098:  GOTO   10EA
0209C:  MOVF   01,F
0209E:  BNZ   20C4
.................... 					    modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
020A0:  MOVFF  1B4,2CC
020A4:  MOVLB  2
020A6:  CLRF   xCE
020A8:  MOVFF  1B6,2CD
020AC:  MOVLW  02
020AE:  MOVWF  xCF
020B0:  MOVLB  0
020B2:  CALL   1206
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
020B6:  MOVLB  1
020B8:  CLRF   x87
020BA:  MOVLW  02
020BC:  MOVWF  x86
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
020BE:  CLRF   xAA
.................... 					} else { 
020C0:  BRA    20E0
020C2:  MOVLB  0
.................... 						modbus_read_register_response(modbus_rx.func,modbus_rx.address,start_addr,num_registers); 
020C4:  MOVFF  1B6,2CC
020C8:  MOVFF  1B4,2CD
020CC:  MOVFF  2C7,2CF
020D0:  MOVFF  2C6,2CE
020D4:  MOVFF  2C9,2D1
020D8:  MOVFF  2C8,2D0
020DC:  BRA    1CD4
020DE:  MOVLB  1
.................... 					} 
.................... 					break; 
020E0:  BRA    2236
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
020E2:  MOVFF  1B8,2C7
020E6:  MOVFF  1B9,2C6
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
020EA:  MOVFF  1BA,2CD
020EE:  MOVFF  1BB,2CC
020F2:  MOVFF  2C7,2D3
020F6:  MOVFF  2C6,2D2
020FA:  MOVFF  1BA,2D5
020FE:  MOVFF  1BB,2D4
02102:  RCALL  1D56
02104:  MOVFF  01,2CA
....................  
.................... 					if ( result ) { 
02108:  MOVLB  2
0210A:  MOVF   xCA,F
0210C:  BZ    2130
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
0210E:  MOVFF  1B4,2CC
02112:  CLRF   xCE
02114:  MOVFF  1B6,2CD
02118:  MOVFF  2CA,2CF
0211C:  MOVLB  0
0211E:  CALL   1206
.................... 						current.modbus_last_error=result; 
02122:  MOVLB  1
02124:  CLRF   x87
02126:  MOVFF  2CA,186
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timers.led_on_green=0; 
0212A:  CLRF   xAA
.................... 					}  else { 
0212C:  BRA    2152
0212E:  MOVLB  2
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(modbus_rx.address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
02130:  MOVFF  1BA,2CD
02134:  MOVFF  1BB,2CC
02138:  MOVFF  1B4,2CE
0213C:  MOVFF  2C7,2D0
02140:  MOVFF  2C6,2CF
02144:  MOVFF  1BA,2D2
02148:  MOVFF  1BB,2D1
0214C:  MOVLB  0
0214E:  BRA    1F90
02150:  MOVLB  1
.................... 					} 
.................... 					break; 
02152:  BRA    2236
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
02154:  MOVFF  1B8,2C7
02158:  MOVFF  1B9,2C6
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
0215C:  MOVFF  1BA,2C9
02160:  MOVFF  1BB,2C8
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
02164:  MOVLB  2
02166:  CLRF   xCB
02168:  MOVF   xC9,F
0216A:  BNZ   2172
0216C:  MOVF   xC8,W
0216E:  SUBWF  xCB,W
02170:  BC    21F6
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
02172:  MOVF   xCB,W
02174:  ADDWF  xC6,W
02176:  MOVWF  xCC
02178:  MOVLW  00
0217A:  ADDWFC xC7,W
0217C:  MOVWF  xCD
0217E:  BCF    FD8.0
02180:  RLCF   xCB,W
02182:  ADDLW  05
02184:  ADDLW  B8
02186:  MOVWF  FE9
02188:  MOVLW  01
0218A:  MOVWF  FEA
0218C:  BTFSC  FD8.0
0218E:  INCF   FEA,F
02190:  MOVFF  FEF,2CE
02194:  BCF    FD8.0
02196:  RLCF   xCB,W
02198:  ADDLW  06
0219A:  ADDLW  B8
0219C:  MOVWF  FE9
0219E:  MOVLW  01
021A0:  MOVWF  FEA
021A2:  BTFSC  FD8.0
021A4:  INCF   FEA,F
021A6:  MOVFF  FEF,2CF
021AA:  MOVFF  2CE,2D1
021AE:  MOVFF  2CF,2D0
021B2:  MOVFF  2CD,2D3
021B6:  MOVFF  2CC,2D2
021BA:  MOVFF  2CE,2D5
021BE:  MOVFF  2CF,2D4
021C2:  MOVLB  0
021C4:  RCALL  1D56
021C6:  MOVFF  01,2CA
....................  
.................... 						if ( result ) { 
021CA:  MOVLB  2
021CC:  MOVF   xCA,F
021CE:  BZ    21F2
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(modbus_rx.address,modbus_rx.func,result); 
021D0:  MOVFF  1B4,2CC
021D4:  CLRF   xCE
021D6:  MOVFF  1B6,2CD
021DA:  MOVFF  2CA,2CF
021DE:  MOVLB  0
021E0:  CALL   1206
.................... 							current.modbus_last_error=result; 
021E4:  MOVLB  1
021E6:  CLRF   x87
021E8:  MOVFF  2CA,186
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timers.led_on_green=0; 
021EC:  CLRF   xAA
.................... 			 
.................... 							break; 
021EE:  MOVLB  2
021F0:  BRA    21F6
.................... 						} 
.................... 					} 
021F2:  INCF   xCB,F
021F4:  BRA    2168
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
021F6:  MOVF   xCA,F
021F8:  BNZ   2212
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(modbus_rx.address,start_addr,num_registers); 
021FA:  MOVFF  1B4,2CC
021FE:  MOVFF  2C7,2CE
02202:  MOVFF  2C6,2CD
02206:  MOVFF  2C9,2D0
0220A:  MOVFF  2C8,2CF
0220E:  MOVLB  0
02210:  BRA    1FD8
.................... 					} 
....................  
.................... 					break;   
02212:  MOVLB  1
02214:  BRA    2236
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(modbus_rx.address,modbus_rx.func,ILLEGAL_FUNCTION); 
02216:  MOVFF  1B4,2CC
0221A:  MOVLB  2
0221C:  CLRF   xCE
0221E:  MOVFF  1B6,2CD
02222:  MOVLW  01
02224:  MOVWF  xCF
02226:  MOVLB  0
02228:  CALL   1206
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION; 
0222C:  MOVLB  1
0222E:  CLRF   x87
02230:  MOVLW  01
02232:  MOVWF  x86
....................  
.................... 					/* red led for 1 second */ 
.................... 					timers.led_on_green=0; 
02234:  CLRF   xAA
.................... 			} 
.................... 			/* reset watchdog seconds now that we are done processing request */ 
.................... 			current.watchdog_seconds=0; 
02236:  CLRF   x91
02238:  CLRF   x90
....................  
.................... 		} else { 
0223A:  BRA    2250
.................... 			/* MODBUS packet for somebody else */ 
.................... 			if ( current.modbus_other_packets < 65535 ) 
0223C:  INCFSZ x84,W
0223E:  BRA    2246
02240:  INCFSZ x85,W
02242:  BRA    2246
02244:  BRA    224C
.................... 				current.modbus_other_packets++; 
02246:  INCF   x84,F
02248:  BTFSC  FD8.2
0224A:  INCF   x85,F
....................  
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timers.led_on_green=20; 
0224C:  MOVLW  14
0224E:  MOVWF  xAA
02250:  MOVLB  0
.................... 		} 
....................  
.................... 	} 
.................... //	output_low(TP_RED); 
.................... } 
02252:  GOTO   24D8 (RETURN)
....................  
....................  
.................... #include "interrupt_pcwx.c" 
.................... /* HIGH priority interrupt will interrupt other interrupts. Compiler will 
.................... automatically save all registers ... which seems to incur about a 60 cycle 
.................... penalty  
....................  
.................... this ISR polls anemometers and counts between falling edges. 
.................... */ 
.................... #int_timer2 HIGH 
.................... void isr_100us(void) { 
.................... 	static int8 tick=0; 
....................  
.................... 	/* anemometer polling state variables */ 
.................... 	/* anemometer 0 / PIN_B0 */ 
.................... 	short ext0_count; 
.................... 	short ext0_now; 
.................... 	static short ext0_last=0; 
.................... 	static short ext0_state=0; 
....................  
.................... 	/* anemometer 1 / PIN_B1 */ 
.................... 	short ext1_count; 
.................... 	short ext1_now; 
.................... 	static short ext1_last=0; 
.................... 	static short ext1_state=0; 
....................  
.................... 	/* anemometer 2 / PIN_B2 */ 
.................... 	short ext2_count; 
.................... 	short ext2_now; 
.................... 	static short ext2_last=0; 
.................... 	static short ext2_state=0; 
....................  
.................... //	output_high(TP_RED); 
.................... 	 
.................... 	/* count time between falling edges */ 
.................... 	if ( ext0_count && 0xffff != timers.pulse_period[0] ) 
*
00480:  MOVLB  2
00482:  BTFSS  xE8.0
00484:  BRA    049E
00486:  MOVLB  1
00488:  INCFSZ x99,W
0048A:  BRA    0496
0048C:  INCFSZ x9A,W
0048E:  BRA    0496
00490:  MOVLB  2
00492:  BRA    049E
00494:  MOVLB  1
.................... 		timers.pulse_period[0]++; 
00496:  INCF   x99,F
00498:  BTFSC  FD8.2
0049A:  INCF   x9A,F
0049C:  MOVLB  2
.................... 	if ( ext1_count && 0xffff != timers.pulse_period[1] ) 
0049E:  BTFSS  xE8.2
004A0:  BRA    04BA
004A2:  MOVLB  1
004A4:  INCFSZ x9B,W
004A6:  BRA    04B2
004A8:  INCFSZ x9C,W
004AA:  BRA    04B2
004AC:  MOVLB  2
004AE:  BRA    04BA
004B0:  MOVLB  1
.................... 		timers.pulse_period[1]++; 
004B2:  INCF   x9B,F
004B4:  BTFSC  FD8.2
004B6:  INCF   x9C,F
004B8:  MOVLB  2
.................... 	if ( ext2_count && 0xffff != timers.pulse_period[2] ) 
004BA:  BTFSS  xE8.4
004BC:  BRA    04D6
004BE:  MOVLB  1
004C0:  INCFSZ x9D,W
004C2:  BRA    04CE
004C4:  INCFSZ x9E,W
004C6:  BRA    04CE
004C8:  MOVLB  2
004CA:  BRA    04D6
004CC:  MOVLB  1
.................... 		timers.pulse_period[2]++; 
004CE:  INCF   x9D,F
004D0:  BTFSC  FD8.2
004D2:  INCF   x9E,F
004D4:  MOVLB  2
....................  
.................... 	/* anemometer 0 / PIN_B0 trigger on falling edge */ 
.................... 	ext0_now=input(PIN_B0); 
004D6:  BCF    xE8.1
004D8:  BTFSC  F81.0
004DA:  BSF    xE8.1
.................... 	if ( 0 == ext0_now && 1 == ext0_last ) { 
004DC:  BTFSC  xE8.1
004DE:  BRA    0564
004E0:  MOVLB  1
004E2:  BTFSC  xB0.1
004E4:  BRA    04EA
004E6:  MOVLB  2
004E8:  BRA    0564
.................... 		current.pulse_count[0]++; 
004EA:  INCF   5F,F
004EC:  BTFSS  FD8.2
004EE:  BRA    04F6
004F0:  MOVLB  0
004F2:  INCF   x60,F
004F4:  MOVLB  1
.................... 		current.pulse_sum[0]++; 
004F6:  MOVLW  01
004F8:  MOVLB  0
004FA:  ADDWF  x65,F
004FC:  BTFSC  FD8.0
004FE:  INCF   x66,F
00500:  BTFSC  FD8.2
00502:  INCF   x67,F
00504:  BTFSC  FD8.2
00506:  INCF   x68,F
.................... 		if ( 1 == ext0_state ) { 
00508:  MOVLB  1
0050A:  BTFSS  xB0.2
0050C:  BRA    0554
.................... 			/* currently counting, time to finish */ 
.................... 			ext0_count=0; 
0050E:  MOVLB  2
00510:  BCF    xE8.0
.................... 			current.pulse_period[0]=timers.pulse_period[0]; 
00512:  MOVFF  19A,4E
00516:  MOVFF  199,4D
.................... 			if ( current.pulse_period[0] < current.pulse_min_period[0] ) { 
0051A:  MOVF   4E,W
0051C:  SUBWF  54,W
0051E:  BNC   0530
00520:  BNZ   0528
00522:  MOVF   53,W
00524:  SUBWF  4D,W
00526:  BC    0530
.................... 				current.pulse_min_period[0]=current.pulse_period[0]; 
00528:  MOVFF  4E,54
0052C:  MOVFF  4D,53
.................... 			} 
.................... 			if ( current.pulse_period[0] > current.pulse_max_period[0] && current.pulse_period[0] != 65535  ) { 
00530:  MOVF   5A,W
00532:  SUBWF  4E,W
00534:  BNC   0550
00536:  BNZ   053E
00538:  MOVF   4D,W
0053A:  SUBWF  59,W
0053C:  BC    0550
0053E:  INCFSZ 4D,W
00540:  BRA    0548
00542:  INCFSZ 4E,W
00544:  BRA    0548
00546:  BRA    0550
.................... 				current.pulse_max_period[0]=current.pulse_period[0]; 
00548:  MOVFF  4E,5A
0054C:  MOVFF  4D,59
.................... 			} 
.................... 			ext0_state=0; 
00550:  MOVLB  1
00552:  BCF    xB0.2
.................... 		} 
.................... 		if ( 0 == ext0_state ) { 
00554:  BTFSC  xB0.2
00556:  BRA    0564
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[0]=0; 
00558:  CLRF   x9A
0055A:  CLRF   x99
.................... 			ext0_count=1; 
0055C:  MOVLB  2
0055E:  BSF    xE8.0
.................... 			ext0_state=1; 
00560:  MOVLB  1
00562:  BSF    xB0.2
.................... 		} 
.................... 	} 
.................... 	ext0_last = ext0_now; 
00564:  MOVLB  1
00566:  BCF    xB0.1
00568:  MOVLB  2
0056A:  BTFSS  xE8.1
0056C:  BRA    0574
0056E:  MOVLB  1
00570:  BSF    xB0.1
00572:  MOVLB  2
....................  
.................... 	/* anemometer 1 / PIN_B1 trigger on falling edge */ 
.................... 	ext1_now=input(PIN_B1); 
00574:  BCF    xE8.3
00576:  BTFSC  F81.1
00578:  BSF    xE8.3
.................... 	if ( 0 == ext1_now && 1 == ext1_last ) { 
0057A:  BTFSC  xE8.3
0057C:  BRA    05FC
0057E:  MOVLB  1
00580:  BTFSC  xB0.3
00582:  BRA    0588
00584:  MOVLB  2
00586:  BRA    05FC
.................... 		current.pulse_count[1]++; 
00588:  MOVLB  0
0058A:  INCF   x61,F
0058C:  BTFSC  FD8.2
0058E:  INCF   x62,F
.................... 		current.pulse_sum[1]++; 
00590:  MOVLW  01
00592:  ADDWF  x69,F
00594:  BTFSC  FD8.0
00596:  INCF   x6A,F
00598:  BTFSC  FD8.2
0059A:  INCF   x6B,F
0059C:  BTFSC  FD8.2
0059E:  INCF   x6C,F
.................... 		if ( 1 == ext1_state ) { 
005A0:  MOVLB  1
005A2:  BTFSS  xB0.4
005A4:  BRA    05EC
.................... 			/* currently counting, time to finish */ 
.................... 			ext1_count=0; 
005A6:  MOVLB  2
005A8:  BCF    xE8.2
.................... 			current.pulse_period[1]=timers.pulse_period[1]; 
005AA:  MOVFF  19C,50
005AE:  MOVFF  19B,4F
.................... 			if ( current.pulse_period[1] < current.pulse_min_period[1] ) { 
005B2:  MOVF   50,W
005B4:  SUBWF  56,W
005B6:  BNC   05C8
005B8:  BNZ   05C0
005BA:  MOVF   55,W
005BC:  SUBWF  4F,W
005BE:  BC    05C8
.................... 				current.pulse_min_period[1]=current.pulse_period[1]; 
005C0:  MOVFF  50,56
005C4:  MOVFF  4F,55
.................... 			} 
.................... 			if ( current.pulse_period[1] > current.pulse_max_period[1] && current.pulse_period[1] != 65535 ) { 
005C8:  MOVF   5C,W
005CA:  SUBWF  50,W
005CC:  BNC   05E8
005CE:  BNZ   05D6
005D0:  MOVF   4F,W
005D2:  SUBWF  5B,W
005D4:  BC    05E8
005D6:  INCFSZ 4F,W
005D8:  BRA    05E0
005DA:  INCFSZ 50,W
005DC:  BRA    05E0
005DE:  BRA    05E8
.................... 				current.pulse_max_period[1]=current.pulse_period[1]; 
005E0:  MOVFF  50,5C
005E4:  MOVFF  4F,5B
.................... 			} 
.................... 			ext1_state=0; 
005E8:  MOVLB  1
005EA:  BCF    xB0.4
.................... 		} 
.................... 		if ( 0 == ext1_state ) { 
005EC:  BTFSC  xB0.4
005EE:  BRA    05FC
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[1]=0; 
005F0:  CLRF   x9C
005F2:  CLRF   x9B
.................... 			ext1_count=1; 
005F4:  MOVLB  2
005F6:  BSF    xE8.2
.................... 			ext1_state=1; 
005F8:  MOVLB  1
005FA:  BSF    xB0.4
.................... 		} 
.................... 	} 
.................... 	ext1_last = ext1_now; 
005FC:  MOVLB  1
005FE:  BCF    xB0.3
00600:  MOVLB  2
00602:  BTFSS  xE8.3
00604:  BRA    060C
00606:  MOVLB  1
00608:  BSF    xB0.3
0060A:  MOVLB  2
....................  
.................... 	/* anemometer 2 / PIN_B2 trigger on falling edge */ 
.................... 	ext2_now=input(PIN_B2); 
0060C:  BCF    xE8.5
0060E:  BTFSC  F81.2
00610:  BSF    xE8.5
.................... 	if ( 0 == ext2_now && 1 == ext2_last ) { 
00612:  BTFSC  xE8.5
00614:  BRA    0694
00616:  MOVLB  1
00618:  BTFSC  xB0.5
0061A:  BRA    0620
0061C:  MOVLB  2
0061E:  BRA    0694
.................... 		current.pulse_count[2]++; 
00620:  MOVLB  0
00622:  INCF   x63,F
00624:  BTFSC  FD8.2
00626:  INCF   x64,F
.................... 		current.pulse_sum[2]++; 
00628:  MOVLW  01
0062A:  ADDWF  x6D,F
0062C:  BTFSC  FD8.0
0062E:  INCF   x6E,F
00630:  BTFSC  FD8.2
00632:  INCF   x6F,F
00634:  BTFSC  FD8.2
00636:  INCF   x70,F
.................... 		if ( 1 == ext2_state ) { 
00638:  MOVLB  1
0063A:  BTFSS  xB0.6
0063C:  BRA    0684
.................... 			/* currently counting, time to finish */ 
.................... 			ext2_count=0; 
0063E:  MOVLB  2
00640:  BCF    xE8.4
.................... 			current.pulse_period[2]=timers.pulse_period[2]; 
00642:  MOVFF  19E,52
00646:  MOVFF  19D,51
.................... 			if ( current.pulse_period[2] < current.pulse_min_period[2] ) { 
0064A:  MOVF   52,W
0064C:  SUBWF  58,W
0064E:  BNC   0660
00650:  BNZ   0658
00652:  MOVF   57,W
00654:  SUBWF  51,W
00656:  BC    0660
.................... 				current.pulse_min_period[2]=current.pulse_period[2]; 
00658:  MOVFF  52,58
0065C:  MOVFF  51,57
.................... 			} 
.................... 			if ( current.pulse_period[2] > current.pulse_max_period[2] && current.pulse_period[2] != 65535 ) { 
00660:  MOVF   5E,W
00662:  SUBWF  52,W
00664:  BNC   0680
00666:  BNZ   066E
00668:  MOVF   51,W
0066A:  SUBWF  5D,W
0066C:  BC    0680
0066E:  INCFSZ 51,W
00670:  BRA    0678
00672:  INCFSZ 52,W
00674:  BRA    0678
00676:  BRA    0680
.................... 				current.pulse_max_period[2]=current.pulse_period[2]; 
00678:  MOVFF  52,5E
0067C:  MOVFF  51,5D
.................... 			} 
.................... 			ext2_state=0; 
00680:  MOVLB  1
00682:  BCF    xB0.6
.................... 		} 
.................... 		if ( 0 == ext2_state ) { 
00684:  BTFSC  xB0.6
00686:  BRA    0694
.................... 			/* not counting, time to start */ 
.................... 			timers.pulse_period[2]=0; 
00688:  CLRF   x9E
0068A:  CLRF   x9D
.................... 			ext2_count=1; 
0068C:  MOVLB  2
0068E:  BSF    xE8.4
.................... 			ext2_state=1; 
00690:  MOVLB  1
00692:  BSF    xB0.6
.................... 		} 
.................... 	} 
.................... 	ext2_last = ext2_now; 
00694:  MOVLB  1
00696:  BCF    xB0.5
00698:  MOVLB  2
0069A:  BTFSS  xE8.5
0069C:  BRA    06A4
0069E:  MOVLB  1
006A0:  BSF    xB0.5
006A2:  MOVLB  2
....................  
....................  
.................... 	/* every 10 cycles we tell main() loop to do milisecond activities */ 
.................... 	tick++; 
006A4:  INCF   xBB,F
.................... 	if ( 10 == tick ) { 
006A6:  MOVF   xBB,W
006A8:  SUBLW  0A
006AA:  BNZ   06B4
.................... 		tick=0; 
006AC:  CLRF   xBB
.................... 		timers.now_millisecond=1; 
006AE:  MOVLB  1
006B0:  BSF    xAD.2
006B2:  MOVLB  2
.................... 	} 
....................  
.................... //	output_low(TP_RED); 
.................... } 
....................  
.................... /*  Raspberry PI connected serial port*/ 
006B4:  BCF    F9E.1
006B6:  MOVLB  0
006B8:  GOTO   0122
.................... #int_rda 
.................... void isr_rda() { 
.................... 	int8 c; 
....................  
.................... 	c=fgetc(MODBUS_SERIAL); 
*
00708:  RCALL  06BC
0070A:  MOVFF  01,2E5
....................  
.................... 	if ( current.bridged_uarts ) { 
0070E:  MOVLB  1
00710:  BTFSS  x8F.0
00712:  BRA    0720
.................... 		/* from PI to debugging cable */ 
.................... 		fputc(c,DEBUG); 
00714:  MOVLB  2
00716:  MOVF   xE5,W
00718:  MOVLB  0
0071A:  BRA    06D2
.................... 		return; 
0071C:  BRA    0778
0071E:  MOVLB  1
.................... 	}  
....................  
....................  
.................... 	/* Modbus */ 
.................... 	if (!modbus_serial_new) { 
00720:  BTFSC  xB0.0
00722:  BRA    077A
.................... 		if(modbus_serial_state == MODBUS_GETADDY) { 
00724:  MOVF   xB1,F
00726:  BNZ   0738
.................... 			modbus_serial_crc.d = 0xFFFF; 
00728:  SETF   xB3
0072A:  SETF   xB2
.................... 			modbus_rx.address = c; 
0072C:  MOVFF  2E5,1B4
.................... 			modbus_serial_state++; 
00730:  INCF   xB1,F
.................... 			modbus_rx.len = 0; 
00732:  CLRF   xB5
.................... 			modbus_rx.error=0; 
00734:  CLRF   xB7
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) { 
00736:  BRA    0766
00738:  DECFSZ xB1,W
0073A:  BRA    0744
.................... 			modbus_rx.func = c; 
0073C:  MOVFF  2E5,1B6
.................... 			modbus_serial_state++; 
00740:  INCF   xB1,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) { 
00742:  BRA    0766
00744:  MOVF   xB1,W
00746:  SUBLW  02
00748:  BNZ   0766
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0074A:  INCFSZ xB5,W
0074C:  BRA    0752
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
0074E:  MOVLW  FE
00750:  MOVWF  xB5
.................... 			} 
.................... 			modbus_rx.data[modbus_rx.len]=c; 
00752:  MOVLW  B8
00754:  ADDWF  xB5,W
00756:  MOVWF  FE9
00758:  MOVLW  01
0075A:  MOVWF  FEA
0075C:  BTFSC  FD8.0
0075E:  INCF   FEA,F
00760:  MOVFF  2E5,FEF
.................... 			modbus_rx.len++; 
00764:  INCF   xB5,F
.................... 		} 
....................  
.................... 		modbus_calc_crc(c); 
00766:  MOVFF  2E5,2E6
0076A:  MOVLB  0
0076C:  RCALL  06DC
.................... 		modbus_enable_timeout(TRUE); 
0076E:  MOVLW  01
00770:  MOVLB  2
00772:  MOVWF  xE6
00774:  MOVLB  0
00776:  RCALL  043A
00778:  MOVLB  1
.................... 	} 
.................... } 
....................  
....................  
....................  
0077A:  BCF    F9E.5
0077C:  MOVLB  0
0077E:  GOTO   007C
.................... void init() { 
.................... 	int8 i; 
....................  
.................... //	setup_adc_ports(AN0_TO_AN7,VSS_VREF); 
.................... //	setup_adc(ADC_CLOCK_DIV_16 | ADC_TAD_MUL_20 ); 
....................  
.................... 	setup_adc(ADC_OFF); 
*
008F0:  BCF    FC2.0
....................  
.................... 	port_b_pullups(0b00001000); 
008F2:  MOVLW  08
008F4:  MOVWF  F61
008F6:  BCF    FF1.7
....................  
.................... 	set_tris_a(0b00000000); 
008F8:  MOVLW  00
008FA:  MOVWF  F92
.................... 	set_tris_b(0b11111111); 
008FC:  MOVLW  FF
008FE:  MOVWF  F93
.................... 	set_tris_c(0b10010010); 
00900:  MOVLW  92
00902:  MOVWF  F94
.................... 	set_tris_d(0b10000000);  
00904:  MOVLW  80
00906:  MOVWF  F95
.................... 	set_tris_e(0b00000000); 
00908:  BCF    F96.0
0090A:  BCF    F96.1
0090C:  BCF    F96.2
0090E:  BCF    F96.3
....................  
....................  
.................... 	/* data structure initialization */ 
.................... 	timers.led_on_green=0; 
00910:  MOVLB  1
00912:  CLRF   xAA
.................... 	timers.load_off_seconds=2; 
00914:  CLRF   xAC
00916:  MOVLW  02
00918:  MOVWF  xAB
.................... 	timers.now_adc_sample=0; 
0091A:  BCF    xAD.0
.................... 	timers.now_adc_reset_count=0; 
0091C:  BCF    xAD.1
.................... 	timers.now_millisecond=0; 
0091E:  BCF    xAD.2
.................... 	timers.port_b=0b11111111; 
00920:  SETF   xAE
.................... 	timers.port_c=0b11111111; 
00922:  SETF   xAF
....................  
.................... 	for ( i=0 ; i<3 ; i++ ) { 
00924:  MOVLB  2
00926:  CLRF   xC6
00928:  MOVF   xC6,W
0092A:  SUBLW  02
0092C:  BNC   09DA
.................... 		current.pulse_period[i]=0; 
0092E:  CLRF   03
00930:  MOVFF  2C6,02
00934:  BCF    FD8.0
00936:  RLCF   02,F
00938:  RLCF   03,F
0093A:  MOVF   02,W
0093C:  ADDLW  4D
0093E:  MOVWF  FE9
00940:  MOVLW  00
00942:  ADDWFC 03,W
00944:  MOVWF  FEA
00946:  CLRF   FEC
00948:  MOVF   FED,F
0094A:  CLRF   FEF
.................... 		current.pulse_min_period[i]=65535; 
0094C:  CLRF   03
0094E:  MOVFF  2C6,02
00952:  BCF    FD8.0
00954:  RLCF   02,F
00956:  RLCF   03,F
00958:  MOVF   02,W
0095A:  ADDLW  53
0095C:  MOVWF  FE9
0095E:  MOVLW  00
00960:  ADDWFC 03,W
00962:  MOVWF  FEA
00964:  SETF   FEC
00966:  MOVF   FED,F
00968:  SETF   FEF
.................... 		current.pulse_max_period[i]=0; 
0096A:  CLRF   03
0096C:  MOVFF  2C6,02
00970:  BCF    FD8.0
00972:  RLCF   02,F
00974:  RLCF   03,F
00976:  MOVF   02,W
00978:  ADDLW  59
0097A:  MOVWF  FE9
0097C:  MOVLW  00
0097E:  ADDWFC 03,W
00980:  MOVWF  FEA
00982:  CLRF   FEC
00984:  MOVF   FED,F
00986:  CLRF   FEF
.................... 		current.pulse_count[i]=0; 
00988:  CLRF   03
0098A:  MOVFF  2C6,02
0098E:  BCF    FD8.0
00990:  RLCF   02,F
00992:  RLCF   03,F
00994:  MOVF   02,W
00996:  ADDLW  5F
00998:  MOVWF  FE9
0099A:  MOVLW  00
0099C:  ADDWFC 03,W
0099E:  MOVWF  FEA
009A0:  CLRF   FEC
009A2:  MOVF   FED,F
009A4:  CLRF   FEF
.................... 		current.pulse_sum[i]=0; 
009A6:  CLRF   xE1
009A8:  MOVFF  2C6,2E0
009AC:  CLRF   xE3
009AE:  MOVLW  04
009B0:  MOVWF  xE2
009B2:  MOVLB  0
009B4:  RCALL  08CE
009B6:  MOVF   01,W
009B8:  ADDLW  65
009BA:  MOVWF  FE9
009BC:  MOVLW  00
009BE:  ADDWFC 02,W
009C0:  MOVWF  FEA
009C2:  MOVF   FEE,F
009C4:  MOVF   FEE,F
009C6:  CLRF   FEC
009C8:  MOVF   FED,F
009CA:  CLRF   FEF
009CC:  MOVF   FED,F
009CE:  CLRF   FEF
009D0:  MOVF   FED,F
009D2:  CLRF   FEF
.................... 	} 
009D4:  MOVLB  2
009D6:  INCF   xC6,F
009D8:  BRA    0928
....................  
.................... 	current.modbus_our_packets=0; 
009DA:  MOVLB  1
009DC:  CLRF   x83
009DE:  CLRF   x82
.................... 	current.modbus_other_packets=0; 
009E0:  CLRF   x85
009E2:  CLRF   x84
.................... 	current.modbus_last_error=0; 
009E4:  CLRF   x87
009E6:  CLRF   x86
.................... 	current.sequence_number=0; 
009E8:  CLRF   x89
009EA:  CLRF   x88
.................... 	current.uptime_minutes=0; 
009EC:  CLRF   x8B
009EE:  CLRF   x8A
.................... 	current.interval_milliseconds=0; 
009F0:  CLRF   x8D
009F2:  CLRF   x8C
.................... 	current.adc_buffer_index=0; 
009F4:  CLRF   x81
.................... 	current.factory_unlocked=0; 
009F6:  CLRF   x8E
.................... 	current.bridged_uarts=0; 
009F8:  BCF    x8F.0
.................... 	current.watchdog_seconds=0; 
009FA:  CLRF   x91
009FC:  CLRF   x90
....................  
....................  
.................... 	/* power control switch */ 
.................... 	current.power_on_delay=config.power_on_above_delay; 
009FE:  MOVFF  4A,194
00A02:  MOVFF  49,193
.................... 	current.power_off_delay=config.power_off_below_delay; 
00A06:  MOVFF  46,196
00A0A:  MOVFF  45,195
.................... 	current.power_override_timeout=0; 
00A0E:  CLRF   x98
00A10:  CLRF   x97
....................  
....................  
.................... 	/* interrupts */ 
....................  
.................... 	/* external interrupts for anemometers */ 
.................... 	ext_int_edge(0,H_TO_L); 
00A12:  BCF    FF1.6
.................... //	enable_interrupts(INT_EXT); 
.................... 	ext_int_edge(1,H_TO_L); 
00A14:  BCF    FF1.5
.................... //	enable_interrupts(INT_EXT1); 
.................... 	ext_int_edge(2,H_TO_L); 
00A16:  BCF    FF1.4
.................... //	enable_interrupts(INT_EXT2); 
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from internal 16 MHz clock */ 
.................... 	/* prescale=16, match=24, postscale=1. Match is 24 because when match occurs, one cycle is lost */ 
.................... 	// setup_timer_2(T2_DIV_BY_16,24,1);  
....................  
.................... 	/* one periodic interrupt @ 100uS. Generated from system 12 MHz clock */ 
.................... 	/* prescale=4, match=74, postscale=1. Match is 74 because when match occurs, one cycle is lost */ 
.................... 	setup_timer_2(T2_DIV_BY_4,74,1); 
00A18:  MOVLW  00
00A1A:  IORLW  05
00A1C:  MOVWF  FBA
00A1E:  MOVLW  4A
00A20:  MOVWF  FBB
....................  
.................... 	enable_interrupts(INT_TIMER2); 
00A22:  BSF    F9D.1
.................... //	enable_interrupts(INT_RDA2); /* debug cable */ 
.................... 	/* RDA - PI is turned on in modbus_slave_pcwx's init */ 
.................... } 
00A24:  MOVLB  0
00A26:  GOTO   22F6 (RETURN)
....................  
....................  
.................... void periodic_millisecond(void) { 
.................... 	static int8 uptimeticks=0; 
.................... 	static int16 adcTicks=0; 
.................... 	static int16 ticks=0; 
.................... 	/* button debouncing */ 
.................... //	static int16 b0_state=0; /* bridge push button */ 
.................... //	static int16 b1_state=0; /* reset line from PI */ 
.................... 	static int16 b2_state=0; /* watchdog line from PI */ 
.................... 	/* power control */ 
.................... 	static int16 adcValue; /* updates after each ADC sample run */ 
....................  
.................... 	timers.now_millisecond=0; 
*
00F64:  MOVLB  1
00F66:  BCF    xAD.2
....................  
.................... //	fputc('.',DEBUG); 
....................  
.................... #if 0 
.................... 	/* button must be down for 12 milliseconds */ 
.................... 	b0_state=(b0_state<<1) | !bit_test(timers.port_b,BUTTON_BIT) | 0xe000; 
.................... 	if ( b0_state==0xf000) { 
.................... 		/* button pressed */ 
.................... 		current.bridged_uarts = !current.bridged_uarts; 
.................... 		fprintf(DEBUG,"# bridged=%u\r\n",current.bridged_uarts); 
.................... 	} 
....................  
.................... 	/* if we are in bridged uarts ... only check for button press */ 
.................... 	if ( current.bridged_uarts ) { 
.................... 		return; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* reset must be down for 12 milliseconds */ 
.................... 	b1_state=(b1_state<<1) | !bit_test(timers.port_c,PIC_BOOTLOAD_REQUEST_BIT) | 0xe000; 
.................... 	if ( b1_state==0xf000) { 
.................... 		/* reset line asserted */ 
.................... 		if ( config.allow_bootload_request ) { 
.................... 			reset_cpu(); 
.................... 		} 
.................... 		/* BUG - I think that bootload request should be high for x milliseconds, rather than low */ 
.................... 	} 
.................... #endif 
....................  
.................... 	/* watchdog must be down for 12 milliseconds for hit to register */ 
.................... 	b2_state=(b2_state<<1) | !bit_test(timers.port_c,WATCHDOG_FROM_PI_BIT) | 0xe000; 
00F68:  BCF    FD8.0
00F6A:  MOVLB  2
00F6C:  RLCF   xC1,W
00F6E:  MOVWF  xC6
00F70:  RLCF   xC2,W
00F72:  MOVWF  xC7
00F74:  MOVLW  00
00F76:  MOVLB  1
00F78:  BTFSS  xAF.5
00F7A:  MOVLW  01
00F7C:  MOVLB  2
00F7E:  IORWF  xC6,F
00F80:  MOVFF  2C6,2C1
00F84:  MOVF   xC7,W
00F86:  IORLW  E0
00F88:  MOVWF  xC2
.................... 	if ( b2_state==0xf000) { 
00F8A:  MOVF   xC1,F
00F8C:  BNZ   0F94
00F8E:  MOVF   xC2,W
00F90:  SUBLW  F0
00F92:  BNZ   0F94
.................... 		/* watchdog hit */ 
.................... //		current.watchdog_seconds=0; 
.................... 	} 
....................  
.................... 	/* anemometers quit moving */ 
.................... 	if ( 0xffff == timers.pulse_period[0] ) 
00F94:  MOVLB  1
00F96:  INCFSZ x99,W
00F98:  BRA    0FA2
00F9A:  INCFSZ x9A,W
00F9C:  BRA    0FA2
.................... 				current.pulse_period[0]=0; 
00F9E:  CLRF   4E
00FA0:  CLRF   4D
.................... 	if ( 0xffff == timers.pulse_period[1] ) 
00FA2:  INCFSZ x9B,W
00FA4:  BRA    0FAE
00FA6:  INCFSZ x9C,W
00FA8:  BRA    0FAE
.................... 				current.pulse_period[1]=0; 
00FAA:  CLRF   50
00FAC:  CLRF   4F
.................... 	if ( 0xffff == timers.pulse_period[2] ) 
00FAE:  INCFSZ x9D,W
00FB0:  BRA    0FBA
00FB2:  INCFSZ x9E,W
00FB4:  BRA    0FBA
.................... 				current.pulse_period[2]=0; 
00FB6:  CLRF   52
00FB8:  CLRF   51
....................  
....................  
.................... 	/* read port_b and c pin states */ 
.................... 	timers.port_b=port_b; 
00FBA:  MOVFF  F81,1AE
.................... 	timers.port_c=port_c; 
00FBE:  MOVFF  F82,1AF
....................  
.................... 	/* green LED control */ 
.................... 	if ( current.bridged_uarts ) { 
00FC2:  BTFSS  x8F.0
00FC4:  BRA    0FCA
.................... 		/* always on when ports are bridged */ 
.................... 		output_high(LED_GREEN); 
00FC6:  BSF    F89.3
.................... 	} else { 
00FC8:  BRA    0FD6
.................... 		/* green LED in Modbus mode */ 
.................... 		if ( 0==timers.led_on_green ) { 
00FCA:  MOVF   xAA,F
00FCC:  BNZ   0FD2
.................... 			output_low(LED_GREEN); 
00FCE:  BCF    F89.3
.................... 		} else { 
00FD0:  BRA    0FD6
.................... 			output_high(LED_GREEN); 
00FD2:  BSF    F89.3
.................... 			timers.led_on_green--; 
00FD4:  DECF   xAA,F
.................... 		} 
.................... 	} 
....................  
....................  
....................  
....................  
.................... 	/* some other random stuff that we don't need to do every cycle in main */ 
.................... 	if ( current.interval_milliseconds < 65535 ) { 
00FD6:  INCFSZ x8C,W
00FD8:  BRA    0FE0
00FDA:  INCFSZ x8D,W
00FDC:  BRA    0FE0
00FDE:  BRA    0FE6
.................... 		current.interval_milliseconds++; 
00FE0:  INCF   x8C,F
00FE2:  BTFSC  FD8.2
00FE4:  INCF   x8D,F
.................... 	} 
....................  
.................... 	/* seconds */ 
.................... 	ticks++; 
00FE6:  MOVLB  2
00FE8:  INCF   xBF,F
00FEA:  BTFSC  FD8.2
00FEC:  INCF   xC0,F
.................... 	if ( 1000 == ticks ) { 
00FEE:  MOVF   xBF,W
00FF0:  SUBLW  E8
00FF2:  BNZ   1078
00FF4:  MOVF   xC0,W
00FF6:  SUBLW  03
00FF8:  BNZ   1078
.................... 		ticks=0; 
00FFA:  CLRF   xC0
00FFC:  CLRF   xBF
....................  
.................... 		/* watchdog power control of pi */ 
.................... 		if ( current.watchdog_seconds != 65535 ) { 
00FFE:  MOVLB  1
01000:  INCFSZ x90,W
01002:  BRA    100A
01004:  INCFSZ x91,W
01006:  BRA    100A
01008:  BRA    1010
.................... 			current.watchdog_seconds++; 
0100A:  INCF   x90,F
0100C:  BTFSC  FD8.2
0100E:  INCF   x91,F
.................... 		} 
....................  
.................... 		/* shut off when: 
.................... 			a) watchdog_seconds_max != 0 AND watchdog_seconds is greater than watchdog_seconds_max AND it isn't already off  
.................... 		*/ 
.................... 		if ( 0 != config.watchdog_seconds_max && current.watchdog_seconds > config.watchdog_seconds_max && 0 == timers.load_off_seconds ) { 
01010:  MOVF   3E,F
01012:  BNZ   1018
01014:  MOVF   3F,F
01016:  BZ    1036
01018:  MOVF   3F,W
0101A:  SUBWF  x91,W
0101C:  BNC   1036
0101E:  BNZ   1026
01020:  MOVF   x90,W
01022:  SUBWF  3E,W
01024:  BC    1036
01026:  MOVF   xAB,F
01028:  BNZ   1036
0102A:  MOVF   xAC,F
0102C:  BNZ   1036
.................... 			timers.load_off_seconds=config.pi_offtime_seconds; 
0102E:  MOVFF  41,1AC
01032:  MOVFF  40,1AB
.................... 		} 
....................  
.................... 		/* control power to the raspberrry pi load */ 
.................... 		if ( 0==timers.load_off_seconds ) { 
01036:  MOVF   xAB,F
01038:  BNZ   1042
0103A:  MOVF   xAC,F
0103C:  BNZ   1042
.................... 			output_high(PI_POWER_EN); 
0103E:  BSF    F8B.0
.................... 		} else { 
01040:  BRA    1058
.................... 			output_low(PI_POWER_EN); 
01042:  BCF    F8B.0
.................... 			timers.load_off_seconds--; 
01044:  MOVF   xAB,W
01046:  BTFSC  FD8.2
01048:  DECF   xAC,F
0104A:  DECF   xAB,F
....................  
.................... 			if ( 0 == timers.load_off_seconds ) { 
0104C:  MOVF   xAB,F
0104E:  BNZ   1058
01050:  MOVF   xAC,F
01052:  BNZ   1058
.................... 				/* reset watchdog seconds so we can turn back on */ 
.................... 				current.watchdog_seconds=0; 
01054:  CLRF   x91
01056:  CLRF   x90
.................... 			} 
.................... 		} 
....................  
.................... 		 
.................... 		/* uptime counter */ 
.................... 		uptimeTicks++; 
01058:  MOVLB  2
0105A:  INCF   xBC,F
.................... 		if ( 60 == uptimeTicks ) { 
0105C:  MOVF   xBC,W
0105E:  SUBLW  3C
01060:  BNZ   1078
.................... 			uptimeTicks=0; 
01062:  CLRF   xBC
.................... 			if ( current.uptime_minutes < 65535 )  
01064:  MOVLB  1
01066:  INCFSZ x8A,W
01068:  BRA    1070
0106A:  INCFSZ x8B,W
0106C:  BRA    1070
0106E:  BRA    1076
.................... 				current.uptime_minutes++; 
01070:  INCF   x8A,F
01072:  BTFSC  FD8.2
01074:  INCF   x8B,F
01076:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
....................  
.................... 	if ( 65535 == adcValue ) { 
01078:  INCFSZ xC3,W
0107A:  BRA    108E
0107C:  INCFSZ xC4,W
0107E:  BRA    108E
.................... 		/* signaled that a new ADC sample was taken and we need to run again */ 
.................... 		/* read current ADC value */	 
.................... 		adcValue=adc_get(0); 
01080:  CLRF   xDA
01082:  MOVLB  0
01084:  RCALL  0EDC
01086:  MOVFF  02,2C4
0108A:  MOVFF  01,2C3
.................... 	} 
....................  
.................... #if 0 
.................... 	if ( adcValue > config.power_on_above_adc ) { 
.................... 		if ( current.power_on_delay > 0 ) { 
.................... 			current.power_on_delay--; 
.................... 		} else { 
.................... 			current.p_on=1; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_on_delay=config.power_on_above_delay; 
.................... 	} 
.................... 			 
....................  
.................... 	if ( adcValue < config.power_off_below_adc ) { 
.................... 		if ( current.power_off_delay > 0 ) { 
.................... 			current.power_off_delay--; 
.................... 		} else { 
.................... 			current.p_on=0; 
.................... 		} 
.................... 	} else { 
.................... 		current.power_off_delay=config.power_off_below_delay; 
.................... 	} 
.................... #endif	 
....................  
.................... 	/* ADC sample counter */ 
.................... 	if ( timers.now_adc_reset_count ) { 
0108E:  MOVLB  1
01090:  BTFSS  xAD.1
01092:  BRA    109C
.................... 		timers.now_adc_reset_count=0; 
01094:  BCF    xAD.1
.................... 		adcTicks=0; 
01096:  MOVLB  2
01098:  CLRF   xBE
0109A:  CLRF   xBD
.................... 	} 
....................  
.................... 	/* ADC sampling trigger */ 
.................... 	adcTicks++; 
0109C:  MOVLB  2
0109E:  INCF   xBD,F
010A0:  BTFSC  FD8.2
010A2:  INCF   xBE,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) { 
010A4:  MOVF   3B,W
010A6:  SUBWF  xBD,W
010A8:  BNZ   10BE
010AA:  MOVF   3C,W
010AC:  SUBWF  xBE,W
010AE:  BNZ   10BE
.................... 		adcTicks=0; 
010B0:  CLRF   xBE
010B2:  CLRF   xBD
.................... 		timers.now_adc_sample=1; 
010B4:  MOVLB  1
010B6:  BSF    xAD.0
.................... 		adcValue=65535; /* signal power control (above) on next pass to resample */ 
010B8:  MOVLB  2
010BA:  SETF   xC4
010BC:  SETF   xC3
.................... 	} 
....................  
....................  
....................  
.................... } 
010BE:  MOVLB  0
010C0:  GOTO   24C6 (RETURN)
....................  
....................  
.................... void main(void) { 
*
02256:  CLRF   FF8
02258:  BCF    FF1.2
0225A:  BSF    F9F.1
0225C:  BCF    F9F.5
0225E:  BSF    FD0.7
02260:  BSF    07.7
02262:  CLRF   FEA
02264:  CLRF   FE9
02266:  CLRF   35
02268:  BCF    FB8.3
0226A:  MOVLW  0C
0226C:  MOVWF  FAF
0226E:  MOVLW  A6
02270:  MOVWF  FAC
02272:  MOVLW  90
02274:  MOVWF  FAB
02276:  BCF    F70.3
02278:  MOVLW  4D
0227A:  MOVWF  F75
0227C:  MOVLW  A6
0227E:  MOVWF  F72
02280:  MOVLW  90
02282:  MOVWF  F71
02284:  MOVLB  1
02286:  BCF    xB0.0
02288:  CLRF   xB1
0228A:  MOVLB  2
0228C:  CLRF   xBB
0228E:  MOVLB  1
02290:  BCF    xB0.1
02292:  BCF    xB0.2
02294:  BCF    xB0.3
02296:  BCF    xB0.4
02298:  BCF    xB0.5
0229A:  BCF    xB0.6
0229C:  MOVLB  2
0229E:  CLRF   xBC
022A0:  CLRF   xBE
022A2:  CLRF   xBD
022A4:  CLRF   xC0
022A6:  CLRF   xBF
022A8:  CLRF   xC2
022AA:  CLRF   xC1
022AC:  MOVF   FC1,W
022AE:  ANDLW  F0
022B0:  MOVWF  FC1
022B2:  MOVLW  00
022B4:  MOVLB  F
022B6:  MOVWF  x38
022B8:  MOVWF  x3C
022BA:  MOVWF  x39
022BC:  MOVWF  x3A
022BE:  MOVWF  x3B
022C0:  MOVLB  1
022C2:  CLRF   x88
022C4:  CLRF   F77
022C6:  CLRF   F78
022C8:  CLRF   F79
022CA:  CLRF   2F
022CC:  CLRF   30
022CE:  MOVLB  2
022D0:  CLRF   xB7
022D2:  CLRF   xB8
022D4:  CLRF   xB9
022D6:  CLRF   xBA
022D8:  CLRF   xC3
022DA:  CLRF   xC4
.................... 	int8 i; 
....................  
.................... 	i=restart_cause(); 
022DC:  MOVF   FD0,W
022DE:  ANDLW  0F
022E0:  BTFSS  FD0.4
022E2:  MOVLW  00
022E4:  BSF    FD0.0
022E6:  BSF    FD0.1
022E8:  BSF    FD0.4
022EA:  BSF    FD8.3
022EC:  BSF    FD8.4
022EE:  MOVWF  xC5
....................  
.................... 	init(); 
022F0:  MOVLB  0
022F2:  GOTO   08F0
....................  
....................  
.................... 	/* debugging messages sent on RS-485 port ... so we will start transmitting */ 
.................... 	output_high(RS485_DE); 
022F6:  BSF    F8C.1
.................... 	output_high(RS485_NRE); 
022F8:  BSF    F8C.0
....................  
.................... 	fprintf(DEBUG,"# pcwx %s\r\n",__DATE__); 
022FA:  MOVLW  82
022FC:  MOVWF  FF6
022FE:  MOVLW  07
02300:  MOVWF  FF7
02302:  MOVLW  07
02304:  MOVLB  2
02306:  MOVWF  xC7
02308:  MOVLB  0
0230A:  CALL   0A2A
0230E:  MOVLW  8E
02310:  MOVWF  FF6
02312:  MOVLW  07
02314:  MOVWF  FF7
02316:  CALL   0A54
0231A:  MOVLW  0D
0231C:  BTFSS  FA4.4
0231E:  BRA    231C
02320:  MOVWF  F73
02322:  MOVLW  0A
02324:  BTFSS  FA4.4
02326:  BRA    2324
02328:  MOVWF  F73
.................... 	fprintf(DEBUG,"# restart_cause()=%u ",i); 
0232A:  MOVLW  98
0232C:  MOVWF  FF6
0232E:  MOVLW  07
02330:  MOVWF  FF7
02332:  MOVLW  12
02334:  MOVLB  2
02336:  MOVWF  xC7
02338:  MOVLB  0
0233A:  CALL   0A2A
0233E:  MOVFF  2C5,2C7
02342:  MOVLW  1B
02344:  MOVLB  2
02346:  MOVWF  xC8
02348:  MOVLB  0
0234A:  CALL   0AA2
0234E:  MOVLW  20
02350:  BTFSS  FA4.4
02352:  BRA    2350
02354:  MOVWF  F73
.................... 	switch ( i ) { 
02356:  MOVLB  2
02358:  MOVF   xC5,W
0235A:  XORLW  07
0235C:  MOVLB  0
0235E:  BZ    237A
02360:  XORLW  0C
02362:  BZ    2388
02364:  XORLW  04
02366:  BZ    2396
02368:  XORLW  03
0236A:  BZ    23A4
0236C:  XORLW  02
0236E:  BZ    23B2
02370:  XORLW  0D
02372:  BZ    23C0
02374:  XORLW  03
02376:  BZ    23CE
02378:  BRA    23DC
.................... 		case WDT_TIMEOUT: fprintf(DEBUG,"WDT_TIMEOUT"); break; 
0237A:  MOVLW  AE
0237C:  MOVWF  FF6
0237E:  MOVLW  07
02380:  MOVWF  FF7
02382:  CALL   0A54
02386:  BRA    23E8
.................... 		case MCLR_FROM_SLEEP: fprintf(DEBUG,"MCLR_FROM_SLEEP"); break; 
02388:  MOVLW  BA
0238A:  MOVWF  FF6
0238C:  MOVLW  07
0238E:  MOVWF  FF7
02390:  CALL   0A54
02394:  BRA    23E8
.................... 		case MCLR_FROM_RUN: fprintf(DEBUG,"MCLR_FROM_RUN"); break; 
02396:  MOVLW  CA
02398:  MOVWF  FF6
0239A:  MOVLW  07
0239C:  MOVWF  FF7
0239E:  CALL   0A54
023A2:  BRA    23E8
.................... 		case NORMAL_POWER_UP: fprintf(DEBUG,"NORMAL_POWER_UP"); break; 
023A4:  MOVLW  D8
023A6:  MOVWF  FF6
023A8:  MOVLW  07
023AA:  MOVWF  FF7
023AC:  CALL   0A54
023B0:  BRA    23E8
.................... 		case BROWNOUT_RESTART: fprintf(DEBUG,"BROWNOUT_RESTART"); break; 
023B2:  MOVLW  E8
023B4:  MOVWF  FF6
023B6:  MOVLW  07
023B8:  MOVWF  FF7
023BA:  CALL   0A54
023BE:  BRA    23E8
.................... 		case WDT_FROM_SLEEP: fprintf(DEBUG,"WDT_FROM_SLEEP"); break; 
023C0:  MOVLW  FA
023C2:  MOVWF  FF6
023C4:  MOVLW  07
023C6:  MOVWF  FF7
023C8:  CALL   0A54
023CC:  BRA    23E8
.................... 		case RESET_INSTRUCTION: fprintf(DEBUG,"RESET_INSTRUCTION"); break; 
023CE:  MOVLW  0A
023D0:  MOVWF  FF6
023D2:  MOVLW  08
023D4:  MOVWF  FF7
023D6:  CALL   0A54
023DA:  BRA    23E8
.................... 		default: fprintf(DEBUG,"unknown!"); 
023DC:  MOVLW  1C
023DE:  MOVWF  FF6
023E0:  MOVLW  08
023E2:  MOVWF  FF7
023E4:  CALL   0A54
.................... 	} 
.................... 	fprintf(DEBUG,"\r\n"); 
023E8:  MOVLW  26
023EA:  MOVWF  FF6
023EC:  MOVLW  08
023EE:  MOVWF  FF7
023F0:  CALL   0A54
....................  
.................... 	fprintf(DEBUG,"# read_param_file() starting ..."); 
023F4:  MOVLW  2A
023F6:  MOVWF  FF6
023F8:  MOVLW  08
023FA:  MOVWF  FF7
023FC:  CALL   0A54
.................... 	read_param_file(); 
02400:  GOTO   0CDE
.................... 	fprintf(DEBUG," complete\r\n"); 
02404:  MOVLW  4C
02406:  MOVWF  FF6
02408:  MOVLW  08
0240A:  MOVWF  FF7
0240C:  CALL   0A54
....................  
....................  
.................... 	if ( config.modbus_address != 255 && config.modbus_address > 127 ) { 
02410:  INCFSZ 36,W
02412:  BRA    2416
02414:  BRA    2438
02416:  MOVF   36,W
02418:  SUBLW  7F
0241A:  BC    2438
.................... 		fprintf(DEBUG,"# write_default_param_file() starting ..."); 
0241C:  MOVLW  58
0241E:  MOVWF  FF6
02420:  MOVLW  08
02422:  MOVWF  FF7
02424:  CALL   0A54
.................... 		write_default_param_file(); 
02428:  CALL   0CAC
.................... 		fprintf(DEBUG," complete\r\n"); 
0242C:  MOVLW  82
0242E:  MOVWF  FF6
02430:  MOVLW  08
02432:  MOVWF  FF7
02434:  CALL   0A54
.................... 	} 
....................  
.................... 	/* start Modbus slave */ 
.................... 	setup_uart(TRUE); 
02438:  BSF    FAB.7
0243A:  BSF    FAB.4
.................... 	/* modbus_init turns on global interrupts */ 
.................... 	fprintf(DEBUG,"# modbus_init() starting ..."); 
0243C:  MOVLW  8E
0243E:  MOVWF  FF6
02440:  MOVLW  08
02442:  MOVWF  FF7
02444:  CALL   0A54
.................... 	modbus_init(); 
02448:  GOTO   0D50
.................... 	fprintf(DEBUG," complete\r\n"); 
0244C:  MOVLW  AC
0244E:  MOVWF  FF6
02450:  MOVLW  08
02452:  MOVWF  FF7
02454:  CALL   0A54
....................  
.................... 	fprintf(DEBUG,"# bridged_uarts=%u\r\n",current.bridged_uarts); 
02458:  MOVLW  00
0245A:  MOVLB  1
0245C:  BTFSC  x8F.0
0245E:  MOVLW  01
02460:  MOVLB  2
02462:  MOVWF  xC6
02464:  MOVLW  B8
02466:  MOVWF  FF6
02468:  MOVLW  08
0246A:  MOVWF  FF7
0246C:  MOVLW  10
0246E:  MOVWF  xC7
02470:  MOVLB  0
02472:  CALL   0A2A
02476:  MOVFF  2C6,2C7
0247A:  MOVLW  1B
0247C:  MOVLB  2
0247E:  MOVWF  xC8
02480:  MOVLB  0
02482:  CALL   0AA2
02486:  MOVLW  0D
02488:  BTFSS  FA4.4
0248A:  BRA    2488
0248C:  MOVWF  F73
0248E:  MOVLW  0A
02490:  BTFSS  FA4.4
02492:  BRA    2490
02494:  MOVWF  F73
....................  
.................... 	/* Prime ADC filter */ 
.................... 	for ( i=0 ; i<30 ; i++ ) { 
02496:  MOVLB  2
02498:  CLRF   xC5
0249A:  MOVF   xC5,W
0249C:  SUBLW  1D
0249E:  BNC   24AC
.................... 		adc_update(); 
024A0:  MOVLB  0
024A2:  CALL   0E36
.................... 	} 
024A6:  MOVLB  2
024A8:  INCF   xC5,F
024AA:  BRA    249A
....................  
.................... 	/* set power switch to initial state */ 
.................... 	current.p_on=config.power_startup; 
024AC:  MOVFF  42,192
....................  
....................  
.................... 	/* shut off RS-485 transmit once transmit buffer is empty */ 
.................... 	while ( ! TRMT2 ) 
.................... 		; 
024B0:  BTFSS  F72.1
024B2:  BRA    24B0
.................... 	output_low(RS485_DE); 
024B4:  BCF    F8C.1
.................... 	output_low(RS485_NRE); 
024B6:  BCF    F8C.0
.................... 	/* done with RS-485 port startup message */ 
....................  
....................  
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
024B8:  CLRWDT
....................  
.................... #if 0 
.................... 		if ( current.bridged_uarts ) { 
.................... 			disable_interrupts(INT_TIMER2); 
.................... 			if ( kbhit(DEBUG) ) { 
.................... 				fputc(fgetc(DEBUG),MODBUS_SERIAL); 
.................... 			} 
....................  
.................... 			if ( !bit_test(timers.port_b,BUTTON_BIT) ) { 
.................... 				current.bridged_uarts=0; 
.................... 				enable_interrupts(INT_TIMER2); 
.................... 			} 
....................  
.................... 			continue; 
.................... 		}  
.................... #endif 
....................  
.................... 		if ( timers.now_millisecond ) { 
024BA:  MOVLB  1
024BC:  BTFSS  xAD.2
024BE:  BRA    24C8
.................... 			periodic_millisecond(); 
024C0:  MOVLB  0
024C2:  GOTO   0F64
024C6:  MOVLB  1
.................... 		} 
....................  
....................  
.................... 		if ( timers.now_adc_sample ) { 
024C8:  BTFSS  xAD.0
024CA:  BRA    24D4
.................... 			timers.now_adc_sample=0; 
024CC:  BCF    xAD.0
.................... 			adc_update(); 
024CE:  MOVLB  0
024D0:  CALL   0E36
.................... 		} 
....................  
.................... //		if ( ! current.bridged_uarts ) { 
.................... 			modbus_process(); 
024D4:  MOVLB  0
024D6:  BRA    2020
.................... //		} 
....................  
.................... 	} 
024D8:  MOVLB  2
024DA:  BRA    24B8
.................... } 
024DC:  SLEEP 

Configuration Fuses:
   Word  1: 2300   HSM NOPLLEN PRIMARY_ON NOFCMEN NOIESO
   Word  2: 3F1E   PUT BROWNOUT BORV19 WDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
